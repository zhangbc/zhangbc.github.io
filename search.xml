<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Java基础】Java基础100实例]]></title>
    <url>%2F2019%2F04%2F12%2Fjava_code_100%2F</url>
    <content type="text"><![CDATA[【学习参考资料】：菜鸟教程-Java教程 通过菜鸟教程-Java教程的初步学习，现将其教程训练代码汇聚成篇。 菜鸟教程-Java Coding学习笔记 Applet应用程序实例 文档注释演示实例 序列化和反序列化 Socket编程—服务端实例 Socket编程—客户端实例 Java进阶知识 遍历演示 Map遍历实例 泛型方法实例 泛型的有界类型参数实例 泛型类实例 类型通配符实例 发邮件(纯文本，HTML文本，附件) 图片二进制转换 JAVA8新特性实例 JAVA操作MYSQL实例 菜鸟教程-Java实例Java 环境设置实例 Java实例 – 如何编译一个Java文件？ Java实例 – Java如何运行一个编译过的类文件？ Java实例 – 如何执行指定class文件目录（classpath）？ Java实例 – 如何查看当前Java运行的版本？ 12$ javac -d . HelloWorld.java$ java com.runoob.HelloWorld Java 字符串 Java 实例 – 字符串比较 Java 实例 - 查找字符串最后一次出现的位置 Java 实例 - 删除字符串中的一个字符 Java 实例 - 字符串替换 Java 实例 - 字符串反转 Java 实例 - 字符串查找 Java 实例 - 字符串分割 Java 实例 - 字符串分割(StringTokenizer) Java 实例 - 字符串大小写转换 Java 实例 - 测试两个字符串区域是否相等 Java 实例 - 字符串性能比较测试 Java 实例 - 字符串优化 Java 实例 - 字符串格式化 Java 实例 - 连接字符串 Java 数组 Java 实例 – 数组排序及元素查找 Java 实例 – 数组添加元素 Java 实例 – 获取数组长度 Java 实例 – 数组反转 Java 实例 – 数组输出 Java 实例 – 数组获取最大和最小值 Java 实例 – 数组合并 Java 实例 – 数组填充 Java 实例 – 数组扩容 Java 实例 – 查找数组中的重复元素 Java 实例 – 删除数组元素 Java 实例 – 数组差集 Java 实例 – 数组交集 Java 实例 – 在数组中查找指定元素 Java 实例 – 判断数组是否相等 Java 实例 - 数组并集 Java 时间处理 Java 实例 - 格式化时间（SimpleDateFormat） Java 实例 - 获取当前时间 Java 实例 - 获取年份、月份等 Java 实例 - 时间戳转换成时间 Java 方法 Java 实例 – 方法重载 Java 实例 – 输出数组元素 Java 实例 – 汉诺塔算法 Java 实例 – 斐波那契数列 Java 实例 – 阶乘 Java 实例 – 方法覆盖 Java 实例 – instanceOf 关键字用法 Java 实例 – break 关键字用法 Java 实例 – continue 关键字用法 Java 实例 – 标签(Label) Java 实例 – enum 和 switch 语句使用 Java 实例 – Enum（枚举）构造函数及方法的使用 Java 实例 – for 和 foreach循环使用 Java 实例 – Varargs 可变参数使用 Java 实例 – 重载(overloading)方法中使用 Varargs 打印图形 Java 实例 – 打印菱形 Java 实例 – 九九乘法表 Java 实例 – 打印三角形 Java 实例 – 打印倒立的三角形 Java 实例 – 打印平行四边形 Java 实例 – 打印矩形 Java 文件操作 Java 实例 - 文件写入 Java 实例 - 读取文件内容 Java 实例 - 删除文件 Java 实例 - 将文件内容复制到另一个文件 Java 实例 - 向文件中追加数据 Java 实例 - 创建临时文件 Java 实例 - 修改文件最后的修改日期 Java 实例 - 获取文件大小 Java 实例 - 文件重命名 Java 实例 - 设置文件只读 Java 实例 - 检测文件是否存在 Java 实例 - 在指定目录中创建文件 Java 实例 - 获取文件修改时间 Java 实例 - 创建文件 Java 实例 - 文件路径比较 Java 目录操作 Java 实例 - 递归创建目录 Java 实例 - 删除目录 Java 实例 - 判断目录是否为空 Java 实例 - 判断文件是否隐藏 Java 实例 - 获取目录大小 Java 实例 - 在指定目录中查找文件 Java 实例 - 获取文件的上级目录 Java 实例 - 获取目录最后修改时间 Java 实例 - 打印目录结构 Java 实例 - 遍历指定目录下的所有目录 Java 实例 - 遍历指定目录下的所有文件 Java 实例 - 在指定目录中查找文件 Java 实例 - 遍历系统根目录 Java 实例 - 查看当前工作目录 Java 实例 - 遍历目录 Java 异常处理 Java 实例 - 异常处理方法 Java 实例 - 多个异常处理（多个catch） Java 实例 - Finally的用法 Java 实例 - 使用 catch 处理异常 Java 实例 - 多线程异常处理 Java 实例 - 获取异常的堆栈信息 Java 实例 - 重载方法异常处理 Java 实例 - 链试异常 Java 实例 - 自定义异常 Java 数据结构 Java 实例 – 数字求和运算 Java 实例 – 利用堆栈将中缀表达式转换成后缀 Java 实例 – 在链表（LinkedList）的开头和结 Java 实例 – 获取链表（LinkedList）的第一个 Java 实例 – 删除链表中的元素 Java 实例 – 获取链表的元素 Java 实例 – 获取向量元素的索引值 Java 实例 – 栈的实现 Java 实例 – 链表元素查找 Java 实例 – 压栈出栈的方法实现字符串反转 Java 实例 – 队列（Queue）用法 Java 实例 – 获取向量的最大元素 Java 实例 – 链表修改 Java 实例 – 旋转向量 Java 集合 Java 实例 – 数组转集合 Java 实例 – 集合比较 Java 实例 – HashMap遍历 Java 实例 – 集合长度 Java 实例 – 集合打乱顺序 Java 实例 – 集合遍历 Java 实例 – 集合反转 Java 实例 – 删除集合中指定元素 Java 实例 – 只读集合 Java 实例 – 集合输出 Java 实例 – 集合转数组 Java 实例 – List 循环移动元素 Java 实例 – 查找 List 中的最大最小值 Java 实例 – 遍历 HashTable 的键值 Java 实例 – 使用 Enumeration 遍历 HashTable Java 实例 – 集合中添加不同类型元素 Java 实例 – List 元素替换 Java 实例 – List 截取 Java 网络实例 Java 实例 – 获取指定主机的IP地址 Java 实例 – 查看端口是否已使用 Java 实例 – 获取本机ip地址及主机名 Java 实例 – 获取远程文件大小 Java 实例 – Socket 实现多线程服务器程序 Java 实例 – 查看主机指定文件的最后修改时间 Java 实例 – 使用 Socket 连接到指定主机 Java 实例 – 网页抓取 Java 实例 – 获取 URL响应头的日期信息 Java 实例 – 获取 URL 响应头信息 Java 实例 – 解析 URL Java 实例 – ServerSocket 和 Socket 通信实例 Java 线程 Java 实例 – 查看线程是否存活 Java 实例 – 获取当前线程名称 Java 实例 – 状态监测 Java 实例 – 线程优先级设置 Java 实例 – 死锁及解决方法 Java 实例 – 获取线程id Java 实例 – 线程挂起 Java 实例 – 终止线程 Java 实例 – 生产者/消费者问题 Java 实例 – 获取线程状态 Java 实例 – 获取所有线程 Java 实例 – 查看线程优先级 Java 实例 – 中断线程 github代码送门: java_projects/runoob 腾讯云coding代码送门: java_project/dev]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】Java扩展知识]]></title>
    <url>%2F2019%2F04%2F12%2Fjava_extend_knowledge%2F</url>
    <content type="text"><![CDATA[【学习参考资料】：菜鸟教程-Java教程 1，Java文档注释1）Java支持三种注释方式，分别是//、/* */、/** */(说明注释)。 2）javadoc标签 标签 描述 示例 @author 标识一个类的作者 @author description @deprecated 指名一个过期的类或成员 @deprecated description {@docRoot} 指明当前文档根目录的路径 Directory Path @exception 标志一个类抛出的异常 @exception exception-name explanation {@inheritDoc} 从直接父类继承的注释 Inherits a comment from the immediate surperclass. {@link} 插入一个到另一个主题的链接 {@link name text} {@linkplain} 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic. @param 说明一个方法的参数 @param parameter-name explanation @return 说明返回值类型 @return explanation @see 指定一个到另一个主题的链接 @see anchor @serial 说明一个序列化属性 @serial description @serialData 明通过writeObject( ) 和 writeExternal( )方法写的数据 @serialData description @serialField 说明一个ObjectStreamField组件 @serialField name type description @since 标记当引入一个特定的变化时 @since release @throws 和 @exception标签一样. The @throws tag has the same meaning as the @exception tag. {@value} 显示常量的值，该常量必须是static属性。 Displays the value of a constant, which must be a static field. @version 指定类的版本 @version info 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.runoob;​​import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;​/** * 文档注释演示实例 * @author zhangbc * @version 1.0 */public class SquareNumber &#123; /** * This method returns the square of number. * This is a multiline description. You can use as many lines as you like. * @param number The value to be squared. * @return number squared. */ public double square(double number) &#123; return number * number; &#125;​ /** * This method input a number from the user. * @return The value input as a double. * @throws IOException in input error * @see IOException */ public double getNumber() throws IOException &#123; InputStreamReader isr = new InputStreamReader(System.in); BufferedReader inData = new BufferedReader(isr); String str; str = inData.readLine(); return Double.parseDouble(str); &#125;​ /** * This method demonstrates square(). * @param args args unused. * @throws IOException on input error. * @see IOException */ public static void main(String[] args) throws IOException &#123; SquareNumber sn = new SquareNumber(); double val; System.out.print("Enter value to be squared:"); val = sn.getNumber(); val = sn.square(val); System.out.println("Squared value is : " + val); &#125;&#125; 2，Java 8 新特性1）Java8(即jdk1.8)新特性 （1）Lambda 表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。（2）方法引用：可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。（3）默认方法：默认方法就是一个在接口里面有了一个实现的方法。（4）新工具：新的编译工具，如：Nashorn引擎jjs、 类依赖分析器jdeps。（5）Stream API：把真正的函数式编程风格引入到Java中。（6）Date Time API：加强对日期与时间的处理。（7）Optional 类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。（8）Nashorn, JavaScript 引擎：允许我们在JVM上运行特定的javascript应用。 3，Java MySQL连接 MysqlDemo.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.runoob;​import java.sql.*;​/** * 连接数据库实例 * @author zhangbc * @version v1.0 * @date 2019/3/28 22:14 */public class MysqlDemo &#123;​ /** * JDBC驱动名及其数据库URL */ static final String JDBC_DRIVER = "com.mysql.jdbc.Driver"; static final String DB_URL = "jdbc:mysql://127.0.0.1:3306/pyspider_db";​ /** * 数据库的用户与密码 */ static final String USER = "root"; static final String PASSWORD = "xxxxxx";​ public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; Class.forName(JDBC_DRIVER); System.out.println("连接数据库..."); conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);​ System.out.println("实例化Statement对象..."); stmt = conn.createStatement(); String sql; sql = "select id, name, url from websites;"; ResultSet rs = stmt.executeQuery(sql);​ while (rs.next()) &#123; int id = rs.getInt("id"); String name = rs.getString("name"); String url = rs.getString("url");​ System.out.printf("ID: %d\t站点名称：%s\t站点URL：%s\n", id, name, url); &#125;​ rs.close(); stmt.close(); conn.close(); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125;​ try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4，Java 9 新特性详情参见：Java 9 新特性]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】Java网络编程]]></title>
    <url>%2F2019%2F04%2F12%2Fjava_net_program%2F</url>
    <content type="text"><![CDATA[【学习参考资料】：菜鸟教程-Java教程 1，Java网络编程1）概述 网络编程：编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net包中J2EE的API包含有类和接口，他们提供低层次的通信细节。主要有： TCP：传输控制协议，保障了两个应用程序之间的可靠通信，通常用于互联网协议，称为TCP/IP； UDP：用户数据报协议，一个无连接的协议，提供了应用程序之间要发送的数据的数据包。 2）Socket编程 套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。 当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 3）ServerSocket类的方法：服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。 4）Socket类的方法：java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。 5）InetAddress类的方法：表示互联网协议（IP）地址。 6）demo实例 GreetingClient.java 1234567891011121314151617181920212223242526272829import java.io.*;import java.net.Socket;/** * Socket编程--客户端实例 * @author zhangbc * @date 2019/3/7 14:26 */public class GreetingClient &#123; public static void main(String[] args) &#123; String serverName = args[0]; int port = Integer.parseInt(args[1]); try &#123; System.out.println("连接到主机：" + serverName + ", 端口号：" + port); Socket client = new Socket(serverName, port); System.out.println("远程主机地址：" + client.getRemoteSocketAddress()); OutputStream outServer = client.getOutputStream(); DataOutputStream outData = new DataOutputStream(outServer); outData.writeUTF("Hello from " + client.getLocalSocketAddress()); InputStream inFromServer = client.getInputStream(); DataInputStream inData = new DataInputStream(inFromServer); System.out.println("服务器响应：" + inData.readUTF()); client.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; GreetingServer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketTimeoutException;import java.lang.Thread;/** * @author zhangbc * @date 2019/3/7 15:09 */public class GreetingServer extends Thread &#123; private ServerSocket serverSocket; public static void main(String[] args) &#123; int port = Integer.parseInt(args[0]); try &#123; Thread thread = new GreetingServer(port); thread.run(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; public GreetingServer(int port) throws IOException &#123; serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(10000); &#125; public void run() &#123; while (true) &#123; try &#123; System.out.println("等待远程连接，端口号为：" + serverSocket.getLocalPort() + "..."); Socket server = serverSocket.accept(); DataInputStream inData = new DataInputStream(server.getInputStream()); System.out.println(inData.readUTF()); DataOutputStream outData = new DataOutputStream(server.getOutputStream()); outData.writeUTF("谢谢连接我：" + server.getLocalSocketAddress() + "\nGoodbye!"); server.close(); &#125; catch (SocketTimeoutException es) &#123; System.out.println("Socket timed out!"); break; &#125; catch (IOException ex) &#123; ex.printStackTrace(); break; &#125; &#125; &#125;&#125; 2，Java发送邮件 SendEmail.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.runoob;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import javax.mail.Message.RecipientType;import java.util.Properties;/** * 发邮件(纯文本，HTML文本，附件) * @author zhangbocheng * @version v1.0 * @date 2019/3/7 20:40 */public class SendEmail &#123; public static void main(String[] args) throws NullPointerException &#123; // 收件人邮箱 String to = "xxxxxxxxxxxxxxxxx@qq.com"; // 发件人邮箱 final String from = "xxxxxxxxxxxxxxxxx@163.com"; final String pwd = "xxxxxxxx"; // 指定发邮件的主机 String host = "smtp.163.com"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty("mail.host", host); properties.put("mail.smtp.auth", "true"); // 获取默认Session对象 Session session = Session.getDefaultInstance(properties, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(from, pwd); &#125; &#125;); try &#123; // 创建默认的MimeMessage对象 MimeMessage message = new MimeMessage(session); // Set From：头部头字段 message.setFrom(new InternetAddress(from)); // Set To：头部头字段 message.addRecipient(RecipientType.TO, new InternetAddress(to)); // Set Subject：头部头字段 message.setSubject("This is the Subject Line!"); // 设置消息体 message.setText("This is test text."); // 发送HTML消息，可以插入html标签 message.setContent("&lt;h1&gt;This is actual message&lt;/h1&gt;", "text/html;charset=utf-8"); // 创建消息部分 BodyPart messageBodyPart = new MimeBodyPart(); // 消息 messageBodyPart.setText("This is message body."); // 创建多重消息 Multipart multipart = new MimeMultipart(); // 设置文本消息 multipart.addBodyPart(messageBodyPart); // 附件部分 messageBodyPart = new MimeBodyPart(); String fileName = "/home/projects/java_pro/java_instances_demo/src/main/java/com/runoob/SendEmail.java"; DataSource source = new FileDataSource(fileName); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(fileName); multipart.addBodyPart(messageBodyPart); // 发送完整部分 message.setContent(multipart); // 发送消息 Transport.send(message); System.out.println("Sent message successfully."); &#125; catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125; 3，Java Applet基础1）Applet基础 Applet是一种Java程序，一般运行在支持Java的Web浏览器内，是一个全功能的Java应用程序。 Java 中 Applet 类继承了 java.applet.Applet 类。 Applet 类没有定义 main()，所以一个 Applet 程序不会调用 main() 方法。 Applet 被设计为嵌入在一个 HTML 页面。 当用户浏览包含 Applet 的 HTML 页面，Applet 的代码就被下载到用户的机器上。 要查看一个 Applet 需要 JVM。 JVM 可以是 Web 浏览器的一个插件，或一个独立的运行时环境。 用户机器上的 JVM 创建一个 Applet 类的实例，并调用 Applet 生命周期过程中的各种方法。 Applet 有 Web 浏览器强制执行的严格的安全规则，Applet 的安全机制被称为沙箱安全。 Applet 需要的其他类可以用 Java 归档（JAR）文件的形式下载下来。 2）Applet的生命周期 Applet 类中的四个方法给我们提供了一个框架： init: 提供所需的任何初始化。在 Applet 标记内的 param 标签被处理后调用该方法。 start: 浏览器调用 init 方法后，该方法被自动调用。每当用户从其他页面返回到包含 Applet 的页面时，则调用该方法。 stop: 当用户从包含 Applet 的页面移除的时候，该方法自动被调用。 destroy: 此方法仅当浏览器正常关闭时调用。 paint: 该方法在 start() 方法之后立即被调用，或者在 Applet 需要重绘在浏览器的时候调用。paint() 方法实际上继承于 java.awt。 3）Applet类 每一个 Applet 都是 java.applet.Applet 类的子类，基础的 Applet 类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。 4）Applet的调用 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello World, Applet&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hr&gt;&lt;applet code="HelloWorldApplet.class" width="320" height="120"&gt;&lt;/applet&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】Java进阶编程]]></title>
    <url>%2F2019%2F04%2F11%2Fjava_advance_program%2F</url>
    <content type="text"><![CDATA[【学习参考资料】：菜鸟教程-Java教程 1，Java数据结构Java工具包提供了强大的数据结构，在Java中的数据结构主要包括以下接口和类：枚举（Enumeration），位集合（BitSet），向量（Vector），栈（Stack），字典（Dictionary），哈希表（Hashtable），属性（Properties）。 1）枚举（Enumeration）：该接口定义了一种从数据结构中取回连续元素的方式。 2）位集合（BitSet）：该类实现了一组可以单独设置和清除的位或标志。 3）向量（Vector）：对象的元素通过索引访问，在创建时不必给对象指定大小，其大小会根据需要动态的变化。 4）栈（Stack）：实现了一个后进先出的数据结构，是Vector的一个子类。 5）字典（Dictionary）：是一个抽象类，定义了键映射到值的数据结构。当想要通过特定的键而不是整数索引来访问数据时，应使用Dictionary。注意：Dictionary类已经过时了，在实际开发中，你可以实现Map接口来获取键/值的存储功能。 6）哈希表（Hashtable）：提供了一种在用户定义键结构的基础上来组织数据的手段。Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。 7）属性（Properties）：继承于 Hashtable.Properties 类表示了一个持久的属性集；属性列表中每个键及其对应值都是一个字符串。 2，Java集合框架1）集合框架设计目标 （1）必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的；（2）允许不同类型的集合，以类似的方式工作，具有高度的互操作性；（3）对一个集合的扩展和适应必须是简单的。 2）Java集合框架图 3）集合框架是一个用来代表和操纵集合的统一架构，包含如下内容： （1）接口：是代表集合的抽象数据类型。例：Collection，List，Set，Map等。（2）实现（类）：是集合接口的具体实现。从本质上，他们是可重复使用的数据结构，例：ArrayList，LinkedList，HashSet，HashMap。（3）算法：是实现集合接口的对象里的方法执行的一些有用的计算，例：搜索和排序，这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。 集合框架的类和接口均在java.util包中。任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 4）集合接口 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。 List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 5）集合实现类（集合类）：Java提供了一套实现了Collection接口的标准集合类。 6）集合算法：集合定义了三个不可改变的静态变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP。Collection Algorithms是一个列表中的所有算法实现。 7）迭代：使用Java Iterator，通过实例列出Iterator和listIterator接口提供的所有方法。 ArrayListDemo.java 123456789101112131415161718192021222324252627282930public class ArrayListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("Hello"); list.add("World"); list.add("Maven"); list.add("Demo");​ // 遍历1：使用foreach遍历List System.out.println("使用foreach遍历List:"); for (String str: list) &#123; System.out.print(str + " "); &#125;​ // 遍历2：把链表变为数组相关的内容进行遍历List String[] strArray = new String[list.size()]; list.toArray(strArray); System.out.println("\n把链表变为数组相关的内容进行遍历List:"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.print(strArray[i] + " "); &#125;​ // 遍历3：使用迭代器进行相关遍历List Iterator&lt;String&gt; iterator = list.iterator(); System.out.println("\n使用迭代器进行相关遍历List:"); while (iterator.hasNext()) &#123; System.out.print(iterator.next() + " "); &#125; &#125;&#125; MapDemo.java 1234567891011121314151617181920212223242526272829303132333435public class MapDemo &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("key1", "value1"); map.put("key2", "value2"); map.put("key3", "value3");​ // 遍历1：通过Map.KeySet遍历 System.out.println("通过Map.KeySet遍历key与value："); for (String key: map.keySet()) &#123; System.out.println("key=" + key + ", value=" + map.get(key)); &#125;​ // 遍历2：通过Map.entrySet使用iterator遍历 System.out.println("通过Map.entrySet使用iterator遍历key和value："); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println("key=" + entry.getKey() + ", value=" + entry.getValue()); &#125;​ // 遍历3：推荐，通过Map.entrySet遍历 System.out.println("通过Map.entrySet遍历key和value:"); for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; System.out.println("key=" + entry.getKey() + ", value=" + entry.getValue()); &#125;​ // 遍历4：通过Map.values()遍历 System.out.println("通过Map.values()遍历所有的value，但不能遍历key："); for (String val: map.values()) &#123; System.out.println("value=" + val); &#125; &#125;&#125; 8）比较器：使用 Java Comparator，通过实例列出Comparator接口提供的所有方法。 3，Java泛型1）Java泛型（generics） 是JDK5中引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，即：所操作的数据类型被指定为一个参数。 2）定义泛型方法的规则 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt;E&gt;）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（如int,double,char的等）。 123456789101112131415161718192021222324252627282930/** * 泛型方法实例 */class GenericMethod &#123; public static void main(String[] args) &#123; // 创建不同类型的数组：Integer，Double和Character Integer[] intArray = &#123;1, 2, 3, 4, 5&#125;; Double[] doubleArray = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; Character[] charArray = &#123;'H', 'E', 'L', 'L', '0'&#125;;​ System.out.println("整型数组元素为："); printArray(intArray); System.out.println("双精度小数数组元素为："); printArray(doubleArray); System.out.println("字符型数组元素为："); printArray(charArray); &#125;​ /** * 泛型方法printArray * @param inputArray * @param &lt;E&gt; */ public static &lt;E&gt; void printArray(E[] inputArray) &#123; for (E element: inputArray) &#123; System.out.printf("%s ", element); &#125; System.out.println(); &#125;&#125; 3）有界的类型参数：限制那些被允许传递到一个类型参数的类型种类范围。声明首先要列出类型参数的名称，后跟 extends 关键字，最后紧跟它的上界。 123456789101112131415161718192021222324252627/** * 泛型的有界类型参数实例 */class MaxGenericMethod &#123; public static void main(String[] args) &#123; System.out.printf("%d,%d和%d中最大的数为%d.\n\n", 3, 4, 5, maximum(3, 4, 5));​ System.out.printf("%.2f,%.2f和%.2f中最大的数为%.2f.\n\n", 6.6, 7.7, 8.8, maximum(6.6, 7.7, 8.8));​ System.out.printf("%s,%s和%s中最大的数为%s.\n\n", "pear", "apple", "orange", maximum("pear", "apple", "orange")); &#125;​ public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) &#123; T max = x; if (y.compareTo(max) &gt; 0) &#123; max = y; &#125; if (z.compareTo(max) &gt; 0) &#123; max = z; &#125; return max; &#125;&#125; 4）泛型类：在类名后面添加类型参数声明部分。泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 123456789101112131415161718192021222324/** * 泛型类实例 * @param &lt;T&gt; */class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125;​ public T get() &#123; return t; &#125;​ public static void main(String[] args) &#123; Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); Box&lt;String&gt; stringBox = new Box&lt;&gt;(); integerBox.add(10); stringBox.add("菜鸟教程");​ System.out.printf("整型值为：%d\n", integerBox.get()); System.out.printf("字符串为：%s\n", stringBox.get()); &#125;&#125; 5）类型通配符：一般使用?代替具体的类型参数。 （1）类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型；（2）类型通配符下限通过形如List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型。 1234567891011121314151617181920212223242526/** * 类型通配符实例 */class Wildcard &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;&gt;(); List&lt;Number&gt; number = new ArrayList&lt;&gt;();​ name.add("icon"); age.add(18); number.add(314);​ getData(name); getUpperNumber(age); getUpperNumber(number); &#125;​ public static void getData(List&lt;?&gt; data) &#123; System.out.printf("data: %s\n", data.get(0)); &#125;​ public static void getUpperNumber(List&lt;? extends Number&gt; data) &#123; System.out.println("data: " + data.get(0)); &#125;&#125; 4，Java序列化1）Java序列化：Java提供了一种对象序列化的机制，该机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据，有关对象的类型的信息和存储在对象中数据的类型。 （1）序列化一个对象，并将它发送到输出流。1public final void writeObject(Object x) throws IOException （2）从流中取出下一个对象，并将对象反序列化。1public final void readObject(Object x) throws IOException, ClassNotFundException 2）完整demo实例： Employee.java 12345678910111213141516171819package runoob;​import java.io.*;​/** * Employee类实现Serializable接口 * @author 张伯成 * @date 2019/3/7 12:30 */public class Employee implements Serializable &#123; public String name; public String address; public transient int SSN; public int number;​ public void mailCheck() &#123; System.out.println("Mailing a check to " + name + " " + address); &#125;&#125; SerializeDemo.java 12345678910111213141516171819202122232425/** * SerializeDemo类，序列化对象 */class SerializeDemo &#123; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.name = "Reyan Ali"; employee.address = "Phonkka kuan, Ambehta Peer."; employee.SSN = 11122333; employee.number = 101;​ try &#123; FileOutputStream fileOut = new FileOutputStream("employee.ser"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(employee); out.close(); fileOut.close(); System.out.println("Serialized data is saved in employee.ser."); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;​ DeserializeDemo.java 123456789101112131415161718192021222324252627/** * DeserializeDemo类，反序列化对象 */class DeserializeDemo &#123; public static void main(String[] args) &#123; Employee employee; try &#123; FileInputStream fileIn = new FileInputStream("employee.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); employee = (Employee) in.readObject(); in.close(); fileIn.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); return; &#125; catch (ClassNotFoundException ex) &#123; System.out.println("Employee class not found."); ex.printStackTrace(); return; &#125; System.out.println("Deserialize Employee..."); System.out.println("Name: " + employee.name); System.out.println("Address: " + employee.address); System.out.println("SSN: " + employee.SSN); System.out.println("Number: " + employee.number); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】Java面向对象]]></title>
    <url>%2F2019%2F04%2F11%2Fjava_object_oriented%2F</url>
    <content type="text"><![CDATA[【学习参考资料】：菜鸟教程-Java教程 1，Java 继承1）Java继承的概念：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 2）Java继承类型：Java不支持多继承，但是支持多重继承。3）Java继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 4）Java继承关键字 继承可以使用extends和implements这两个关键字来实现继承，都继承于java.lang.Object，默认继承object祖先类。 （1）extends：只能继承一个类。（2）implements：可以变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口。（3）super：通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。（4）this：指向自己的引用。（5）finally：声明类可以把类定义为不能继承的，即最终类；或用于修饰方法，该方法不能被子类重写。 5）Java构造器 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 ExtendsDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.springboot;​/** * @function: * @author: 张伯成 * @date: 2019/3/3 */public class ExtendsDemo &#123; public static void main(String[] args) &#123; System.out.println("==========SubClassOne 类继承==========="); SubClassOne sc1 = new SubClassOne(); SubClassOne sc2 = new SubClassOne(100); System.out.println("==========SubClassTwo 类继承==========="); SubClassTwo sc3 = new SubClassTwo(); SubClassTwo sc4 = new SubClassTwo(200); &#125;&#125;​​/** * SuperClass 祖先类 */class SuperClass &#123; private int number; SuperClass() &#123; System.out.println("SuperClass()"); &#125;​ SuperClass(int number) &#123; this.number = number; System.out.println("SuperClass(int number)"); &#125;&#125;​​/** * SubClassOne 类继承 */class SubClassOne extends SuperClass &#123; private int number; SubClassOne() &#123; System.out.println("SubClassOne()"); &#125;​ SubClassOne(int number) &#123; super(300); this.number = number; System.out.println("SubClassOne(int number): " + number); &#125;&#125;​​/** * SubClassTwo 类继承 */class SubClassTwo extends SuperClass &#123; private int number; SubClassTwo() &#123; super(300); System.out.println("SubClassTwo()"); &#125;​ SubClassTwo(int number) &#123; this.number = number; System.out.println("SubClassTwo(int number): " + number); &#125;&#125; 2，Java Override/Overload1）重写（Override）重写是子类对父类对允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写。重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。1234567891011121314151617181920212223242526272829/** * Animal类，祖先类 */class Animal &#123; public void move() &#123; System.out.println("动物可以移动..."); &#125;&#125;​​/** * AnimalDog类，继承Animal，并重写父类的move()方法 */class AnimalDog extends Animal &#123; public void move() &#123; super.move(); System.out.println("狗可以跑和走."); &#125;&#125;​​class DogTest &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); Animal dog = new AnimalDog(); animal.move(); dog.move(); &#125;&#125; 2）方法的重写规则 参数列表必须完全与被重写方法的相同。 返回类型必须完全与被重写方法的返回类型相同。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 3）super：当需要在子类中调用父类的被重写方法时，要使用super关键字。 4）重载（Overload）：在一个类里面，方法名字相同，而参数不同，返回类型可同可不同。 5）重载规则 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载； 无法以返回值类型作为重载函数的区分标准。 OverLoading.java12345678910111213141516171819202122232425262728public class OverLoading &#123; public int test() &#123; System.out.println("test()"); return 1; &#125;​ public void test(int number) &#123; System.out.println("test(int)"); &#125;​ public String test(int number, String str) &#123; System.out.println("test(int, String)"); return "test(int, String)"; &#125;​ public String test(String str, int number) &#123; System.out.println("test(String,int)"); return "test(String,int)"; &#125;​ public static void main(String[] args) &#123; OverLoading overLoad = new OverLoading(); System.out.println(overLoad.test()); overLoad.test(100); System.out.println(overLoad.test(100, "test3")); System.out.println(overLoad.test("test", 100)); &#125;&#125; 6）重写和重载的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 3，Java 多态多态是同一个行为具有多个不同表现形式或形态的能力。多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 1）多态的优点：消除类型之间的耦合关系；可替换性；可扩充性；接口性；灵活性；简化性。 2）多态存在的三个必要条件：继承；重写；父类引用指向子类对象。 PolymorphicDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.example.springboot;​/** * @function: * @author: 张伯成 * @date: 2019/3/3 */public class PolymorphicDemo &#123; public static void main(String[] args) &#123; show(new Cat()); show(new Dog());​ Animals animal = new Cat(); animal.eat();​ Cat cat = (Cat) animal; cat.work(); &#125;​ public static void show(Animals animal) &#123; animal.eat();​ if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.work(); &#125; else if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.work(); &#125; &#125;&#125;​​abstract class Animals &#123; abstract void eat();&#125;​​class Cat extends Animals &#123; public void eat() &#123; System.out.println("吃鱼"); &#125;​ public void work() &#123; System.out.println("抓老鼠"); &#125;&#125;class Dog extends Animals &#123; public void eat() &#123; System.out.println("吃骨头"); &#125;​ public void work() &#123; System.out.println("看家"); &#125;&#125; 3）虚函数：虚函数的存在是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。 4）多态的实现方式：重写；接口；抽象类和抽象方法。 4，Java 抽象类在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 1）抽象类：在Java语言中使用abstract class定义抽象类。 2）继承抽象类 3）抽象方法：abstract 关键字可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体；抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 4）抽象类总结规定 （1）抽象类不能被实例化；只有抽象类的非抽象子类可以创建对象；（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能；（4）构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法；（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 5，Java 封装1）在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装 最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 2）封装的优点 （1）两个的封装能够减少耦合；（2）类内部的结构可以自由修改；（3）可以对成员变量进行更精确的控制；（4）隐藏信息，实现细节。 6，Java 接口1）接口概念 接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 2）接口与类相似点 一个接口可以有多个方法。 接口文件保存在.java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 3）接口与类的区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 4）接口特性 接口是隐式的，接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 接口的方法都是公有的。 5）抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 6）接口的声明1234[可见度] interface 接口名称 [extends 其他的接口名名] &#123; // 声明变量 // 抽象方法&#125; 7）接口的实现：当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类；类使用implements关键字实现接口，在类声明中，implements关键字放在class声明后面。 （1）重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 （2）在实现接口的时候，需要注意以下规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 8）接口的继承 9）接口的多继承：在Java中，类的多继承是不合法，但接口允许多继承；在接口的多继承中extenfs关键字只需要用一次，在其后跟着继承接口。 10）标记接口 标记接口是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。 标记接口的作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 标记接口的主要目的：建立一个公共的父接口；向一个类添加数据类型。 7，Java 包（Package） 1）包的作用 （1）把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。（2）如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。（3）包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 总之，Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 2）创建包 3）import语句：为了能够使用某一个包的成员，需要在Java程序中明确导入该包。 4）package的目录结构 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 5）设置CLASSPATH系统变量 用下面的命令显示当前的CLASSPATH变量： 12345# Windows 平台（DOS 命令行下）$ C:\&gt; set CLASSPATH# UNIX 平台（Bourne shell 下）$ echo $CLASSPATH 删除当前CLASSPATH变量内容： 1234# Windows 平台（DOS 命令行下）$ C:\&gt; set CLASSPATH=# UNIX 平台（Bourne shell 下）$ unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量： 1234# Windows 平台（DOS 命令行下）$ C:\&gt; set CLASSPATH=C:\users\jack\java\classes# UNIX 平台（Bourne shell 下）$ CLASSPATH=/home/jack/java/classes; export CLASSPATH]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】Java基础知识]]></title>
    <url>%2F2019%2F04%2F11%2Fjava_basic_knowledge%2F</url>
    <content type="text"><![CDATA[【学习参考资料】：菜鸟教程-Java教程 1，Java基本数据类型变量就是申请内存来存储值。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 Java有两大数据类型：内置数据类型和引用数据类型。 1）内置数据类型 名称 描述 取值范围 默认值 主要用途 byte 8位，有符号的，以二进制补码表示的整数 - $2^7$ ~ $2^7$ -1 0 在大型数组中节约空间，代替整数 short 16位，有符号的，以二进制补码表示的整数 -$2^{15}$~$2^{15}$-1 0 节省空间 int 32位，有符号的，以二进制补码表示的整数 -$2^{31}$~$2^{31}$-1 0 整型变量的默认类型 long 64位，有符号的，以二进制补码表示的整数 -$2^{63}$~$2^{63}$-1 0L 使用在需要比较大整数的系统上 float 单精度、32位、符合IEEE 754标准的浮点数 -$2^{31}$~$2^{31}$-1 0.0f 在存储大型浮点数组时可以节省空间；不能用来表示精确的值 double 双精度、64位、符合IEEE 754标准的浮点数 -$2^{63}$~$2^{63}$-1 0.0d 浮点数变量的默认类型 boolean 表示一位的信息 true,false false 作为一种标记来记录true/false情况 char 单一的 16 位 Unicode 字符 \u0000~\uffff(0~$2^{16}$-1) 存储任何字符 2）引用类型 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 3）Java常量：常量在程序运行时，不会被修改，关键字final。通常使用大写字母表示常量。 4）Java类型转换 自动类型转换：转换从低级到高级。 数据类型转换满足的原则：（1）不能对boolean类型进行类型转换；（2）不能把对象类型转换成不相关类的对象；（3）在把容量大的类型转换为容量小的类型时必须使用强制类型转换；（4）转换过程中可能导致溢出或损失精度；（5）浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。 强制类型转换：条件是转换的数据类型必须是兼容的。 隐含强制类型转换 2，Java语句类型1）循环结构 while do...while for foreach 增强型for循环：主要用于数组 demo：1234567891011121314151617public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(","); &#125; System.out.print("\n"); String [] names =&#123;"James", "Larry", "Tom", "Lacy"&#125;; # 增强型for循环 for( String name : names ) &#123; System.out.print( name ); System.out.print(","); &#125; &#125;&#125; 2）break语句：主要用于循环语句或者switch语句中；跳出最里层的循环，并且继续执行该循环下面的语句。 3）continue语句：适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代。 4）分支结构 if：一个if语句包含一个布尔表达式和一条或多条语句。 switch case语句：判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 3，Java基础类1）Number &amp; Math类 2）Math类：包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 3）Character类：对单个字符进行操作。 将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 4）String类 用于获取有关对象的信息的方法称为访问器方法。 5）StringBuffer和StringBuilder类 和String类不同的是，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder类在Java 5中被提出，它和StringBuffer之间的最大不同在于 StringBuilder的方法不是线程安全的（不能同步访问）。 由于StringBuilder相较于StringBuffer有速度优势，所以多数情况下建议使用 StringBuilder类。 在应用程序要求线程安全的情况下，则必须使用 StringBuffer类。 4，Java数组1）声明数组123dataType[] arrayRefVar; // 首选的方法 # ordataType arrayRefVar[]; // 效果相同，但不是首选方法 2）创建数组 1arrayRefVar = new dataType[arraySize]; 3）多维数组1234567891011type[][] typeName = new type[typeLength1][typeLength2]; // 直接为每一维分配空间​// 从最高维开始，分别为每一维分配空间String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String("Good");s[0][1] = new String("Luck");s[1][0] = new String("to");s[1][1] = new String("you");s[1][2] = new String("!"); 4）Arrays类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法，按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 5，Java日期时间java.util包提供了Date类来封装当前的日期和时间。 Date类提供两个构造函数来实例化 Date 对象。第一个构造函数使用当前日期和时间来初始化对象。1Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。1Date(long millisec) 1）获取当前日期时间12345678import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; Date date = new Date(); System.out.println(date.toString()); &#125;&#125; 2）日期比较 getTime()：获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 before(), after(), equals() compareTo()：由Comparable接口定义的，Date类实现了这个接口。 3）格式化日期时间 SimpleDataFormat1234567public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); SimpleDateFormat ft = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); System.out.println("当前时间为："+ft.format(now)); &#125;&#125; printf1234567891011121314151617public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); //c的使用 System.out.printf("全部日期和时间信息：%tc%n", now); //f的使用 System.out.printf("年-月-日格式：%tF%n", now); //d的使用 System.out.printf("月/日/年格式：%tD%n", now); //r的使用 System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n", now); //t的使用 System.out.printf("HH:MM:SS格式（24时制）：%tT%n", now); //R的使用 System.out.printf("HH:MM格式（24时制）：%tR", now); &#125;&#125; 4）Java休眠（Sleep）1234567891011public class SleepDemo &#123; public static void main(String[] args) &#123; try &#123; System.out.println(new Date()+"\n"); Thread.sleep(1000*5); System.out.println(new Date()+"\n"); &#125; catch (Exception ex)&#123; System.out.println("Got an exception: "+ex); &#125; &#125;&#125; 5）Calendar类123456789101112131415161718192021public class DateTestDemo &#123; public static void main(String[] args) &#123; // 创建一个代表系统当前日期的Calendar对象 Calendar now = Calendar.getInstance(); int year = now.get(Calendar.YEAR); int month = now.get(Calendar.MONTH); int day = now.get(Calendar.DAY_OF_WEEK); int date = now.get(Calendar.DATE); int hour = now.get(Calendar.HOUR_OF_DAY); int minute = now.get(Calendar.MINUTE); int second = now.get(Calendar.SECOND);​ System.out.println(now.getTime()); System.out.printf("%d-%d-%d %d:%d:%d\n%d\n", year, month, day, hour, minute, second, date);​ // 创建一个表示2009年3月12日的Calendar对象 now.set(2009, 3-1, 12); System.out.println(now.getTime()); &#125;&#125; 6）GregorianCalendar类：实现了公历日历，是Calendar类的一个具体实现。1234567891011public class DateTestDemo &#123; public static void main(String[] args) &#123; GregorianCalendar gCalender = new GregorianCalendar(); int year = gCalender.get(Calendar.YEAR); if (gCalender.isLeapYear(year)) &#123; System.out.println("当前年份是闰年！"); &#125; else &#123; System.out.println("当前年份不是闰年！"); &#125; &#125;&#125; 6，正则表达式1） java.util.regex包主要包括以下三个类： Pattern类：是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类：是对输入字符串进行解释和匹配操作的引擎。 PatternSyntaxException：是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 12345678public class RegexDemo &#123; public static void main(String[] args) &#123; String content = "I am a student, graduated from HuBei University."; String pattern = ".*HuBei.*"; boolean isMath = Pattern.matches(pattern, content); System.out.println("字符串是否包含类'HuBei'子字符串？"+isMath); &#125;&#125; 2）捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。1234567891011121314151617181920public class RegexDemo &#123; public static void main(String[] args) &#123; String content = "I am a student, graduated from HuBei University in 2013. "; String pattern = "(\\D*)(\\d+)(.*)";​ // 创建Pattern对象 Pattern rex = Pattern.compile(pattern);​ // 创建matcher对象 Matcher matcher = rex.matcher(content); if (matcher.find()) &#123; System.out.println("Found value: " + matcher.group(0)); System.out.println("Found value: " + matcher.group(1)); System.out.println("Found value: " + matcher.group(2)); System.out.println("Found value: " + matcher.group(3)); &#125; else &#123; System.out.println("No match!!!"); &#125; &#125;&#125; 7，Java方法1）Java方法定义：Java方法是语句的集合，他们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 2）Java方法的优点 使程序变得更简短而清晰 有利于程序维护 可以提高程序开发的效率 提高了代码的重用性 3）Java方法的命名规则 必须以字母、&#39;_&#39;或&#39;＄&#39;开头（方法名第一个单词应以小写字母开头，后面的单词则用大写字母开头写，不使用连接符）； 可以包括数字，但不能以它开头； 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。 4）Java方法的定义123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 5）Java方法调用1234567891011121314151617public class MaxTest &#123; public static void main(String[] args) &#123; int i = 2, j = 4; int max = getMax(i, j); System.out.printf("%d和%d比较，最大值是：%d.", i, j, max); &#125;​ private static int getMax(int num1, int num2) &#123; int result; if (num1 &gt; num2) result = num1; else result = num2;​ return result; &#125;&#125; 6）void关键字 7）Java方法重载：一个类的两个方法拥有相同的名字，但是有不同的参数列表。 8）变量作用域 9）命令行参数：命令行参数是在执行程序时候紧跟在程序名字后面的信息。 10）构造方法：当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 11）可变参数：JDK1.5开始，Java支持传递同类型的可变参数给一个方法。1typeName... parameterName 在方法声明中，在指定参数类型后加一个省略号(...) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。12345678910111213141516171819202122public class MaxTest &#123; public static void main(String[] args) &#123;​ double max = getMax(1, 2, 3, 4, 5, 6, 7, 8, 0, 1); System.out.printf("...numbers中，最大值是：%.2f.", max); &#125;​ private static double getMax(double... numbers) &#123; if (numbers.length == 0) &#123; System.out.println("No argument passed."); return -10000000000L; &#125;​ double result = numbers[0]; for (double var: numbers) &#123; if (var &gt; result) &#123; result = var; &#125; &#125; return result; &#125;&#125; 12）finalize()方法：在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。 Java 的内存回收可以由 JVM 来自动完成。 FinalizationDemo.java如下：1234567891011121314151617181920212223public class FinalizationDemo &#123; public static void main(String[] args) &#123; Cake c1 = new Cake(1); Cake c2 = new Cake(2); Cake c3 = new Cake(3);​ c2 = c3 = null; System.gc(); // 调用Java垃圾回收集器 &#125;&#125;​class Cake extends Object &#123; private int id; public Cake(int id) &#123; this.id = id; System.out.println("Cake Object " + id + " is created."); &#125;​ protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("Cake object " + id + " is disposed."); &#125;&#125; 8，Java流（Stream），文件（File）和IOJava.io包几乎包含了所有操作输入、输出需要的类。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 1）读取控制台输入：Java的控制台输入由System.in完成。1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 2）从控制台读取多字符输入：从BufferedReader对象读取一个字符要使用 read()方法。1int read() throws IOException BRReadLine.java1234567891011public class BRReadLine &#123; public static void main(String[] args) throws IOException &#123; char ch; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println("输入字符，按下'q'键退出."); do &#123; ch = (char) br.read(); System.out.println(ch); &#125; while (ch != 'q'); &#125;&#125; 3）从控制台读取字符串：从 标准输入读取一个字符要使用BufferedReader的 readLine()方法。1String readLine() throws IOException BRReadLines.java123456789101112public class BRReadLines &#123; public static void main(String[] args) throws IOException &#123; String str; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println("Enter lines of text;"); System.out.println("Enter 'end' to quit."); do &#123; str = br.readLine(); System.out.println(str); &#125; while (!str.equals("end")); &#125;&#125; 4）控制台输出：控制台的输出由 print() 和 println() 完成。12345678public class WriteDemo &#123; public static void main(String[] args) &#123; int num; num = 'A'; System.out.write(num); System.out.write('\n'); &#125;&#125; 5）读写文件：一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 6）FileInputStream：该流用于从文件读取数据，它的对象可以用关键字new来创建。12345678910111213141516171819202122232425/** * 把给定的context以二进制写进文件，同时输出控制台 * 但是存在乱码问题 */public class FileStreamTest &#123; public static void main(String[] args) throws IOException &#123; try &#123; byte[] bWrite = &#123;'a', 11, 21, 32, 40, 54&#125;; OutputStream os = new FileOutputStream("file_test.txt"); for (byte var: bWrite) &#123; os.write(var); &#125; os.close();​ InputStream is = new FileInputStream("file_test.txt"); int size = is.available(); for (int i = 0; i &lt; size; i++) &#123; System.out.println((char) is.read() + " "); &#125; is.close(); &#125; catch (IOException ex) &#123; System.out.println("File InputStream error: " + ex.toString()); &#125; &#125;&#125; 7）FileOutputStream：该流用来创建一个文件并向文件中写数据，它的对象可以用关键字 new 来创建。1234567891011121314151617181920212223242526272829303132333435/** * 把给定的context以二进制写进文件，同时输出控制台 */public class FileIOStreamTest &#123; public static void main(String[] args) throws IOException &#123; File file = new File("file_test.txt");​ // 构建FileOutputStream对象，文件不存在会自动新建 FileOutputStream fop = new FileOutputStream(file);​ // 构建对象，参数可以指定编码，默认为操作系统默认编码，windows是gbk OutputStreamWriter writer = new OutputStreamWriter(fop, "UTF-8");​ // 写入到缓冲区 writer.append("中文输入"); writer.append("\r\n"); writer.append("English input");​ // 关闭写入流，同时会把缓冲区的内容写入文件 writer.close();​ // 关闭输出流，释放系统资源 fop.close();​ FileInputStream fip = new FileInputStream(file); InputStreamReader reader = new InputStreamReader(fip, "UTF-8"); StringBuilder sb = new StringBuilder(); while (reader.ready()) &#123; sb.append((char) reader.read()); &#125; System.out.println(sb.toString()); reader.close(); fip.close(); &#125;&#125; 关于文件和I/O的一些其他类：File Class；FileReader Class；FileWriter Class。 9，Java中的目录1）创建目录File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。 mkdirs()方法创建一个文件夹和它的所有父文件夹。 1234567public class CreateDir &#123; public static void main(String[] args) &#123; String dirName = "/home/share/java"; File file = new File(dirName); file.mkdirs(); &#125;&#125; 2）读取目录12345678910111213141516171819202122public class ReadDir &#123; public static void main(String[] args) throws IOException &#123; String dirName = "/home/share"; File fp = new File(dirName); if (fp.isDirectory()) &#123; System.out.println("目录：" + dirName); // 提取包含的文件和文件夹的列表 String[] strings = fp.list(); for (int i = 0; i &lt; strings.length; i++) &#123; File tmp = new File(dirName + "/" + strings[i]); if (tmp.isDirectory()) &#123; System.out.println(strings[i] + " 是一个目录."); &#125; else &#123; System.out.println(strings[i] + " 是一个文件."); &#125; &#125; &#125; else &#123; System.out.println(dirName + " 不是一个目录."); &#125; &#125;&#125; 3）删除目录或文件：删除文件可以使用java.io.File.delete()方法。123456789101112131415161718192021public class DeleteDir &#123; public static void main(String[] args) &#123; File folder = new File("/home/share/java"); deleteFolder(folder); &#125;​ // 删除文件及目录 private static void deleteFolder(File folder) &#123; File[] files = folder.listFiles(); if (files != null) &#123; for (File fp: files) &#123; if (fp.isDirectory()) &#123; deleteFolder(fp); &#125; else &#123; fp.delete(); &#125; &#125; &#125; folder.delete(); &#125;&#125; 10，Java Scanner类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。基本语法如下：1Scanner scanner = new Scanner(System.in); 1）使用next方法 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next()不能得到带有空格的字符串。 ScannerNext.java12345678910111213public class ScannerNext &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println("Next方式接收：");​ // 判断是否还有输入 if (scan.hasNext()) &#123; String str = scan.next(); System.out.println("输入的数据为：" + str); &#125; scan.close(); &#125;&#125; 2）使用nextLine方法 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 ScannerNextLines.java12345678910111213class ScannerNextLines &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println("NextLine方式接收：");​ // 判断是否还有输入 if (scan.hasNextLine()) &#123; String str = scan.nextLine(); System.out.println("输入的数据为：" + str); &#125; scan.close(); &#125;&#125; 注意：如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取。 ScannerNumbers.java12345678910111213141516171819202122232425262728293031323334public class ScannerNumbers &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in);​ int numberI; float numberF; double numberD; System.out.println("输入整数："); if (scan.hasNextInt()) &#123; numberI = scan.nextInt(); System.out.println("整数是：" + numberI); &#125; else &#123; System.out.println("输入的不是整数！"); &#125;​ System.out.println("输入浮点数："); if (scan.hasNextFloat()) &#123; numberF = scan.nextFloat(); System.out.println("浮点数是：" + numberF); &#125; else &#123; System.out.println("输入的不是浮点数！"); &#125;​ System.out.println("输入双精度小数："); if (scan.hasNextDouble()) &#123; numberD = scan.nextDouble(); System.out.println("双精度小数是：" + numberD); &#125; else &#123; System.out.println("输入的不是双精度小数！"); &#125;​ scan.close(); &#125;&#125; 11，Java异常处理1）理解Java异常处理是如何工作的，需掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。 2）Exception 类的层次 所有的异常类是从 java.lang.Exception 类继承的子类。 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable 类还有一个子类Error 。 Error 用来指示运行时环境发生的错误。例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 在 Java 内置类中，有大部分常用检查性和非检查性异常。 3）Java内置类4）异常方法：主要是Throwable的方法。5）捕获异常123456789101112public class ExceptionDemo &#123; public static void main(String[] args) &#123; try &#123; int[] array = new int[2]; array[0] = 1; System.out.println("Access elements three: " + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println("Exception: " + ex.toString()); &#125; System.out.println("Out of the block."); &#125;&#125; 6）多重捕获块：一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 7）throws/throw关键字：如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 8）finally关键字：finally 关键字用来创建在 try 代码块后面执行的代码块；无论是否发生异常，finally 代码块中的代码总会被执行；在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 ExceptionDemo.java1234567891011121314public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] array = new int[2]; try &#123; System.out.println("Access elements three: " + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println("Exception throw: " + ex.toString()); &#125; finally &#123; array[0] = 20; System.out.println("First element value: " + array[0]); System.out.println("The finally statement is executed."); &#125; &#125;&#125; 9）声明自定义异常 所有异常都必须是 Throwable 的子类。 如写一个检查性异常类，则需要继承 Exception 类。 如写一个运行时异常类，那么需要继承 RuntimeException 类。 综合实例 InsufficientFundException.java： 123456789101112/** * 自定义异常，继承Exception类 */public class InsufficientFundException extends Exception &#123; private double amount; public InsufficientFundException(double amount) &#123; this.amount = amount; &#125; public double getAmount() &#123; return amount; &#125;&#125; CheckingAccount.java： 1234567891011121314151617181920212223242526272829303132333435/** * 银行账户基本操作类 */public class CheckingAccount &#123; private double balance; private int number; public CheckingAccount(int number) &#123; this.number = number; &#125;​ // 存钱 public void deposit(double amount) &#123; balance += amount; &#125;​ // 取钱 public void withdraw(double amount) throws InsufficientFundException &#123; if (amount &lt;= balance) &#123; balance -= amount; &#125; else &#123; double needs = amount - balance; throw new InsufficientFundException(needs); &#125; &#125;​ // 返回余额 public double getBalance() &#123; return balance; &#125;​ // 返回账号 public int getNumber() &#123; return number; &#125;&#125; BankDemo.java： 123456789101112131415161718192021** * 模拟银行账户基本操作实例 */class BankDemo &#123; public static void main(String[] args) &#123; CheckingAccount account = new CheckingAccount(6228481); System.out.println("Deposit $500..."); account.deposit(500.00);​ try &#123; System.out.println("Withdrawing $100..."); account.withdraw(100);​ System.out.println("Withdrawing $600..."); account.withdraw(600); &#125; catch (InsufficientFundException ex) &#123; System.out.println("Sorry, but you are short $"+ex.getAmount()); ex.printStackTrace(); &#125; &#125;&#125; 10）通用异常在Java中定义了两种类型的异常和错误： JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据库理论】关系数据库]]></title>
    <url>%2F2019%2F04%2F10%2Fdb_rdb%2F</url>
    <content type="text"><![CDATA[本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，关系模型的基本概念 关系及基本术语 在关系模型中，表格的第一行称为关系框架，是属性$A_1$，$A_2$，$A_3$，$\dots$，$A_k$的有限集合。 表中的每行称为关系的一个元组；每列称为属性，它在某个值域上的取值，不同的属性可以在相同的值域上取值。 关系中的属性个数称为元数（Arity），元组个数称为基数。 关键字 超关键字(Super Key)：在关系中能够唯一标识元组的属性集合。 候选关键字(Candidate Key)：如果某一属性集合是超关键字，但去掉其中任意属性后就不再是超关键字，这样的属性称为候选关键字。 候选关键字的诸属性称为主属性，不包含在任何候选关键字中的属性称为非主属性（非码属性）。 主关键字(Primary Key)：如果关系中存在多个候选关键字，用户可选作元组标识的一个候选关键字为主关键字。 合成关键字(Composite Key)：当某个候选关键字包含多个属性时，该候选关键字称为合成关键字。 外部关键字(Foreign Key)：如果关系R的某个（些）属性K不是R中的候选关键字，而是另一个关系S的候选关键字，则K称为R的外部关键字。 二，关系模式 在关系数据库中，关系模式是型，关系是值。 【定义3-1】关系的描述称为关系模式，形式化表示为$R(U, D, DOM, I, F)$其中，$R$为关系名，$U$为组成该关系的属性名集合，$D$是$U$中属性的域，$DOM$为属性到域的映像集合，$I$为完整性约束集合，$F$为属性间数据的依赖关系集合。 ⚠️关系模式中带有下画线的属性集为主关键字。 三，关系模型的完整性 域完整性约束：主要规定属性值必须取自值域，一个属性能否为空值由其语义决定。 实体完整性约束：规定基本关系的所有主属性都不能取空值，而不仅是主属性整体不能取空值。 参照完整性约束：要求“不引用不存在的实体”，考虑的是不同关系之间的或同一关系的不同元组之间的制约。形式定义： 如果属性集K是关系R的主关键字，K也是关系S的外关键字，那么在关系S中，K的取值只允许两种可能，要么为空值，要么等于关系R中某个主关键字的值。关系R称为“参照关系”模式，关系S称为“依赖关系”模式。 用户自定义完整性约束：针对某个具体关系数据库的约束条件。 四，关系代数 关系查询语言分类 关系代数语言：查询操作是以集合操作为基础运算的DML语言。 关系演算语言：查询操作是以谓词演算为基础运算的DML语言。 关系代数的五种基本操作 相等定义：设有同类关系$r_1$和$r_2$，若$r_1$的任何一个元组都是$r_2$的一个元组，则称关系$r_2$包含关系$r1$，记作$r_1$ $\subseteq$ $r_2$或 $r_2$ $\supseteq$ $r_1$，如果$r_1$ $\subseteq$ $r_2$且$r_1$ $\supseteq$ $r_2$，则称关系$r_1$等于关系$r_2$，记作$r_1$=$r_2$。 【定义3-2】并(Union)：设有同类关系$r_1$[R]和$r_2$[R]，两者的并(Union)运算定义 $r_1$ $\bigcup$ $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\vee$ $t$ $\in$ $r_2$ }式中，$\bigcup$为并运算符。$r_1$ $\bigcup$ $r_2$的结果关系是$r_1$的所有元组与$r_2$的所有元组的并集（去掉重复元组）。 【定义3-3】差(Difference)：设有同类关系$r_1$[R]和$r_2$[R]，两者的差(Difference)运算定义为 $r_1$ - $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\wedge$ $t$ $\notin$ $r_2$ }式中，- 为相减运算符。$r_1$ - $r_2$的结果关系是$r_1$的所有元组减去$r_1$与$r_2$相同的元组所剩下的元组的集合。 【定义3-4】笛卡儿积(Difference)：设$r$[R]为$k_1$元关系，$s$[S]为$k_2$元关系，两者的笛卡儿积(Difference)运算定义为 $r$ $\times$ $s$ = { $t$ $\mid$ $t$ = &lt;$u,v$&gt; $\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $s$ }。 【定义3-5】投影(Projection)：是对一个关系进行垂直分割，消去某些列，并重新安排列的顺序的操作。设有$r$[R]为$k$元关系，其关系框架R={$A_1$,$A_2$,$\dots$,$A_k$}，$A_{j_1}$，$A_{j_2}$，$\dots$，$A_{j_n}$ 为R中互不相同的属性，那么关系$r$在属性（分量）$A_{j_1}$，$A_{j_2}$，$\dots$，$A_{j_n}$ 上的投影运算定义为 $\Pi$ $A_{j_1}$,$A_{j_2}$,$\dots$,$A_{j_n}$ $($ $r$ $)$ = { $u$ $\mid$ $u$ = &lt; $t$ [$A_{j_1}$],$t$[$A_{j_2}$],$\dots$,$t$[$A_{j_n}$] &gt; $\wedge$ $t$ $\in$ $r$ }式中，$\Pi$为投影运算符。 【定义3-6】选择(Selection)：根据某些条件对关系进行水平分割，即选取符合条件的元组的操作。条件可用命题公式F表示，由运算对象和运算符组成： 运算对象：常数（用引号括起来）、元组分量（属性名或列的序号） 运算符：算术比较运算符（$\lt$,$\le$,$\gt$,$\ge$,=,$\ne$，也称$\theta$符），逻辑运算符（$\vee$,$\wedge$,$\neg$） 关系R关于公式F的选择操作用$\sigma$F$($R$)$表示，其定义为：$\sigma$F $($ R $)$ $\equiv$ { $t$ $\mid$ $t$ $\in$ R $\wedge$ F($t$)=true}式中，$\sigma$为选择运算符。$\sigma$F$($R$)$表示从R中挑选满足公式F为真的元组所构成的关系。 关系代数的其他操作 【定义3-7】交(Intersection)：设有同类关系$r_1$[R]和$r_2$[R]，两者的交(Intersection)运算定义 $r_1$ $\bigcap$ $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\wedge$ $t$ $\in$ $r_2$}式中，$\bigcap$为交运算符。$r_1\bigcapr_2$的结果关系是$r_1$与$r_2$的所有相同元组构成的集合，显然，$r_1\bigcapr_2$ 等于$r_1$ - ($r_1$ - $r_2$ )或者$r_2$ - ($r_2$ - $r_1$ )。 【定义3-8】$\theta$-连接：设$r$[R]、$s$[S]关系框架分别为R = {$A_1$,$A_2$,$\dots$,$A_n$} 和 {$B_1$,$B_2$,$\dots$,$B_m$}，那么关系$r$和$s$的$\theta$-连接（$\theta$-Join）运算定义为：$r$ $\Join$ $s$ = { $t$ $\mid$ $t$ = &lt; $u, v$ &gt;$\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $u$[$A_i$]$\theta$ $v$[$B_j$]} 【定义3-9】F-连接 ：设$r$[R]、$s$[S]关系框架分别为R = { $A_1$,$A_2$,$\dots$,$A_n$ }，{ $B_1$,$B_2$,$\dots$,$B_m$ }，F($A_1$,$A_2$,$\dots$,$A_n$,$B_1$,$B_2$,$\dots$,$B_m$)为一公式，那么关系$r$和$s$的F-连接（F-Join）运算定义为：$r$ $\Join$ $s$ = { $t$ $\mid$ $t$ = &lt; $u, v$&gt;$\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $s$ $\wedge$F($u$[$A_1$],$\dots$,$u$[$A_n$]),$u$[$B_1$],$\dots$,$u$[$B_m$]) }即：$r$ $\Join$ $s$ = $\sigma$F $(r$ $\times$ $s)$ 【定义3-10】自然连接： Natural Jion是一种特殊的等值连接，它要求关系R和关系S具有相同的属性组B($b_1$,$b_2$,$b_3$,$\dots$ $\dots$)，这些属性组的取值是相等的，在最后生成的关系中去掉属性重复的列。其计算过程如下： (1)计算$r$ $\times$ $s$；(2)设$r$和$s$的公共属性是$A_1$,$A_2$,$\dots$,$A_m$，选出$r$ $\times$ $s$中满足$r.A_1$=$s.A_1$,$r.A_2$=$s.A_2$, $\dots$, $r.A_m$=$s.A_m$的那些元组；(3)去掉$s.A_1$,$s.A_2$,$\dots$,$s.A_m$这些列。 【定义3-11】除(Division)：给定关系$r$(X,Y)和$s$(Y,Z)，其中，X，Y，Z为属性组，$r$中的Y与$s$中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除(Division)运算得到一个新的关系$p$(X)，$p$是r中满足下列条件的元组在X属性列上的投影，即元组在X上的分量值$x$的像集$Y_x$包含s在Y上投影的集合，记为$r$ $\div$ $s$ = { $t_r$[X]$\mid$ $t_r$ $\in$ $r$ $\wedge$ $\pi_y$($s$) $\subseteq$ $Y_x$ }式中，$Y_x$为$x$在$r$中的像集，$x$=$t_r$[X]。 五，关系演算关系演算是以数理逻辑中的谓词为基础的，按谓词变元的不同，关系演算可以分为元组关系演算和域关系演算。 元组关系演算：以元组为变量。1） 在元组关系演算中，元组关系演算表达式的一般形式为：$\{t|P(t)\}$式中，t是元组变量，表示一个元数确定的元组，P是满足一定逻辑条件的公式，公式可以分解为一些原子公式，$\{t|P(t)\}$表示满足公式P的所有元组$t$的集合。2）在一个演算公式中，未用存在量词$\exists$或全称量词$\forall$符号定义的元组变量，称为自由元组变量，否则称为约束元组变量。 域关系演算：以属性(域)为变量，简称域演算。]]></content>
      <categories>
        <category>数据库技术</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java基础】Java入门知识]]></title>
    <url>%2F2019%2F04%2F08%2Fjava_introductory_knowledge%2F</url>
    <content type="text"><![CDATA[【学习参考资料】：菜鸟教程-Java教程 1，java简介 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。 1）Java分为三个体系： JavaSE(J2SE)Java2 Platform Standard Edition，java平台标准版） JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版) 2）Java的主要特性： java语言是简单的； java语言是面向对象的（纯面向对象）； java语言的分布式的； java语言是健壮的（丢弃指针，强类型机制，异常处理，垃圾的自动收集）； java语言是安全的（安全防范机制（类ClassLoader），安全管理机制（类SecurityManager））； java语言是可移植的； java语言是解释型的； java是高性能的； java语言多线程的； java语言是动态的。 3）Java的发展史：诞生于1995年；2014年3月18日，Oracle公司发表Java SE8。 4）Java工具：Java语言尽量保证系统内存在1G以上。 2，Java开发环境配置1）下载JDK工具解压安装，对应不同的系统选择适合的版本。 2）变量设置参数如下： 变量名：JAVA_HOME 变量值：C:\Program Files (x86)\Java\jdk1.8.0_91 // 要根据自己的实际路径配置 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; //记得前面有个”.“ 变量名：Path 变量值：%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 3）测试JDK是否安装成功12~ java -version # 输出java安装的版本~ javac -version # 输出javac安装的版本 注意：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。 4）Java开发工具选择 Eclipse IntelliJ IDEA(推荐) 3，Java基础语法1）相关概念 类：类是一个模板，描述一个对象的行为和状态。 java中的类： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 构造方法：每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 创建对象：在Java中，使用关键字new创建一个新的对象，主要有三步：声明，实例化（new），初始化。 对象：对象是一个类的实例，有状态和行为。 在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 方法：方法即行为，一个类可以有很多方法。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 2）编程注意点 大小写敏感 类名每个单词的首字母大写（帕斯卡命名法） 方法名以小写字母开头，之后每个单词首字母大写（驼峰命名法） 源文件名必须和类名相同 主方法入口，所有的Java程序由public static void main(String []args)方法开始执行 3）Java标识符 标识符：类名，变量名及方法名都称为标识符。 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始； 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合； 关键字不能用作标识符； 标识符是大小写敏感的； 合法标识符举例：age、$salary、_value、__1_value； 非法标识符举例：123abc、-salary； 4）Java修饰符 （1）访问控制： default, public, protected, private 修饰符 当前类 同一包内 子孙类（同一包） 子孙类（不同包） 其他包 public Y Y Y Y Y protected Y Y Y Y /N N default Y Y Y N N private Y N N N N protected说明： 子类与基类在同一包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。 （2）访问控制和继承，注意以下原则： 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为 public，不能声明为private。 父类中声明为private的方法，不能够被继承。 （3）非访问控制：final, abstract,static, synchronized,volatile static：创建类方法和类变量； final：修饰类，方法和变量。修饰的类不可被继承；修饰的方法不能被继承的类重新定义；修饰的变量为常量，不可修改。 abstract：创建抽象类和抽象方法； synchronized：用于线程编程，synchronized声明的方法同一时间只能被一个线程访问； transient：序列化的对象包含被 transient修饰的实例变量时，Java虚拟机(JVM)跳过该特定的变量；该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile：用于线程编程， 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值，当成员变量发生变化时，会强制线程将变化值回写到共享内 5）Java变量 局部变量：类的方法中的变量。 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 类变量（静态变量）：独立于方法之外的变量，用static修饰。成员变量（非静态变量）：独立于方法之外的变量，不用static修饰。 6）Java数组：储存在堆上的对象，可以保存多个同类型变量。 7）Java枚举：Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。 8）Java关键字：参见Java关键字列表 9）Java注释 10）Java空行：空白行，或者有注释的行，Java编译器都会忽略掉。 11）Java继承在Java中，一个类可以由其他类派生。被继承的类称为超类（super class），派生类称为子类（subclass）。 12）Java接口：在Java中，接口可以理解为对象间相互通信的协议。 13）源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致 如果一个类定义在某个包中，那么package语句应该在源文件的首行 如果源文件包含import语句，那么应该放在package语句和类定义之间；如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 14）Java包：包主要用来对类和接口进行分类。 15）Import语句 16）Java运算符 算术运算符 关系运算符 位运算符：Java定义类位运算符，应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 逻辑运算符 赋值运算符 其他运算符（instanceof，自增，自减，条件运算符） 17）Java 源程序与编译型运行区别]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据库实战】SQL Server数据库常用脚本]]></title>
    <url>%2F2019%2F04%2F07%2Fsql_used_script%2F</url>
    <content type="text"><![CDATA[1，创建链接远程服务器及其删除12345exec sp_addlinkedserver 'web','','SQLOLEDB','192.168.10.106'exec sp_addlinkedsrvlogin 'web','false',null,'sa','123'--删除链接服务器exec sp_dropserver 'web','droplogins' 2，重置SQLSERVER表的自增列，让自增列重新计数语法：123456DBCC CHECKIDENT( table_name [, &#123; NORESEED | &#123; RESEED [,new_reseed_value ] &#125; &#125; ] ) [ WITH NO_INFOMSGS ] 参数： table_name:是要对其当前标识值进行检查的表名。指定的表必须包含标识列。表名必须符合标识符规则。 NORESEED:指定不应更改当前标识值。 RESEED:指定应该更改当前标识值。 new_reseed_value:用作标识列的当前值的新值。 WITH NO_INFOMSGS:取消显示所有信息性消息。 查看某表当前的种子值，示例：1dbcc checkident('mainTable',noreseed); 123-------------显示如下----------------检查标识信息: 当前标识值 &apos;2707&apos;，当前列值 &apos;2707&apos;。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 重置表mainTable的当前标识值为1，示例：1dbcc checkident('mainTable',reseed,1); 123-------------显示如下----------------检查标识信息: 当前标识值 &apos;NULL&apos;，当前列值 &apos;1&apos;。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 3，几个有用的存储过程 修改xx表中所有值null 123456789101112131415161718192021222324252627282930313233/************************* 功能：修改xx表中所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/if (OBJECT_ID('modifyNull','P') is not null) drop procedure modifyNullgocreate procedure modifyNull(@table char(100))asbegin --定义游标 declare col_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select b.name from sysobjects a inner join syscolumns b on a.id=b.id where a.name=@table --打开游标 open col_cur declare @columnName nvarchar(100) fetch next from col_cur into @columnName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='update ' + @table + ' set ' + @columnName + ' = ISNULL(' + @columnName + ', '''')' exec(@sql) fetch next from col_cur into @columnName end --关闭游标 close col_cur --释放游标 deallocate col_curend 修改数据库中所有表的所有列为null 123456789101112131415161718192021222324252627/************************* 功能：修改数据库中所有表的所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/create procedure [dbo].[modifyAllNull]asbegin declare tab_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select name from sysobjects where xtype='U' --打开游标 open tab_cur declare @tableName nvarchar(100) fetch next from tab_cur into @tableName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='exec dbo.modifyNull ' +'''' + @tableName + '''' exec(@sql) fetch next from tab_cur into @tableName end --关闭游标 close tab_cur --释放游标 deallocate tab_curend]]></content>
      <categories>
        <category>数据库技术</category>
      </categories>
      <tags>
        <tag>数据库实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据库理论】绪论]]></title>
    <url>%2F2019%2F04%2F06%2Fdb_introduction%2F</url>
    <content type="text"><![CDATA[本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据库的概念 数据库定义：数据库（DB）是长期保存在计算机的存储设备上并按照某种模型组织起来的，可以被各种用户或应用共享的数据集合。 数据库分类：关系数据库，层次数据库，网状数据库. 数据库基本特征：1）具有较高的数据独立性；数据独立性是指数据的组织方法和储存方法与应用程序互不依赖，彼此独立的特性，包括物理独立性和逻辑独立性。2）数据库用综合的方法组织数据，保证尽可能高的访问效率；3）具有较小的数据冗余，可以供多个用户共享；4）具有安全控制机制，能够保证数据的安全，可靠；5）数据允许多用户共享，能够有效，及时地处理数据，并能够保证数据的一致性和完整性。 二，数据库管理系统（DBMS） DBMS的定义：DBMS是位于用户与操作系统之间的数据管理软件，数据库在建立，运用和维护时由数据库管理系统统一管理，控制。 DBMS的目标： 1）用户界面友好； 2）功能完备； 3）效率高，DBMS应该具有较高的系统效率和高的用户生产率，其中系统效率包括： （1）计算机内部资源的利用率，即能够充分利用磁盘空间，CPU，设备等资源，并注意使各种资源的负载均衡以提高整个系统的效率；（2）DBMS本身的运行效率，根据系统目标确定恰当的体系结构，数据结构和算法，保证DBMS运行的高效率；用户生产率是指用户设计和开发应用程序的效率； 4）结构清晰：DBMS内部结构清新，层次分明既便于支持其外层开发环境的构造，也便于自身的设计、开发与维护； 5）开放性：DBMS的开放性是指符合标准和规范，如ODBC标准，SQL标准等。 DBMS的基本功能： 1）数据库定义功能：DDL可以定义数据库中数据之间的联系，可以定义数据的完整性约束条件和保证完整性的触发机制等，包括全局逻辑数据结构（模式）的定义，局部逻辑数据结构（外模式）的定义，保密定义等；2）数据库操纵功能：DML可以接收，分析和执行用户提出的访问数据库的各种要求，完成对数据库的各种基本操作，如对数据库的检索，插入，删除和修改等操作，可以重新组织数据的存储结构，可以完成数据库的备份和恢复等操作；3）数据库的控制功能：DCL包括整个数据库系统的运行控制，数据库的完整性控制，数据库的安全性控制及多用户环境下的数据库并发访问控制等；4）数据库的运行管理功能：指DBMS运行机制和管理功能；5）数据库组织和存储管理功能6）数据库的建立和维护功能7）数据库通信功能 DBMS的组成： 1）数据库定义语言及其翻译程序： DDL用于描述数据库中要存储的现实世界实体的语言，包括数据字典中数据库的逻辑结构，完整性约束，物理存储结构的表述，数据库的各种数据操作和数据库的维护管理的各种依据。包括： 模式DDL：定义全局逻辑数据结构(包括所有字段的名称，特征及其相互关系)，数据的完整性，安全性约束；外模式DDL：为用户定义所用的局部逻辑数据结构(包括与用户的应用程序有关的字段名称，特征及其相互关系)，描述外模式到模式之间的映射关系；内模式DDL：用于描述数据在存储介质上的安排和存放方式，描述模式到内模式之间的映射关系； 2）数据库操纵语言及其编译（或解释）程序： DML用于实现对数据库的一些基本操作，如数据检索，数据插入，数据修改和数据删除，其中数据插入，数据修改和数据删除操作又称为数据更新操作。分为： 宿主型DML：本身不能独立使用，必须嵌入到宿主语言中，如C，COLBOL，PASCAL等，因此也称嵌入型DML，仅负责对数据库数据的操纵，其他工作都由宿主语言完成；自主型DML，又称自含型DML，可以独立进行数据查询，数据更新等操作，语法简单，使用方便，适合终端用户使用； 3）数据库运行控制程序：包括系统初启程序(DBMS的神经中枢)，访问控制程序，安全性控制程序，完整性检查程序，并发控制程序，数据存取/更新程序，通信控制程序； 4）数据库服务实用程序：包括数据装入程序，工作日志程序，性能监督程序，数据库重新组织程序，系统恢复程序，转储/编辑/打印程序。 数据库管理与数据库管理员(DBA)： 1）DBA：从事数据库管理工作的人员，不是数据库的“占有者”，而是数据库的“保护者”。 2) DBA职责 在数据库设计开始之前，DBA首先调查数据库的用户需求。 在数据库设计阶段，DBA要负责数据库标准的制定和功用数据字典的研制，要负责各级数据库模式的设计，负责数据库安全，可靠方面的设计，决定文件组织的方法。 在数据库运行阶段，DBA要负责对用户进行数据库方面的培训，负责数据库的转储和恢复，数据维护，用户的使用权限等，负责监控数据库的性能。 三，数据库系统（DBS） DBS定义：指在计算机系统中引入数据库后的系统构成，一般由数据库，数据库系统运行环境，数据库管理系统及其开发工具，数据库管理员和用户组成。 数据库系统的三级模式结构： 1）模式定义：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，而不涉及具体的值。 2）三级模式结构： 外模式：也称子模式或者用户模式，是数据库用户看见和使用的局部数据的逻辑结构和特征的描述，是数据库的用户视图，是和某个应用相关的数据逻辑表示；一个数据库可以有多个外模式； 模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共视图，是数据库的整个逻辑描述，并说明一个数据库所采用的数据模型；一个数据库只有一个模式； 内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据库的内部表示方式；一个数据库只有一个内模式。 二级映像功能和数据独立性： 1）外模式/模式映像：当模式改变时，DBA对各个外模式/模式的映像做出相应改变，使外模式保持不变，从而使应用程序不改变，保证了数据的逻辑独立性； 2）模式/内模式映像：唯一定义了数据全局逻辑结构和存储方式之间的对应关系。当数据库的存储方式改变时，DBA将对模式/内模式映像做出相应的改变，使模式保持不变，从而保证了数据的物理独立性。 数据库系统的体系结构： 1）单用户结构的数据库系统：最早最简单，不能共享数据； 2）主从式结构的数据库系统：结构简单，数据易于维护维护和管理，但系统的可靠性不高； 3）分布式结构的数据库系统：数据在逻辑上上一个整体，但是分布在计算机网络的不同结点上。 4）客户端/服务器结构的数据库系统 数据库系统的工作流程： 1）DBA建立并维护数据库； 2）用户编写应用程序； 3）应用程序在DBMS支持下运行，在模式，外模式，内模式，用户源程序翻译为目标代码后，即可启动目标程序。 四，数据库的发展 人工管理阶段： 1）特点：数据不保存；应用程序管理数据；数据不共享；数据不具有独立性。 文件系统阶段： 1）优点：数据可以长期保存；有专门的软件即文件系统管理数据，文件系统把数据组织成相互独立的数据文件；文件的形式多样化； 2）缺点：数据共享性差，冗余度大；数据独立性差；数据联系弱。 数据库系统阶段 数据库技术的研究，应用领域和发展方向 数据模型 数据库管理系统软件的研制 数据操作 数据库理论：主要集中在关系的规范化理论，关系数据理论等。 代表性的数据库应用领域和发展方向： 因特网上的Web数据库 面向对象数据库 多媒体数据库 并行数据库 人工智能领域的知识库和主动数据库 模糊数据库系统]]></content>
      <categories>
        <category>数据库技术</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据库理论】数据模型]]></title>
    <url>%2F2019%2F04%2F06%2Fdb_data_model%2F</url>
    <content type="text"><![CDATA[本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据描述 数据的三种范畴 1）现实世界（客观世界）：现实世界所反映的客观存在的事物及其相互之间的联系，指数处理对象最原始的表现形式。 2）信息世界（观念世界）：是现实世界在人们头脑中的反映，经过一定的选择，命名和分类而形成的。以下为相关概念： 实体（Entity）：客观存在的事物在人们头脑中的反映，或说，客观存在并可相互区别的客观事物或抽象事件。 属性（Attribute）：实体所具有的某一方面的特性。 域（Domain）：一个属性可能取的所有属性值的范围称为该属性的域。 码（Key）：唯一标识实体的属性集。 实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（Entity Set）：同一类型实体的集合。 3）机器世界（数据世界或存储世界）数据化后的信息称为数据，所以说数据是信息的符号表示。以下为相关概念： 数据项（字段，Field）：对应于信息世界中的属性。 记录（Record）：对应于每个实体所对应的数据。 记录型（Record Type）：对应于信息世界中的实体型。 文件（File）：对应于信息世界中的实体集。 关键字（Key）：对应于能够唯一标识一个记录的字段集。 实体间的联系 一对一联系：如果实体集A中每个实体，实体集B中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记作1:1； 一对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中至多有一个实体与之联系，则称实体集A与实体集B具有一对多联系，记作1:n； 多对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中有m（m&gt;=0）个实体与之联系，则称实体集A与实体集B具有多对多联系，记作n:m。 二，概念模型与E-R方法 数据模型 1）数据模型应满足以下要求： i）能够比较真实地模拟现实世界；ii）容易为人所理解；iii）便于在计算机上实现。 2）数据模型分类： i）概念模型：即信息模型，是按用户的观点来对数据和信息建模的，主要用于数据设计；ii）基本数据模型：主要包括网状模型，层次模型，关系模型等，是按计算机系统的观点对数据建模的，主要用于DBMS的实现。 数据模型的三要素 1）数据结构：用于描述系统的静态特性。数据结构是所有研究对象类型的集合，这些对象是数据库的组成部分，分为两大类： 与数据类型，内容，性质有关的对象； 与数据之间联系有关的对象。 2）数据操作：用于描述系统的动态特征。数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有检索和修改（插入，删除，更新）两大数据操作。 3）数据完整性约束：是一组完整性规则的集合。完整性规则是给定的数据模型中的数据及其联系所具有的制约和存储规则，用于限制符合数据模型的数据库状态及状态的变化，用于确保数据的正确、有效和相容。 概念数据模型 1）概念模型的定义：按用户的观点对现实世界进行数据建模而形成的，是一种独立于计算机系统的模型，完全不涉及信息在计算机系统中的表示，也不依赖于具体的数据库管理系统，用于描述某个特定组织所关心的信息结构。 2）概念模型的相关基本概念：实体、属性、域、码、实体型和实体集。 3）概念模型的基本关系：在概念模型中主要解决问题是实体间的联系。 E-R图表示法 1）实体型：用矩形表示，矩形框内写明实体名； 2）属性：用椭圆表示，椭圆内写明属性名； 3）联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标注联系的类型（1:1，1:n，n:m）。 E-R模型优点： i）接近人的思想，容易理解；ii）与计算机无关，用户容易接受。 三，传统的三大数据模型 层次模型 1）层次模型定义：用树形结构表示实体之间的联系的模型称为层次模型。 2）建立数据的层次模型需要满足以下条件： i）有且仅有一个结点没有父结点，这个结点即为树根结点；ii）其他数据记录有且仅有一个父结点。 3）层次模型的基本特点：任何一个给定的记录值只有按其路径查看，才能体现它的全部含义，没有一个子记录值能够脱离父记录值而独立存在的。 4）层次模型的最明显特点：层次清晰，构造简单，易于实现，可以很方便地表示一对一和一对多这两种实体之间的联系。 5）层次模型的主要优点： i）层次模型本身比较简单；ii）实体间联系是固定的，且预先定义好的应用系统采用层次模型来实现，其性能优于关系模型的性能，不低于网状模型的性能；iii）层次模型提供了良好的完整性支持。 6）层次模型的主要缺点： i）现实世界中很多联系是非层次性的，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据或创建非自然组织（引入虚结点）来解决；ii）对插入和删除操作的限制比较多；iii）查询子结点必须通过父结点；iv）由于结构严谨，层次命令趋于程序化。 网状模型 1）网状模型的定义： 网状模型是一种有向图，在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型： i）允许一个以上的结点无父结点；ii）一个结点可以有多于一个的父结点。 2）为了描述网状模型的记录之间的联系，引进了系（Set）的概念，所谓系可以理解为命名了的联系，它由一个父记录型和一个或多个子记录型构成。 3）网状数据库的定义：用网状模型设计出来的数据库称为网状数据库。 4）网状模型的主要优点： i）能够更为直接地描述现实世界，如一个结点可以有多个父结点；ii）具有良好的性能，存取效率较高。 5）网状模型的主要缺点： i）结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于用户最终掌握；ii）其DDL，DML语言复杂，用户不易使用。 关系模型 1）关系模型的主要优点： i）数据结构比较简单；ii）具有很高的数据独立性；iii）可以直接处理多对多联系；iv）坚实的理论基础。 2）值域的定义：在关系模型中，一个n元关系有n个属性，属性的取值范围称为值域。 3）关系模型主要缺点：存取路径对用户透明，查询效率往往不如非关系数据模型。 四，数据独立与三层结构 三级模式结构 外模式：又称为用户模式，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看得见和使用的局部数据的逻辑结构和特征描述，是与某一个应用有关的数据的逻辑表示。 模式：可分为概念模式和逻辑模式，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。 一个数据库只有一个模式，其中概念模式可以用实体-联系模型模型来描述，逻辑模式以某种数据模型为基础，综合考虑所有用户的需求，并将其形成全局逻辑结构。 内模式：又称为存储模式，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。 数据的独立性 逻辑数据独立性：当模式改变时，只要对外模式/模式映像做相应的改变，就可以使外模式保持不变，以外模式为依据编写的应用程序就不受影响，从而应用程序不必修改，保证了数据与程序之间的逻辑独立性。 存储数据独立性：当内模式改变时，只要对模式/内模式映像做相应的改变，使模式保持不变，应用程序就不受影响，从而保证了数据与程序之间的物理独立性，称为存储数据独立性。 五，数据库管理系统 DBMS的主要功能 数据库的主要职责就是有效地实现数据库三级模式之间的转换，即把用户或应用程序对数据库的一次访问，从用户级带到概念级，再导向物理级，转换为对存储数据的操作。 1）数据库定义2）数据库操作及查询优化3）数据库控制运行管理4）数据组织，存储和管理5）数据库的恢复和维护6）数据库的多种接口7）其他功能 DBMS的组成 1）DBMS由查询处理器和存储管理器两大部分组成。其中： (1) 查询处理器主要有DDL编译器，DML编译器，嵌入式DML的预编译器及查询运行核心程序；(2) 存储管理器有授权和完整性管理器，事务管理器，文件管理器及缓冲区管理器。 2）查询处理程序：把用较高级的语言所表示的数据库操作（查询、更新等）转换成一系列对数据库的请求。 3）存储管理程序：包括文件管理程序和缓冲区管理程序。 4）事务管理程序：保证数据库中所有事务全部都能正确执行。 用户访问数据库的过程（略）]]></content>
      <categories>
        <category>数据库技术</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
</search>
