---
title: 【数据库理论】关系模式的规范化与查询优化
type: categories
copyright: false
date: 2019-04-13 22:31:38
tags: 数据库理论
categories: 数据库技术
title_en: db_query_opt
mathjax: true
---

> 本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。

## 一，问题的提出
1，**关系模式**

`关系模式`定义：一个关系模式是一个系统，它是有一个五元组$R(U, D, DOM, I, F)$组成，其中，$R$为关系名，$U$是$R$的一组属性集合$\{ A_1,A_2,A_3,\dots,A_n \}$，$D$是$U$中属性的域集合$\{ D_1,D_2,D_3,\dots,D_n \}$，$DOM$为属性$U$到域$D$的映射，$I$为完整性约束集合，$F$为属性间的函数依赖关系。

2，**关系**

1）`关系`定义：在关系模式$R( U, D, DOM, I, F )$中，当且仅当$U$上的一个关系$r$足$F$时，$r$称为关系模式$R$的一个关系，记作$R(U)$或$R(U,F)$。

2）关系数据库对关系有一个**最起码的要求**： 每个属性必须是不可分割的数据项。满足列这个条件的关系模式就属于`第一范式（1NF）`。

3）`数据依赖`：通过一个关系中属性间值的相等与否以体现数据间的相互关系，是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。主要有：`函数依赖FD`，`多值依赖MVD`。

3，**插入异常**：表示数据插入时出现问题，即无法在缺少另一个实体实例或者关系实例的情况下表示实体或者实体的信息。

4，**删除异常**：删除表的某一行来反映某个实体实例或者关系实例消失，会导致丢失另一个不同实例实体或者关系实例的信息。

5，**更新异常**：更改表所对应的某个实体实例或者关系实例的单个属性，会将多行的相关信息全部更新。

## 二，关系模式的函数依赖
1，**函数依赖（`FD`）**

1）`函数依赖（FD）`定义：设$R(U)$是属性集$U$上的关系模式，$X$，$Y \subseteq U$。若对$R(U)$的任意一个可能的关系$r$，$r$中有任意两个元组$t_1$和$t_2$，如果$t_1 [ X ] = t_2 [ X ]$，有$t_1[ Y ] = t_2[ Y ]$，则称$X$函数确定$Y$，或者说$Y$函数依赖$X$，记为$X \rightarrow Y$。
 
>（1）如果$X \rightarrow Y$，但是$Y \nsubseteq X$，则称$X \rightarrow Y$是`非平凡的函数依赖`；
>（2）如果$X \rightarrow Y$，但是$Y \subseteq X$，则称$X \rightarrow Y$是`平凡的函数依赖`；
>（3）如果$X \rightarrow Y$，则$X$为这个函数依赖的`决定属性集(Determinant)`；
>（4）如果$X \rightarrow Y$，$Y \rightarrow X$，则记为$X \longleftrightarrow Y$；
>（5） 如果$Y$不函数依赖于$X$，则记为$X \nrightarrow Y$。

2）`完全函数依赖`和`部分函数依赖`
设$R(U)$是属性集$U$上的关系模式，如果$X \rightarrow Y$，并且对于$X$的任何一个真子集$Z$，都有$Z \nrightarrow Y$，则称$Y$完全依赖于$X$，记$X \stackrel{f}{\rightarrow} Y$；若$X \rightarrow Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记$X \stackrel{p}{\rightarrow} Y$。

3）`传递函数依赖`
设$R(U)$是属性集$U$上的关系模式，$X \subseteq U$，$Y \subseteq U$，$Z \subseteq U$，$Z - X$，$Z - Y$，$Y - X$均非空，如果$X \rightarrow Y(Y \nsubseteq X)$，$Y \nrightarrow X$，$Y \rightarrow Z$，则称$Z$传递依赖于$X$。

2，**键**

> 1）`候选键`：设$R(U)$是属性集$U$上的关系模式，$K \subseteq U$，如果$K \stackrel{f}{\rightarrow}  U$，则$K$为$R$的`候选键`。
候选键包含了关系模式的所有属性，称为`全键`。
> 2）`主属性`：包含在任意一个候选键中的属性称为`主属性`。
> 3）`非主属性`：不包含在任意候选键中的属性称为`非主属性`或`非键属性`。
> 4）`外键`：在关系模式$R$中属性或者属性组$X$并非$R$的候选键，但$X$是另一个关系模式的候选键，则称$X$是$R$的`外部键`，也称`外键`。

3，**函数依赖的逻辑蕴含**

1）**阿姆斯特朗公理体系**
   
   （1）`包含规则`：设$R(U)$是属性集$U$上的关系模式，$X \subseteq U$，$Y \subseteq U$，且$Y \subseteq X$，则$X \rightarrow Y$。
   
   （2）`平凡依赖`：由包含规则得到的函数依赖都是平凡函数依赖。
   
   （3）`逻辑蕴含`：设$R(U)$是属性集$U$上的关系模式，$F$是$R$上函数依赖集合，如果$R$的任意关系实例$r$使$F$成立的，函数依赖$X \rightarrow Y$均成立，则称$F$逻辑蕴含$X \rightarrow Y$。
   
   （4）`阿姆斯特朗公理`：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$的一个函数依赖集合，$X \subseteq U$，$Y \subseteq U$，$Z \subseteq U$。包含如下规则：

> i）`包含规则`：又称`自反律`，如果$Y \subseteq X \subseteq Z$，则$X \rightarrow Y$为$F$所蕴含；
> ii）`传递规则`：如果$F$蕴含$X \rightarrow Y$，$Y \rightarrow Z$，则$X \rightarrow Z$为$F$所蕴含；
> iii）`增广规则`：如果$F$蕴含$X \rightarrow Y$，且$Z \subseteq U$，则$XZ \rightarrow YZ$为$F$所蕴含。

`阿姆斯特朗公理`包含蕴含规则如下：

> i）`合并规则`：如果$X \rightarrow Y$，$X \rightarrow Z$，则$X \rightarrow YZ$；
> ii）`伪传递规则`：如果$X \rightarrow Y$，$WY \rightarrow Z$，则$WX \rightarrow Z$；
> iii）`分解规则`：如果$X \rightarrow Y$，$Z \subseteq Y$，则$X \rightarrow Z$；
> iv）`集合累积规则`：如果$X \rightarrow YZ$且$Z \rightarrow W$，则$X \rightarrow YZW$。

**【`引理4-1`】** $X \rightarrow A_1A_2A_3 \dots A_n$ 成立的充分必要条件是$X \rightarrow A_i（i=1，2，\dots，n）$成立。

2）**闭包，覆盖和最小覆盖**

（1）`函数依赖的闭包`：设$R$是一个具有属性集合$U$的关系模式，$F$是给定的函数依赖的集合，由$F$推导出的所有函数依赖的集合称为$F$的`闭包`，记作$F^{+}$。

（2）`函数依赖集的覆盖`：$R$表上的两个函数依赖集合$F$和$G$，如果函数依赖集$G$可以从$F$用`蕴含规则`推导出来，换言之，如果 $G \subset  F^{+}$，则称$F$ `覆盖` $G$，如果$F$ 覆盖 $G$ 且 $G$ 覆盖 $F$，则称这两个`函数依赖集等价`，记作$F \equiv G$。

（3）`属性集的闭包`：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$上的函数依赖集，$X \subseteq U$，定义$X$的`闭包` $X^+$，作为$X$函数决定的最大属性集$Y$，则最大属性集满足 $X \rightarrow Y$ 存在于 $F^+$ 中。

**【`算法4-1`】** 属性集 $X$ 的闭包 $X^+$ 的迭代算法：
> i）选$X$作为闭包$X^+$的初始值$X[0]$；
> ii）由$X[i]$计算$X[i+1]$时，它是由 $X[i]$ 并上属性集合$A$所组成的，其中$A$为$F$中存在的函数依赖 $Y \rightarrow Z$，而$A \subseteq Z$，$Y \subseteq X[i]$。因为$U$是有穷的所以上述过程经过有限步后会达到$X[i] = X[i+1]$，此时$X[i]$为所求的$X^+$。

（4）`最小覆盖`
> i）$F$中任意函数依赖的右部只包含一个属性；
> ii）不存在这样的函数依赖 $X \rightarrow A$，使得$F$与 $F- \{ X \rightarrow A \}$ 等价；
> iii）不存在这样的函数依赖$X \rightarrow A$，$X$包含真子集$Z(Z \subset X)$，使得 $(F-\{ X \rightarrow A \} \cup \{ Z \rightarrow A \})$与$F$等价。
如果$F$满足上述条件，则函数依赖$F$称为`极小或者最小函数依赖集`。

（5）`最小覆盖集算法`

从函数依赖集$F$构造最小覆盖$M$的算法如下：
> i）从函数依赖集$F$，创建函数依赖的一个等价集$H$，它的函数依赖的右边只有单个属性（使用`分解规则`）
> ii）从函数依赖集$H$，顺次去掉在$H$中非关键的单个函数依赖。一个函数依赖$X \rightarrow Y$在一个函数依赖集中是非关键的，指如果 $X \rightarrow Y$ 从$H$中去掉，得到结果$J$，仍然满足$H^+ = J^+$，或者说$H \equiv J$。
> iii）从函数依赖集$J$，顺次用左边具有更少属性的函数依赖替换原来的函数依赖，只要不会导致$J^+$改变。
> iv）从剩下的函数依赖集中收集所有左边相同的函数依赖，使用`合并规则`创建一个等价的函数依赖集$M$，它的所有依赖的左边是`唯一`的。

（6）每个函数依赖集$F$都等价于一个极小函数依赖集。

## 三，关系模式的规范化

`规范化`定义：把一个给定规范模式转化为某种范式的过程称为`关系模式的规范过程`，简称`规范化`。

1，**第一范式**

**【`定义4-1`】** 设$R$是一个关系模式，如果$R$的每个属性的值域都是**不可分割**的简单数据项的集合，则这个模式称为`第一范式关系模式`，记作`1NF`。

2，**第二范式**

**【`定义4-2`】** 如果关系模式$R$是`第一范式`，而且每个非主属性都**完全函数依赖**于$R$的键，则$R$称为`第二范式的关系模式`，记作`2NF`。

3，**第三范式**

**【`定义4-3`】** 设关系模式$R$满足`2NF`，而且它的任意一个非键属性都**不传递依赖**于任何候选键，则$R$称为`第三范式的关系模式`，记作`3NF`。

4，**BCNF**

**【`定义4-4`】** 设关系模式$R$满足`1NF`，如果对$R$的每个函数依赖 $X \rightarrow Y$ 且 $Y \nsubseteq X$，$X$必为`候选键`，则$R$满足`BCNF`，即：在关系模式 $R(U,F)$ 中，如果每个决定因素都包含键，则$R(U,F) \in BCNF$。

*一个满足`BCNF`的关系模式有如下* **条件**：

> i）所有非键属性对每个键都是完全函数依赖；
> ii）所有的键属性对每个不包含它的键，也是完全函数依赖；
> iii）没有任何属性完全函数依赖于非键属性的任意一组属性。

5，**多值依赖与第四范式**

1）**多值依赖**
   
   （1）`多值依赖`定义：设 $R(U)$ 是属性集$U$上的一个关系模式，$X$，$Y$，$Z$是$U$的子集，并且 $Z=U-X-Y$，关系模式$R(U)$中多值依赖 $X \rightarrow \rightarrow Y$ 成立，当且仅当对$R(U)$的任意关系$r$，给定的一对 $(x，z)$ 值，有一组$Y$的值，这组值仅仅取决于$x$值，而与$z$值无关。
   
   （2）如果 $X \rightarrow \rightarrow Y$，而 $Z=\varnothing$，即$Z$为空，则 $X \rightarrow \rightarrow Y$ 称为`平凡的多值依赖`。
  
   （3）`多值依赖的公理`（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。）

> i）`对称性规则`：如果 $X \rightarrow \rightarrow Y$，则 $X  \rightarrow \rightarrow U-X-Y$；
> ii）`传递性规则`：如果 $X \rightarrow \rightarrow Y$，$Y  \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow Z-Y$；
> iii）`增广规则`：如果 $X \rightarrow \rightarrow Y$，$V \subseteq W$，则 $WX  \rightarrow \rightarrow VY$；
> iv）`替代规则`：如果 $X  \rightarrow Y$，则$X \rightarrow \rightarrow Y$；
> v）`聚集规则`：如果$X \rightarrow \rightarrow Y$，$Z \subseteq Y$，$W \cap Z = \varnothing$，$W \rightarrow Z$，则 $X \rightarrow Z$。
   
   （4）`多值依赖的推导规则`（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。）
   
> i）`合并规则`：如果 $X \rightarrow \rightarrow Y$， $X \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow YZ$；
> ii）`分解规则`：如果 $X \rightarrow \rightarrow Y$， $X \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow Y \cap Z$，$X \rightarrow \rightarrow Y-Z$，$X \rightarrow \rightarrow Z-Y$；
> iii）`伪传递规则`：如果 $X \rightarrow \rightarrow Y$，$WY \rightarrow \rightarrow Z$，则 $WX \rightarrow \rightarrow (Z-WY)$；
> iv）`混合伪传递规则`：如果 $X \rightarrow \rightarrow Y$，$XY \rightarrow Z$，则 $X \rightarrow (Z-Y)$。

   （5）在$R(U)$上，如果有 $X \rightarrow \rightarrow Y$ 在 $W(W \subseteq U)$ 上成立，则 $X \rightarrow \rightarrow Y$ 称为$R(U)$的`嵌入型多值依赖`。
   
2）**第四范式**

**【`定义4-5`】**  设关系模式 $R(U,F) \in 1NF$，$F$是$R$上的多值依赖集，如果$R$的每个非平凡多值依赖 $X \rightarrow \rightarrow Y$（$Y-X \ne \varnothing$，$XY$未包含$R$的全部属性），$X$都含有$R$的候选键，则称$R$是`第四范式`，记为`4NF`。

6，**各范式之间的关系**

1）**各范式之间的关系**
$$4NF \subset BCNF \subset 3NF \subset 2NF \subset 1NF$$

2）**各范式小结**
![各范式小结](/images/db_query_opt_normal_form_20190413.png)

> i）$4NF$：限制关系模式的属性之间`不允许`有非平凡且非函数依赖的多值依赖；
> ii）$3NF \rightarrow BCNF$：消除主属性对候选关键字的`部分和传递`函数依赖；
> iii）$2NF \rightarrow 3NF$：消除非主属性对候选关键字的`传递`函数依赖；
> iv）$1NF \rightarrow 2NF$：消除非主属性对候选关键字的`部分`函数依赖。

## 四，关系模式的分解特性

1，**关系模式的分解**

1）`关系模式的分解`定义：把一个关系模式分解成若干个关系模式的过程，称为`关系模式的分解`。

**【`定义4-6`】** 关系模式$R(U, F)$ 的分解是指$R$为它的一组子集 $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 所代替的过程。其中，$U=U_1 \cup U_2 \dots \cup U_k$，并且设 $U_i \subseteq U_j(1 \le i,j \le k)$，$F_i$是$F$在$U$上的投影，即 $F_i = \{X \rightarrow Y \in F^+ \wedge XY \subseteq U_i \}$。

   分解后表的连接丢失或者多余元组的分解称为`有损分解`，或称`有损连接分解`。
   
2）`关系模式的分解`遵守原则： 
> i）`无损连接性`：信息不失真（不增减信息）；
> ii）`函数依赖保持性`：不破坏属性间存在的依赖关系。

2，**分解的无损连接性**

1）**无损连接的概念**

**【`定义4-7`】** 设$F$是关系模式$R$的函数依赖集，$\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 是$R$ 的一个分解，$r$是$R$的一个关系，定义
$$ m_{\rho}(r)=\pi_{U_{1}}(r) \infty \pi_{U_{2}}(r) \infty \cdots \infty_{\pi_{U_{k}}}(r) $$

如果$R$满足$F$的任意关系$r$均有则$r=m_\rho(r)$，则称分解 $\rho$ `具有无损连接性`。

**【`引理4-2`】** 设 $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 为关系模式$R$的一个分解， $r$是$R$的任一个关系，有
> (1) $r \subseteq m_\rho(r)$；
> (2) 如果 $s = m_\rho(r)$， 则 $\pi_{U_{i}}(r) = \pi_{U_{i}}(s)$；
> (3) $m_\rho(m_\rho(r)) = m_\rho(r)$。

2）**进行关系分解的必要性**

一个关系模式分解后，可以存放原来所不能存放的信息，通常称为“`悬挂`”的元组，这是实际所需要的，也是分解的优点。

3）**无损连接判定方法**

**【`算法4-2`】** (`矩阵法`)判别一个分解的无损连接性的算法。
> (1) 构造初始表：构造一个$k$行$n$列的初始表，其中，每列对应于$R$的一个属性，每行用于表示分解后的一个模式组成。如果属性$A_j$属于关系模式$R_i$，则表示在表的第$i$行第$j$列置符号$a_j$，否则置符号$b_{ij}$。
> (2) 根据$F$中的函数依赖修改表的内容：考察$F$中的每个函数依赖 $X \rightarrow Y$，在属性组$X$所在的那些列上寻找具有相同符号的行，如果找到这样的两行或者更多行，则修改这些行，使这些行上属性组$Y$所在的列上元素相同。`修改规则`是：如果$Y$所在的要修改的行有一个为$a_j$，则这些元素均变成$a_j$；否则改为$b_{mj}$（其中$m$为这些行的最小行号）。
> (3) 判断分解是否为无损连接：如果通过修改，发现表中有一行变为 $a_1,a_2,\dots,a_n$，则`分解是无损连接的`，否则`分解不具有无损连接性`。
  
**【`定理4-1`】** （`定理法`）设 $\rho = \{ R_1,R_2 \}$ 是关系模式$R$的一个分解，$F$是$R$的函数依赖集，$U_1$，$U_2$和$U$分别是$R_1$，$R_2$和$R$的属性集合，那么$\rho$是$R$(关于$F$)的无损分解的充分必要条件为
$$(U_1\cap U_2) \rightarrow U_1 - U_2 \in F^+$$ 
`或者`  
$$(U_1\cap U_2) \rightarrow U_2 - U_1 \in F^+$$

**【`定理4-2`】** （`逐步分解定理`）设$F$是关系模式$R$的函数依赖集，$\rho = \{ R_1,R_2,\dots,R_k \}$ 是$R$关于$F$的一个无损连接。
> （1）如果 $\sigma = \{ S_1,S_2,\dots,S_m \}$ 是 $R_i$ 关于 $F_i$ 的一个无损连接分解，则 $\varepsilon = \{ R_1,R_2,\dots,R_{i-1},S_1,S_2,\dots,S_m,R_{i+1},\dots,R_k \}$ 是$R$关于$F$的无损连接分解，其中，$F_i = \pi_{R_i}(F)$。
> （2）设 $\tau = \{ R_1,\dots,R_{k},R_{k+1},\dots,R_n \}$ 是 $R$ 的一个分解，其中，$\tau \supseteq \rho$，$\tau$ 也是$R$关于$F$的无损连接分解。

3）**分解的函数依赖保持性**

**【`定义4-8`】** 设$F$是关系模式$R$的函数依赖集， $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 为$R$的一个分解，如果 $F_i = \pi_{R_i}(F)(i=1,2,\dots,k)$ 的并集 $(F_1 \cup F_2 \cup \dots \cup F_k)^+ \equiv F^+$，则称分解 $\rho$ 具有`函数依赖保持性`。

3，**关系模式分解算法**

1）**分解的基本要求**：分解后的关系模式与分解前的关系模式等价，即分解必须具有`无损连接`和`函数依赖保持性`。

2）**分解算法的结论**
>  i）如果要求分解具有`无损连接性`，则分解一定可以达到`BCNF`；
>  ii）如果要求分解保持`函数依赖`，则分解可以达到`3NF`，但不一定能够达到`BCNF`；
>  iii）如果要求分解既具有`无损连接性`，又保持`函数依赖`，则分解可以达到`3NF`，但不一定能够达到`BCNF`。

## 五，关系模式的优化
1，**水平分解**

1）`水平分解`的**定义**：`水平分解`是把关系元组分为若干个子集合，每个子集合定义为一个子关系，以提高系统效率的过程。

2）`水平分解`的**规则**：
> （1）根据“`80%与20%原则`”，在一个大型关系中，经常使用的数据只是很有限的一部分，可以把经常使用的数据分解出来形成一个子关系。
> （2）如果关系$R$上具有$n$个事务，而且多数事务存取的数据不相交，则$R$可分解为不大于$n$个子关系，使每个事务存取的数据形成一个关系。

2，**垂直分解**

1）`垂直分解`的**定义**设 $R(A_1,A_2,\dots,A_k)$ 是关系模式，$R$的一个垂直分解是$n$个关系的集合$\{ R_1(B_1,B_2,\dots,B_v),\dots,R_n(D_1,D_2,\dots,D_m) \}$，其中，$\{B_1,B_2,\dots,B_v \},\dots,\{ D_1,D_2,\dots,D_m \}$ 是 $\{ A_1,A_2,\dots,A_k  \}$ 的子集合。

2）`垂直分解`的**基本原则**：经常在一起使用的属性从$R$中分解出来形成一个独立的关系。

## 六，关系查询优化

1，**关系系统及其查询优化**

1）**查询优化工作**：
> i）关系数据库内部提供的优化机制；
> ii）用户通过改变查询的运算次序和建立索引等机制进行优化。

2）**关系数据库查询优化的`总目标`**：选择有效的策略，快速求得给定关系表达式的值，以减少查询执行的总开销。
 
3）**查询执行的开销计算**
> i）在集中式数据库中，`总代价=I/O代价+CPU代价`
> ii）在多用户环境下，`总代价=I/O代价+CPU代价+内存代价`

2，**查询优化的一般策略**
> 1）尽量先执行选择运算
> 2）在执行连接前对关系适当地预处理：
>> i）索引连接；
>> ii）排序合并连接

3，**关系代数等价变换规则**

1）`连接，笛卡尔积交换律`
$$E_1 \times E_2 \equiv E_2 \times E_1$$  
$$E_{1} \infty E_{2} \equiv E_{2} \infty E_{1}$$ 
$$\begin{array}{c}{E_{1} \infty E_{2}} \\ {F}\end{array} \equiv \begin{array}{c}{E_{2} \infty E_{1}} \\ {F}\end{array}$$

2）`连接，笛卡尔积结合律`
$$(E_1 \times E_2) \times E_3 \equiv E_1 \times (E_2 \times E_3)$$  
$$(E_{1} \infty E_{2}) \infty E_{3} \equiv E_{1} \infty (E_{2} \infty E_{3})$$  
$$\begin{array}{c}{(E_{1} \infty E_{2}) \infty E_{3}} \\ {F_1} \quad \quad {F_2} \end{array} \equiv \begin{array}{c}{E_{1} \infty (E_{2} \infty E_{3})} \\ {F_1} \quad \quad {F_2} \end{array}$$

3）`投影的串接定律`
$$\pi A_1,A_2,\dots,A_n(\pi B_1,B_2,\dots.B_m(E)) = \pi A_1,A_2,\dots,A_n(E)$$

4）`选择的串接定律`
$$\sigma_{F_1}(\sigma_{F_2}(E)) \equiv \sigma_{F_1 \wedge F_2}(E)$$

5）`选择与投影的交换律`
$$F(\pi A_1,A_2,\dots,A_n(E)) \equiv \pi A_1,A_2,\dots,A_n(\sigma_F(E)) $$

6）`选择与笛卡尔积的交换律`
$$\sigma_F(E_1 \times E_2) \equiv \sigma_F(E_1) \times E_2$$  
$$\sigma_F(E_1 \times E_2) \equiv \sigma_{F_1}(E_1) \times \sigma_{F_2}(E_2) （其中F = F_1 \wedge F_2）$$  
$$\sigma_F(E_1 \times E_2) \equiv \sigma_{F_2}(\sigma_{F_1} (E_1) \times E_2)$$

7）`选择与并运算的交换`
设$E = E_1 \cup E_2$，$E_1$、$E_2$有相同的属性名，则
$$\sigma_F(E_1 \cup E_2) \equiv \sigma_F(E_1) \cup \sigma_F(E_2) $$

8）`选择与差运算的交换`
$$\sigma_F(E_1 - E_2) \equiv \sigma_F(E_1) - \sigma_F(E_2) $$

9）`投影与笛卡尔积的交换`
$$\pi A_1,A_2,\dots,A_n,B_1,B_2,\dots,B_m(E_1 \times E_2) \equiv \pi A_1,A_2,\dots,A_n(E_1) \cup \pi B_1,B_2,\dots,B_m(E_2)$$

10）`投影与并运算的交换`
$$\pi A_1,A_2,\dots,A_n(E_1 \cup E_2) \equiv \pi A_1,A_2,\dots,A_n(E_1) \cup \pi A_1,A_2,\dots,A_m(E_2)$$

4，**关系代数表达式的优化算法**

- 关系系统的查询优化步骤：
> （1）把查询转换成某种内部表示
> （2）把语法树转换成标准（优化）形式
> （3）选择底层的存取路径
> （4）生成查询计划，选择代价最小的查询计划