{"meta":{"title":"天堂的鸽子","subtitle":"天道酬勤","description":"每天积累一点，学习一点，只有不坚持的，没有做不到的！","author":"Bocheng Zhang","url":"https://zhangbc.github.io","root":"/"},"pages":[{"title":"","date":"2019-04-09T13:11:32.521Z","updated":"2019-04-09T13:11:32.521Z","comments":true,"path":"404.html","permalink":"https://zhangbc.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2019-08-08T16:30:13.948Z","updated":"2019-08-08T16:30:13.948Z","comments":true,"path":"README.html","permalink":"https://zhangbc.github.io/README.html","excerpt":"","text":"博客目录一览表数据库系列 理论篇 【数据库理论】数据模型【数据库理论】关系数据库【数据库理论】关系模式的规范化与查询优化【数据库理论】数据库的设计与实施【数据库理论】数据库的安全和保护【数据库理论】数据库与SQL Server2005简介【数据库理论】管理数据库【数据库理论】管理表【数据库理论】操作查询【数据库理论】T-SQL语言【数据库理论】存储过程【数据库理论】SQL Server2005高级功能 实战 【数据库实战】SQL Server数据库常用脚本 Java编程 入门基础篇 【Java基础】Java入门知识【Java基础】Java基础知识【Java基础】Java面向对象【Java基础】Java进阶编程【Java基础】Java网络编程【Java基础】Java扩展知识【Java基础】Java基础100实例 Python编程 编码规范系列 【Python编码规范】编程入门(引论)【Python编码规范】编程惯用法【Python编码规范】基础语法【Python编码规范】库【Python编码规范】设计模式 爬虫系列 【Python爬虫实例】Python解决521反爬方案 数据结构与算法 算法题 【经典算法】字符串旋转和包含算法 数据结构 生活日常篇 心得体会 【心路历程】贫困，不能阻碍你的梦【心路历程】面对现实，做好自己（一）【心路历程】面对现实，做好自己（二）【心路历程】面对现实，做好自己（三）【心路历程】面对现实，做好自己（四）【心路历程】面对现实，做好自己（五）【心路历程】面对现实，做好自己（六）【心路历程】面对现实，做好自己（七） 工作学习总结"},{"title":"","date":"2019-04-09T13:11:32.531Z","updated":"2019-04-09T13:11:32.531Z","comments":true,"path":"aboutme.html","permalink":"https://zhangbc.github.io/aboutme.html","excerpt":"","text":"关于作者 学习蜗牛，慢慢向前爬，终有一天会到达目的地； 学习IT，学会学习，独立思考，终有一天，会找到IT的乐趣！"},{"title":"分类","date":"2019-04-07T07:00:02.000Z","updated":"2019-04-10T12:08:59.536Z","comments":true,"path":"categories/index.html","permalink":"https://zhangbc.github.io/categories/index.html","excerpt":"","text":""},{"title":"Schedule","date":"2019-04-12T18:31:33.000Z","updated":"2019-08-08T16:30:36.362Z","comments":true,"path":"schedule/index.html","permalink":"https://zhangbc.github.io/schedule/index.html","excerpt":"","text":"博客目录一览表数据库系列 理论篇 【数据库理论】数据模型【数据库理论】关系数据库【数据库理论】关系模式的规范化与查询优化【数据库理论】数据库的设计与实施【数据库理论】数据库的安全和保护【数据库理论】数据库与SQL Server2005简介【数据库理论】管理数据库【数据库理论】管理表【数据库理论】操作查询【数据库理论】T-SQL语言【数据库理论】存储过程【数据库理论】SQL Server2005高级功能 实战 【数据库实战】SQL Server数据库常用脚本 Java编程 入门基础篇 【Java基础】Java入门知识【Java基础】Java基础知识【Java基础】Java面向对象【Java基础】Java进阶编程【Java基础】Java网络编程【Java基础】Java扩展知识【Java基础】Java基础100实例 Python编程 编码规范系列 【Python编码规范】编程入门(引论)【Python编码规范】编程惯用法【Python编码规范】基础语法【Python编码规范】库【Python编码规范】设计模式 爬虫系列 【Python爬虫实例】Python解决521反爬方案 数据结构与算法 算法题 【经典算法】字符串旋转和包含算法 数据结构 生活日常篇 心得体会 【心路历程】贫困，不能阻碍你的梦【心路历程】面对现实，做好自己（一）【心路历程】面对现实，做好自己（二）【心路历程】面对现实，做好自己（三）【心路历程】面对现实，做好自己（四）【心路历程】面对现实，做好自己（五）【心路历程】面对现实，做好自己（六）【心路历程】面对现实，做好自己（七） 工作学习总结"},{"title":"标签","date":"2019-04-07T06:57:35.000Z","updated":"2019-04-14T11:04:51.007Z","comments":true,"path":"tags/index.html","permalink":"https://zhangbc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【机器学习基础】从回归问题引基础：多项式曲线拟合","slug":"【机器学习基础】从回归问题引基础：多项式曲线拟合","date":"2019-09-17T13:52:56.000Z","updated":"2019-09-17T14:21:10.944Z","comments":true,"path":"2019/09/17/prml_01_polynomial_curve_fitting/","link":"","permalink":"https://zhangbc.github.io/2019/09/17/prml_01_polynomial_curve_fitting/","excerpt":"","text":"举例：多项式曲线拟合假设给定一个训练集。这个训练集由 $x$ 的 $N$ 次观测组成，写作 $\\mathbf{x}\\equiv(x_1,\\dots, x_N)^T $ ，伴随这对应的 $t$ 的观测值，记作 $\\mathbf{t}\\equiv (t_1,\\dots, t_N)^T$。其中，输入数据集合 $\\mathbf{x}$ 通过选择$x_n(n=1,\\dots,N)$ 的值来生成，这些 $x_n$ 均匀分布在区间[0, 1]，目标数据集 $\\mathbf{t}$ 的获得方式是：首先计算函数$sin(2\\pi x)$ 的对应的值，然后给每个点增加一个小的符合高斯分布的随机噪声，从而得到对应的$t_n$ 的值。 我们的目标是利用这个训练集预测对于输入变量的新值 $ \\hat{x}$ 得到的目标变量的值 $\\hat{t}$。 如下图1.1，由 $N$ =10个数据点组成的训练集的图像，用蓝色圆圈表示。 如图1.2，误差函数对应于每个数据点与函数$y(x, \\boldsymbol{w})$之间位移（绿⾊垂直线）的平⽅和（的⼀半）。 但是现在，我们要⽤⼀种相当⾮正式的、相当简单的⽅式来进⾏曲线拟合。特别地，我们将 使⽤下⾯形式的多项式函数来拟合数据，公式(1.1)如下： y(x, \\boldsymbol{w})=w_{0}+w_{1} x+w_{2} x^{2}+\\ldots+w_{M} x^{M}=\\sum_{i=0}^{M} w_{j} x^{j}其中 $M$ 是多项式的阶数（order），$x^j$ 表⽰ $x$ 的 $j$ 次幂。 多项式系数 $w_0 , \\dots , w_M$ 整体记作向量 $\\boldsymbol{w}$。 注意，虽然多项式函数 $y(x, \\boldsymbol{w})$ 是 $x$ 的⼀个⾮线性函数，它是系数 $\\boldsymbol{w}$ 的⼀个线性函数。类似多项式函数的这种关于未知参数满⾜线性关系的函数有着重要的性质，被叫做线性模型。 系数的值可以通过调整多项式函数拟合训练数据的⽅式确定。 这可以通过最⼩化误差函数 （error function）的⽅法实现。公式(1.2)如下： E(\\boldsymbol{w})=\\frac{1}{2} \\sum_{n=1}^{N}\\left\\{y\\left(x_{n}, \\boldsymbol{w}\\right)-t_{n}\\right\\}^{2}我们可以通过过选择使得 $E(\\boldsymbol{w})$ 尽量⼩的 $\\boldsymbol{w}$ 来解决曲线拟合问题。由于误差函数是系数 $\\boldsymbol{w}$ 的⼆次函数， 因此它关于系数的导数是 $\\boldsymbol{w}$ 的线性函数， 所以误差函数的最⼩值有⼀个唯⼀解， 记 作 $\\boldsymbol{w}^*$ ，可以⽤解析的⽅式求出。最终的多项式函数由函数 $y\\left(x, \\boldsymbol{w}^*\\right)$ 给出。 如下图1.3～1.6，不同阶数的多项式曲线，⽤红⾊曲线表⽰，拟合了图1.1中的数据集。 当 $M$=9时，多项式函数精确地通过了每⼀个数据点，$E(\\boldsymbol{w}^*)$ = 0。 然⽽， 拟合的曲线剧烈震荡，就表达函数 $sin(2\\pi x)$ ⽽⾔表现很差。这种⾏为叫做过拟合（over-fitting）。 通常用根均⽅（RMS）误差来计算，公式(1.3)如下： E_{R M S}=\\sqrt{2 E\\left(\\boldsymbol{w}^{*}\\right) / N}如图1.7，当M 的取值为 $3 \\leq M \\leq 8$ 时， 测试误差较⼩， 对于⽣成函 数 $sin(2\\pi x)$ 也能给出合理的模拟。 如图1.8，不同阶数的多项式的系数 $\\boldsymbol{w}^{*}$ 的值。观察随着多项式阶数的增加，系数的⼤⼩是如何剧烈增⼤的。 如图1.9～1.10，使⽤$M$ = 9的多项式对$N$ = 15个数据点和$N$ = 100个数据点通过最⼩化平⽅和 误差函数的⽅法得到的解。 常⽤来控制过拟合现象的⼀种技术是正则化（regularization）。 这种技术涉及到给误差函数增加⼀个惩罚项，使得系数不会达到很⼤的值。这种惩罚项最简单的形式采⽤所有系数的平⽅和的形式。这推导出了误差函数的修改后的形式，公式(1.4)如下： \\tilde{E}(\\boldsymbol{w})=\\frac{1}{2} \\sum_{n=1}^{N}\\left\\{y\\left(x_{n}, \\boldsymbol{w}\\right)-t_{n}\\right\\}^{2}+\\frac{\\lambda}{2}\\|\\boldsymbol{w}\\|^{2}其中，系数 $\\lambda$ 控制了正则化项相对于平⽅和误差项的重要性； \\|\\boldsymbol{w}\\|^{2} \\equiv \\boldsymbol{w}^{T} \\boldsymbol{w}=w_{0}^{2}+w_{1}^{2}+\\ldots+w_{M}^{2}通过把给定的数据中的⼀部分从测试集中分离出，来确定系数 $\\boldsymbol{w}$。这个分离出来的验证集（validation set），也被称为拿出集（hold-out set），⽤来最优化模型的复杂度（$M$ 或者 $\\lambda$）。 如图1.11～1.12，使⽤正则化的误差函数，⽤ $M$ = 9的多项式拟合图中的数据集。其中正则化参数 $\\lambda$ 选择 了两个值，分别对应于 $\\ln \\lambda=-18$ 和 $\\ln \\lambda=0$。 如图1.13，不同的正则化参数 $\\lambda$ 下，$M$ = 9的多项式的系数 $\\boldsymbol{w}^{*}$ 的值。观察随着 $\\lambda$ 的增大，系数的⼤⼩是逐渐变小的。 如图1.14，对于$M$ = 9的多项式，均⽅根误差与 $\\ln \\lambda$ 的关系。 总结 本小节为机器学习的入门篇，主要通过一个多项式拟合具体实例引出了线性模型相关概念，训练集的意义，误差函数，根均方差，修正误差函数等公式，正则化参数概念。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://zhangbc.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习基础","slug":"机器学习基础","permalink":"https://zhangbc.github.io/tags/机器学习基础/"}]},{"title":"【资源共享】eBook分享大集合","slug":"【资源共享】eBook分享大集合","date":"2019-08-28T16:03:18.000Z","updated":"2019-08-28T16:16:05.493Z","comments":true,"path":"2019/08/29/eBooks_share/","link":"","permalink":"https://zhangbc.github.io/2019/08/29/eBooks_share/","excerpt":"","text":"eBook分享大集合 主要以IT领域经典书籍收藏，以备不时之需。 福利传送门：【GitHub】 欢迎各位指点，要是能补充更是感激不尽。 服务器系统类 Linux高性能服务器编程 Shell脚本学习指南 高级Bash脚本编程指南.3.9.1 (杨春敏 黄毅 译) 鸟哥的Linux私房菜基础篇(第3版) 深入理解计算机系统 机器学习类 吴恩达深度学习教程 deepLearning深度学习(开源版) python自然语言处理实战：核心技术与算法 机器学习方法 社交网站的数据挖掘与分析 统计学习方法 用Python进行自然语言处理 算法类 Java数据结构和算法(第2版) 编程之法面试和算法心得 编程珠玑(第2版) 编程珠玑2 大话数据结构 计算机程序设计艺术第1卷：基本算法（第3版） 计算机程序设计艺术第2卷：半数值算法（第3版） 计算机程序设计艺术第3卷：排序与查找（第2版） 剑指offer 数据结构(C语言版).严蔚敏_吴伟民.扫描版 数据结构与算法分析(C++描述)(第3版) 算法导论(第2版) 网络类 HTTP权威指南 TCP-IP详解卷1：协议 TCP-IP详解卷2：实现 TCP-IP详解卷3：TCP事务协议，HTTP，NNTP和UNIX域协议 图解TCP IP(第5版) 程序语言类C/C++语言 C++ Primer(第5版)(中文版) C和指针 C语言程序设计 C语言的科学和艺术 modern-cpp-tutorial 大规模C++程序设计 深入体验C语言项目开发 实用C语言编程（第3版） Python语言 Django Web开发指南 Python.Cookbook(第2版)中文版 Python标准库中文版 Python高级编程（法莱德） Python核心编程(第2版) Python灰帽子 python基础教程(第2版) Python源码剖析 think in Python 编写高质量代码 改善Python程序的91个建议 利用Python进行数据分析 流畅的Python 深入浅出Python Java语言 Head First Java 中文高清版 Java编程思想(第4版) Java核心技术(第8版)卷I_基础知识 Java核心技术 Java入门经典 阿里巴巴Java开发手册终极版v1.3.0 设计模式之禅 秦晓波 PHP语言 Ajax与PHPWeb开发.pdf PHP高级程序设计_模式、框架与测试 PHP项目开发案例全程实录 PHP与MYSQL权威指南 C#/.NET语言 .NET本质论 .NET应用程序架构设计 原则 模式与实践 ASP.NET MVC4 WEB编程 ASP.NET MVC4高级编程 ASP.NET MVC4框架揭秘 ASP.NET.4.0 揭秘(卷1) ASP.NET.4.0 揭秘(卷2) ASP.NET本质论 ASP.NET设计模式 C#本质论 C#程序开发范例宝典 C#高级编程（第7版） C#入门经典(第3版) C#入门经典(第5版) C#与.NET程序员面试宝典 CLR.via.C#（第3版） IT企业必读的200个.NET面试题 WCF服务编程 WCF全面解析（上册） WCF全面解析（下册） 编写高质量代码改善C#程序的157个建议 大话设计模式 Web技术 CSS权威指南(第3版) HTML5程序设计(第2版) HTML5权威指南 JavaScript高级应用与实践 JavaScript权威指南(第4版) JavaScript权威指南(第6版) JavaScript入门经典(第4版) jQuery权威指南 WebKit技术内幕 高性能网站建设进阶指南 论道HTML5 认识与设计：理解UI设计准则 数据库类Oracle Oracle高性能SQL引擎剖析-SQL优化与调优机制详解 PLSQL操作手册 编程艺术深入数据库体系结构 剑破冰山 Oracle开发艺术 收获，不止Oracle MySQL MySQL 5权威指南(第3版) MYSQL必知必会 MySQL技术内幕(第4版) MySQL技术内幕：SQL编程 MySQL技术内幕InnoDB存储引擎 MySQL性能调优与架构设计 高性能MySQL(第2版) 高性能MySQL(第3版) SQL Server SQL2005技术内幕： T-SQ程序设计 SQL2005技术内幕：存储引擎 SQL2008技术内幕：T-SQL查询 SQL2008技术内幕：T-SQL语言基础 SQLServer2008查询性能优化 SQLSERVER2008学习笔记：日常维护、深入管理、性能优化 SQL反模式 Transact-SQL权威指南 数据库索引设计与优化 数据库性能调优.原理与技术 大数据类 Hadoop权威指南(第2版) MongoDB权威指南 MongoDB实战 R与Hadoop大数据分析实战 Spark大数据处理：技术、应用与性能优化 Spark快速数据处理 其他系列IT思维类 编码的奥秘 编码—隐匿在计算机软硬件背后的语言上 程序员的自我修养—链接、装载与库 程序员修炼之道 代码整洁之道 高效能人士的七个习惯 计算机程序的构造和解释 浪潮之巅 全栈增长工程师指南 人月神话 数学之美(第2版) 修改代码的艺术 一万小时天才理论 非书籍类 C语言学习资料.exe 架构设计类 GOF设计模式 UML和模式应用(第3版) 分布式JAVA应用 基础与实践 精通.NET企业项目开发：最新的模式、工具与方法 领域驱动设计C#2008实现 - 问题.设计.解决方案 领域驱动设计—软件核心复杂性应对之道 领域驱动设计与模式实战 企业应用架构模式 探索CQRS和事件源 微软应用技术架构(第2版) 重构_改善既有代码的设计 重构与模式 敏捷开发类 Scrum敏捷软件开发 Web开发敏捷之道 Web开发敏捷之道：应用Rails进行敏捷Web开发（第4版） 测试驱动开发的3项修炼：走出TDD丛林 大规模定制模式下的敏捷产品开发 高效程序员的45个习惯：敏捷开发修炼之道 敏捷估计与规划 敏捷技能修炼-敏捷软件开发与设计的最佳实践 敏捷开发：原则、模式与实践 敏捷开发的必要技巧 敏捷开发的艺术 敏捷开发回顾：使团队更强大 敏捷开发知识体系 敏捷软件开发：原则、模式与实践(C#版) 敏捷软件开发：原则、模式与实践 敏捷无敌 敏捷武士：看敏捷高手交付卓越软件 敏捷整合开发：更快改进性能的案例与实用技术 硝烟中的Scrum和XP 应用Rails进行敏捷Web开发(第3版) 用户故事与敏捷方法 LFS(100M+) 由于 GitHub 是gitLFS属于付费产品，免费空间有限，不作上传处理。 百度云传送门：【LFS_EBOOKS】 提取码：hpgp C#范例开发大全 C#核心开发技术从入门到精通 C语言程序设计_现代方法(第2版) C语言入门经典(第4版) Java核心技术(第10版)卷II_高级特性 Oracle+Database+11g数据库管理艺术 PHP 核心技术与最佳实践 SQL Server 2012编程入门经典(第4版) SQL Server企业级平台管理实践 大话设计模式 大话数据库 大数据Spark企业级实战版 代码大全(第2版) 代码重构(C# &amp; ASP.NET版) 锋利的jquery 软件设计精要与模式 实现领域驱动设计 数据结构与算法分析Java语言描述(第3版) 算法导论(第3版) GitHub上传100M以上文件解决方案 工具下载，详见【官网】 git-lfs-windowsgit-lfs-mac 基本步骤及其命令 123456789# 在项目中安装lfs$ git lfs install# 需要push的文件$ git lfs track \"程序语言类\\C&amp;C++语言\\C语言入门经典(第四版).（美）霍顿.pdf\"$ git add .gitattributes$ git lfs track \"程序语言类\\C&amp;C++语言\\C语言入门经典(第四版).（美）霍顿.pdf\"$ git add \"程序语言类\\C&amp;C++语言\\C语言入门经典(第四版).（美）霍顿.pdf\"$ git commit -m \"[add] add lfs ebook for C.\"$ git push origin master","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://zhangbc.github.io/categories/杂七杂八/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://zhangbc.github.io/tags/其他/"}]},{"title":"【经典算法】字符串转换成整数","slug":"【经典算法】字符串转换成整数","date":"2019-08-28T15:59:47.000Z","updated":"2019-08-28T16:12:53.702Z","comments":true,"path":"2019/08/28/algorithm_strings_02/","link":"","permalink":"https://zhangbc.github.io/2019/08/28/algorithm_strings_02/","excerpt":"","text":"本系列为《编程之法：面试和算法心得》的读书笔记。 算法1.3：字符串转换成整数 题目描述 输入一个由数字组成的字符串，把它转换成整数并输出。例如:输入字符串”123”，输出整数为123。给定函数原型 int StrToInt(const char *str)，实现字符串转换成整数的功能，不能使用库函数atoi。 分析与解法 思路分析：当扫描字符串的第一个字符“1”时，由于是第一位，故得到数字1；继续向后扫描到第二个字符”2“，之前已经得到数字1，在其后添加一个数字2，得到数字12，相当于前面的数字扩大了10倍然后加上刚扫描到的数字2，即：1×10+2=12。同理，扫描到第三个字符”3“，即可得到最终整数123为所求。故而，其基本思路就是：从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字。 但是，在处理过程中，需要考虑以下问题： 1）空指针的输入：输入的是指针，在访问空指针时程序会崩溃，需要提前判空；2）正负符号：整数不仅包括数字，还有可能包括以“+”或“-”开头表示正负整数，遇到负号“-”需要做转换；3）非法字符：输入的字符串中可能有不是数字的字符（如误操作其他字符），需要预先判断，碰到非法字符程序应停止转换；4）整型溢出：输入的数字是以字符串的形式输入，若输入一个很长的字符串可能导致溢出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 算法1.3：字符串转成整数int StrToInt(const char* str)&#123; static const int MAX_INT = (int)((unsigned)~0 &gt;&gt; 1); static const int MIN_INT = -(int)((unsigned)~0 &gt;&gt; 1); unsigned int n = 0; // 判空 if(str == 0) &#123; return 0; &#125; // 处理空格 while(isspace(*str)) &#123; ++str; &#125; // 处理正负 int sign = 1; if(*str == '+' || *str == '-') &#123; if(*str == '-') &#123; sign = -1; &#125; str++; &#125; while(isdigit(*str)) &#123; int c = *str - '0'; if(sign &gt; 0 &amp;&amp; (n &gt; MAX_INT/10 || (n == MAX_INT/10 &amp;&amp; c &gt; MAX_INT%10))) &#123; n = MAX_INT; break; &#125; else if(sign &lt; 0 &amp;&amp; (n &gt; (unsigned)MIN_INT/10 || (n == (unsigned)MIN_INT/10 &amp;&amp; c &gt; (unsigned)MIN_INT%10))) &#123; n = MIN_INT; break; &#125; n = n *10 + c; str++; &#125; return sign &gt; 0 ? n:-n;&#125; 算法分析：此算法难点在于处理数据溢出，其时间复杂度为 $O(n)$。 练习题 实现 string 到 double 的转换。","categories":[{"name":"C++","slug":"C","permalink":"https://zhangbc.github.io/categories/C/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhangbc.github.io/tags/数据结构与算法/"}]},{"title":"【经典算法】字符串旋转和包含算法","slug":"【经典算法】字符串旋转和包含算法","date":"2019-08-08T15:40:40.000Z","updated":"2019-08-08T15:48:32.238Z","comments":true,"path":"2019/08/08/algorithm_strings_01/","link":"","permalink":"https://zhangbc.github.io/2019/08/08/algorithm_strings_01/","excerpt":"","text":"本系列为《编程之法：面试和算法心得》的读书笔记。 作为一名大龄青年，为了即将踏入研究生之路，特此需要做一些计算机相关基础知识的积累，以弥补算法知识，谨以此开始自己的算法学习之路。 算法1.1：旋转字符串 题目描述 给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。 分析与解法 解法一：暴力移位法 1234567891011121314151617181920212223242526272829// 算法1.1：旋转字符串，暴力移位法void LeftShiftOne(char* strs, int number)&#123; int i = 0; char ch = strs[i]; for(i = 1; i &lt; number; i++) &#123; strs[i-1] = strs[i]; &#125; strs[i-1] = ch;&#125;void LeftRoatateString(char* strs, int n, int m)&#123; while(m--) &#123; LeftShiftOne(strs, n); &#125;&#125;// 测试函数int main(int argc, char* argv[])&#123; char strs[] = \"ABCDEFGH\"; LeftRoatateString(strs, 8, 3); cout &lt;&lt; strs &lt;&lt; endl; return 0;&#125; 算法分析：针对长度为n的字符串而言，假设需要移动m个字符到字符串的尾部，总共需要移动 m*n 次操作，同时设立一个变量存储第一个字符，故时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$，不合题意。 解法二：三步反转法 思路分析：将一个字符串分成X和Y两部分，在每个部分字符串上定义反转操作，如$X^T$，即把X的所有字符反转（例如X=”abc”，则 $X^T$=”cba”），于是得到：$(X^T Y^T)^T$=$YX$。 12345678910111213141516171819202122232425262728// 算法1.1：旋转字符串，三步反转法void ReverseString(char* str, int from, int to)&#123; while(from &lt; to) &#123; char ch = str[from]; str[from++] = str[to]; str[to--] = ch; &#125;&#125;void LeftReverseString(char* strs, int n, int m)&#123; m %= n; ReverseString(strs, 0, m-1); ReverseString(strs, m, n-1); ReverseString(strs, 0, n-1);&#125;// 测试函数int main(int argc, char* argv[])&#123; char strs[] = \"ABCDEFGH\"; LeftReverseString(strs, 8, 3); cout &lt;&lt; strs &lt;&lt; endl; return 0;&#125; 算法分析：针对长度为n的字符串而言，假设需要移动m个字符到字符串的尾部，总共需要移动 2*n 次操作，同时设立一个变量存储第一个字符，故时间复杂度为 $O(n)$，空间复杂度为 $O(1)$，符合题意。 练习题（自己动手） 链表翻转。例如给出一个链表和一个数k，链表为1—&gt;2—&gt;3—&gt;4—&gt;5—&gt;6，k=2，则翻转后为2—&gt;1—&gt;6—&gt;5—&gt;4—&gt;3；若k=3，翻转后3—&gt;2—&gt;1—&gt;6—&gt;5—&gt;4。 编写程序在原来字符串中把字符串尾部的m个字符移动到字符串的头部，要求：长度为n的字符串操作时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。例如，源字符串为 “Ilovebaofeng”，m=7时输出为：“baofengIlove”。 单词翻转。输入一个英文句子，翻转句子中单词的顺序，但是单词内字符的顺序不变，句子中单词以空格符号隔开。为简单起见，标点符号和普通字符一样处理。例如，输入”I am a student.”，输出为 “student. a am I”。 算法1.2：字符串包含 题目描述 给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何快速地判断字符串B中的所有字符是否都在字符串A里面？为简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数 bool StringContain(string &amp;A, string &amp;B)。示例一：string 1：ABCD，string 2： BAD，答案为true；示例二：string 1：ABCD，string 2： BCE，答案为false；示例三：string 1：ABCD，string 2： AA，答案为true。 分析与解法 解法一：常规解法 123456789101112131415161718192021222324// 算法1.2：字符串包含，常规方法bool StringContain(string &amp;a, string &amp;b)&#123; for(int i=0; i &lt; b.length(); i++) &#123; int j; for(j=0; (j &lt; a.length()) &amp;&amp; (a[j] != b[i]); j++); if(j &gt;= a.length()) &#123; return false; &#125; &#125; return true;&#125;// 测试函数int main(int argc, char* argv[])&#123; string a = \"ABCD\"; string b = \"AA\"; bool result = StringContain(a, b); cout &lt;&lt; result &lt;&lt; endl; return 0;&#125; 算法分析：这是一种最直观也是最简单的方法思路。此算法需要 $O（n*m）$ 次操作，时间开销较大。 解法二：排序方法 123456789101112131415161718// 算法1.2：字符串包含，排序方法bool StringContainSort(string &amp;a, string &amp;b)&#123; sort(a.begin(), a.end()); // 包含于&lt;algorithm&gt;模块内 sort(b.begin(), b.end()); for(int pa = 0, pb = 0; pb &lt; b.length(); pb++) &#123; while((pa &lt; a.length()) &amp;&amp; (a[pa] &lt; b[pb])) &#123; pa++; &#125; if(pa &gt;= a.length() || (a[pa] &gt; b[pb])) &#123; return false; &#125; &#125; return true;&#125; 算法分析：两个字符串的排序需要（常规情况）$O(m log m)+O(n log n)$ 次操作（快排算法），然后需要线性扫描 $O(m+n)$ 次操作。 解法三： 转换成素数 思路分析： 1）假定有一个仅由字母组成的字符串，按照从小到大的顺序，让每个字母与一个素数唯一对应，即用26个素数分别对应于A~Z；2）遍历长字符串。求得每个字符对应素数的乘积；3）遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除；4）输出结果。 12345678910111213141516171819202122232425// 算法1.2：字符串包含，转换成素数bool StringContainPrime(string &amp;a, string &amp;b)&#123; const int array[26] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101&#125;; int f = 1; for(int i = 0; i &lt; a.length(); i++) &#123; int x = array[a[i] - 'A']; if(f % x) &#123; f *= x; &#125; &#125; for(int j = 0; j &lt; b.length(); j++) &#123; int x = array[b[j] - 'A']; if(f % x) &#123; return false; &#125; &#125; return true;&#125; 算法分析：算法的时间复杂度为 $O(n)$ ，最好的情况为 $O(1)$（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回 false）， n 为长字串的长度，空间复杂度为 $O(1)$。注意：此方法只有理论意义，因为整数乘积很大会造成溢出风险。 解法四：Hashtable方法 思路分析：先把长字符串 A中的所有字符都放入一个 Hashtable 里，然后轮询短字符串 B，看短字符串 B 的每个字符是否都在 Hashtable 里，如果都存在，说明长字符串 A 包含短字符串 B， 否则，说明不包含。 123456789101112131415161718// 算法1.2：字符串包含，Hashtable方法bool StringContainHash(string &amp;a, string &amp;b)&#123; int hash = 0; for(int i = 0; i &lt; a.length(); i++) &#123; hash |= (1 &lt;&lt; (a[i] - 'A')); &#125; for(int j = 0; j &lt; b.length(); j++) &#123; if(hash &amp; (1 &lt;&lt; (b[j] - 'A'))) &#123; return false; &#125; &#125; return true;&#125; 算法分析：此方法实质是用一个整数代替了Hashtable，空间复杂度为 $O(1)$，时间复杂度为 $O(n)$。 练习题（自己动手） 变位词：如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，比如 bad 和 adb 即为兄弟字符串，现提供一个字符串，如何在字典中迅速找到它的兄弟字符串，请描述数据结构和查询过程。","categories":[{"name":"C++","slug":"C","permalink":"https://zhangbc.github.io/categories/C/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zhangbc.github.io/tags/数据结构与算法/"}]},{"title":"【Python编码规范】设计模式","slug":"【Python编码规范】设计模式","date":"2019-06-13T14:55:38.000Z","updated":"2019-08-08T15:33:23.828Z","comments":true,"path":"2019/06/13/python_code91_05/","link":"","permalink":"https://zhangbc.github.io/2019/06/13/python_code91_05/","excerpt":"","text":"本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。 温馨提醒：在阅读本书之前，强烈建议先仔细阅读：PEP规范，增强代码的可阅读性，配合优雅的pycharm编辑器(开启pep8检查)写出规范代码，是Python入门的第一步。 建议50：利用模块实现单例模式1）所有的变量都会绑定到模块；2）模块只初始化一次；3）import机制是线程安全的。 建议51: 用mixin模式让程序更加灵活模板方法模式：在一个方法中定义一个算法的骨架，并将一些实现步骤延迟到子类中。 Python 中每一个类都有一个__base__属性，是一个元组，用来存放所有的基类，基类在运行中可以动态改变。 建议52：用发布订阅模式实现松耦合 发布订阅模式（publish/subscribe或pub/sub）是一种编程模式，消息的发送者（发布者）不会发送其消息给特定的接收者（订阅者），而是将发布的消息分为不同的类别直接发布，并不关注订阅者是谁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/env python# coding:utf-8​​\"\"\"发布订阅模式实现\"\"\"​​import messagefrom collections import defaultdict​​route_table = defaultdict(list)​​def sub(topic, callback): \"\"\"​ :param topic: :param callback: :return: \"\"\"​ if callback in route_table[topic]: return​ route_table[topic].append(callback)​​def pub(topic, *args, **kwargs): \"\"\"​ :param topic: :param args: :param kwargs: :return: \"\"\"​ for func in route_table[topic]: func(*args, **kwargs)​​def greeting(name): \"\"\"​ :param name: :return: \"\"\"​ print 'Hello, &#123;0&#125;.'.format(name)​​if __name__ == '__main__':​ sub('greet', greeting) pub('greet', 'LaiYonghao')​ message.sub('greet', greeting) message.pub('greet', 'Welcome to Python') 建议53：用状态模式美化代码状态模式：当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。主要用于控制一个对象状态的条件表达式过于复杂的情况，其可把状态的判断逻辑转移到表示不同状态的一系列类中，进而把复杂的判断逻辑简化。@stateful修饰函数，重载了被修饰类的getattr()方法从而使得类的实例方法能调用当前状态类的方法。被@stateful修饰后的类的实例是带有状态的，能够使用curr()查询当前状态，也可以使用switch()进行状态切换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# coding:utf-8​​\"\"\"状态模式实现\"\"\"​​from state import switch, stateful, State, behavior​​@statefulclass People(object): \"\"\"​ \"\"\"​ class Workday(State): \"\"\"​ \"\"\"​ default = True​ @behavior def day(self): print 'work hard.'​ class Weekend(State): \"\"\"​ \"\"\"​ @behavior def day(self): print 'play harder.'​​def main(): \"\"\"​ :return: \"\"\"​ people = People() for i in xrange(1, 8): if i == 6: switch(people, People.Weekend) if i == 1: switch(people, People.Workday) people.day()​​if __name__ == '__main__':​ main()","categories":[{"name":"Python","slug":"python","permalink":"https://zhangbc.github.io/categories/python/"}],"tags":[{"name":"Python编码规范","slug":"python-coding-convention","permalink":"https://zhangbc.github.io/tags/python-coding-convention/"}]},{"title":"【Python编码规范】库","slug":"【Python编码规范】库","date":"2019-05-12T15:01:16.000Z","updated":"2019-05-12T15:21:55.643Z","comments":true,"path":"2019/05/12/python_code91_04/","link":"","permalink":"https://zhangbc.github.io/2019/05/12/python_code91_04/","excerpt":"","text":"本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。 温馨提醒：在阅读本书之前，强烈建议先仔细阅读：PEP规范，增强代码的可阅读性，配合优雅的pycharm编辑器(开启pep8检查)写出规范代码，是Python入门的第一步。 建议36：掌握字符串的基本用法Python小技巧：Python遇到未闭合的小括号会自动将多行代码拼接为一行和把相邻的两个字符串字面量拼接在一起的。 12345&gt;&gt;&gt; st = ('select * '... 'from table '... 'whre field=\"value\";')&gt;&gt;&gt; st'select * from table whre field=\"value\";' 字符串用法举例： 12345678&gt;&gt;&gt; print isinstance('hello world', basestring) # basestring是str与unicode的基类True&gt;&gt;&gt; print isinstance('hello world', unicode)False&gt;&gt;&gt; print isinstance('hello world', str)True&gt;&gt;&gt; print isinstance(u'hello world', unicode)True split()的陷阱示例 123456&gt;&gt;&gt; ' Hello World'.split(' ')['', 'Hello', 'World']&gt;&gt;&gt; ' Hello World'.split()['Hello', 'World']&gt;&gt;&gt; ' Hello World'.split(' ')['', 'Hello', '', '', 'World'] title()应用示例 1234567&gt;&gt;&gt; import string&gt;&gt;&gt; string.capwords('hello wOrld')'Hello World'&gt;&gt;&gt; string.capwords(' hello wOrld ')'Hello World'&gt;&gt;&gt; ' hello wOrld '.title()' Hello World ' 建议37：按需选择sort()或者sorted()sorted(iterable[, cmp[, key[, reverse]]])：作用于任何可迭代对象，返回一个排序后的列表； sort(cmp[, key[, reverse]]])：一般作用于列表，直接修改原有列表，返回为None。 1）对字典进行排序 1234567&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; phone_book = &#123;'Linda': '775', 'Bob': '9349', 'Carol': '5834'&#125;&gt;&gt;&gt; sorted_pb = sorted(phone_book.iteritems(), key=itemgetter(1)) ​# 按照字典的value进行排序&gt;&gt;&gt; print phone_book&#123;'Linda': '775', 'Bob': '9349', 'Carol': '5834'&#125;&gt;&gt;&gt; print sorted_pb[('Carol', '5834'), ('Linda', '775'), ('Bob', '9349')] 2）多维list排序​1234567&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; game_result = [['Linda', 95, 'B'], ['Bob', 93, 'A'], ['Carol', 69, 'D'], ['zhangs', 95, 'A']]&gt;&gt;&gt; sorted_res = sorted(game_result, key=itemgetter(1, 2)) # 按照学生成绩排序，成绩相同的按照等级排序&gt;&gt;&gt; print game_result[['Linda', 95, 'B'], ['Bob', 93, 'A'], ['Carol', 69, 'D'], ['zhangs', 95, 'A']]&gt;&gt;&gt; print sorted_res[['Carol', 69, 'D'], ['Bob', 93, 'A'], ['zhangs', 95, 'A'], ['Linda', 95, 'B']] 3）字典中混合list排序 12345678910111213&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; list_dict = &#123;... 'Li': ['M', 7],... 'Zhang': ['E', 2],... 'Du': ['P', 3],... 'Ma': ['C', 9],... 'Zhe': ['H', 7]... &#125;&gt;&gt;&gt; sorted_ld = sorted(list_dict.iteritems(), key=lambda (k, v): itemgetter(1)(v)) # 按照字典的value[m,n]中的n值排序&gt;&gt;&gt; print list_dict&#123;'Zhe': ['H', 7], 'Zhang': ['E', 2], 'Ma': ['C', 9], 'Du': ['P', 3], 'Li': ['M', 7]&#125;&gt;&gt;&gt; print sorted_ld[('Zhang', ['E', 2]), ('Du', ['P', 3]), ('Zhe', ['H', 7]), ('Li', ['M', 7]), ('Ma', ['C', 9])] 4）list中混合字典排序 123456789101112&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; game_result = [... &#123;'name': 'Bob', 'wins': 10, 'losses': 3, 'rating': 75&#125;,... &#123;'name': 'David', 'wins': 3, 'losses': 5, 'rating': 57&#125;,... &#123;'name': 'Carol', 'wins': 4, 'losses': 5, 'rating': 57&#125;,... &#123;'name': 'Patty', 'wins': 9, 'losses': 3, 'rating': 71.48&#125;... ]&gt;&gt;&gt; sorted_res = sorted(game_result, key=itemgetter('rating', 'name')) # 按照name和rating排序&gt;&gt;&gt; print game_result[&#123;'wins': 10, 'losses': 3, 'name': 'Bob', 'rating': 75&#125;, &#123;'wins': 3, 'losses': 5, 'name': 'David', 'rating': 57&#125;, &#123;'wins': 4, 'losses': 5, 'name': 'Carol', 'rating': 57&#125;, &#123;'wins': 9, 'losses': 3, 'name': 'Patty', 'rating': 71.48&#125;]&gt;&gt;&gt; print sorted_res[&#123;'wins': 4, 'losses': 5, 'name': 'Carol', 'rating': 57&#125;, &#123;'wins': 3, 'losses': 5, 'name': 'David', 'rating': 57&#125;, &#123;'wins': 9, 'losses': 3, 'name': 'Patty', 'rating': 71.48&#125;, &#123;'wins': 10, 'losses': 3, 'name': 'Bob', 'rating': 75&#125;] 建议38：使用copy模块深拷贝对象 浅拷贝(shallow copy)：构造一个新的复合对象并将从原对象中发现的引用插入该对象中。实现方式有：工厂函数，切片操作，copy模块中copy操作等； 深拷贝(deep copy)：构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续进行拷贝，因此产生的对象不受其他引用对象操作的影响。实现方式有copy模块中的deepcopy()操作。 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#!/usr/bin/env python# coding:utf-8from copy import copyfrom copy import deepcopyclass Pizza(object): \"\"\" \"\"\" def __init__(self, name, size, price): self.name = name self.size = size self.price = price def get_pizza_info(self): return self.name, self.size, self.price def show_pizza_info(self): print \"Pizza name: &#123;0&#125;, size: &#123;1&#125;, price: &#123;2&#125;\".format(self.name, self.size, self.price) def change_size(self, size): \"\"\" :param size: :return: \"\"\" self.size = size def change_price(self, price): \"\"\" :param price: :return: \"\"\" self.price = priceclass Order(object): \"\"\" \"\"\" def __init__(self, name): self.customer_name = name self.pizza_list = list() self.pizza_list.append(Pizza(\"Mushroom\", 12, 30)) def order_more(self, pizza): \"\"\" :param pizza: :return: \"\"\" self.pizza_list.append(pizza) def change_name(self, name): \"\"\" :param name: :return: \"\"\" self.customer_name = name def get_oder_detail(self): \"\"\" :return: \"\"\" print \"Customer name: &#123;0&#125;\".format(self.customer_name) for index, item in enumerate(self.pizza_list): item.show_pizza_info() def get_pizza(self, number): \"\"\" :param number: :return: \"\"\" return self.pizza_list[number]def customer_one(): c1 = Order(\"zhang San\") c1.order_more(Pizza(\"seafood\", 9, 40)) c1.order_more(Pizza(\"fruit\", 12, 35)) print \"==============Customer one order info=================\" c1.get_oder_detail() c2 = copy(c1) print \"==============Customer two order info(copy)=================\" c2.change_name(\"Li Si\") c2.get_pizza(2).change_size(9) c2.get_pizza(2).change_price(30) c2.get_oder_detail() c3 = deepcopy(c1) print \"==============Customer three order info(deepcopy)=================\" c3.change_name(\"Li Si\") c3.get_pizza(1).change_size(10) c3.get_pizza(1).change_price(50) c3.get_oder_detail() print \"==============Customer one order info=================\" c1.get_oder_detail()if __name__ == '__main__': customer_one() 运行结果如下： 1234567891011121314151617181920==============Customer one order info=================Customer name: zhang SanPizza name: Mushroom, size: 12, price: 30Pizza name: seafood, size: 9, price: 40Pizza name: fruit, size: 12, price: 35==============Customer two order info(copy)=================Customer name: Li SiPizza name: Mushroom, size: 12, price: 30Pizza name: seafood, size: 9, price: 40Pizza name: fruit, size: 9, price: 30==============Customer three order info(deepcopy)=================Customer name: Li SiPizza name: Mushroom, size: 12, price: 30Pizza name: seafood, size: 10, price: 50Pizza name: fruit, size: 9, price: 30==============Customer one order info=================Customer name: zhang SanPizza name: Mushroom, size: 12, price: 30Pizza name: seafood, size: 9, price: 40Pizza name: fruit, size: 9, price: 30 建议39：使用Counter进行计数统计 使用dict 12345678910&gt;&gt;&gt; some_data = ['a', 2, '2', 4, 5, '2', 'b', 7, 'a', 5, 'd', 'a', 'z']&gt;&gt;&gt; count_frq = dict()&gt;&gt;&gt; for index, item in enumerate(some_data):... if item in count_frq:... count_frq[item] += 1... else:... count_frq[item] = 1... &gt;&gt;&gt; print count_frq&#123;'a': 3, 2: 1, 'b': 1, 4: 1, 5: 2, 7: 1, '2': 2, 'z': 1, 'd': 1&#125; 使用defaultdict 12345678&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; some_data = ['a', 2, '2', 4, 5, '2', 'b', 7, 'a', 5, 'd', 'a', 'z']&gt;&gt;&gt; count_frq = defaultdict(int)&gt;&gt;&gt; for index, item in enumerate(some_data):... count_frq[item] += 1... &gt;&gt;&gt; print count_frqdefaultdict(&lt;type 'int'&gt;, &#123;'a': 3, 2: 1, 'b': 1, 4: 1, 5: 2, 7: 1, '2': 2, 'z': 1, 'd': 1&#125;) 使用set与list 12345678&gt;&gt;&gt; some_data = ['a', 2, '2', 4, 5, '2', 'b', 7, 'a', 5, 'd', 'a', 'z']&gt;&gt;&gt; count_set = set(some_data)&gt;&gt;&gt; count_list = list()&gt;&gt;&gt; for index, item in enumerate(some_data):... count_list.append((item, some_data.count(item)))... &gt;&gt;&gt; print count_list[('a', 3), (2, 1), ('2', 2), (4, 1), (5, 2), ('2', 2), ('b', 1), (7, 1), ('a', 3), (5, 2), ('d', 1), ('a', 3), ('z', 1)] 使用更为优雅的Pythonic方法—collections.Counter 1234567891011121314&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; some_data = ['a', 2, '2', 4, 5, '2', 'b', 7, 'a', 5, 'd', 'a', 'z']&gt;&gt;&gt; print Counter(some_data)Counter(&#123;'a': 3, 5: 2, '2': 2, 2: 1, 'b': 1, 4: 1, 7: 1, 'z': 1, 'd': 1&#125;)&gt;&gt;&gt; print Counter('success')Counter(&#123;'s': 3, 'c': 2, 'e': 1, 'u': 1&#125;)&gt;&gt;&gt; print Counter(s=3, c=2, e=1, u=1)Counter(&#123;'s': 3, 'c': 2, 'u': 1, 'e': 1&#125;)&gt;&gt;&gt; print Counter(&#123;'s': 3, 'c': 2, 'u': 1, 'e': 1&#125;)Counter(&#123;'s': 3, 'c': 2, 'u': 1, 'e': 1&#125;)&gt;&gt;&gt; print list(Counter(some_data).elements())['a', 'a', 'a', 2, 'b', 4, 5, 5, 7, '2', '2', 'z', 'd']&gt;&gt;&gt; print Counter(some_data).most_common(3) # 出现频次最高的前三个字符[('a', 3), (5, 2), ('2', 2)] 建议40：深入理解ConfigParser 实例 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# coding:utf-8import ConfigParserconf = ConfigParser.ConfigParser()conf.read('config.ini')print conf.get('default', 'host')conf = ConfigParser.ConfigParser()conf.read('config.ini')print conf.get('online', 'conn_str') # 仅在default下​====================config.ini=========================[default]conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)sdbn = msyqlhost = 127.0.0.1user = rootport = 3306pw = xxxxxxdb = test[online]conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)sdbn = msyqlhost = 127.0.0.1user = rootport = 3306pw = xxxxxxdb = test 建议41：使用argparese处理命令行参数12345import argparseparser = argparse.ArgumentParser()parser.add_argument('-v', dest='verbose', action='store_true')args = parser.parse_args()print args 建议42：使用pandas处理大型csv文件csv作为一种逗号分隔型值的纯文本格式文件，常见于数据库数据的导入导出、数据分析中记录的存储等。 以下列举几个与csv处理相关的API： csv.reader(csvfile[, dialect=&#39;excel&#39;][, fmtparam])：用于CSV文件的读取，返回一个reader对象用于在CSV文件中进行行迭代； csv.writer(csvfile, dialect=&#39;excel&#39;, **fmtparams)：用于写入CSV文件； csv.DictReader(csvfile, fieldnames=None, restKey=&#39;&#39;, restval=&#39;&#39;, dialect=&#39;excel&#39;, *args, **kwds)：用于支持字典的读取； csv.DictReader(csvfile, fieldnames=None, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, *args, **kwds)：用于支持字典的写入。 实例 12345678910111213141516171819import csv# 写入csvwith open('csv_test.csv', 'wb') as fp: fields = ['Tran_date', 'Product', 'Price', 'PaymentType'] writer = csv.DictWriter(fp, fieldnames=fields) writer.writerow(dict(zip(fields, fields))) data = &#123;'Tran_date': '1/2/09 6:17', 'Product': 'Nick', 'Price': '1200', 'PaymentType': 'Mastercard'&#125; writer.writerow(data)# 读取csvwith open('csv_test.csv', 'rb') as fp: for item in csv.DictReader(fp): print item csv使用非常简单，基本可以满足大部分需求，但是对于上百MB或G级别以上的文件处理无能为力。这种情况下，可以考虑使用pandas模块，它支持以下两种数据结构。 Series：是一种类似数组的带索引的一维数据结构，支持的类型与NumPy兼容。 123456789101112131415161718192021&gt;&gt;&gt; from pandas import Series&gt;&gt;&gt; obj = Series([1, 'a', (1, 2), 3], index=['a', 'b', 'c', 'd'])&gt;&gt;&gt; obja 1b ac (1, 2)d 3dtype: object&gt;&gt;&gt; obj_dic = Series(&#123;'Book': 'Python', 'Author': 'Dan', 'ISBN': '011334', 'Price': 25&#125;, index=['book', 'Author', 'ISBN', 'Price'])&gt;&gt;&gt; obj_dicbook NaN # 匹配失败，导致数据丢失Author DanISBN 011334Price 25dtype: object&gt;&gt;&gt; obj_dic.isnull()book TrueAuthor FalseISBN FalsePrice Falsedtype: bool DataFrame：类似于电子表格，其数据为排好序的数据列的集合，每一列都可以是不同的数据类型，类似一个二维数组，支持行和列的索引。 1234567891011&gt;&gt;&gt; from pandas import DataFrame&gt;&gt;&gt; data = &#123;'OrderDate': ['1-6-10', '1-23-10', '2-9-10', '2-26-10', '3-15-10'],... 'Region': ['East', 'Central', 'Central', 'West', 'East'],... 'Rep': ['Jones', 'Kivell', 'Jardine', 'Gill', 'Sorvino']&#125;&gt;&gt;&gt; DataFrame(data, columns=['OrderDate', 'Region', 'Rep']) OrderDate Region Rep0 1-6-10 East Jones1 1-23-10 Central Kivell2 2-9-10 Central Jardine3 2-26-10 West Gill4 3-15-10 East Sorvino pandas中处理CSV文件的函数主要为read_csv()和to_csv()。 指定读取部分列和文件的行数 123456789&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; df = pd.read_csv('/home/projects/pythoner/quality_code/csv_test.csv', nrows=5, usecols=['Tran_date', 'Product', 'Price'])&gt;&gt;&gt; df Tran_date Product Price0 1/2/09 6:17 Nick 12001 2/2/09 6:17 Nick 12002 3/2/09 6:17 Nick 12003 4/2/09 6:17 Nick 12004 5/2/09 6:17 Nick 1200 设置CSV文件与excel兼容 12345678910111213141516&gt;&gt;&gt; import csv&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; dia = csv.excel()&gt;&gt;&gt; dia.delimiter = \",\"&gt;&gt;&gt; pd.read_csv('/home/projects/pythoner/quality_code/csv_test.csv', dialect=dia, error_bad_lines=False) Tran_date Product Price PaymentType0 1/2/09 6:17 Nick 1200 Mastercard1 2/2/09 6:17 Nick 1200 Mastercard2 3/2/09 6:17 Nick 1200 Mastercard3 4/2/09 6:17 Nick 1200 Mastercard4 5/2/09 6:17 Nick 1200 Mastercard5 6/2/09 6:17 Nick 1200 Mastercard6 7/2/09 6:17 Nick 1200 Mastercard7 8/2/09 6:17 Nick 1200 Mastercard8 9/2/09 6:17 Nick 1200 Mastercard9 10/2/09 6:17 Nick 1200 Mastercard 对文件进行分块处理并返回一个可迭代的对象 123456789101112131415&gt;&gt;&gt; reader = pd.read_table('/home/projects/pythoner/quality_code/csv_test.csv', chunksize=5, iterator=True)&gt;&gt;&gt; iter(reader).next() Tran_date,Product,Price,PaymentType0 1/2/09 6:17,Nick,1200,Mastercard1 2/2/09 6:17,Nick,1200,Mastercard2 3/2/09 6:17,Nick,1200,Mastercard3 4/2/09 6:17,Nick,1200,Mastercard4 5/2/09 6:17,Nick,1200,Mastercard&gt;&gt;&gt; iter(reader).next() Tran_date,Product,Price,PaymentType5 6/2/09 6:17,Nick,1200,Mastercard6 7/2/09 6:17,Nick,1200,Mastercard7 8/2/09 6:17,Nick,1200,Mastercard8 9/2/09 6:17,Nick,1200,Mastercard9 10/2/09 6:17,Nick,1200,Mastercard 当文件格式相似时，支持多个文件合并处理 123456789101112131415&gt;&gt;&gt; file_list = ['/home/projects/pythoner/quality_code/csv_test1.csv', '/home/projects/pythoner/quality_code/csv_test2.csv']&gt;&gt;&gt; dfs = [pd.read_csv(f) for f in file_list]&gt;&gt;&gt; total_df = pd.concat(dfs)&gt;&gt;&gt; total_df Tran_date Product Price PaymentType0 1/2/09 6:17 Nick 1200 Mastercard1 2/2/09 6:17 Nick 1200 Mastercard2 3/2/09 6:17 Nick 1200 Mastercard3 4/2/09 6:17 Nick 1200 Mastercard4 5/2/09 6:17 Nick 1200 Mastercard0 6/2/09 6:17 Nick 1200 Mastercard1 7/2/09 6:17 Nick 1200 Mastercard2 8/2/09 6:17 Nick 1200 Mastercard3 9/2/09 6:17 Nick 1200 Mastercard4 10/2/09 6:17 Nick 1200 Mastercard 建议43：一般情况使用ElementTree解析XMLElementTree解析XML具有以下特性： 使用简单，将整个XML文件以树的形式展示，每一个元素的属性以字典的形式表示，非常方便处理； 内存上消耗明显低于DOM解析； 支持XPath查询，非常方便获取任意结点的值。 建议44：理解模块pickle优劣1）pickle.dump(obj,file[,protocol])：序列化数据到一个文件描述符。 其中：protocol为序列化使用的协议版本，0表示ASCII协议，为默认值；1表示老式的二进制协议；2表示2.3版本引入的新二进制协议。 2）pickle.load()：表示把文件中的对象恢复为原来的对象，这个过程也被称为反序列化。 123456789101112import cPickle as pickle​​my_data = &#123;\"name\": \"Python\", \"type\": \"language\", \"version\": \"2.7.6\"&#125;fp = open('pickle.dat', 'wb')pickle.dump(my_data, fp)fp.close()​fp = open('pickle.dat', 'rb')out = pickle.load(fp)print outfp.close() pickle的优点： 1）接口简单，容易使用；2）pickle的存储格式具有通用性，能够被不同平台的Python解析器共享；3）支持的数据类型广泛；4）pickle模块是可扩展的；5）能够自动维护对象间的引用。 pickle的缺点： 1）pickle不能保证操作的原子性；2）pickle存在安全性问题；3）pickle协议是Python特定的，不同语言之间的兼容性难以保证。 建议45：序列化的另一个不错的选择—JSONJSON具有以下优势： 使用简单，支持多种数据类型；仅存在两大数据结构：名称/值对的集合（对象，记录，结构，字典，散列表，键列表，关联数组等）；值的有序列表（数组，向量，列表，序列等）。 存储格式可读性好，容易修改； json支持跨平台跨语言操作，能够轻易被其他语言解析，存储格式较紧凑，所占空间较小； 具有较强的扩展性； json在序列化datetime时会抛出TypeError异常，需要对json本身的JSONEncoder进行扩展。 建议46：使用traceback获取栈信息 实例 1234567891011121314151617181920212223242526272829303132import trackbackg_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g']def f(): g_list[5] return g()def g(): return h()def h(): del g_list[2] return i()def i(): g_list.append('i') print g_list[7]if __name__ == '__main__': try: f() except IndexError as e: print 'Error: &#123;0&#125;'.format(e) traceback.print_exc() 输出结果如下： 12345678910111213Error: list index out of rangeTraceback (most recent call last): File \"/home/projects/pythoner/quality_code/configure_parser.py\", line 33, in &lt;module&gt; f() File \"/home/projects/pythoner/quality_code/configure_parser.py\", line 13, in f return g() File \"/home/projects/pythoner/quality_code/configure_parser.py\", line 17, in g return h() File \"/home/projects/pythoner/quality_code/configure_parser.py\", line 22, in h return i() File \"/home/projects/pythoner/quality_code/configure_parser.py\", line 27, in i print g_list[7]IndexError: list index out of range 建议47：使用logging记录日志信息1，日志级别 Level 使用情形 DEBUG 详细的信息，在追踪问题时使用 INFO 正常的信息 WARNING 一些不可预见的问题发生，或者将要发生，如磁盘空间低等，但不影响程序的运行 ERROR 由于某些严重的问题，程序中的一些功能受到影响 CRITICAL 严重的错误，或者程序本身不能继续运行 2， logging lib的四个主要对象 logger：程序信息输出的接口，分散在不同的代码中，使得程序可以在运行时记录相应的信息，并根据设置的日志级别或者filter来决定哪些信息需要输出，并将这些信息分发到其关联的handler。 Handler：用来处理信息的输出，可以将信息输出到控制台、文件或者网络。 Formatter：决定log信息的格式。 Filter：决定哪些信息需要输出，可以被handler和logger使用，支持层次关系。 logging.basicConfig([**kwargs]) 提供对日志系统的基本配置，默认使用StreamHandler和Formatter并添加到root logger。字典参数列表如下： 格式 描述 filename 指定FileHandler的文件名，而不是默认的StreamHandler filemode 打开文件的模式，默认为‘a’ format 输出格式字符串 datefmt 日期格式 level 设置root logger的日志级别 stream 指定StreamHandler，若与filename冲突，忽略stream 实例 1234567891011121314def get_logger(file_name, level=logging.INFO): \"\"\" 设置日志文件输出 :param file_name: 文件名称 :param level: 日志严重级别 ==&gt; CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET :return: \"\"\" logger = logging.getLogger() logger.setLevel(level) file_handler = logging.FileHandler(file_name, encoding=\"utf-8\") file_handler.setLevel(level) formatter = logging.Formatter(\"%(asctime)s %(name)s %(levelname)s [line %(lineno)s]: %(message)s\") file_handler.setFormatter(formatter) logger.addHandler(file_handler) 3，使用建议 1）尽量为logging取一个名字而不是采用默认，eg：logger=logging.getLogger(__name__)；2）为了方便找出问题，logging的名字建议以模块或者class命名；3）logging只是线程安全的，不支持多进程写入同一个日志文件。 建议48：使用threading模块编写多线程程序 Python多线程支持两种方式创建： 1）通过继承Thread类，重写其run()方法(不是start()方法)；不支持守护线程；2）创建threading.Thread对象,在它的初始化函数（__init__()）中将可调用对象作为参数传入。 建议49：使用Queue使多线程编程更加安全Python中的Queue模块提供了以下队列： Queue.Queue(maxsize)：先进先出，maxsize为队列大小，其值为非正数时为无限循环队列； Queue.LifoQueue(maxsize)：后进先出，相当于栈； Queue.PriorityQueue(maxsize)：优先级队列。 生产-消费者模式实现demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/usr/bin/env python# coding:utf-8​​import Queueimport threadingimport random​​WRITE_LOCK = threading.Lock()​​class Producer(threading.Thread): \"\"\" 生产-消费者模式（生产者） \"\"\"​ def __init__(self, queue, condition, name): \"\"\"​ :param queue: :param condition: :param name: \"\"\"​ super(Producer, self).__init__() self.queue = queue self.name = name self.condition = condition print \"Producer &#123;0&#125; started.\".format(self.name)​ def run(self): \"\"\"​ :return: \"\"\"​ while True: global WRITE_LOCK self.condition.acquire() # 获取锁对象 if self.queue.full(): with WRITE_LOCK: print 'Queue is full, producer wait!' self.condition.wait() else: value = random.randint(0, 10) with WRITE_LOCK: print \"&#123;name&#125; put value: &#123;value&#125; into queue.\"\\ .format(name=self.name, value=value) self.queue.put(\"&#123;0&#125;: &#123;1&#125;\".format(self.name, value)) self.condition.notify() self.condition.release()​​class Consumer(threading.Thread): \"\"\" 生产-消费者模式（消费者） \"\"\"​ def __init__(self, queue, condition, name): \"\"\"​ :param queue: :param condition: :param name: \"\"\"​ super(Consumer, self).__init__() self.queue = queue self.name = name self.condition = condition print \"Consumer &#123;0&#125; started.\".format(self.name)​ def run(self): \"\"\"​ :return: \"\"\"​ while True: global WRITE_LOCK self.condition.acquire() # 获取锁对象 if self.queue.empty(): with WRITE_LOCK: print 'Queue is empty, consumer wait!' self.condition.wait() else: value = self.queue.get() with WRITE_LOCK: print \"&#123;name&#125; get value: &#123;value&#125; from queue.\"\\ .format(name=self.name, value=value) self.condition.notify() self.condition.release()​​if __name__ == '__main__':​ qe = Queue.Queue(10) con = threading.Condition() producer_1 = Producer(qe, con, \"P1\") producer_1.start() # producer_2 = Producer(qe, con, \"P2\") # producer_2.start()​ consumer_1 = Consumer(qe, con, \"C1\") consumer_1.start()","categories":[{"name":"Python","slug":"python","permalink":"https://zhangbc.github.io/categories/python/"}],"tags":[{"name":"Python编码规范","slug":"python-coding-convention","permalink":"https://zhangbc.github.io/tags/python-coding-convention/"}]},{"title":"【Python爬虫实例】Python解决521反爬方案","slug":"【Python爬虫实例】Python解决521反爬方案","date":"2019-05-05T15:49:14.000Z","updated":"2019-05-05T16:09:48.352Z","comments":true,"path":"2019/05/05/python_anti_spider_521/","link":"","permalink":"https://zhangbc.github.io/2019/05/05/python_anti_spider_521/","excerpt":"","text":"参考文献：https://github.com/xiantang/Spider/blob/master/Anti_Anti_Spider_521/pass_521.py 写在前面的话Python在爬虫方面的优势，想必业界无人不知，随着互联网信息时代的的发展，Python爬虫日益突出的地位越来越明显，爬虫与反爬虫愈演愈烈。下面分析一例关于返回HTTP状态码为521的案例。 案例准备 案例网站：【中国一带一路官网】， 以抓取文章【“一带一路”建设成果图鉴丨陆海内外联动，湖北推动产能合作纵深推进】为例，进行深度剖析。 案例剖析1） 浏览器访问【“一带一路”建设成果图鉴丨陆海内外联动，湖北推动产能合作纵深推进】： 2）写ython代码访问，查看http(s)返回状态 123456789101112131415161718# coding:utf-8import requestsfrom fake_useragent import UserAgentUSER_AGENT = UserAgent()ua = USER_AGENT.randomurl = r'https://www.yidaiyilu.gov.cn/xwzx/gnxw/87373.htm'headers = &#123; \"Host\": \"www.yidaiyilu.gov.cn\", \"User-Agent\": ua&#125;rs = requests.session()resp = rs.get(url)print(resp.status_code)print(resp.text) 不幸的是，返回的http的状态码却是501，text为一段混淆的js代码。 3）百度查资料，推荐为文首的【参考文献】 继续参照资料修改代码，Python执行JS首选execjs，pip安装如下：1pip install PyExecJS 将请求到的js执行： 1234text_521 = ''.join(re.findall('&lt;script&gt;(.*?)&lt;/script&gt;', resp.text))func_return = text_521.replace('eval', 'return')content = execjs.compile(func_return)print(content.call('f')) 将返回的结果print发现还是一段JS，标准格式化（【格式化Javascript工具】），结果如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var _2i = function () &#123; setTimeout('location.href=location.pathname+location.search.replace(/[\\?|&amp;]captcha-challenge/,\\'\\')', 1500); document.cookie = '__jsl_clearance=1557019601.296|0|' + (function () &#123; var _2i = [([(-~[] &lt;&lt; -~[])] * (((+!+&#123;&#125;) + [(-~[] &lt;&lt; -~[])] &gt;&gt; (-~[] &lt;&lt; -~[]))) + []), (-~&#123;&#125; + [] + [ [] ][0]) + [3 - ~(+!+&#123;&#125;) - ~(+!+&#123;&#125;)], (-~&#123;&#125; + [] + [ [] ][0]) + [5], (-~&#123;&#125; + [] + [ [] ][0]) + [~~''], (-~&#123;&#125; + [] + [ [] ][0]), [-~~~!&#123;&#125; + [~~ [] ] - (-~~~!&#123;&#125;)], (-~&#123;&#125; + [] + [ [] ][0]) + [-~&#123;&#125; - ~[-~&#123;&#125; - ~&#123;&#125;]], (-~&#123;&#125; + [] + [ [] ][0]) + (-~&#123;&#125; + [] + [ [] ][0]), [-~(+!+&#123;&#125;)], (-~&#123;&#125; + [] + [ [] ][0]) + ([(-~[] &lt;&lt; -~[])] * (((+!+&#123;&#125;) + [(-~[] &lt;&lt; -~[])] &gt;&gt; (-~[] &lt;&lt; -~[]))) + []), (-~&#123;&#125; + [] + [ [] ][0]) + (-~[-~&#123;&#125; - ~&#123;&#125;] + [ [] ][0]), (((-~[] &lt;&lt; -~[]) &lt;&lt; (-~[] &lt;&lt; -~[])) + [ [] ][0]), [3 - ~(+!+&#123;&#125;) - ~(+!+&#123;&#125;)], (-~&#123;&#125; + [] + [ [] ][0]) + (((-~[] &lt;&lt; -~[]) &lt;&lt; (-~[] &lt;&lt; -~[])) + [ [] ][0]), [5], [-~&#123;&#125; - ~[-~&#123;&#125; - ~&#123;&#125;]], (-~&#123;&#125; + [] + [ [] ][0]) + [-~(+!+&#123;&#125;)], (-~[-~&#123;&#125; - ~&#123;&#125;] + [ [] ][0]), [~~''] ], _1d = Array(_2i.length); for (var _5 = 0; _5 &lt; _2i.length; _5++) &#123; _1d[_2i[_5]] = ['Bz', (-~[-~&#123;&#125; - ~&#123;&#125;] + [ [] ][0]), [&#123;&#125; + [] + [ [] ][0]][0].charAt(-~~~!&#123;&#125;), 'DR', ([(-~[] &lt;&lt; -~[])] / (+!/!/) + [] + [ [] ][0]).charAt(-~[-~~~!&#123;&#125; - ~(-~[] - ~&#123;&#125; - ~&#123;&#125;)]) + (+[(+!+&#123;&#125;), (+!+&#123;&#125;)] + []).charAt((+!+&#123;&#125;)), [ [][ [] ] + [] + [ [] ][0] ][0].charAt(-~&#123;&#125; - ~[-~&#123;&#125; - ~&#123;&#125;]), 'qM', (((-~[] &lt;&lt; -~[]) &lt;&lt; (-~[] &lt;&lt; -~[])) + [ [] ][0]) + (+[(+!+&#123;&#125;), (+!+&#123;&#125;)] + []).charAt((+!+&#123;&#125;)) + (-~&#123;&#125; /~~''+[]+[[]][0]).charAt((+!/!/)),'S','g%',(((-~[]&lt;&lt;-~[])&lt;&lt;(-~[]&lt;&lt;-~[]))+[[]][0]),'HxXL',[[][[]]+[]+[[]][0]][0].charAt(-~&#123;&#125;-~[-~&#123;&#125;-~&#123;&#125;]),'D',[-~(+!+&#123;&#125;)],'T%','YW',[&#123;&#125;+[]+[[]][0]][0].charAt(-~~~!&#123;&#125;),'vw'][_5]&#125;;return _1d.join('')&#125;)()+';Expires=Sun, 05-May-19 02:26:41 GMT;Path=/; '&#125;;if((function()&#123;try&#123;return !!window.addEventListener;&#125;catch(e)&#123;return false;&#125;&#125;)())&#123;document.addEventListener(' DOMContentLoaded ',_2i,false)&#125;else&#123;document.attachEvent(' onreadystatechange ',_2i)&#125; 4）修改与浏览器相关的代码，然后放入浏览器的console进行调试。 注意，在调试过程中，不难发现，js变量是动态生成的。最初还嵌套有document.createElement(&#39;div&#39;)，Python的execjs包不支持处理这类代码，需要做相应处理。 5）综上分析，完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/env python# coding:utf-8import sysimport reimport requestsimport execjsfrom fake_useragent import UserAgentreload(sys)sys.setdefaultencoding('utf8')class YiDaiYiLuSpider(object): \"\"\" 中国一带一路网（521反爬） \"\"\" USER_AGENT = UserAgent() ua = USER_AGENT.random url = r'https://www.yidaiyilu.gov.cn/xwzx/gnxw/87373.htm' headers = &#123; \"Host\": \"www.yidaiyilu.gov.cn\", \"User-Agent\": ua &#125; @classmethod def get_text521(cls): \"\"\" :return: \"\"\" rs = requests.session() resp = rs.get(url=cls.url, headers=cls.headers) text_521 = ''.join(re.findall('&lt;script&gt;(.*?)&lt;/script&gt;', resp.text)) cookie_id = '; '.join(['='.join(item) for item in resp.cookies.items()]) return cookie_id, text_521 @classmethod def generate_cookies(cls, func): \"\"\" :param func: :return: \"\"\" func_return = func.replace('eval', 'return') content = execjs.compile(func_return) eval_func = content.call('f') var = str(eval_func.split('=')[0]).split(' ')[1] rex = r\"&gt;(.*?)&lt;/a&gt;\" rex_var = re.findall(rex, eval_func)[0] mode_func = eval_func.replace('document.cookie=', 'return ').replace(';if((function()&#123;try&#123;return !!window.addEventListener;&#125;', ''). \\ replace(\"catch(e)&#123;return false;&#125;&#125;)())&#123;document.addEventListener('DOMContentLoaded',\" + var + \",false)&#125;\", ''). \\ replace(\"else&#123;document.attachEvent('onreadystatechange',\" + var + \")&#125;\", '').\\ replace(r\"setTimeout('location.href=location.pathname+location.search.replace(/[\\?|&amp;]captcha-challenge/,\\'\\')',1500);\", '').\\ replace('return return', 'return').\\ replace(\"document.createElement('div')\", '\"https://www.yidaiyilu.gov.cn/\"').\\ replace(r\"&#123;0&#125;.innerHTML='&lt;a href=\\'/\\'&gt;&#123;1&#125;&lt;/a&gt;';&#123;0&#125;=&#123;0&#125;.firstChild.href;\".format(var, rex_var), '') content = execjs.compile(mode_func) cookies_js = content.call(var) __jsl_clearance = cookies_js.split(';')[0] return __jsl_clearance @classmethod def crawler(cls): \"\"\" :return: \"\"\" url = r'https://www.yidaiyilu.gov.cn/zchj/sbwj/87255.htm' cookie_id, text_521 = cls.get_text521() __jsl_clearance = cls.generate_cookies(text_521) cookies = \"&#123;0&#125;;&#123;1&#125;;\".format(cookie_id, __jsl_clearance) cls.headers[\"Cookie\"] = cookies print(cls.headers) res = requests.get(url=url, headers=cls.headers) res.encoding = 'utf-8' print(res.text)if __name__ == '__main__': YiDaiYiLuSpider.crawler() 运行结果如下：","categories":[{"name":"Python","slug":"python","permalink":"https://zhangbc.github.io/categories/python/"}],"tags":[{"name":"Python爬虫实例","slug":"Python爬虫实例","permalink":"https://zhangbc.github.io/tags/Python爬虫实例/"}]},{"title":"【Python编码规范】基础语法","slug":"【Python编码规范】基础语法","date":"2019-05-04T23:59:26.000Z","updated":"2019-05-04T17:29:21.855Z","comments":true,"path":"2019/05/05/python_code91_03/","link":"","permalink":"https://zhangbc.github.io/2019/05/05/python_code91_03/","excerpt":"","text":"本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。 温馨提醒：在阅读本书之前，强烈建议先仔细阅读：PEP规范，增强代码的可阅读性，配合优雅的pycharm编辑器(开启pep8检查)写出规范代码，是Python入门的第一步。 Python 基础语法，即Python程序的基本要素，分为： 基本数据类型：数字、字符串、列表、字典、集合、元组等； 常见的语法：条件、循环、函数、列表解析等。 建议19：有节制地使用from…import语句Python提供了3种方式引入外部模块：import语句，from...import...及__import__函数。 __import__函数可以显式地将模块名称作为字符串传递并赋值给命名空间的变量。 在使用import时需要注意以下事项： 1）一般尽量优先使用import a形式，如果访问B时需要使用a.B的形式；2）有节制地使用from a import B形式，可以直接访问B；3）尽量避免使用from a import *，减少污染命名空间。 Python的import机制：Python在初始化运行环境的时候会预先加载一批内建模块到内存中，其相关信息被存放在sys.modules中。 from a import ...无节制的使用产生的问题： 1）命名空间的冲突； 文件a.py： 12def add(): print \"add in module A.\" 文件b.py： 12def add(): print \"add in module B.\" 测试文件importtest.py： 123456from a import addfrom b import addif __name__ == '__main__': add() 2）循环嵌套导入的问题。 可以考虑from...import的情况： 1）当只需要导入部分属性或方法时；2）模块中的这些属性和方法访问频率较高导致使用“模块名.名称”的形式进行访问过于烦琐时；3）模块的文档明确说明需要使用from...import形式，导入的是一个包下面的子模块，且使用from...import形式能够更为简单和便捷时。 建议20：优先使用absolute import来导入模块在Python2.4以前默认为隐式的relative import，局部范围的模块将覆盖同名的全局范围的模块。Python2.5后虽然默认的仍是relative import，但它为absolute import提供了一种新的机制，在模块中使用from __future__ import absolute_import语句进行说明后再进行导入。同时还通过点号.提供了一种显式进行relative import的方法。 相比于absolute import，relative import在实际应用中反馈的问题较多(Python3中已移除)，absolute import的可读性和出现问题后的可跟踪性更好，因此，推荐优先使用absolute import。 建议21：i+=1不等于++iPython解释器会将++i操作解释为+(+i)，其中+表示正数符号。对于--i也是类似。 实例一 123&gt;&gt;&gt; i=1&gt;&gt;&gt; ++i1 实例二：无限循环 12345i = 0ls = [1, 2, 3, 4, 5, 6]while i &lt; len(ls): print ls[0] ++i 建议22：使用with自动关闭资源 with 语句的语法： 12with 表达式 [as 目标]: 代码块 包含with语句的代码块执行过程如下： 1）计算表达式的值，返回一个上下文管理器对象；2）加载上下文管理器对象的__exit__()方法以备后用；3）调用上下文管理器对象的__enter__()方法；4）若with语句中设置了目标对象，则将__enter__()方法的返回值赋值给目标对象；5）执行with中的代码块；6）若步骤5)中的代码正常结束，调用上下文管理器对象的__exit__()方法，其返回值直接忽略；7）若步骤5)中的代码执行过程中发生异常，调用上下文管理器对象的__exit__()方法，并将异常类型，值及traceback信息作为参数传递给__exit__()方法。若__exit__()的返回值为false，则异常会被重新抛出；若__exit__()的返回值为true，则异常会被挂起，程序继续执行。 建议23：使用else子句简化循环（异常处理）12345678910111213def is_prime(number): \"\"\"​ :param number: :return: \"\"\"​ for i in xrange(2, number): for j in xrange(2, i): if i % j == 0: break else: print '&#123;0&#125; is a prime number.'.format(i) 当循环“自然”终结（循环条件为假）时else从句会被执行一次；当循环是由break语句得到中断时，else子句就不被执行。 建议24：遵循异常处理的几点原则Python中常用的异常处理语法是：try，except，else，finally，可以有多种组合。 异常处理流程图如下： 异常处理遵循的基本原则： 1）注意异常的粒度，不推荐在try中放入过多的代码；2）谨慎使用单独的except语句处理所有异常，最好能定位具体的异常；3）注意异常捕捉的顺序，在合适的层次处理异常；向上层传递的时候需要警惕异常被丢失的情况，可以使用不带参数的raise来传递；4）使用更为友好的异常信息，遵循异常参数的规范。 建议25：避免finally中可能发生的陷阱无论try语句中是否有异常抛出，finally语句总会被执行。 12345678910111213141516# -*-coding:UTF-8 -*-​def test(a): try: if a &lt;= 0: raise ValueError(\"data can not be negative.\") else: return a except ValueError as ex: print ex finally: print \"The end!\" return -1​print test(0)print test(2) 建议26：深入理解None，正确判断对象是否为空Python中以下数据会被当作空处理： 常量None； 常量False； 任何形式的数值类型零，如0，0L，0.0，0j； 空的序列，如‘’，()，[]； 空字典，如{}； 当用户定义的类中定义了nonzero()方法和len()方法，并且该方法返回整数0或者布尔值False。 注意：None的特殊性体现在它既不是0，False，也不是空字符串，它就是一个空值对象；其数据类型为NoneType，遵循单例模式，是唯一的，因而不能创建None对象。所有赋值为None的变量都相等，并且None与任何其他非None的对象比较结果都是False。 123456789101112&gt;&gt;&gt; id(None)140735411631784&gt;&gt;&gt; None == 0False&gt;&gt;&gt; None == \"\"False&gt;&gt;&gt; a = None&gt;&gt;&gt; id(a)140735411631784&gt;&gt;&gt; b = None&gt;&gt;&gt; a == b # 所有赋值为`None`的变量都相等True 实例：列表判空 12345ls = []if ls is not None: print \"ls is: \", lsesle: print \"ls is None\" 以上程序运行输出为：ls is: []，显然不是我们的预期结果。应修正为： 12345ls = []if ls: print \"ls is: \", lsesle: print \"ls is None\" 建议27：连接字符串优先使用join而不是+1）使用操作符+连接字符串的方法 123&gt;&gt;&gt; str1, str2, str3 = \"testing \", \"string \", \"concatenation \"&gt;&gt;&gt; str1 + str2 + str3'testing string concatenation ' 2）使用join方法连接字符串的方法 12&gt;&gt;&gt; ''.join([str1, str2, str3])'testing string concatenation ' 性能测试函数 123456789101112131415161718192021222324252627282930# -*-coding:UTF-8 -*-​import timeit​str_list = [\"It is a long value string will not keep in memory \" for n in xrange(10000)]​​def join_test(): return ''.join(str_list)​​def plus_test(): res = '' for i, v in enumerate(str_list): res += v​ return res​​if __name__ == '__main__':​ join_timer = timeit.Timer(\"join_test()\", \"from __main__ import join_test\") print join_timer.timeit(number=10) # 0.00255298614502 print join_timer.timeit(number=100000) # 13.4903669357 plus_timer = timeit.Timer(\"plus_test()\", \"from __main__ import plus_test\") print plus_timer.timeit(number=10) # 0.0193991661072 print plus_timer.timeit(number=100000) # 400.628134012 从以上测试效果看，join()方法的效率要高于+操作符，尤其是字符串规模较大时，两者的效率十分明显。 执行一次+，就会申请一块新的内存空间，并将上一次的操作结果和本次的右操作数复制到新申请的内存空间。时间复杂度为 $O(n^2)$;对于join()，会首先计算需要申请的总的内存空间，然后一次性申请所需内存并将字符序列中的每一个元素复制到内存中去，时间复杂度为$O(n)$。 建议28：格式化字符串时尽量使用.format方式而不是%Python中内置%操作符和.format方式都可以用作格式化字符串。 %转换说明符的基本形式为： 1%[转标记][宽度[.精确度]] 转换类型 常见用法 1）直接格式化字符或者数值 12&gt;&gt;&gt; print \"your score is %06.1f\" % 9.5your score is 0009.5 2）以元组的形式格式化 123456&gt;&gt;&gt; import math&gt;&gt;&gt; item_name = 'circumference'&gt;&gt;&gt; radius = 3&gt;&gt;&gt; print \"The %s of a circle with radius %f is %0.3f\" % \\... (item_name, radius, math.pi*radius*2)The circumference of a circle with radius 3.000000 is 18.850 3）以字典的形式格式化 123&gt;&gt;&gt; item_dict = &#123;'item_name': 'circumference', 'radius': 3, 'value': math.pi*radius*2&#125;&gt;&gt;&gt; print \"The %(item_name)s of a circle with radius %(radius)f is %(value)0.3f\" % (item_dict)The circumference of a circle with radius 3.000000 is 18.850 .format方式格式化字符串的基本语法为： 1.format([[填充符]对齐方式][符号][#][0][宽度][,][.精度][转换类型]) 常见用法 1）使用位置符号123&gt;&gt;&gt; print \"The number &#123;0:,&#125; in hex is: &#123;0:#x&#125;,\" \\... \"The number &#123;1&#125; in oct is: &#123;1:#o&#125;\".format(4746, 45)The number 4,746 in hex is: 0x128a,The number 45 in oct is: 0o55 2）使用名称 123&gt;&gt;&gt; print \"The max number is &#123;max&#125;, the min number is &#123;min&#125;, the average number is &#123;avg&#125;\"\\... .format(max=9, min=3, avg=6)The max number is 9, the min number is 3, the average number is 6 3）通过属性 1234567891011&gt;&gt;&gt; class Customer(object):... def __init__(self, name, sex, phone):... self.name = name... self.sex = sex... self.phone = phone... ... def __str__(self):... return 'Customer (&#123;self.name&#125;, &#123;self.sex&#125;, &#123;self.phone&#125;)'.format(self=self) ... &gt;&gt;&gt; print Customer(\"Lisa\", \"F\", \"13304634561\")Customer (Lisa, F, 13304634561) 4）格式化元组的具体项 123&gt;&gt;&gt; point = (1, 5)&gt;&gt;&gt; print 'X:&#123;0[0]&#125;; Y:&#123;0[1]&#125;'.format(point)X:1; Y:5 为什么要尽量使用format方式而不是%操作符来格式化字符串？ 1）format方式在使用上较%操作符更为灵活；使用format方式时，参数的顺序与格式化的顺序不必完全相同；2）format方式可以方便地作为参数传递；3）%最终会被.format方式替代；4）%方法在某些特殊情况下使用需要特别小心。如下例，特别小心 , 。 1234567&gt;&gt;&gt; items = (\"mouse\", \"mobilephone\", \"cup\")&gt;&gt;&gt; print \"items list are %s\" % (items)Traceback (most recent call last): File \"&lt;input&gt;\", line 1, in &lt;module&gt;TypeError: not all arguments converted during string formatting&gt;&gt;&gt; print \"items list are %s\" % (items,)items list are ('mouse', 'mobilephone', 'cup') 建议29：区别对待可变对象和不可变对象Python中一切皆对象，每一个对象都有一个唯一的标识符(id())，类型(type())以及值。 可变对象：字典，字节数组，列表； 不可变对象：数字，字符串，元组。 实例 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# coding=utf-8class Student(object): \"\"\" 区别可变对象与不可变对象 \"\"\" def __init__(self, name, course=list()): self.name = name self.course = course def add_course(self, course_name): self.course.append(course_name) def print_course(self): for index, item in enumerate(self.course): print item, ' ' print '\\n'if __name__ == '__main__': stu_a = Student(\"Wang Yi\") stu_a.add_course(\"English\") stu_a.add_course(\"Math\") print \"&#123;0&#125;'s course: \".format(stu_a.name) stu_a.print_course() print \"=================================\" stu_b = Student(\"Li san\") stu_b.add_course(\"Chinese\") stu_b.add_course(\"Physics\") print \"&#123;0&#125;'s course: \".format(stu_b.name) stu_b.print_course() 输出结果如下： 12345678910Wang Yi's course: English Math =================================Li san's course: English Math Chinese Physics 修正建议：传入None作为默认参数，在创建对象时动态生成列表。 12345def __init__(self, name, course=None): self.name = name if course is None: course = list() self.course = course 建议30：[]，()，{}：一致的容器初始化形式==&gt;列表解析 列表解析的语法为： 1[expr for iter_item in iterable if cond_expr] 列表解析的使用 1）支持多重嵌套 123&gt;&gt;&gt; nested_list = [['Hello', 'World'], ['Goodbye', 'World']]&gt;&gt;&gt; print [[s.upper() for s in xs] for xs in nested_list][['HELLO', 'WORLD'], ['GOODBYE', 'WORLD']] 2）支持多重迭代 12&gt;&gt;&gt; [(a, b) for a in ['a', '1', 1, 2] for b in ['1', 3, 4, 'b'] if a != b][('a', '1'), ('a', 3), ('a', 4), ('a', 'b'), ('1', 3), ('1', 4), ('1', 'b'), (1, '1'), (1, 3), (1, 4), (1, 'b'), (2, '1'), (2, 3), (2, 4), (2, 'b')] 3）列表解析语法中的表达式可以是简单表达式，也可以是复杂表达式，甚至函数。 1234567891011&gt;&gt;&gt; def f(v):... if v % 2 == 0:... v = v ** 2... else:... v = v + 1... return v... &gt;&gt;&gt; print [f(v) for v in [2, 3, 4, -1] if v &gt; 0][4, 4, 16]&gt;&gt;&gt; print [v ** 2 if v % 2 == 0 else v + 1 for v in [2, 3, 4, -1] if v &gt; 0][4, 4, 16] 4）列表解析语法中的iterable可以是任意可迭代对象。 建议31：记住函数传参既不是传值也不是传引用==&gt;而是传对象（的引用）1）传引用 1234567891011121314&gt;&gt;&gt; def inc(n):... print id(n)... n = n + 1... print id(n)... &gt;&gt;&gt; n = 3&gt;&gt;&gt; id(n)140407485781272&gt;&gt;&gt; &gt;&gt;&gt; inc(n)140407485781272140407485781248&gt;&gt;&gt; print n3 分析：按照传引用的观点，结果输出应为4，并且inc()函数里面执行操作n=n+1的前后n的id值应该是不变的。 2）传值 123456789101112131415&gt;&gt;&gt; def change_list(org_list):... print \"orginator list is: \", org_list... new_list = org_list... new_list.append(\"I am new.\")... print \"new list is: \", new_list ... return new_list... &gt;&gt;&gt; org_list = ['a', 'b', 'c']&gt;&gt;&gt; new_list = change_list(org_list)orginator list is: ['a', 'b', 'c']new list is: ['a', 'b', 'c', 'I am new.']&gt;&gt;&gt; print new_list['a', 'b', 'c', 'I am new.']&gt;&gt;&gt; print org_list['a', 'b', 'c', 'I am new.'] 分析：通过程序输出不难发现，在传值过程中，原来的列表对象随着新对象的变化随之发生变化。 3）可变对象传引用，不可变对象传值 12345678910111213141516171819202122232425262728&gt;&gt;&gt; def change(org_list):... print id(org_list)... new_list = org_list... print id(new_list)... if len(new_list) &gt; 5:... new_list = ['a', 'b', 'c']... for i, e in enumerate(new_list):... if isinstance(e, list):... new_list[i] = \"***\"... print new_list... print id(new_list)... &gt;&gt;&gt; test1 = [1, ['a', 1, 3], [2, 1], 6]&gt;&gt;&gt; change(test1)45124735284512473528[1, '***', '***', 6]4512473528&gt;&gt;&gt; print test1[1, '***', '***', 6]&gt;&gt;&gt; test2 = [1, 2, 3, 4, 5, 6, [1]]&gt;&gt;&gt; change(test2)45114667044511466704['a', 'b', 'c']4512476552&gt;&gt;&gt; print test2[1, 2, 3, 4, 5, 6, [1]] 分析：传入参数org_list为列表，属于可变对象，按照可变对象传引用的理解，new_list和org_list指向同一块内存，因此两者的id值输出一致，即修改new_list会导致org_list的直接修改；但是在test2中调用函数change()前后并没有发生改变。 Python中的赋值机制理解： 123a = 5b = ab = 7 验证上述过程 1234567891011&gt;&gt;&gt; a = 5&gt;&gt;&gt; id(a)140407485781224&gt;&gt;&gt; b = a&gt;&gt;&gt; id(b)140407485781224&gt;&gt;&gt; b = 7&gt;&gt;&gt; id(b)140407485781176&gt;&gt;&gt; id(a)140407485781224 小结：对于Python函数参数传递的正确说法是：传对象或者传对象的引用。函数参数在传递的过程中将整个对象传入，对可变对象对修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象；而对于不可变对象，由于不能真正被修改，因而修改往往是通过生成一个新对象然后赋值来实现的。 建议32：警惕默认参数潜在的问题 实例 123456789101112131415161718&gt;&gt;&gt; def test(new_item, list_a=list()):... print id(list_a)... list_a.append(new_item)... print id(list_a)... return list_a... &gt;&gt;&gt; test('a', ['b', 2, 4, [1, 2]])45114677124511467712['b', 2, 4, [1, 2], 'a']&gt;&gt;&gt; test(1)45124397604512439760[1]&gt;&gt;&gt; test('a')45124397604512439760[1, 'a'] 分析：在连续调用test(1)和test(‘a’)，结果和预想的完全不一样。 解决方案：在函数调用过程中动态生成，可以在定义时使用None对象作为占位符。 12345678910111213141516&gt;&gt;&gt; def test(new_item, list_a=None):... if list_a is None:... list_a = list()... print id(list_a)... list_a.append(new_item)... print id(list_a)... return list_a... &gt;&gt;&gt; test('a')45117940244511794024['a']&gt;&gt;&gt; test(1)45124401924512440192[1] 建议33：慎用变长参数Python支持可变长度的参数列表，可以通过函数定义时使用*args和**kwargs这两个特殊语法实现。 *args：实现可变参数列表； *args用于接收一个包装为元组形式的参数列表来传递非关键字参数，参数个数任意。 12345678910&gt;&gt;&gt; def summary(*args):... result = 0... for x in args[0:]:... result += x... return result... &gt;&gt;&gt; print summary(2, 4)6&gt;&gt;&gt; print summary(1, 2, 3, 4, 5)15 **kwargs：实现字典形式的关键字参数列表。 12345678&gt;&gt;&gt; def category_table(**kwargs):... for name, value in kwargs.items():... print \"&#123;0&#125; is a kind of &#123;1&#125;.\".format(name, value)... &gt;&gt;&gt; category_table(apple=\"fruit\", carrot=\"vegetable\", python=\"programming language\")python is a kind of programming language.carrot is a kind of vegetable.apple is a kind of fruit. 建议34：深入理解str()和repr()的区别str()和repr()的区别： 1）二者的目标不同：str()面向用户，其目的是可读性，返回字符串类型；repr()面向的Python解释器，或者说开发者，其目的是准确性，返回表示Python解释器内部的含义，常作为debug用途；2）在解释器中直接输入a时默认调用repr()，而print a则调用str()；3）repr()的返回值一般可用eval()函数还原对象，即：obj == eval(repr(obj))；4）二者分别调用__str__()和__repr__()方法，一般而言，在类中都应该定义__repr__()方法（默认方法）。 1234567891011&gt;&gt;&gt; s = \"' '\"&gt;&gt;&gt; str(s)\"' '\"&gt;&gt;&gt; repr(s)'\"\\' \\'\"'&gt;&gt;&gt; eval(repr(s)) == sTrue&gt;&gt;&gt; eval(str(s))' '&gt;&gt;&gt; eval(str(s)) == sFalse 建议35：分清staticmethod和classmethod的适用场景Python中的静态方法(staticmethod)和类方法(classmethod)都依赖于装饰器(decorator)来实现。 静态方法(staticmethod) 1234class C(object): @staticmethod def f(args1, args2, ...): pass 类方法(classmethod) 1234class C(object): @classmethod def f(cls,args1, args2, ...): pass 静态方法所带来的问题 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# coding=utf-8class Fruit(object): \"\"\" Fruit类 \"\"\" def __init__(self, area=\"\", category=\"\", batch=\"\"): self.area = area self.category = category self.batch = batch @staticmethod def init_product(product_info): area, category, batch = map(str, product_info.split('-')) fruit = Fruit(area, category, batch) return fruitclass Apple(Fruit): passclass Orange(Fruit): passif __name__ == '__main__': apple = Apple('2', '5', '10') orange = Orange.init_product(\"3-3-9\") print \"apple is instance of Apple: \", isinstance(apple, Apple) print \"orange is instance of Orange: \", isinstance(orange, Orange) 输出结果： 12apple is instance of Apple: Trueorange is instance of Orange: False 分析：静态方法实际上相当于一个定义在类中的函数，init_product()返回的实际是Fruit对象，所以不会是Orange对象。因而静态方法并不能获取期望的结果，类方法才是正确的解决方案。 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# coding=utf-8class Fruit(object): \"\"\" Fruit类 \"\"\" def __init__(self, area=\"\", category=\"\", batch=\"\"): self.area = area self.category = category self.batch = batch @classmethod def init_product(cls, product_info): area, category, batch = map(str, product_info.split('-')) fruit = cls(area, category, batch) return fruitclass Apple(Fruit): passclass Orange(Fruit): passif __name__ == '__main__': apple = Apple('2', '5', '10') orange = Orange.init_product(\"3-3-9\") print \"apple is instance of Apple: \", isinstance(apple, Apple) print \"orange is instance of Orange: \", isinstance(orange, Orange)","categories":[{"name":"Python","slug":"python","permalink":"https://zhangbc.github.io/categories/python/"}],"tags":[]},{"title":"【Python编码规范】编程惯用法","slug":"【Python编码规范】编程惯用法","date":"2019-04-27T16:09:25.000Z","updated":"2019-04-27T16:41:29.208Z","comments":true,"path":"2019/04/28/python_code91_02/","link":"","permalink":"https://zhangbc.github.io/2019/04/28/python_code91_02/","excerpt":"","text":"本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。 温馨提醒：在阅读本书之前，强烈建议先仔细阅读：PEP规范，增强代码的可阅读性，配合优雅的pycharm编辑器(开启pep8检查)写出规范代码，是Python入门的第一步。 建议8：利用assert语句来发现问题 断言(assert)基本语法如下： 1assert expression1 [\",\" expression2] assert用法举例： 123456&gt;&gt;&gt; x = 1&gt;&gt;&gt; y = 2&gt;&gt;&gt; assert x == y , \"not equals\"Traceback (most recent call last): File \"&lt;input&gt;\", line 1, in &lt;module&gt;AssertionError: not equals 关于assert的几点说明事项 1）__debug__的值默认为True，且只读，无法修改(Python2.7)。2）断言是有代价的，对性能产生一定影响。禁用断言的方法是在运行脚本的时候加上-O标记(不优化字节码，而是忽略与断言相关的语句)。 使用断言(assert)注意点： 1）不要滥用，这是使用断言最基本的原则；2）如果Python本身的异常能够处理就不要再使用断言；3）不要使用断言来检查用户的输入；4）在函数调用后，当需要确认返回值是否合理时可以使用断言；5）当条件时业务逻辑继续下去的先决条件时，可以使用断言。 建议9：数据交换值时不推荐使用中间交换变量12345&gt;&gt;&gt; from timeit import Timer&gt;&gt;&gt; Timer('temp=x;x=y;y=temp','x=2;y=3').timeit()0.03472399711608887&gt;&gt;&gt; Timer('x,y=y,x','x=2;y=3').timeit()0.031581878662109375 测试用例说明：不借助中间变量的方式耗费的时间更少，代码简洁，值得推荐。 建议10：充分利用Lazy evaluation的特性Lazy evaluation常被译作“延时计算”或“惰性计算”，指的是仅仅在真正需要执行的时候才计算表达式的值。典型例子：生成器表达式。 1）避免不必要的计算，带来性能上的提升；2）节省空间，使用无限循环的数据结构成为可能。 实例： 123456789101112131415161718#!/usr/bin/env python# coding:utf-8from itertools import islicedef fib(): a, b = 0, 1 while True: yield a a, b = b, a+bif __name__ == '__main__': print(list(islice(fib(), 5))) 建议11：理解枚举替代实现的缺陷1）替代方法 使用类属性 12345&gt;&gt;&gt; class Seasons(object):... Spring, Summer, Autumn, Winter = xrange(4)... &gt;&gt;&gt; print(Seasons.Spring)0 借助函数 12345678&gt;&gt;&gt; def enum(*args, **kwargs):... return type(\"Enum\", (object,), dict(zip(args, xrange(len(args))), **kwargs))... &gt;&gt;&gt; Seasons = enum(\"Spring\", \"Summer\", \"Autumn\", Winter=3)&gt;&gt;&gt; Seasons.Summer1&gt;&gt;&gt; Seasons.Winter3 使用collections.namedtuple 123456&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Seasons = namedtuple('Seasons','Spring Summer Autumn Winter')._make(xrange(4)) &gt;&gt;&gt; print SeasonsSeasons(Spring=0, Summer=1, Autumn=2, Winter=3)&gt;&gt;&gt; print Seasons.Autumn2 2）替代缺陷 允许枚举值重复 123456&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Seasons = namedtuple('Seasons','Spring Summer Autumn Winter')._make(xrange(4)) &gt;&gt;&gt; SeasonsSeasons(Spring=0, Summer=1, Autumn=2, Winter=3)&gt;&gt;&gt; Seasons._replace(Spring=2) # 不合理Seasons(Spring=2, Summer=1, Autumn=2, Winter=3) 支持无意义的操作 12&gt;&gt;&gt; Seasons.Summer + Seasons.Autumn == Seasons.Winter # 无意义True 3）Python2.7的替代方案(Python3.4后引入Enum类型)：flufl.enum 12345678910111213141516171819#!/usr/bin/env python# coding:utf-8from flufl.enum import Enum​​class Seasons(Enum):​ Spring = \"Spring\" Summer = 2 Autumn = 3 Winter = 4​​Seasons = Enum('Seasons', 'Spring Summer Autumn Winter')​print Seasonsprint Seasons.Summer.value 建议12：不推荐使用type来进行类型检查1）基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# coding:utf-8import typesclass UserInt(int): \"\"\" 用户类UserInt继承int类实现定制化，不支持操作符（+=） \"\"\" def __init__(self, value=0): self._value = int(value) def __add__(self, other): if isinstance(other, UserInt): return UserInt(self._value + other._value) return self._value + other def __iadd__(self, other): raise NotImplementedError(\"not support operation.\") def __str__(self): return str(self._value) def __repr__(self): return \"Integer(&#123;0&#125;)\".format(self._value)if __name__ == '__main__': n = UserInt() print(n) # 输出 0 m = UserInt(2) print(m) # 输出 2 print(n+m) # 输出 2 print(type(n) is types.IntType) # 使用type进行类型判断，输出 False print(isinstance(n, int)) # 输出 True 2）在旧式类中，所有类的实例的type值都相等。 123456789101112&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; a = A()&gt;&gt;&gt; class B:... pass... &gt;&gt;&gt; b = B()&gt;&gt;&gt; type(a) == type(b)True&gt;&gt;&gt; type(a)&lt;type 'instance'&gt; 3）可以用isinstance()函数检查。 12345678&gt;&gt;&gt; isinstance(2, float)False&gt;&gt;&gt; isinstance(\"a\", (str, unicode))True&gt;&gt;&gt; isinstance((2,3), (str, list))False&gt;&gt;&gt; isinstance((2,3), (str, list, tuple))True 建议13：尽量转换为浮点类型再做除法当涉及除法运算的时候尽量先将操作数转换成浮点类型再做运算。 浮点数不精确性导致的无限循环： 1234&gt;&gt;&gt; i=1&gt;&gt;&gt; while i!=1.5:... i=i+0.1... print i 建议14：警惕eval()的安全漏洞 实例：根据用户的输入，计算Python表达式的值 12345678910111213141516171819# -*-coding:UTF-8 -*-​​import sysfrom math import *​def ExpCalcBot(string): try: print \"Your answer is\", eval(string) except NameError: print \"The expression you enter is not valid.\"​while True: print 'Please enter a number or operation. Enter e to complete. ' inputStr = raw_input() if inputStr == 'e': sys.exit() elif repr(inputStr) != ' ': ExpCalcBot(inputStr) 输入：__import__(&quot;os&quot;).system(&quot;dir&quot;)：显示当前目录下的所有文件； __import__(&quot;os&quot;).system(&quot;del */Q&quot;)：删除当前目录下的所有文件。 因此，在实际应用过程中，如果使用对象不是信任源，应该尽量避免使用eval，在需要使用eval的地方可以用安全性更好的ast.literal_eval替代。 建议15：使用enumerate()获取序列迭代的索引和值对序列进行迭代并获取序列中的元素进行处理的几种方法举例： 方法一 在每次循环中对索引变量进行自增 12345li = ['a', 'b', 'c', 'd', 'e']index = 0for i in li: print(\"index:\", index, \"element:\", i) index += 1 方法二 使用range()和len()方法结合 123li = ['a', 'b', 'c', 'd', 'e']for i in xrange(len(li)): print(\"index:\", i, \"element:\", li[i]) 方法三 使用while循环，用len获取循环次数 12345li = ['a', 'b', 'c', 'd', 'e']i = 0while i &lt; len(li): print(\"index:\", i, \"element:\", li[i]) i += 1 方法四 使用zip()方法 123li = ['a', 'b', 'c', 'd', 'e']for i, e in zip(range(len(li)), li): print(\"index:\", i, \"element:\", e) 方法五(推荐) 使用enumerate()获取序列迭代对索引和值 123li = ['a', 'b', 'c', 'd', 'e']for i, e in enumerate(li): print(\"index:\", i, \"element:\", e) 注意：在获取迭代过程中字典的key和value，应该使用如下iteritems()方法(Python3不再适用)。 123&gt;&gt;&gt; person=&#123;'name': 'Josn', 'age': 19, 'hobby': 'football'&#125;&gt;&gt;&gt; for k,v in person.iteritems():... print k, \":\", v 建议16：分清==与is的适用场景123456789101112&gt;&gt;&gt; a=\"Hi\"&gt;&gt;&gt; b=\"Hi\"&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a==b # is 和 == 结果是一样的True&gt;&gt;&gt; a1 =\"I am using long string for testing\" # 注意区分&gt;&gt;&gt; b1 =\"I am using long string for testing\"&gt;&gt;&gt; a1 is b1False&gt;&gt;&gt; a1==b1 # is 和 == 结果是不一样的True is：即object identity，表示的是对象标识符，检查对象的标识符是否一致，也就是比较两个对象在内存中是否拥有同一块内存空间； ==：即equal，表示的是值相等，用来判断两个对象的值是否相等，可以被重载。 字符串驻留(string interning)机制：对于较小的字符串，为了提高系统性能会保留其值的一个副本，当创建新的字符串时直接指向该副本即可。 注意：判断两个对象相等应该使用 == 而不是 is。 建议17：考虑兼容性，尽可能使用UnicodePython内建的字符串有两种类型：str和Unicode，共同祖先为basestring。 123456789&gt;&gt;&gt; str_uni = u'unicode字符串' # 前面加u表示Unicode&gt;&gt;&gt; str_uniu'unicode\\u5b57\\u7b26\\u4e32'&gt;&gt;&gt; print(str_uni)unicode字符串&gt;&gt;&gt; type(str_uni)&lt;type 'unicode'&gt;&gt;&gt;&gt; type(str_uni).__bases__(&lt;type 'basestring'&gt;,) Unicode：又称万国码，为每种语言设置了唯一的二进制编码表示方式，提供从数字代码到不同语言字符集之间的映射，从而满足跨平台、跨语言之间的文本处理要求。 Unicode编码系统分为编码方式和实现方式 在编码方式上，分为UCS-2和UCS-4，UCS-2用两个字节编码；UCS-4用四个字节编码。 实现方式又称为Unicode转换方式，简称UTF，包括UTF-7、UTF-8、UTF-16、UTF-32等。 UTF-8 较为常见，其特点是对不同范围的字符使用不同长度的编码，其中0x00～0x7F的字符UTF-8编码与ASCII编码完全相同；其最大长度是4个字节。 Windows本地默认编码是CP936。 解码：str.decode([编码参数[，错误处理]]) 编码：str.encode([编码参数[，错误处理]])错误处理参数有3种方式： （1）strict：默认值，抛出UnicodeError异常；（2）ignore：忽略不可转换的字符；（3）replace：将不可转换字符用?代替。 常见的编码参数 对于A、B两种编码系统之间的相互转换示意图如下： 有些软件在保存UTF-8编码时，会在文件最开始地方插入不可见的BOM(0xEF，0xBB，0xBF， 即BOM)，可以利用codecs模块解决。 123456import codecs​content = open('manage.py', 'r').read()if content[:3] == codecs.BOM_UTF8: content = content[:3]print content.decode(\"utf-8\") 编码声明的三种方式： 123456789# coding=&lt;encoding name&gt; #方式一​​#!/usr/bin/env python# -*- coding:&lt;encoding name&gt; -*- #方式二​​#!/usr/bin/env python# vim:set fileencoding=&lt;encoding name&gt; #方式三 建议18：构建合理的包层次来管理module本质上，每一个Python文件都是一个模块，使用模块可以增强代码的可维护性和可重用性。 包 即目录，包含一个__init__.py文件，允许嵌套。包中的模块通过“.”访问符进行访问，即“包名.模块名”。 直接导入一个包 1import package 导入子模块或者子包，包嵌套的情况下可以进行嵌套导入 1234567from package import moduleimport package.modulefrom package import subpackageimport package.subpackagefrom package.subpackage import moduleimport package.subpackage.module 包中__init__.py文件的作用 1）使包和普通目录区分；2）在该文件中声明模块级别的import语句，从而使其变成包级别可见；3）通过该文件中定义__all__变量，控制需要导入的子包或者模块。 使用包的好处 1）合理组织代码，便于维护和使用；2）能够有效地避免名称空间冲突。","categories":[{"name":"Python","slug":"python","permalink":"https://zhangbc.github.io/categories/python/"}],"tags":[{"name":"Python编码规范","slug":"python-coding-convention","permalink":"https://zhangbc.github.io/tags/python-coding-convention/"}]},{"title":"【Python编码规范】Python编码入门","slug":"【Python编码规范】Python编码入门","date":"2019-04-25T14:56:39.000Z","updated":"2019-04-26T16:09:59.802Z","comments":true,"path":"2019/04/25/python_code91_01/","link":"","permalink":"https://zhangbc.github.io/2019/04/25/python_code91_01/","excerpt":"","text":"本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。 温馨提醒：在阅读本书之前，强烈建议先仔细阅读：PEP规范，增强代码的可阅读性，配合优雅的pycharm编辑器(开启pep8检查)写出规范代码，是Python入门的第一步。 本书主要内容 1）容易被忽视的重要概念和常识，如代码的布局和编写函数的原则等；2）编写Python程序管用的方法，如利用assert语句去发现问题，使用enumerate()获取序列迭代的索引和值等；3）语法中的关键条款，如有节制地使用from…import语句，异常处理的几点基本原则等；4）常见库的使用，如按需选择sort()或者sorted()，使用Queue使多线程更安全等；5）Python设计模式的使用，如用发布订阅模式实现松耦合，用状态模式美化代码等；6）Python内部机制，如名字查找机制，描述符机制等；7）开发工具的使用，如pip等各种开发工具的使用，各种代码测试用具的使用等；8）Python代码的性能分析，优化的原则，工具，技巧，以及常见性能问题的解决等。 建议1：理解Pythonic概念1）Pythonic的定义：充分体现Python自身特色的代码风格。 The Zen of Python(Python之禅) 1234567891011121314151617181920212223&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!&gt;&gt;&gt; 快速排序 1234567891011121314151617181920def sort_quick(array): \"\"\" 快速排序 :param array: :return: \"\"\" less = list() greater = list() if len(array) &lt;= 1: return array pivot = array.pop() for index, item in enumerate(array): if item &lt;= pivot: less.append(item) else: greater.append(item) return sort_quick(less) + [pivot] + sort_quick(greater) 2）代码风格 交换两个变量的值，packaging/unpackaging机制 1234x = 2y = 3x, y = y, xprint x, y 容器遍历 12for index, item in enumerate(items): do_sth_with(item) 列表逆序 1234list_a = [1, 2, 3, 4, 5]str_c = 'abcdef'print(list(reversed(list_a)))print(list(reversed(str_c))) 标准库 12# 字符串格式化print 'Hello %(name)s!' % &#123;'name': 'Tom'&#125; 注解：%是非常影响可读性的，因为数量多了之后，很难清除哪一个占位符对应哪一个实参。 str.format()：Python最为推荐达到字符串格式化方法。 12# 字符串格式化, 替代%print 'Hello &#123;name&#125;!'.format(name='Tom') 3）Python的包和模块结构 (1) 包和模块的命名采用小写，单数形式且短小；(2)包通常作为命名空间，如只包含空的__init__.py文件。 建议2：编写pythonic代码1）要避免劣化代码 (1)避免只用大小写来区分不同的对象；(2)避免使用容易引起混淆的名称；(3)不要害怕过长的变量名。 实例1（函数名称，变量名意义均不明） 12345678910111213def funA(list_items, num): \"\"\" :param list_items: :param num: :return: \"\"\" for element in list_items: if num == element: return True return False 实例2（推荐） 12345678910111213def find_num(list_search, num): \"\"\" :param list_search: :param num: :return: \"\"\" for index, value in enumerate(list_search): if num == value: return True return False 2）pep8检测工具 1234C:\\&gt;pip install -U pep8C:\\Users\\Administrator\\Desktop\\zxt&gt;pep8 --first database.pydatabase.py:83:1: E302 expected 2 blank lines, found 1&gt;pep8 --show-source --show-pep8 waijiao.py 3）深入认识Python有助于编写Pythonic代码 掌握Python提供的所有特性，包括语言特性和库特性； 跟进学习Python的最新版本提供的新特性，掌握其变化趋势； 深入学习公认比较Pythonic的代码，例如Flask、gevent、requests等。 建议3：理解python与C语言的不同之处1）“缩进” 与 “{}“Python中使用严格的代码缩进方式分隔代码块，应养成良好的习惯，统一缩进风格，不要混用Tab键和空格。 2）&#39; 与 &quot;在C语言中，二者有严格的区分，但是在Python中，区别较小。 1234567Python 2.7.10 (default, Jul 15 2017, 17:16:57) &gt;&gt;&gt; str1 = \"He said, \\\"Hello!\\\"\"&gt;&gt;&gt; str2 = 'He said, \"Hello!\"'&gt;&gt;&gt; str1'He said, \"Hello!\"'&gt;&gt;&gt; str2'He said, \"Hello!\"' 3）三元操作符 ?: 1234x = 0y = -2print(x if x &lt; y else y)-2 4）switch...case 123456789n = raw_input(\"please input a number:\")if n == \"0\": print \"You typed zero.\"elif n == \"1\": print \"You are in top.\"elif n == \"2\": print \"N is an even number.\"else: print \"Error!\" 用跳转也可以实现： 123456def func(): return &#123; \"0\": \"You typed zero.\", \"1\": \"You are in top.\", \"2\": \"N is an even number.\" &#125;.get(n, \"Error!\") 建议4：在代码中适当添加注释Python有3种形式的代码注释：块注释，行注释，文档注释(docstring)。 (1）使用块或者行注释的时候仅注释复杂的操作，算法，难以理解的技巧或者不够一目了然的代码；(2）注释和代码隔开一定的距离；(3）给外部可访问的函数和方法添加文档注释(docstring)（&quot;&quot;&quot; &quot;&quot;&quot;）；(4）推荐文件头部包含copyright申明，模块描述等。 12345678910111213141516171819202122232425262728\"\"\"Requests HTTP library~~~~~~~~~~~~~~~~~~~~~Requests is an HTTP library, written in Python, for human beings. Basic GETusage: &gt;&gt;&gt; import requests &gt;&gt;&gt; r = requests.get('https://www.python.org') &gt;&gt;&gt; r.status_code 200 &gt;&gt;&gt; 'Python is a programming language' in r.content True... or POST: &gt;&gt;&gt; payload = dict(key1='value1', key2='value2') &gt;&gt;&gt; r = requests.post('http://httpbin.org/post', data=payload) &gt;&gt;&gt; print(r.text) &#123; ... \"form\": &#123; \"key2\": \"value2\", \"key1\": \"value1\" &#125;, ... &#125;The other HTTP methods are supported - see `requests.api`. Full documentationis at &lt;http://python-requests.org&gt;.:copyright: (c) 2015 by Kenneth Reitz.:license: Apache 2.0, see LICENSE for more details.\"\"\" 建议5：通过适当添加空行使代码布局更为优雅，合理Python代码布局应当遵循以下基本规则：1）在一组代码表达完一个完整的思路之后，应该用空白行进行间隔； 反例（多余空行） 12345if guess == number: print(\"Good job!\") else: print(\"Nope\") 2）尽量保持上下文语义的易理解性(如调用函数写在被调用函数之上)； 123456def A(): B()def B(): pass 3）避免过长的代码行，每行最好不要超过80个字符，超过的部分可以用圆括号、方括号、花括号等进行连接，并保存行连接的元素垂直对齐； 12x = ('This is a verey long string.' 'It is used for testing line limited characters') 4）不要为了保持水平对齐而使用多余的空格，同时也不要在一行有多个命令； 反例（多余的空格） 1234x = 5Year = 2013name = \"Jam\"d2 = &#123;'spam': 2, 'eggs': 3&#125; 反例（一行中多个命令） 1X = 1; Y = 2; 5）空格的使用要能在需要强调的时候警示读者：（1）二元运算符、比较、布尔运算的左右两边应该有空格； 1x == 1 （2）逗号和分号前不要使用空格； 推荐 1234if x == 4: print(x, y)x, y = y, x 反例（不推荐） 1234if x == 4 : print(x , y)x , y = y , x （3）函数名和左右括号之间，序列索引操作时序列名和[ ]之间不要空格，函数默认参数两侧不需要空格； 1234def sort_quick(array, if_print=0): ...arrays = [9, 8, 4, 5, 32, 64, 2, 1, 0, 10, 19, 27] （4）强调前面的操作符的时候使用空格。 12-2 - 5b*b + a*a 建议6：编写函数的4个原则函数 能够带来最大化的代码重用和最小化的代码冗余，不仅可以提高程序的健壮性，还可以增强可读性，减少维护成本。 1）函数设计尽量短小，嵌套层次不宜过深(最好控制在3层以内)； 2）函数声明应该做到合理，简单，易于使用； 3）函数参数设计应该考虑向下兼容； 4）一个函数只做一件事，尽量保证函数语句粒度的一致性。 建议7：将常量集中到一个文件Python使用常量： 通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下画线连接各个单词；通过自定义的类实现常量功能。 示例：const.py 123456789101112131415161718192021222324#!/usr/bin/env python# coding:utf-8import sysclass _const(object): class ConstError(TypeError): pass class ConstCaseError(ConstError): pass def __setattr__(self, name, value): if self.__dict__.has_key(name): raise self.ConstError, \"Can't change const.&#123;name&#125;\".format(name=name) if not name.isupper(): raise self.ConstCaseError, 'const name \"&#123;name&#125;\" is not all uppercase'.format(name=name) self.__dict__[name] = valuesys.modules[__name__] = _const() 调用实例 1234567import constconst.COMPANY = \"IBM\"print(const.COMPANY)const.COMPANY = \"IBM2\" 上述调用会报错，因为代码中的常量一旦生成便不可更改 123456Traceback (most recent call last): File \"/home/projects/pythoner/quality_code/algorithm_sort.py\", line 40, in &lt;module&gt; const.COMPANY = \"IBM2\" File \"/home/projects/pythoner/quality_code/const.py\", line 18, in __setattr__ raise self.ConstError, \"Can't change const.&#123;name&#125;\".format(name=name)const.ConstError: Can't change const.COMPANY","categories":[{"name":"Python","slug":"python","permalink":"https://zhangbc.github.io/categories/python/"}],"tags":[{"name":"Python编码规范","slug":"python-coding-convention","permalink":"https://zhangbc.github.io/tags/python-coding-convention/"}]},{"title":"【心路历程】做好自己，面对现实（七）","slug":"【心路历程】做好自己，面对现实（七）","date":"2019-04-22T14:53:30.000Z","updated":"2019-04-22T15:00:36.255Z","comments":true,"path":"2019/04/22/myself_08/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_08/","excerpt":"","text":"弹指一瞬，已是四年没有更新这个系列的东西，想说的太多却欲言又止，生活的磨练快让我认不得从前的自己了，今日此时此刻翻阅了一下以前的关于自己的想法与历程，觉得有必要继续这个系列的话题了，以记录自己最真实的生活状态，人生旅程漫漫，不能没有梦，不能忘了原有的动力，即使穷生活也得还原生活的本真，揭开虚伪的面纱，还自己一个最真实的人生。 大学毕业快五年，我一直没有忘记思考自己想要什么样的生活？其实我还是没有想太明白，从不怕被人抛弃，也不怕人笑话，其实我对金钱一直是比较抵触的，但当听说很多朋友已买房的时候，我开始慢慢怀疑自己是不是有点另类了，多少人为了一套房子煞费苦心，得到了之后却并没觉得开心？虽然他们负债累累，谨小慎微的过着余生可数的日子，但是他们实现了人生一个小小的目标，而且时间不算太长。再回头审视自己，从学校出来，拿着微薄的薪水，带着一颗自卑的心，一直就这么撑着，因为身体的原因，还有倔强的性格，一丝丝不甘心的愿望，顿时觉得自己被时代抛弃了美好的青春年华。殊不知是自己缺少一颗闯进的心，缺少一个真正的规划的人生目标，2014年错失了一次从头再来的机会，那些所谓贷款的还款计划，今日想起来，着实应证了那句话，贫困限制了你的视野。穷怕了，连一个利息钱都不想多付一分，如果时时刻刻算着自己的经济账，那如何超脱自己，达到不受金钱的束缚？ 毕业就知道，三年一个小坎，五年一个大坎，跳过了就成功了，没有跳过注定平庸，至少一段相当长的时期会过着不是自己想要的生活。其实毕业这五年，我算是平庸得不能在平庸了，但是至始至终有一颗不甘平庸的心。2013年得力于同窗的举荐进了一家不大不小的医药物流企业做ERP技术支持，从零开始，从维护一个简易的电商平台再到一个分公司ERP业务系统再到整个公司ERP系统，不足一年就已完全掌控，对ERP流程优化，业务系统改造，与部门有效沟通均出了应有之力。尽管如此，对当时的生活状态还是不满意，工资低不说，主要感觉还是无法满足自己的学习欲望，于是乎，各种倒腾自己的业余生活尝试新技术的学习，还是想做一名合格的码农。2014年4月同事离职，两个人的工作推到了我一个人身上，经一个月的调整，也算平稳过渡，就这么撑到了2015年4月离开。其实对我来说得到了极大了锻炼价值，从中慢慢体会了许多东西，什么事情分轻重缓急，哪些任务需要主次分明，哪些工作项得有条不紊，只有亲身体验了方可知其中的奥妙。在这家公司，让我学会了做事，技术没有收获多少，做事的思维大有提升。2015年4月离职，去了上海，原本是拜师傅去的，仅仅半个月由于自己基础实在是太薄弱，最后夭折，开始寻下一份工作。这辈子一定要尝试自己想做的工作，想过的日子，哪怕没钱，哪怕遭无数人鄙视，一定要去做，必须去满足自己小小的虚荣心，哪怕只有一天，无论付出多大的代价。这是我拜师最大的收获，认识了一位开发大神（也是我同乡），后来离开也拒绝了他给我的半个月薪水，不为别的，就为一个承若：干不好，分文不取，拍屁股走人。他给了我很多建议，受益匪浅，时至今日，我们依然保持着联系，我依然能感受他对我无微不至的关怀。花了一个月的时间，拿到两个比较中意的offer，因不想重拾ERP技术，拒绝了业界许多好心人的推荐，当时的想法就是宁可无工作也不去走老路，一定要坚持自己的信念。经过两家工作性质对比思考，最终选择了薪资较低而且极为陌生的领域，开始决定摸爬滚打。技术用上了我业余的学习所得，当然也没有排除我之前掌握的核心技术栈。说是开发工程师，其实进来才发现也不是那么回事，各种杂活脏活还是由我一个人做，创业公司嘛，坑不少，想想能锻炼人，能感受一波创业的辛酸史，便留下了断了其他念头，老板在吃喝玩乐方面也比较阔气。在这家公司最大的感受就是，创业不易，且行且珍惜，要有危机意识，时时刻刻保持一颗清醒的头脑，一句话谨记，逆水行舟不进则退。其实生活工作亦如此。后来，感觉老板心态变了，不断画饼(平生最恶此举)，我就离开了。期间认识了不少人，见识了不少场合，逢场作戏太多，越来越觉得当初毕业拒绝考虑医院单位是明智之举。2015年5月至2017年4月，就这样结束了我的第二份工作，即将有幸迎来我的第三份工作—我在一家互联网金融的创业公司担任爬虫工程师，算是一个真正入门的coder，又一个全新的挑战。从上海转战武汉，回武汉也是我的一个想法—离家进了一小步，故人在，朋友常聚，情谊永存，工作之外，还需要倒腾一下生活，我是一个极度恋旧情的人，很难和新朋友结交为知己。很赞赏那句“人生得一知己足矣”，但是心里还是不乐意这么去想，我始终坚持人之初性本善的理念，只要敞开心扉，就能拥抱世界，拥抱未来。 面对一个真实的自己，细细回味着自己走过的路，顿时发现自己还是那么的倔强，尝试混迹于各种领域，生活却多了几分艰辛，坚决不留后路，至于生活到底过得如何，我还是靠着勇气战胜了自己，若能克服自卑的心理，或许我的各种尝试才会体现其应有的价值。浪费青春也罢，折腾生活也好，我无怨无悔，我会一如既往地带着人生最初的问题走下去。牛人，就是走到哪里都有可用武之地，都有金钱可挥霍，都有很多有意义的事情等着他去完成。我不是牛人，但我相信这样的人生理念，从一个小白做起，不怕丢失工作，唯恐没有勇气胜任工作。 by zhangbc2018-04-24","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【心路历程】做好自己，面对现实（六）","slug":"【心路历程】做好自己，面对现实（六）","date":"2019-04-22T14:39:55.000Z","updated":"2019-04-22T14:51:53.849Z","comments":true,"path":"2019/04/22/myself_07/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_07/","excerpt":"","text":"晃晃悠悠又是一年时，该到了总结与反思的时候了。想想当初的豪情壮志，如今却被时间磨平了，淡化了，可笑？可恨？可惜？可怜？这一年，不知道用什么言语表达，用什么词汇来描绘，单单是工作那么简单，抑或生活的平淡无奇，或许吧，生性贪婪而又好懒的我，真的不知道怎么总结这一年的得失？该是静下来好好思索思索的时候了，人无远虑，必有近忧。我始终认为人之所以与一般动物有别，就在于思维，靠着自己的思考实现自己应有的价值，思维的宽度决定了人的高度，思维的深度决定了人的价值。活着，本身就体现了一种非凡的价值。基于这个信念，我觉得有必要坦诚地面对现实，做好自己，别人的永远不会是自己的，但是世界是属于每个人的，不要忘却拼搏，终有一天会得到应有的回报。 这一年，从生活上得到的，工作中学到的，自己充电了解到的，都或多或少懂得了一些东西，少了一些面对未来的恐惧，多了一些生活的切身感悟，不再感怀生活，隐隐约约感到了一种无形的压力，迫使我继续前进，管他前面什么玩意儿，只要知道自己在干什么就足够了。规划赶不上变化，这不叫规划，凡是有成就的人，无不例外的实现了自己的既定目标，按着规划一步一步地去实践了，最后得以收获。所以，像我这样的小罗罗，注定成就不了所谓的事业，至少目前的这种态度，因为现实生活告诉我，成功容不得半点借口，今天计划的事情拖到明天，请问时间会倒流吗？对照一下13年的计划（参见13年终总结《2013与2014之流水》），顿时感慨良多。 1，补2013的读书空白。 这个做了一些，但还是严重不足，零零散散涉足了七八本（PDF，包括在读的），接触了Python，MySQL，学习不够深入。 2，每天坚持听一下VOA，抽点时间学习一下英语；(这一点做得非常差，逢考必败的根源所在) 这个做的稀烂，死活坚持不下来，不是没有用，订阅的SQLServerCentral没有研读过，稍微看过几篇，东西确实不错，老外就是老外，干货多多。IT不学真不行，永远了解不了最新的东西，最实在的东西。 3， 计划一次旅行。 玩嘛，我想这个毫无疑问实现了，时间虽短，但也算是达到了预期的效果，开开眼界，找找年轻疯狂的感觉，我想应该知足了，有游记见证，但是还欠一篇拙作，关于看电影引发的个人思考。 4，深入SQL学习，做一个SQL学习系列，这也是14年部门分下的培训任务。 这个系列没有做，多多少少学了一些，缺乏系统性，至于什么原因，我不想辩解，多说无益。部门人员异动，所谓的培训任务也就不了了之。 5，独立开发一到两个有价值的系统。 初生牛犊不怕邪，尽管雄心勃勃的做了个小系统（博客为证），由于种种原因，还是没有最终使用。这也没干好，那也没有做成，我究竟干了些什么呢？ 1，同事四月辞职，当时对业务系统还是没有多少头绪，交接的时候很多事情还是模棱两可，两个人的事情突然让我一个新手来做，顿时感到惶惶不可终日，不能怠慢了各路”神仙“，否则吃不了兜着走。 经过一个月的挣扎，算是基本搞定，平稳过渡，工作从开始的畏手畏脚到现在有的放矢。这或许就是所谓的成长吧，要想彻底的深入掌握ERP，我想还远远不够格，技术需要的不多，其实真正高大上的东西未必能普及到企业中去，ERP关键在于对业务的梳理，流程的理解，随业务的变化而变化，认识—&gt;理解—&gt;掌握—&gt;优化，看起来极其容易，做起来却百般不易。在维护的过程中，我逐渐明白一个道理，呆呆地坐在电脑前是开发不了用户满意的软件的，只有现场勘查，调研，充分理解用户实在的需求，站在用户的角度去探究解决问题的模型，我想即使做不到优秀，至少可以让用户用得满意，用得舒心。切忌，空对空的进行需求交流，分析，这是达不到效果的，最终的结果只会陷入bug—&gt;modify—&gt;bug—&gt;modify的泥潭。 2，生活，其实这没什么好说的，平淡无奇，掀不起半点涟漪。中秋，看了下同学，顺道和亲人过个团圆节，国庆，游了下西湖，走访了一位对我非常有影响力的叔叔，可以这么说，从小学到初中，我从他身上学到了不少东西，跟我讲作业，陪我玩象棋，与我谈未来，每逢寒暑假，只要他在家，我几乎是没有离开过他，对我的生活起着潜移默化的作用。 有这样一位指引者，我是多么的幸运啊！成年了，我们再也不是小孩子了，正因为如此，我们开始忙碌起来，忘记与亲人联系，忘记与朋友聊天，老婆老公，房子车子等一系列话题开始渐入我们的生活，心随之浮躁起来，开始了一些功利化的行为，从此联系似乎带了一种色彩，不再单纯了。疏于亲人，远于儿时最好的玩伴，只要不要同一个城市，作为朋友遗忘的概率极大，新建一个圈子，开始一种新的生活。或许我是一个比较喜欢恋旧的人的缘故吧，总感觉这样不太好，但是又不知如何是好？歌词唱得好：结交了新朋友，别忘了老朋友。感情，是个神奇的东西，它能牵动一个人的每根神经，或远或近，总有一种思念，偶尔总会情不自禁地拿起手中的电话拨拨最熟悉的号码，如果有一天不再联系，我无法想象我的生活有多么凄凉，不会聊谈了，嘴笨了，也许号码就不知不觉地没了，生活与感情，随缘吧。整个年度中，基本保证每周跟外公一次通话，跟父母一次通话，其他亲朋好友随机打，每个月电话费不低于100元，有些人常年未通电话，并非代表我们之间缘分已尽。 3，关于学习，这点确实做得很糟糕，博客数数几篇，寥寥几语，没有含金量，怎么能这样么？Python学习了基本语法，MySQL写点增删改查，多多接触，多多益善，这是个大忌。贪多必失， 用不到，学得多，忘得快，这个经典教训，一定要要牢记。多做笔记，做做分享，向大牛看齐，选一个切入点深入进去，真正学会融会贯通，做好知识储备，经历了一年的摸索，该是清醒的时候了。 4，关于经济目标，14年的规划是一年搞定助学贷款，今年实际完成是50%，弥补了去年的负债，再者向家里还了一笔债务，回家过年备点，基本上一年微薄的薪水就OK了， 存钱是没戏了，毕业三年内，我没有希望能存多少，但愿没有虚度光阴，实际还是虚度了一年。 2014年就这么过去了，总之是离目标有很大差距，主要原因是自己自制力不够，计划过于完美，难以实现。展望2015，希望有一个不一样的收获，所以，规划还是要有的。基于自己贪婪的性格，有必要重新审视一下，计划规划不能是一纸空文。走过的路，见过的人，做过的事，尽量留留痕迹，免得回头追问时间又去哪儿了？延续大四后期的坏习惯，看了大量的战争片，2015年再也不能这样了，否则真的玩完了。 谨记于此，以警示自己，误入歧途不能自拔，2015年应该没有什么大风浪，没有什么大动作，平平静静，充实365天，多多努力才是王道。 by zhangbc2014-12-30","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【心路历程】做好自己，面对现实（五）","slug":"【心路历程】做好自己，面对现实（五）","date":"2019-04-22T14:28:05.000Z","updated":"2019-04-22T14:35:43.822Z","comments":true,"path":"2019/04/22/myself_06/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_06/","excerpt":"","text":"上班已有几天了，可是思绪似乎还是停留在十一之行，也许是没有长大的表现，也许是该为这次的所见所闻记下点什么，一种发自内心的声音不停告诉自己，利用有限的时间，拿起一支拙劣的笔，为那个时刻，为已流失的光阴做一些补救脚印吧。此次杭州之行，收获还是蛮大的，且不说杭州风景，杭州美女，我只想说说杭州给我烙下的一个又一个印象。美丽杭州，说得一点也不过，或许在杭州，让我真真切切地感受到了中国梦的一步步逼近。当然，遇到的某些奇葩，我也就不提了，权且当他们小市民无知吧。 十一，我们花了一整天的时间，沿着西湖的河堤走了很长很长的一段路，西湖如西子，杭州佳人多，风景确实很美，感受在心灵，风景的描述及其感受，恕难从笔，我不擅长优美的散文故事。此篇所探讨的是国庆遇到的一系列的故事。早上，八点出发，坐7路公交，人多拥挤，这是每个城市的最大亮点。提到公交，我不得不感叹下武汉的公交，车猛，两车之间几乎可以保持零距离，人更猛，即使夹在门缝也不愿意下车，真正是做到了“敢为人先”的大无畏精神。相对于武汉，杭州公交略显宽松一点，我们在来回西湖的路上还能找个座位坐坐，恐怕这个待遇在武汉难得，至少我的印象很少，尤其在火车站赶坐公交，或者校门口坐公交，基本都是一路站到底。这或许就是城市生活，几许烦恼几多喜吧。这次出行，让我彻底感到无语的公交是在湖州长兴县城，一下子让我回到了高中时代的县城公交，破就不多说了，可恨的是25分钟一趟，沿途不报站，招手即停，更让你意想不到的是终点站还是高铁站。高铁都有了，还没钱改善一下公交么？从高铁站下来，遇上这样的公交，让我产生无限联想，县城企业无数，高大上的政府大楼（据说30亿建成），我还能说些什么呢？遇到这样的县城，只能是为该城百姓哀其不幸了。想想我们那个穷乡僻壤的小县城，这点还算是好的，年年在改善中，变化中……总体来说，杭州的公交还算不是太拥挤，或许我们赶上最疯狂的那一路吧，暂且留个好印象。 十一晚上，由于一切临时决定，算是做到了随心所欲，疯到了极点，到处招手打的，各路的士哥都把我们给拒绝了，原因是我们离我们所去之处比较近，不愿意送我们，还好心跟我们顺便指了一下方向。我们靠着导航瞎摸也不是个事儿，最后还是让两辆超破的摩的小坑了一把，以每人10元送我们去电影院，也在这里遇到了奇葩，姑且让我作个怪吧，建议出行尽量少做摩的，每个地方的摩的都不是省油的灯。十一点打的，由于是第一次，怕踩大坑，问了是打表还是一口价，说是打表，那没得说了，毕竟我们三个人都是第一次来这里，随便吧，反正我是抱着被坑的心态上车的，再说时候也不早了，离订房处还有一段相当的路程。为什么我是这种心态？说实在的，我对这些司机的故事早有耳闻，打表绕着走，一口价近道飞奔。四年前，在深圳，就这么深深地被坑了一次。上车和司机寒暄了几句，感觉司机人还算靠谱，下车20元，不算坑，毕竟快凌晨了，在某些地方，我想司机肯定会狠狠宰我们一次，毕竟一看我们就是外来主儿。相比摩的，我心里舒坦多了。接下来的三次的士都是这个价，路程不算太近，想到回家过年问起的士价格，真的感觉自己就是一个外乡人，被宰的主儿。从与司机的寒暄中，感受到了杭州人的生存压力，浙江富有，温州老板遍布神州大地，“5~6万的房价楼盘一天被抢空”，这话不管是不是含水分，含多少水分，但是能让我真正感受到杭州的生活成本不会太低，建筑极具特色。城市公共设施建设比较好，电影院随处可见，第一天费劲地找了两三家，第二天顺眼目睹了两三家。有住的就有吃的，有吃的就有乐的，有乐的就有游的，这或许就是杭州给我的一个印象吧。还有一点收获，是在钱塘江边上无意的收获，那就是漂流书屋，公共书屋，城市中能看到长廊边有这样的书亭设施，恐怕不多见，可以默默地感受一下杭州的城市文化建设。很多时候，谈及文化建设都感觉是知识分子的事情，老百姓能温饱就不错了。其实生活离不开文化，与人交流，感受生活，文化无处不在，与大师交流，心里豁然开明，与同龄人畅谈生，人生向往无限，与父辈交心，真真实实感受生活的酸甜苦辣，作为新一代的穷屌丝，文化不应该成为高大上的东西，我觉得有必要丰富一下自己的文化美餐，应该让文化实实在在地融入我们的日常生活，生活有向往，有期待，才有源源不断的奋斗的动力。但是杭州书亭美中不足的是，有书屋，书很陈旧，很少有人去翻阅，我随手翻看了一本书叫《麻雀》，屠格列夫著，这是当年小学四年级的一篇课文，讲述了一篇关于母爱的故事，印象非常深。记得当时读不懂，老师从教案中跟我们朗读课文中省去的那一部分时，我们更是一股脑的傻了。母爱，是一个伟大的话题，我很庆幸，我有一位勤恳和善仁慈，任劳任怨的母亲，只是感觉亏欠她太多太多……再次，翻开这篇课文，想到昨日的电影，心情顿时沉重了不少。 本次国庆之行，算是毕业后比较满意的一次旅行，杭州，长兴，两个不同的城市，两种不同的心境，收获却不是二的。浮浮躁躁的心，不知道又丢失了多少瞬间的灵感，不巧赶上工作的繁忙季，又不想丢失这些美好的记忆，所以还是记下来吧。写着写着，不曾想成了一篇回忆之作。 by zhangbc2014-10-09","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【心路历程】做好自己，面对现实（四）","slug":"【心路历程】做好自己，面对现实（四）","date":"2019-04-22T14:06:46.000Z","updated":"2019-04-22T14:36:41.331Z","comments":true,"path":"2019/04/22/myself_05/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_05/","excerpt":"","text":"水光潋滟晴方好，山色空蒙雨亦奇。欲把西湖比西子，浓妆淡抹总相宜。 ———-苏轼.《饮湖上初晴后雨》 一次疯狂的旅行，一次没有规划的旅行，一群不靠谱的靠谱的旅行， 除此之外，我实在是找不到什么适合的言语来表达这次国庆之行了。岁月总是在不经意的手指尖划过，用心去捕捉生活一瞬间的美，认认真真地感受其中的乐趣，我想这才是我所期盼的生活吧。写作的灵感也就来源于那一刹那之间，仔细回想学生时代，每当写作文的时候，真的就是这么一回事，其实生活亦如此，此次的国庆之行更是如此。 关于国庆之行的最初构想，是由大学班长何伟同志提出的，我只是从旁提提意见，准备十一回武汉聚聚，然后找个景点游哉悠哉。毕业一年了，大家是该聚聚的时候了，说长不长的一年，相信大家经历了很多，也收获了很多，相互叨叨，未必没人不期待吧。为此还特地，班长建了一个群，叫“十一去哪儿”，刚开始那会，激情四起，我心中甚喜，提前了一个月跟部门老大说十一想请假（要知道节前假后请个假有多么困难）。临近九月中旬，再次确定人数的时候，发现就不是原来那么回事了，各有各的忙，离别时难聚更难，相聚是多么不容易啊！没有闲人，既然如此，不必强求，也无须介怀，匆匆之间的生活，理解万岁。说实在话，我的内心依然不甘，计划的十一出行难道真的就要被不能班聚而葬送吗？思来想去，还是不甘心，十一不出行又能干嘛呢？他们都忙， 我闲人一个，那就一个人漂泊了，避远就近，人在苏州，苏杭苏杭，那就杭州了。所以一个人就默默地买好票了。原本不想打扰别人已有的安排，这实在不是我的风格，不强求于人，一切随心所愿的好。可我还是没有忍住，问了下何伟，令我意想不到的是他已经买好回家票了，三言两语，他也改签了去往杭州的高铁票，谁叫我们是好哥们呢？算是坑，也愿跳。9月13日，杭州的票就这么定了，最坏的打算是两个爷们独闯杭州，不为别的，只为西湖。期间，我们也各自咨询了很多亲们，问有没有意向去？回复都是模棱两可的，一句话，不靠谱。不靠谱就不靠谱吧，希望与现实总是存在差距的，那就算一次不靠谱的旅行吧。但是我依然没有放弃寻求伙伴的机会，直到9月27日，一条好友的说说振奋了我，平时少聊天，这次竟然答应得如此爽快，让我惊喜让我意外，此次旅行总算不是纯爷们的队伍了，振奋人心啊！杭州附近的城市，费费劲还是搞到了30日的火车票，算是尘埃落定了。 30日下午，三人分别从不同的三个城市（无锡，杭州，马鞍山）出发，经历火车时间也差不多（5H），就这么开始这次疯子旅行。说是一群疯子，其实也不过，列几个事实，疯不疯，看着说吧： 一，30日晚上相聚约九点，找个餐馆就餐，边吃边聊，彼此熟悉熟悉，然后开始找房子。都说人多不好找，我们也确实找了一阵子，十点多找到了。 二，第二天八点出发，临时看公交，上车，游西湖，随身没有一张地图，只是问了一下团价，觉得太贵，没报，索性两腿跑西湖，一天下来，跑的地点有：三潭印月，博物馆，雷峰塔（人多，没有买门票），钱王祠，苏堤（2.8公里，没走完），花巷观鱼，曲院风荷。小有遗憾，六点多出大门未见音乐喷泉。西湖之景，美不胜收，知足就行，开心便罢。开始寻找吃饭的地方，疯疯癫癫地走了不少路，耗时不少，总算找到一家快餐自助餐厅了。 三，原想着，吃罢饭，该找住的地方，十一游客特多，房子有限，没想到*来了一句，我们去看电影吧。快八点了，我们连电影院都不知道在哪儿，两部手机开始疯狂地搜索，好不容易找到号称浙江省最大的电影院——胜利剧院，话说今天没票了。不达目的决不罢休。又一次次探索，功夫不有心人，错过了《黄金时代》，迎来了《亲爱的》，九点25分准时上演了。 四，看完电影，十一点二十分了。我们还能找到住宿吗？我们真的要睡大街吗？我们真的要夜行杭州城吗？真的，这点着实让人担心，又是两部手机的开始漫无目标地搜寻，电话咨询，我的电话下午就关机了，电源准备不足（出行的亲们，引以为戒）。时至凌晨，我们找到价格不高不低的房子，说实在的，个人感觉杭州的租房价格有点奇葩，单间竟然和标准间一个价，或许我孤陋寡闻了吧。 五，第二天一觉睡到八九点，去了钱塘江，真不是时候，空荡荡的。然后，我们又开始找吃的，不能白来杭州，游的（西湖），乐的（亲爱的），就剩吃喝了。 找了一家比较远的自助餐人均价69元/人，对于我们这几个穷屌丝而言还是可以接受的。下午五点陆续离开杭州，杭州，我们不虚此行。 一篇流水记，即将尾声。写的总是没有亲身经历的来得实在，来得刺激，来得更有价值。许多事情看起来就那么回事，实际上做起来还真不是那么回事，其中的付出，艰辛与快乐并存，恐怕只有当事人才能真真切切地感受了。用朋友的一句话，那就是——一切尽在不言之中。十一行，算是圆满了，完成了我2014年的旅游计划，聚聚聊聊的目的也算达到了，在此特别感谢二位至亲的鼎力相助，我们共同实现了”西湖梦”。这一次疯子旅行，不靠谱的旅行，给我的收获远不止这些，疯疯狂狂的旅行，简简单单的生活，实实在在的人生，何忧之有？ 最后，来一张具有纪念意义而且大家都见过的小照，以此证明我们的西湖之行： by zhangbc2014-10-06","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【心路历程】做好自己，面对现实（三）","slug":"【心路历程】做好自己，面对现实（三）","date":"2019-04-22T14:02:55.000Z","updated":"2019-04-22T14:06:07.377Z","comments":true,"path":"2019/04/22/myself_04/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_04/","excerpt":"","text":"”露从今夜白，月是故乡明。“ 不知道多少个中秋没有和家人在一起过了，大概是童年的记忆了，也渐渐淡忘了这个团圆佳节，不过，或者一个人默默地过。每到中秋，端午，七夕这样的传统佳节，我都会不停地在打电话，或许只有这样才能弥补我思念的空缺，这也许就是我的生活，注定在寂寞中努力寻找属于自己的一丝丝慰藉，成为我平凡人生中一段看似不平凡的征程罢了。 毕业一年有余，每天除了工作之外几乎没有什么业余生活，偶尔心中不免有些内疚，生活为什么不能洒脱一些，主动一些，在物欲横流的今天，难道没有钱真的就得被逼上绝路吗？或许性格原因，或许五体不勤的缘故，我总是找不出一条合适的理由说服自己，活个范儿，管别人爱说咋说呢！ 在学校感受不到假期有多长，有多宝贵，所以大多数时间都是无为地被挥霍了，上班了，才渐渐明白，假期是多么地来之不易，春节从一个月或者更长一下子缩短到一周，尤其对一个回乡途中要耗上两天的漂泊浪子来说，其中的感受无以言表。又是一年中秋时，公司放假三天，所以我想不能再挥霍了，临时决定出去走走，向来没有长远计划，说干就干的劲儿还是有的，也许是上天可怜无规划之人吧，每次都能成事。去年十一回校探友也是9月28、29日临时买的票，一次简单的旅行，还是达到了预期的目的。要走的想法有了，可是接下来还是得仔细考虑考虑，去哪儿和谁做什么等等。仅仅一个想法还是不行的，周全规划一下，方使行动成功，所以一个想法只能算是一个成功的萌芽，并不是开始。三天，不可能走得太远，苏州附近的亲朋好友屈指可数，所以很快锁定了目标，探望一下朋友，随便找个地方玩玩，想法简简单单，仅此而已，人生亦应如此。 中秋三日假，总的来说，还是蛮愉快的。逛了一个景点——昆山周庄，看到古朴的建筑，虽然人少，缺少点氛围，但是总体印象还是不错的，七点回到朋友的住处，临时买菜做饭，两个人的饭菜不一会儿就上桌了，吃着香喷喷的饭菜，仿佛找到了一种久违的感觉。生活就应该这样的，自己动手，丰衣足食，不久的将来有一个新家，开始这样的生活，想想就是一种无比的期待。人的一生终究图个什么，我不知道，但是我应该很清楚地意识到，把握每一个稍纵即逝的幸福时刻，等到踏上黄泉路那一天能够微笑地离开，这或许就是我所理解的人生吧。买菜做饭，虽是一件普通的不能在普通的事，但在这个特殊的时刻，让我陷入了一次思考：生活不就是柴米油盐酱醋吗？为什么很多时候我们无法看清楚它的真面目，不会过日子呢？算一个小账，一顿饭，外面买一顿至少得15元吧，（炒饭另外）两顿就是30元，都说菜价米价上涨，其实去市场走一遭，30元买两顿的饭菜那是绰绰有余的，份量绝对够足，不像外面炒个肉丝，只见青椒不见肉块，其次如果手艺好点，味道也不差，吃着自己做的，心里本来就是美滋滋的。精打细算，学会过日子，否则就是有金山银山也是经不起折腾的。现在生活富裕了，我们的节约意识的确淡薄了不少，想不到这些生活的琐碎，每天只会不停地想，我的工资什么时候涨？或是我的工资都去哪儿了？想起读书那会，尤其是大一的时候，自己拿着一个小本子记录着自己的每一笔开销，小到一个笔记本，牙刷的钱，隔了一个月回头看看清晰的账目，多半会是露出满意的笑脸，俗语说得好，“用钱要用在刀口子”。并不是说要无限制地节约节省，记下来是为了让自己知道钱都花到哪儿去了，不至于花钱花得稀里糊涂，道不出所以然来。一直以来，我好像真没有吝啬过花钱，但是我比较清楚自己的钱都去哪儿了，管理自己的账目应该还算清楚吧。 完了一天，吃罢饭，九点有余，临时找住处，一切还算顺利，第二天一觉睡到十点半，天热没有安排出行，又做了一顿美食。中午就从朋友住处离开了，转战下一个目标。又是一个临时电话搞定一个新行程——去看看舅舅表哥一家人，打工在外，实属不易。从昆山转战苏北，车多行程非常顺利，虽然天气很热，但还是挡不住我心中的热火，想着第二天就是中秋佳节，应该去走走。去年就想着要去看看他们的，一直不想走动，所以未能如心所愿。和一大家子亲人过个中秋，也算是团圆了，看到舅舅舅母脸上的笑容，夹着额头一丝丝皱纹，顿感心中某种不快，上一辈为我们操劳得太多了，而我们呢？偶尔连他们一个小小的心愿都未能满足，这或许所谓的生活之苦吧，再一次让我深深体会带到：经济基础决定上层建筑，有什么样的工作就有什么样的生活。生活充满了太多的无奈，每一个人的境遇所有不同，但是生活的使命却是一致的，照顾上辈，操劳下辈。中华名族的传统美德，牵扯了太多太多的故事……今年的中秋，才让我知道了中秋的滋味，都说好散好聚，我不得不说散得容易，聚之不易。一个牵动无数家庭心的中秋，总是几多欢笑几多愁，看到的是笑脸，诉不出的却是悲愁，你又何谈一个“佳”字？中秋佳节倍思亲，十五的月亮十六圆，希望终有一天，我心中的月亮也能圆，生活虽不易，但是脚下的路还得继续，一条漫漫无尽头的路，路上有亲朋好友的陪伴，不曾寂寞，不曾落单，希望能加快步伐，不负青春，带着微笑向前去。中秋，往常一个人过，电话多多，今年也不另外，但和亲人相聚，私有时间自然有所减少，未能尽可能多的问候，或许这样的日子以后还会越来越多，各位至亲，理解万岁，不曾问候，思念依旧，没有前世的缘分，哪有现在的你们，又怎么会有今生我的福分？ 中秋过去已久，很久没有提笔，不知所云，以纪念今年不一样的中秋，以上次说说作结，算是给自己一个交代，“莫等闲，白了少年头，空悲切。”生活与责任，人生与使命，记住生活的美，才有源源不断的动力！ 记住以下五点，也不枉过一个美好的中秋：一，旅行是人生的必修课，规划很重要，随机应变往往决定了一件事能成与否;二，可口的饭菜是自己做的，靠山靠水不靠天，学会过日子，生活无处不精彩；三，经济基础决定上层建筑，有什么样的工作就有什么样的生活；四，身在他乡，和亲人过一个节，这才是家的感觉。五，节日的问候，时光渐变，我有可能慢慢疏忽这一点，各位至亲见谅。 by zhangbc2014-09-15","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【心路历程】做好自己，面对现实（二）","slug":"【心路历程】做好自己，面对现实（二）","date":"2019-04-22T13:54:02.000Z","updated":"2019-04-22T13:58:58.303Z","comments":true,"path":"2019/04/22/myself_03/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_03/","excerpt":"","text":"大学以来几乎没有碰过什么文学著作，心里想法太多，不能成为现实，这或许就是痴人说梦吧。梦，哦，对了，这是2013年整年最火的一个词儿，习总书记登台，让国人看到了希望，看到了一个中国梦，随着个人梦，青春梦，民族梦……应运而生。我也经常在追问自己：自己到底有没有一个梦，有没有一个明确的方向，该往何处去？ 记得刚毕业那会，找工作犹豫过，想做开发，能力明显不足，懂点语言的皮毛，偶尔也会在朋友们中间调侃几句；有人建议做实施，深入实践，懂得用户真正需要的东西，然后转做开发，由于种种原因，未能实现，后来转战到今天的这家不大的公司做运维（并非真正意义上的运维，算是简单的技术支持吧），很幸运，得到了同学的帮助，领导的赏识，慢慢成熟起来。叔叔曾问我：在公司感觉怎么样？我跟他详聊了一些情况，他说，还是要多学习，对一个行业的前景估量很重要，如果不是自己想要的，就得早作打算。很清楚地记得，他跟我说起过他一个关于对行业的前景估量的故事，坚持自己的正确选择，坚定不移的走下去。不知道为什么，时至今日，我都无法看到一个清晰的方向，IT，一个令人向往而又难以令人琢磨的东西，让人几分陶醉，也让人几分忧伤，陶醉的是自己可以在其中发现自己的兴趣，为她彻夜狂欢也不是不可能，新技术层层不穷，激发我们的求知欲，可以借以免去我们的生活烦忧；忧伤的是担心自己看不清方向，一股头脑热，摘了芝麻丢了西瓜，学不到真正的东西。技术是有助于人的，偶尔也会害了人。看到很多人对IT丧失了信心，开发的转测试，测试的转销售，IT的技术更新，IT人的不断更替，真的让我很难预料以后的道路如何？ 在这个部门，不到一年的时间里，我目睹了几拨人马，匆匆而来又匆匆而去，说句实话，心里不知道什么滋味，或许这就是IT界的一个缩影吧。跳槽，年轻人的专利，也是年轻的资本，出来拼的，图的不是稳定，而是快乐与生活的充实。如果我想图一份安逸的生活，我去年毕业就有可能呆在乡镇医院信息科，而且专业也对口，但是我没有，我不想这样的生活，至少不是我前半生想要的生活，给得了我安逸，却给不了我心灵的满足。根据自身的处境，身上的责任，我现在还不敢轻言跳槽，或许我资本不够，来之前，我就想过，我是来学习的，学不到东西，积累不到资本，我去何处都一样。记得有一次和朋友讨论过这个话题，跳槽，跳来跳去，手上没有筹码，在哪儿都一样。我认真思考过，我还是一个新手，什么都不会的新手，加强学习是我的第一要务。再说了，毕业前三年，我有两件事情要做：一，还贷，二，为未完成的梦做最后一搏。没有特殊情况，我是不会轻易的去改变的，即使我愿意付出更多的时间，我会为自己的想法付出行动，无论多么高的代价。这个五月应该是对我有着特殊意义的，感谢猴哥，让我搞掉了第一笔，作为低薪一族，我不觉得钱对我有多么重要，我对它从来不报任何希望，只要生活是自己想要的，没钱日子照样过。现在的生活虽不是很好，但足以让初生牛犊的我好好磨练磨练，值得熬一熬，抹掉我最初的梦想，也许会唤醒我另一个梦。 在中国梦大浪潮之下，追寻一个真实的自己，需要克服种种阻扰，来自心里的，来自家庭的，来自社会的，如果在乎多了，也就茫然了，不应该不尊重自己心中的想法，一个人如果没有强烈的金钱欲望，我想总会有平静的时刻。静心想想，我是否追随了中国梦而滋生了自己的个人梦，是否付出了行动？做一个会思考的人，在探索中前进，我想终有一天会过上属于自己想要的生活。 by zhangbc2014-05-17","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【心路历程】贫困，不能阻碍你的梦","slug":"【心路历程】贫困，不能阻碍你的梦","date":"2019-04-22T13:36:27.000Z","updated":"2019-04-22T13:58:38.745Z","comments":true,"path":"2019/04/22/myself_02/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_02/","excerpt":"","text":"在考研期间，遇到了几个比我低一届的同学存在的困惑，本想尽早写下这篇日志作为答复，由于考研，所以一直耽搁到了现在，现在想结合自己一路走过来的经历谈谈我个人的一些想法，由于涉及家庭因素，所以只能特殊处理。如果是本人看到的，请原谅我的直述，希望不要介怀。 一个土生土长的农村娃子，经历了太多太多的遭遇，时常会为没钱的日子发愁，是的，我不可否认，农村送出一个大学生的确不容易，本来经济来源相当有限，吃了这顿还得打算下顿。 清苦，节俭，朴素等这些耳熟能详的词语似乎一个一个不但扎根于我们的脑海中，而且我们也是这么走过来的。看看家庭经济比较宽裕的同伴的生活，我们曾经羡慕过，嫉妒过，也抱怨过上天的不公正待遇……因为贫困，眼见了一个个伙伴辍学，很早就迈入了残酷的现实的社会大门；因为贫困，无数父母背井离乡，过着听人使唤的卖苦力的生活，作为子女，当然不希望父母这样，于是一些“懂事”的孩子于心不忍，即使认为自己有能力的也过早地放弃了读书梦。在一次交流中，一位学弟告诉我，他想考研，但又不想读研，顾虑重重，我问其原因。他说主要是家里供不起。还有一位学弟告诉我，他为考研与否一直在纠结，因为家中有个弟弟在读书，家庭超负。这两位哥们其实面对的是同一个经济问题，在经济问题后面应该还有一个更重要的思想问题。烦不烦，很多时候不是取决问题的本身，而是看一个人会不会去思索，能不能去积极主动地面对现实，一味地抱怨只会让你更烦更纠结。 想考研，是为以后生活得更好，这无可厚非，大学生嘛，想实现自己的人生价值，有点野心未必不是好事；想考研，是为赚大钱，拿高薪，这是一种普众心理行为，在现行的社会制度下，晋级，职称无不与学历挂钩，每个人的职业生活压力都很大，也是完全可以理解的；想考研，是想做一项研究，追随自己的兴趣与爱好，立志于科研事业，这应该是考研的最高境界。单单是为赚钱而考研，我不太赞同，一，很多高薪职位并非需要很高的学历；二，考研应该是一笔物力，财力的巨大投资，是一笔青春代价的付出，而且这种投资与付出未必会收到你所期待的结果。如果你把考研的目的这个首要而且又具有决定性的问题想清楚了，那么对你后期的复习会有更大促进作用。考研，应该说一笔风险投资。你想以后要干什么？报什么专业？考什么档次的学校？这三个问题非常重要，关系着你的复习成效。报考的学校档次应该与投资的风险系数是呈正相关的。现在的研究生经费虽然非常高，但是各种补助也是相当丰厚的。关于经费，我想说的是，这不是重点，只要你足够优秀，上帝会偏袒你的，关键是你努力如何，有几分胜算？现在国家教育投资年年在增加，投资范围逐步扩大，你就认定自己有那么差吗？绿色通道，助学贷款，各种社会资助，就在你身边，就看你主不主动。想到四年的我，曾经也为此发愁过，选学校选专业时，优先挑选较便宜的。就在我感到无助的时候，一个从天而降的好消息来了，我们县城第一次提供生源地助学贷款，这对一个需要帮助的家庭来说，不能不说是雪中送炭啊！来到县教委办理手续时，又得到了一笔助学金，而后在大学里，在同学们的帮助与信任之下，得到了四年的高额助学金。四年的大学，你都走过来了，你还怕什么？又担心什么？你是贫困生，应该享受到了一定的资助，平时省吃节用一点点，有什么困难不能克服呢？ 0 贫困，不能阻碍我们的梦。鲤鱼跳龙门，农村出来的人都应该铭记这句话，这应该是我们读书初衷吧。如果我们不去尝试，怎么可能走出山旮旯？大山窝虽美，虽山清水秀，仁和心善，可是在经济与信息技术高速发展的今天，我们的经济从哪里来？难道还要死守农村自家的一亩三分地过日子吗？为了理想的生活，我们只有一条出路，那就是排除杂念，能走多久走多远，走得越远越好。起点高，不但可以改变生活，创造机会，更重要的是可以实现自己的人生价值。我们从农村走来，应该克服农村人比较狭隘的眼光，但不能说是轻视农民，不是他们无能，而是条件受限，应该用发展的、智慧的眼光正视我们的处境，没有优越感那就得靠自己的十二分努力去打拼、去创造，为不辜负乡亲们对我们的殷殷期望，必须拼。吃点苦算什么，我们又不是没有干过农活，比起插秧收割等田地间的耕作，我们要说有多幸福就有多幸福，不是吗？ 贫困，不是我们的错，不能阻碍我们的梦。贫困，这是个可以改变的事实，真心希望有经济困惑的后生们，不要顾虑太多，用你们的青春做资本去追梦吧！ by zhangbc2013-01-08","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【心路历程】面对现实，做好自己（一）","slug":"【心路历程】面对现实，做好自己（一）","date":"2019-04-22T13:23:38.000Z","updated":"2019-04-22T13:33:08.677Z","comments":true,"path":"2019/04/22/myself_01/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/myself_01/","excerpt":"","text":"毕业这么长时间，没有写下一则像样的日记，没有关注VOA的动态，没有规划学习，每天除了工作，简单不断重复的工作，余下的时间在双手之间悄悄溜走，从不觉得心痛，从不觉得自己有多么厚颜，感觉自己被某一种可怕的东西不断迁就着，不回头，也不想回头，偶尔还有一种可恶的念头：人活着，怎么活都是一辈子，干嘛非得拼命似的生活？勤一生，堕一生，两者之间无非就是别人的闲言碎语而已。当一个像我这样拥有此种邪恶念头的人，大概真的忘记了什么是厚颜无耻了？是的，人活着，这一生究竟为了什么，这是一个大话题，不是凭头论足就能下结论的，需要亲身实践，正所谓“纸上得来终觉浅，绝知此事要躬行”嘛。一介草民，无能把此话题说破抑或道明，但是真的有时候得想想，否则只会让自己越陷越深，越走越迷茫。 2013年7月踏出生活四年的大学校门，这次有着非凡的意义。母校，一个平时看不起眼的名称，在那一段时间，一些特定的场合，却总是让我的心在隐隐作痛。小学，初中，高中，大学，经历了这么多次，此次感受最深。这次，离开了母校或许就永远没有下一个母校了，离开虽不是生死离别，但却摆脱不了一种欲言又止的忧伤，轻轻而来，却又悄悄而去，何况还要拜别恩师，道别老乡，送别同窗，这一别就再也找到重逢的那一天了。我的确不知道重逢的那一天去哪儿了？ 这一次走出校门，意味着开始肩负起一份独立的使命，独立生活，独立经济，独立承担责任，来自家庭，事业，还有不远的未来。不远的未来，追逐爱情，抚育下一代，赡养父母……这不是归宿，仅仅是预设的开始，不是来与不来的问题，而是一个时间问题，为了这份使命，你准备了些什么呢？面对毕业，面对当下，我有点开始hold不住了，2013年毕业生699万，毕业不是就业，所以为了生计，解决就业难题才是关键，就业不成，何谈使命，连最起码的经济独立都做不到，还有什么资格空谈人生？一日三顿饱，这是最起码的生活保障。说实在的，当时有很多人为我的就业问题着急了，包括我的父母，我的亲属，我的朋友，我的恩师，社会很现实，将才干才多了去，不缺一个有生理缺陷的残疾人，我最终还是以平常之心坦然面对，走过了，也就习惯了，没有遗憾，没有怨言，从多次面试的经历来看，还是自己的所学甚少，残疾的头衔影响不是很大，毕竟社会还是有一定良知的，相信社会是美好的，你的心才会豁然开朗起来。在此处，也奉劝一些即将就业的后生们，人这一生，自信最重要，实力须有社会实践检测，找准方向，不可人云亦云尔。 毕业后，虽有一些小波折，但是不算太大，最终还是在苏州落定尘埃，高薪谈不上，至少自保了，也算是实现了经济上的基本独立。“上有天堂，下有苏杭”，说实在的，对我一个宅男而言，没有什么特别的感触，苏州的气候的确宜居，其实我所在的是苏州的一个小小的角落，距离苏州城区还有一定的距离。 毕业工作之余，偶尔回头想想自己的最初打算，顿时觉得有些不可思议，几乎没有办法实现，毕业了，如前所述，来自家庭的压力随之剧增，各种想法铺天盖地卷来，真的，有时候觉得无力从心，但又不得不为。对自己失言了，只能姑且一次次原谅而不了了之。一年内搞定助学贷款不是梦，可是预备的考研梦不得不破之，俗话说得好：鱼与熊掌不可兼得。一个人，不能把美事都想尽了，有得必有失，尊重现实，这才是生存的法则。不过不排除大牛们，若觉这是谬言，就权当过眼烟云。 2013年过去了很久，却又历历在目，经历了一些比较特殊的事情，真正从梦中把我拉回了现实，脚踏实地才是王道。毕业就业，工作是什么？我始终认为工作不应该成为一种累赘，即使一种累赘，无法改变之时，我们不妨换一种态度去坦然面对之。把痛苦变成一种乐趣，聊以自慰也未尝不可。工作的心态直接影响你的生活态度，与其对着宝马哭，还不如对着自行车笑。宝马显示了你的富有与尊贵，但是他也让你失去了锻炼身体的机会，脚踏车虽卑微，但偶尔也足可以让你感受兜风的乐趣。家中建设，让我开始感受做为家庭的一员，应尽家庭之义务，即使你未婚，谁说未婚的你就可以对家事不闻不问？压力再大，该承担的不该承担都应倾其所能地去承担，再说了，一家之事，何来你不担当之理？亲人的离世，或许你会说这有什么可说的，是的，生死离别，人之常事嘛。可是，这一次很不同，我的表弟，英年早逝，白发人送黑发人，你见得多吗？我是第二次经历，第一次发生2006年的夏天，不足周岁的亲妹妹的离世，那年，我没法忘记，估计是忘不了的，什么是残酷，这就是残酷，不是天意，而是现实。去年，接到舅舅的电话，听到噩耗的瞬间，我愕然了。不敢相信但又不得不相信 ，人死不能复生，这一既定的事实，就是所谓的上帝（本人不信佛，勿怪）也难以挽回，而且根本无法挽回。一个23岁的小伙子，说没就没了，怎么敢叫人轻言相信？23岁，我们都在干什么啊？在读书，正值青春，正当规划人生并为之奋斗的黄金时刻，说在此处，我不得不为每年高校的命案感到震惊。懂得珍惜生命，或许是活着的我们对已逝的人的最好的敬意吧。逝者已矣，活着美好，且行且珍惜。 以此作文，深知不是写作的料，警示自己误入歧途，越陷越深。 by zhangbc2014-04-15","categories":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/categories/mental-journey/"}],"tags":[{"name":"心路历程","slug":"mental-journey","permalink":"https://zhangbc.github.io/tags/mental-journey/"}]},{"title":"【数据库实践】T-SQL语言及其存储过程","slug":"【数据库实践】T-SQL语言及其存储过程","date":"2019-04-22T00:35:17.000Z","updated":"2019-04-22T11:37:46.818Z","comments":true,"path":"2019/04/22/db_tsql_procedure/","link":"","permalink":"https://zhangbc.github.io/2019/04/22/db_tsql_procedure/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 课本第11～13章主要知识点 一，T-SQL语言T-SQL语言是Microsoft公司在关系型数据库管理系统SQL Server中的SQL-3标准的实现，是Microsoft公司对结构化查询语言(SQL)的扩展。T-SQL语言是一种交互式的语言，具有功能强大，容易理解和掌握等特点。 1，数据定义语言(DDL)：DDL是指用于定义和管理数据库及数据库中各种对象的语句，包括create，alter，drop等。 创建表的语句格式为 1create table 表名 增加列的语句格式为 1alter table 表名 add 列名 列的描述 删除列的语句格式为 1alter table 表名 drop column 列名 修改列定义为 1alter table 表名 alter column 列名 列的描述 删除表的语句格式为 1drop table 表名 2，数据操纵语言(DML)：DML是指用于查询，添加，修改和删除数据库中数据的语句，包括select，insert，update，delete等。 3，数据控制语言(DCL)：DCL是指用于设置或更改数据库用户或者角色权限的语句，包括grant，revoke，deny等。 12345678910111213-- 给所有用户授予select权限grant select on student to publicgo ​-- 给指定用户授予特定权限grant insert,update,delete on student to LiMing,ZhangBingo​-- 联级授权grant select,update on student to user with [admin] option;revoke create table from ZhangWei;revoke select on sc from User;deny select, insert,update,delete on student to LiMing,ZhangBin; 4，其他语言元素(ALE) 1）注释：程序代码中不执行的文本字符串（也称注解），有：--和/* */。 2）变量(@)：局部变量（@），全局变量（@@）。 12345use stuSystemgo​declare @row int set @row=(select count(1) from student) 3）运算符 算术运算符：+，-，*，/，%； 赋值运算符：=； 位运算符：&amp;，|，^； 比较运算符：也称关系运算符，用于比较两个表达式的大小或者是否相同，其比较结果是布尔值TRUE，FALSE，UNKNOWN； 逻辑运算符：and，or，not。优先级别：not &gt; and &gt; or； 字符串串联运算符：允许通过加号(+)进行字符串串联，这个加号称为字符串串联运算符。 4）函数 在T-SQL语言中，函数用于执行一些特殊的运算以支持SQL Server的标准命令。 行集函数：在T-SQL语句中当成表引用。 1select * from openquery(local, 'select * from student;') ta; 聚合函数：用于对一组值进行计算并返回一个单一的值。除count之外，聚合函数忽略空值。 1select avg(score) as avg_score,sum(score) as total_score from sc; Ranking函数：为查询结果数据集分区中的每行返回一个序列值。有：rank，dense_rank，ntile，row_number。 标量函数：用于对传递给它的一个或多个参数值进行处理和计算，并返回一个单一的值。 标量函数 说明 配置函数 返回当前的配置信息 游标函数 返回有关游标的信息 日期和时间函数 对日期和时间输入值进行处理 数学函数 对作为函数参数提供的输入值执行计算 元数据函数 返回有关数据库和数据库对象的信息 安全函数 返回有关用户和角色的信息 字符串函数 对字符串(char或者varchar)输入值执行操作 系统函数 执行操作并返回有关SQL Server中的值、对象和设置的信息 系统统计函数 返回系统的统计信息 文本和图像函数 对文本或者图像输入值或者列执行操作，返回有关这些值的信息 5）流程控制语句 if-else语句 123456use stuSystemselect avg(score) from sc;if (select avg(score) from sc) &lt; 60print '很抱歉，你没有通过考试！'elseprint '祝贺你，考试通过了！' begin-end语句：能够将多个T-SQL语句组合成一个语句块，并将它们视为一个单元处理。 go语句：批的结束语句。批是一起提交并作为一个组执行的若干T-SQL语句。 123456use stuSystemgodeclare @msg varchar(50)set @msg='Hello world!'go case语句 123456789101112use stuSystemgo​select 'score' = case when score is null then '没有成绩' when score &lt; 60 then '不及格' when score &lt; 85 and score &gt;= 60 then '良好' else '优秀' end, cast(sno as varchar(20)) as sno from sc where cno = 'C03' order by score; while-continue-break语句 goto语句 123goto label...label: waitfor语句 1waitfor [delay 'time'|time 'time'] return语句 二，存储过程1，存储过程定义：几乎包含了所有的T-SQL语句，是为了完成特定功能而汇集在一起的一组SQL程序语句，经编译后存储在数据库中。 2，存储过程的调用方法 12exec proc 存储过程名exec proc 存储过程名 参数值[,参数值...] 3，存储过程分类 i）系统存储过程（前缀为SP_）；ii）扩展存储过程（前缀为XP_）；iii）用户自定义存储过程。 4，存储过程的创建和执行 创建存储过程 1234567create procedure dbo.pro_sc_insert@sno char(10),@cno char(2),@score realasbegin insert into sc(sno, cno, score) values(@sno, @cno, @score)end​ 执行存储过程 1exec pro_sc_insert '2010009', 'C1', 88 5，存储过程中的游标 1）游标的定义：可以把游标看成一种数据类型，用于遍历结果集，相当于指针，或是数组中的下标，分为局部游标(local)和全局游标(global)。 2）游标的使用方法 创建游标 123456-- 默认为global；-- forward_only(默认值)：游标只能前进的，只能从头到尾提取记录；-- scoll：可以在行间来回跳转。declare 游标名 cursor [local|global] [forward_only|scoll]for select 查询语句 使用游标：增加了服务器的负担，使用游标的效果远没有使用默认结果集的效率高，因此，能不用游标尽量不要用。 12345678910111213declare cur_select_name cursor for select sname from student;​declare @name varchar(20)open cur_select_namefetch next from cur_select_name into @name-- fetch_status取值：0正常执行；-1超出了结果集；-2所指向的行已不存在。 while(@@fetch_status = 0) begin print '姓名：' + @name fetch next from cur_select_name into @name endclose cur_select_namedeallocate cur_select_name 6，自动执行的存储过程 12use masterexec sp_procoption '存储过程名', 'startup', 'on' 7，存储过程的查看，修改和删除 1）查看存储过程 12345678910111213-- 显示存储过程的参数及其数据类型sp_help[[@name=]name]​-- 显示存储过程的源代码sp_helptext[[@objname=]name]​-- 显示和存储过程相关的数据库对象sp_depends[@objname=]'object'​-- 返回当前数据库中的存储过程列表sp_stored_procedures[[@sp_name=]'name'] [,[@sp_owner=]'owner'] [,[@sp_qualifier=]'sp_qualifier'] 2）修改存储过程 12345alter procedure stu_infowith encryptionas select sno, age from student order by age desc;go 3）删除存储过程 1drop procedure &#123;procedure&#125;[, ...n] 8，扩展存储过程：SQL Server 动态装载并执行的动态链接库（DDL），只能添加到master数据库中。 三，触发器及其应用1，触发器的概念和工作原理 1）触发器的概念：触发器是一种特殊类型的存储过程，在执行语言事件时自动生效。其特殊性表现：它是在执行某些T-SQL语句时自动生效的。 2）DML触发器：在数据库中发生DML事件时启动。将触发器和触发它的语句作为可在触发器内回滚的单个事务对待，如果检测到错误，则整个事务即自动回滚。 3）DDL触发器：是SQL Server 2005的新功能，当服务器或者数据库中发生DDL事件时将调用这些触发器。 2，创建触发器 1）DML触发器主要优点 i）DML触发器可通过数据库中相关表实现联级更改；ii）DML触发器可以防止恶意或者错误的INSERT，UPDATE及DELETE操作，并强制执行比CHECK约束定义的限制更为复杂的其他限制；iii）DML触发器可以评估数据修改前后表的状态，并根据该差异采取措施。 2）insert型DML触发器：通常用于更新时间标记字段，或者验证被触发器监控的字段中数据满足要求的标准，以确保数据的完整性。 12345678910/* 检测sc表添加数据的合法性，即添加的数据与student表的数据不匹配时，将删除此数据. */create trigger tri_sc_ins on scfor insert asbegin declare @sno char(10) select @sno=inserted.sno from inserted if not exists(select sno from student where student.sno=@sno) delete from sc where sno=@snoend 3）update型DML触发器：当在一个有update触发器的表中修改记录时，表中原来的记录被移动到删除表中，修改过的记录插入到了插入表中，触发器可以参考删除表和插入表及被修改的表，以确定如何完成数据库操作。 12345678910/* 防止用户修改SC表的成绩 */create trigger tri_sc_update on scfor updateasif update(scorce)begin raiserror('不能修改成绩！', 16, 10) rollback transactionendgo 4）delete型DML触发器 为了防止确实需要删除但会引起数据一致性问题的记录的删除； 执行可删除主记录的子记录的级联删除操作。 12345678910/* 当删除student表中的记录时，自动删除sc表对应学号的记录. */create trigger tri_del_sc on studentfor deleteasbegin delete @sno char(10) select @sno=deleted.sno from deleted delete from sc where sno=@snoend 5）DDL触发器 DDL触发器目的： i）防止对数据库架构进行某些更改；ii）希望数据库中发生某种情况以响应数据库架构中的更改；iii）要记录数据库架构中的更改或者事件。 1234567891011121314151617/* 防止数据库中的任意表被修改或者删除. */create trigger tri_safetyon databasefor drop_table, alter_tableasprint 'You must disable trigger \"tri_safety\" to drop or alter tables!'rollback/* 防止在数据库中创建表 */create trigger tri_ban_createin databasefor create_tableasprint 'create table issued.'select eventdata().value('(/event_instance/TSQLCommand/CommandText)[1]', 'nvarchar(max)')raiserror('New tables cannot be created in this database.', 16, 1)rollback 3，查看，修改和删除触发器 1）查看触发器 123456789/* 查看触发器的一般信息，如触发器的名称，属性，类型和创建时间 */sp_help 'trigger_name'/* 查看触发器的正文信息 */sp_helptext 'trigger_name'/* 查看指定触发器所引用的表或者指定的表涉及的所有触发器 */sp_depends 'trigger_name'sp_depends 'table_name' 2）修改触发器1sp_rename oldname, newname 3）删除触发器1drop trigger &#123;trigger&#125;[, ...n] 4，触发器的用途 1）可以实现比约束更为复杂的数据约束；2）可以检查SQL所做的操作是否被允许；3）当一个SQL语句对数据表进行操作时，触发器可以根据该SQL语句的操作情况对另一个数据表进行操作；4）约束的本身是不能调用存储过程的，但是触发器可以调用一个或者多个存储过程；5）在执行完SQL语句之后，触发器可以判断更改过的记录是否达到一定条件，如果达到，触发器可以自动调用SQL Mail来发邮件；6）约束不能返回信息，而触发器可以返回信息；7）可以修改原本要操作的SQL语句；8）为了保护已经建好的数据表，触发器可以在接收到以drop和alter开头的SQL语句中，不进行对数据表的操作。 四，嵌入式SQL1，嵌入式SQL简介 1）嵌入式SQL定义：嵌入式SQL是一种将SQL语句直接写入C语言，COLBOL，FORTRAN，Ada等编程语言的源代码中的方法。将SQL语句嵌入的目标源码的语言称为宿主语言。 2，嵌入式SQL的工作原理 提供对于嵌入式SQL的支持，需要数据库厂商除了提供DBMS之外，还必须提供一些工具。为了实现对于嵌入式SQL的支持，技术上必须解决以下4个问题: 1.宿主语言的编译器不可能识别和接受SQL文，需要解决如何将SQL的宿主语言源代码编译成可执行码;2.宿主语言的应用程序如何与DBMS之间传递数据和消息;3.如何把对数据的查询结果逐次赋值给宿主语言程序中的变量以供其处理;4.数据库的数据类型与宿主语言的数据类型有时不完全对应或等价，如何解决必要的数据类型转换问题。嵌入式SQL源码的处理流程 为了解决上述这些问题，数据库厂商需要提供一个嵌入式SQL的预编译器，把包含有嵌入式SQL文的宿主语言源码转换成纯宿主语言的代码。这样一来，源码即可使用宿主语言对应的编译器进行编译。通常情况下，经过嵌入式SQL的预编译之后，原有的嵌入式SQL会被转换成一系列函数调用。因此，数据库厂商还需要提供一系列函数库，以确保链接器能够把代码中的函数调用与对应的实现链接起来。 3，嵌入式SQL的一般形式 预编译 修改和扩充主语言使之能处理SQL语句","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库实践","slug":"db-practice","permalink":"https://zhangbc.github.io/tags/db-practice/"}]},{"title":"【数据库实践】 数据表及其SQL基本操作","slug":"【数据库实践】数据表及其SQL基本操作","date":"2019-04-21T12:05:44.000Z","updated":"2019-04-21T12:36:46.444Z","comments":true,"path":"2019/04/21/db_table_sql/","link":"","permalink":"https://zhangbc.github.io/2019/04/21/db_table_sql/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 课本第09～10章主要知识点 一，表的概述1，表的定义：表是包含 SQL Server 2005数据库中的所有数据的对象。表定义是一个列集合。 2，表的类型 1）分区表：将数据水平划分为多个单元的表，这些单元可以分布到数据库中的多个文件组中。2）系统表：存储服务器配置及其所有表的数据。3）用户表：用户自己创建的数据表和表示示例数据表，用于存储用户的信息，用户可以随意更改。4）临时表：分为本地临时表和全局临时表，存储在tempdb中，当不再使用临时表时会自动将其删除。 二，创建表1，表列的数据类型 1）精确数字型 整数类型（bigint，int，smallint，tinyint） bigint：存储范围为 $-2^{63}$~$2^{63}-1$；占用8个字节。 int：存储范围为 $-2^{31}$~$2^{31}-1$；占用4个字节。 smallint：存储范围为 $-2^{15}$~$2^{15}-1$；占用2个字节。 tinyint：存储范围为 0~255；占用1个字节。 位数据类型（bit） bit：存储范围是0和1，占用1个字节。常作为逻辑变量使用，用于表示真、假或者是、否等二值选择。 数值类型（decimal，numeric） decimal：和numeric一样，可以用2～17个字节来存储$-10^{38}+1$到$10^{38}-1$之间但是固定精度和小数位数位的数字。表示形式decimal(p,s)，其中p确定精确的总位数，默认为18位；s确定小数位数，默认为0。 货币类型（money，smallmoney）：必须在有效位置前加一个货币单位符号。 money：用于存储货币值，数值分为一个正数和一个小数分别存储在两个4字节的整型值中，存储范围为$-2^{63}$~$2^{63}-1$，精确到货币单位的千分之一。 smallmoney：与money数据类型相似，但是存储范为$-2^{31}$~$2^{31}-1$。 2）近似数据类型：real，float。 real：存储十进制数值，最大可以为7位精确位数。存储范围为$-3.40 \\times 10^{-38}$ ~ $3.40 \\times 10^{38}$，占用4个字节。 float：可以精确到15位小数。存储范围为$-1.79 \\times 10^{-308}$ ~ $1.79 \\times 10^{308}$，占用8个字节。float(n)：n指定float数据的精度，n为1～15的整数值。当n为1～7时，实际上是定义了一个real类型的数据，占用4个字节；当n为8～15时，系统认为其是float类型，占用8个字节。 3）日期和时间数据类型：datetime和smalldatetime。 datetime：存储日期和时间的结合体，存储从1753年1月1日0时到9999年12月31日23时59分59秒，其精确度可以达到三百分之一秒，即3.33ms。占用8个字节，日期和时间分别占用4个字节。默认格式为 MM DD YYYY hh:mm A.M./P.M.。 smalldatetime：与datetime类型相似，但是存储范围为1900年1月1日至2079年6月6日。占用4个字节，时间和日期分别占用2个字节，精确度为1min。 4）字符数据类型：char，varchar，text。 char：定义形式为char(n)，n表示所有字符占用的存储空间，其取值为1～8000，默认值为1。如果输入数据的字符串长度小于n，则系统自动在其后面添加空格来填充；如果输入的数据过长，将会截掉其超出部分。如果定义一个char数据类型，且允许该列为空，则该字段被当成varchar来处理。 varchar：定义形式为varchar(n)，可存储长达8000个字符的客人变长度字符串。其存储空间是根据存储在表的每列值的字符数变化的。 text：用于存储文本数据，其容量理论上为 1~$2^{31}-1$，实际应用根据硬盘的存储空间而定。 5）unicode字符数据类型：nchar，nvarchar，ntext。 nchar：定义形式为nchar(n)，n的取值为1～4000。与char类似，但采用unicode标准字符集，unicode标准用2个字节为1个存储单位。 nvarchar：定义形式为nvarchar(n)，n的取值为1～4000。与varchar类似，但采用unicode标准字符集。 ntext：理论上容量为$2^{30}-1$，与text类似，但采用unicode标准字符集。 6）二进制数据类型：binary，varbinary，image。 binary：定义形式为binary(n)，数据存储长度是固定的，即n+4个字节。当输入的二进制数据长度小于n时，余下部分填充0。二进制数据类型的最大长度为8000，常用于存储图像等数据。 varbinary：定义形式为varbinary(n)，数据存储长度是变化的，为实际输入数据的长度加上4个字节，其他类似binary。 image：用于存储图像数据，其理论容量为$2^{31}-1$个字节。 7）其他数据类型：sql_variant，table，timestamp，uniqueidentifier，xml，cursor等。 sql_variant：用于存储除文本、图形数据和timestamp类型数据外的其他任何合法的SQL Server 2005数据。 table：用于存储对表或者视图处理后的结果集。 timestamp：时间戳数据类型，提供数据库范围内的唯一值。 uniqueidentifier：用于存储一个16字节长的二进制数据类型，是SQL Server 2005根据计算机网络适配器地址和CPU时钟产生的全局唯一标识符代码（GUID），通过调用 SQL Server 2005 的NEWID()函数获取。 xml：存储xml类型的数据，其数据容量不能超过2GB。 cursor：是变量或者存储过程OUTPUT参数的一种数据类型，这些参数包含对游标的引用。 8）用户自定义数据类型 语法格式如下： 1sp_addtype [@typename=]type, [@phystype=]system_data_type[, [@nulltype=]'null_type'][, [@owner=]'owner_name'] 举例：自定义一个地址(address)数据类型。 1exec sp_addtype address, 'varchar(80)', 'not null' 2，列的其他属性 1）NULL，NOT NULL和默认值在数据库中，NULL是一个特殊值，表示未知值的概念。默认值是指如果插入行时没有为列指定值，默认值则指定列中使用的值。 2）IDENTITY属性：实现标识符列。 一个表只能有一个使用IDENTITY属性定义的列，且必须通过使用bigint，int，smallint，tinyint或者decimal，numeric数据类型类定义该列； 可指定种子和增量，两者的默认值均为1； 标识符列不允许为空值，也不能包含default定义或者对象； 在设置IDENTITY属性后，可以使用$IDENTITY关键字在选择列表中引用该列，也可以通过名称引用该列； objectproperty函数可以用于确定一个表是否具有IDENTITY列，columnproperty函数可以确定IDENTITY列的名称； 通过使值能显示插入，set identity_insert可以用于禁用该列的IDENTITY属性。 3，表的创建 12345678910use stuSystemgocreate table student( studentID int not null primary key, studentName char(10) not null, class char(10) not null, depart char(16) not null, yearClass char(6) not null) 三，维护表1，修改表名与表结构 1234567-- 修改表名，将studentcourse修改为courseexec sp_rename 'studentcourse', 'course';​-- 修改表结构alter table student add sex char(2);alter table student drop column yearClass;alter table student alter column studentName char(8); 2，删除表 1drop table course; 3，表数据的维护 1）添加数据（insert） 1insert into course values('10015', '计算机网络', '张三', 2, null); 2）更新表数据（update） 1update course set cname='计算机组成原理' where cno='10015'; 3）删除表数据（delete） 1delete from student where sno=200901020023; 四，表数据完整性1，SQL Server提供的数据类型完整性组件 完整性类型 组件 实体完整性 索引，unique约束，primary key约束和identity属性 域完整性 foreign key约束，check约束，default定义，not null定义和规则 参照完整性 foreign key约束，check约束和触发器 用户定义完整性 create table中的所有列级和表级约束，存储过程和触发器 2，primary key约束 表通常具有一列或者一组列可以用于唯一标识表中的一行，这样的一列或者多列称为表的主键（PK），用于强制表的实体完整性。 3，foreign key约束 外键是用于建立和加强两个表数据之间的链接的一列或者多列，用于强制参照完整性。 一个表 中最多可以有253个参照表，因此每个表最多可以有253个foreign key约束； 在foreign key约束中，只能参照同一个数据库中的表； foreign key子句中的列数目和每个列指定的数据类型必须和reference子句中的相同； foreign key约束不能自动创建索引； 参照同一个表中的列时，必须只使用reference子句，而不能使用foreign key子句； 在临时表中，不能使用foreign key约束。 4，check约束：通过限制列可接受的值，check约束可以强制域的完整性。 5，表关系：显示某个表中的列如何链接到另一个表的列；可以防止出现冗余数据。 五，视图1，视图概述 1）视图是一个虚拟表，是由若干个表或者视图中导出的表，其结构和数据是建立在对表的查询基础上的，其内容由查询定义。 2）视图的主要优点和作用： i）着重于特定数据：视图使用户能够着重于他们所感兴趣的特定数据和所负责的特定任务，不必要的数据或者敏感数据可以不出现在视图中；ii）简化数据操作：视图可以简化用户处理数据的方式；iii）提供向后兼容性：视图能够在表的架构更改时为表创建向后兼容接口；iv）自定义数据：视图允许用户以不同方式查看数据，即使在他们同时使用相同的数据时也是如此；v）导出和导入数据：可使用视图将数据导出到其他应用程序；vi）跨服务器组合分区数据：使用分区视图，可以使用多个服务器对数据进行分区。 3）视图分类： i）标准视图：组合了一个或者多个表中的数据，可以获得使用视图的大多数好处，包括将重点放在特定数据上及简化数据操作。ii）索引视图：被具体化了的视图，即它已经经过计算并存储，可以为视图创建唯一的聚集索引。iii）分区视图：在一台或者多台服务器间水平连接一组成员表的分区数据。 2，创建视图 1）创建视图原则 i) 只能在当前数据库中创建视图；ii) 视图名称必须遵循标志符的规则，且对每个用户必须唯一；iii) 可以在其他视图和引用视图的过程之上创建视图；iv) 定义视图的查询不能包括order by，compute，compute by子句或者into关键字；v) 不能在视图上定义全文索引定义；vi) 不能创建临时视图，也不能在临时表上创建视图；vii) 不能对视图执行全文查询，但是如果查询所引用的表被配置为支持全文索引，就可以在视图定义中包含全文查询。 举例： 12345use stuSystemgo​create view view_teacher_choice as select b.tname, a.chsu from course a, teacher b where a.tid=b.tid; 3，使用视图 1）使用视图进行数据检索 1select * from view_teacher_choice; 2）通过视图修改数据 如果在视图定义中使用了with check option子句，则所有在视图上执行的数据修改语句都必须符合定义视图的select语句中所设定的条件。 SQL Server 必须能够明确地解析对视图所引用基表中的特定行所做的修改操作。 对基表中须更新而又不允许空值的所有列，其值在insert语句或者default定义中指定。 如果在视图删除数据，在视图定义的from子句中只能列出一个表。 视图修图数据通过insert，update，delete语句来完成。 4，修改视图 12345use stuSystemgo​alter view view_teacher_choice as select b.tname, a.chsu from course a, teacher b where a.tid=b.tid and a.chsu &gt; 30; 5，重命名视图 1exec sp_rename 'view_teacher_choice', 'view_teacher_choice_total'; 6，查看视图 1234use stuSystemgo​exec sp_helptext 'view_teacher_choice_total'; 7，删除视图 1234use stuSystemgo​drop view view_teacher_choice_total; 六，索引1，索引概述 1）索引定义：索引是对数据库表中一个或者多个列的值进行排序而创建的一种存储结构。 2）索引分类： i）聚集索引(clustered)：保证数据库表中记录的物理顺序与索引顺序相同，一个表只能有一个聚集索引。ii）非聚集索引(nonclustered)：数据库表中记录的物理顺序与索引顺序可以不相同，一个表可以有多个非聚集索引。iii）唯一索引(unique)：表示表中的任何两个记录的索引值都不相同，与表的主键类似，确保索引列不包括重复的值；iv）组合索引：将两个或者多个字段组合起来的索引，而单独的字段允许不是唯一的值。 2，创建索引 1234use stuSystemgo​create index idx_time in course(choice_time asc); 3，查看索引 1exec sp_helpindex idx_time; 4，删除索引 1drop index course.idx_time; 七，SQL操作查询1，简单查询 123456select sno,sn,age from student;select * from student;select distinct sno from course;select sn as sname,sno,age from student;select sn,age-5 from student;select avg(age) from student; 2，带条件的列查询 比较大小和确定范围 部分匹配查询 查询的排序 123456789101112select sno,score from sc where cno='C01';select sno,cno,score from sc where score&gt;80;select sno,cno,score from sc where (cno='C01' or cno='C02') and score&gt;80;select sno,sn from student where age between 18 and 20;select sno,sn,cno from student where score is null;select sno,cno,score from sc where cno in('C01', 'C02');select sno,sn from student where sn like '李%';select sno,score from sc where cno='C01' order by score desc;select sum(score) as total_score, avg(score) as avg_score from sc where sno='0001';select max(score) as max_score,min(score) as min_score,max(score)-min(score) as diff from sc where cno='C01';select count(distinct dept) as dept_num from student;select sno,sum(score) aas total_score from sc where score &gt;= 60 group by sno having(*) &gt;= 3 order bu sum(score) desc; 3，多表查询 所谓多表查询，即在两个或者两个以上的表中进行的查询操作，分为：连接查询和子查询（嵌套查询）。 连接查询 1）内连接 等值连接：在连接条件中使用等于号(=)运算符，与被连接列的列值进行比较，在查询结果中列出被连接表中的所有列，包括其中的重复列。 不等连接：在连接条件中使用除等于号(=)以外的其他比较运算符，与被连接列的列值进行比较，这些运算符包括&gt;，&gt;=，&lt;，&lt;=，!&gt;，!&lt;，&lt;&gt;。 自然连接：在连接条件中使用等于号(=)运算符，与被连接列的列值进行比较，在查询结果中列出被连接表中的所有列，但会删除其中的重复列。 1select * from student a inner join sc b on a.sno=b.sno; 2）交叉连接（笛卡尔积）：两个关系中所有元组的任意组合。 1select * from student cross join sc; 3）自连接：如果在一个连接查询中，涉及的两个表都是同一张表，这种查询称为自连接查询。 1select a.* from student a inner join student b on a.cno=b.cno and b.sno='20090701027'; 4）外连接：其查询结果既包含那些满足条件的行，又包含其中某个表的全部行。 左外连接（left join） 右外连接（right join） 全外连接（full join） 123select a.sno,a.sname,a.class,a.cno,b.score from student a left join sc b on a.sno=b.sno;select a.sno,a.sname,a.class,a.cno,b.score from student a right join sc b on a.sno=b.sno;select a.sno,a.sname,a.class,a.cno,b.score from student a full join sc b on a.sno=b.sno; 子查询 在where子句中包含一个形如select-from-where的查询块，此查询称为子查询或者嵌套查询，包含子查询的语句称为父查询或者外部查询。基本关键字：any，in，all，exists 1234select tname from teacher where tno=any(select tno from tc where cno='C05');select tname from teacher where tno in (select tno from tc where cno='C05');select tname,sal from teacher where sal&gt;all(select sal from teacher where dept='电力系') and dept!='电力系';select tname from teacher where exists (select 1 from tc where teacher.tno=tc.tno and cno='C05');","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库实践","slug":"db-practice","permalink":"https://zhangbc.github.io/tags/db-practice/"}]},{"title":"【数据库实践】 数据库及其管理","slug":"【数据库实践】数据库及其表管理","date":"2019-04-17T15:32:38.000Z","updated":"2019-04-18T11:37:54.594Z","comments":true,"path":"2019/04/17/db_table_manager/","link":"","permalink":"https://zhangbc.github.io/2019/04/17/db_table_manager/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 课本第07～08章主要知识点 一，SQL Server 2005概述1，SQL Server 2005 新特性 SQL Server 是一个全面的，集成的数据库解决方案，为企业中的用户提供了用于企业数据管理和商业智能的一个安全，可靠和高效的平台。 1）Service Broker 提供了一个功能强大的，异步编程的新模型。数据库应用程序通常使用异步编程来缩短交互式响应时间，并增加应用程序总吞吐量。 帮助数据库开发人员生成可靠且可扩展的应用程序。 在SQL Server实例之间提供可靠的消息传递服务。 2）CLR集成3）专用管理员DAC：SQL Server 2005为管理员提供了一种特殊的诊断连接，以供在无法与服务器建立标准连接时使用。4）用户与架构分离 简化删除数据库用户的操作 多个用户可以用户同一个架构 5）分区：分区是大型数据表和索引采取的优化存储性能和数据存储的技术。 2，SQL Server 2005 体系结构 1）数据库引擎组件：为数据存储、处理和安全实现高可伸缩性和高可用性服务。2）报表组件服务组件：提供了全面的报表解决方案，可创建、管理和发布传统的、可打印的报表和交互性的、基于Web的报表。3）分析服务组件：提供数据分析服务。利用分析服务开发人员设计、创建和管理多种数据源和多种数据结构，通过数据分析规律，获取数据知识。4）集成服务组件：用于构建高性能数据集成解决方案（包括为数据仓库提取、转换和加载（ETL）包）的平台。5）其他组件：复制服务组件，通知服务组件，服务代理组件，全文搜索。 3，SQL Server 2005安装 1）SQL Server 2005版本选择 SQL Server 2005企业版：支持32位和64位系统，适合超大型企业。包括联机事务处理，高度复杂的数据分析，数据仓库系统和网站所需的基本功能。 SQL Server 2005标准版：支持32位和64位系统，适合中小型企业。包括电子商务，数据仓库和业务流解决方案所需的基本功能。 SQL Server 2005工作组版：仅支持32位系统，适合小型企业使用。包括SQL Server产品系列的核心数据库功能，可升级至标准版或者企业版。 SQL Server 2005开发版：支持32位和64位系统，仅适合于开发和测试系统使用。具备和企业版完全一样的功能，但有许可限制，只能用于开发和测试。 SQL Server 2005简易版：仅支持32位系统，是一个免费的，使用简单，易于管理的数据库。 SQL Server 2005精简版：仅支持32位系统，适合在移动智能设备上使用。 二，数据库的类型1，系统数据库 数据库是表、视图、索引、存储过程等对象的集合，是数据库管理系统的核心，数据库与管理它的数据库管理系统统一组成数据库服务器。 1）master：记录了SQL Server系统的所有服务器的系统信息，包括实例范围的元数据，端点，链接服务器和系统配置设置。 2）model：用于在SQL Server实例上创建的所有数据库的模板。 3）msdb：提供给SQL Server代理服务器使用的数据库，主要用于为警报，作业，任务调度及记录操作员的操作提供相应的支持。 4）tempdb：连接到SQL Server实例的所有用户都可用的全局资源，保存所有临时表和临时存储过程。 5）resource：是一个隐藏的只读数据库，包含了SQL Server中的所有系统对象，但不包含用户数据或者用户元数据。 2，用户数据库 数据库命名规则如下： 第一个字符必须是字母a～z和A~Z、汉字或者下画线(_)、符号@，#； 后续字符可以是字母a～z和A~Z、汉字、数字或者下画线(_)、符号@，$、数字符号； 标识符不能是T-SQL的保留字； 长度不能超过128。 3，数据库快照 1）数据库快照的定义：数据库快照是用户数据库的只读、静态视图，不包括未提交的事务。 2）数据库快照的特点： 反映某个时刻（完成数据库快照创建的时刻）数据库的数据； 不允许更新； 一个用户数据库可以创建多个数据库快照，并且必须与数据库在同一个服务器实例上。 三，数据库存储文件SQL Server 2005数据库文件名称包括： 逻辑文件名：在所有 T-SQL 语句中引用物理文件时所使用的名称，必须符合SQL Server 标识符规则，而且是唯一的。 物理文件名：包括目录路径的物理文件名称，必须符合操作系统文件命名规则。 SQL Server 2005数据库操作系统文件包括： 数据文件：包括数据和对象，如表、索引、存储过程和视图。 日志文件：包含恢复数据库中的所有事务所需的信息。 1，数据库文件 主要数据库文件（.mdf）：数据库的起点，包括数据库的启动信息，并指向数据库中其他文件。 次要数据库文件（.ndf）：是可选的，由用户定义并存储用户数据。 事务日志文件（.ldf）：用于恢复数据库的日志信息。 2，数据库文件组 主文件组：包含主要数据文件和任何没有明确分配给其他文件组的其他文件。系统表的所有页均分配在主文件组中。 用户定义文件组：通过在 create database 或者 alter database 语句中使用 filegroup 关键字指定的任何文件组。 默认文件组（primary文件组）：如果在数据库中创建对象时没有指定对象所属的文件组，对象将被分配给默认文件组。 注意：日志文件包括在文件组内。 四，数据库的对象1，数据库关系图：以图形方式来表示表之间的关系。 2，表：组织和存储数据。 3，索引：提高数据检索速度，但增加了系统存储空间的开销。 4，视图：实现用户对数据对查询，但是视图的结构和数据是建立在对表的查询基础上的。 5，存储过程和触发器：数据库中的对编程对象。 存储过程独立于表，存储在服务器上，供客户端调用，提供应用程序的效率。 触发器是一种特殊的存储过程，可以大大增强应用程序的健壮性，数据的可恢复性和可管理性。 6，规则和约束：对能够放入表中的内容进行限定。 规则：用于在用户定义数据类型上加以限制。 约束：本身并非实际的对象，而只是描述特定表的元数据。 7，默认值： 默认值有两种类型： 默认值默认其本身是一个对象； 默认值不是实际的对象，只描述表特定列的元数据。 8，全文目录：全文目录是数据的映射，以加速对启用了全文搜索的列中特定文本块的搜索。 五，创建数据库 一个SQL Server实例，最多可以创建32767个数据库。 1，使用SQL Server管理工具创建 2，使用T-SQL创建 1234567891011121314151617create database xsxk on primary -- 建立主要数据文件( name = 'xsxk_data', -- 逻辑名称 filename = 'E:\\students\\xsxk_data.mdf', -- 物理文件路径和名称 size = 1024KB, -- 初始大小 maxsize = unlimited, -- 最大尺寸为无限大 filegrowth = 10% -- 增长速度)log on( name = 'xsxk_log', -- 建立日志文件 filename = 'E:\\students\\xsxk_log.ldf', -- 物理文件路径和名称 size = 1024KB, -- 初始大小 maxsize = 5120KB, filegrowth = 1024KB ) 六，维护数据库1，查看数据库状态 1234use master;go​select name,state,state_desc from sys.databases; 2，修改数据库 1234567891011121314151617181920alter database xsxk modify file( name = 'xsxk_data', -- 逻辑名称 size = 5MB, -- 初始大小 maxsize = 50MB, filegrowth = 2% -- 增长速度)goalter database xsxklog on( name = 'xsxk_log', -- 建立日志文件 filename = 'E:\\students\\xsxk_log.ldf', -- 物理文件路径和名称 size = 1024KB, -- 初始大小 maxsize = 5120KB, filegrowth = 2MB ) go 3，删除数据库 1drop database xsxk; 4，分离和附加数据库 123456789101112-- 分离数据库sp_detach_db xsxk;​-- 附加数据库create database xsxk on( filename = 'E:\\students\\xsxk_data.mdf'),( filename = 'E:\\students\\xsxk_log.ldf') for attach;go 5，其他操作 1）脱机用户数据库 2）联机用户数据库 3）重命名数据库 1alter database xsxk modify name = xsxks 4）收缩数据库 12345-- 将userDB用户数据库中的文件减小，以使userDB中的文件有10%的可用空间dbcc sharinkdatabases(userDB, 10)​-- 将userDB用户数据库中名为DataFile的文件大小收缩到7MDBCC shrinkfile(DataFile, 7)","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库实践","slug":"db-practice","permalink":"https://zhangbc.github.io/tags/db-practice/"}]},{"title":"【数据库理论】数据库的安全和保护","slug":"【数据库理论】数据库的安全和保护","date":"2019-04-14T11:05:17.000Z","updated":"2019-04-14T16:43:26.612Z","comments":true,"path":"2019/04/14/db_security/","link":"","permalink":"https://zhangbc.github.io/2019/04/14/db_security/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，安全与保护概述1）数据安全性控制：防止未经授权的用户和存取数据库中的数据，避免数据的泄露，更改或破坏； 2）数据完整性控制：保证数据库中数据及语义的正确性和有效性，防止任何对数据库造成错误的操作； 3）数据库的并发控制：在多用户同时对一个个数据进行操作时，系统应能够加以控制，防止破坏数据库中的数据； 4）数据库的恢复：在数据库遭到破坏或者数据不正确时，系统有能力把数据库恢复到正确的状态。 二，数据库的安全性1，数据库安全性控制 1）用户标识与鉴别：系统提供的最外层的安全保护措施，其方法是由系统提供一定的方式让用户标识自己的名字或身份。 2）存取控制： （1）定义用户权限，并将用户权限等存储在数据字典中。用户权限是指不同等用户对不同对数据对象允许执行对操作权限，这些定义经过编译后存放在数据字典中，这些定义称为安全规则或授权规则；（2）合法权限检查。用户权限定义和合法权限检查机制组成类DBMS的安全子系统。 3）试图机制：数据安全性，逻辑数据独立性和操作简便性。 4）审计：审计追踪是一个对数据库进行更新对日志，还包括一些其他信息，如哪个用户执行了更新和什么时候执行的更新等。 5）数据加密：防止数据库中数据在存储和传输中失密的有效手段。 2，SQL Server的安全性措施 1）SQL Server安全控制概述 （1）操作系统安全验证（网络层）：通过设置安全模式来实现。（2）SQL Server安全验证（服务器）：通过SQL Server服务器登录名管理来实现。（3）SQL Server数据库安全验证：通过SQL Server数据库用户管理来实现。（4）SQL Server数据库对象安全验证（处理权限）：通过权限管理来实现。 2）SQL Server的安全认证模式 （1）身份验证阶段：Windows身份验证，混合模式验证。（2）权限认证阶段（3）设置身份验证 3）登录名和用户管理1234USE &lt;DATABASE NAME&gt;goCREATE USER &lt;new user_name&gt; FOR LOGIN &lt;login name&gt;; 4）权限管理 （1）权限分类：语句权限，对象权限，隐含权限；（2）角色分类：在SQL Server中，组是通过角色来实现的。角色分为服务器角色和数据库角色（预定义的数据库角色，用户自定义数据库角色和应用程序角色）。 三，数据库的完整性1，数据库的完整性定义：数据库的完整性是指数据的正确性（Correctness），有效性（Validity）和相容性（Consistency）。正确性是指数据的合法性；有效性是指数据是否属于所定义的有效范围；相容性是指表示同一事实的两个数据应一致，不一致就是不相容。 完整性检查：在DBMS中，检查数据库中的数据是否满足语义规定的条件。 2，完整性约束条件 1）完整性约束作用的对象可以是列，元组，关系。其中：列的约束主要是列的类型，取值范围，精度，排序等约束条件；元组的约束是元组中各个字段间的联系约束；关系的约束是若干元组间，关系集合上及关系之间的联系约束。 2）静态约束：指数据库在每个确定状态时的数据对象所应满足的约束条件，是反映数据库状态合理性的约束。 （1）静态列级约束：对一个列的取值范围的说明，即对数据类型的约束（数据的类型，长度，单位，精度等），对数据格式的约束，对取值范围或者取值集合的约束，对空值的约束，其他约束。（2）静态元组约束：规定元组的各个列之间的约束关系。（3）静态关系约束：实体完整性约束，参照完整性约束，函数依赖约束，统计约束。 3）动态约束：指数据库从一种状态转变为另一种状态时，新旧值之间所应满足的约束条件，是反映数据库状态变迁的约束。 （1）动态列级约束：修改列定义或者列值时应满足的约束条件。（2）动态元组约束：修改元组中各个字段间需要满足某种约束条件。（3）动态关系约束：加在关系变化前后状态上的限制条件，如事务一致性，原子性等。 3，完整性控制 1）定义功能：提供定义完整性约束条件的机制。 2）检查功能：检查用户发出的操作请求是否违背列完整性约束条件。 3）如果发现用户的操作请求使数据违背了完整性约束条件，则采取恰当的操作。 4，SQL Server的完整性实现 1）声明型数据完整性约束：在 create table 和 alter table 定义中使用约束限制表中的值。 2）过程型数据完整性约束：由缺省，规则和触发器实现，由视图和存储过程支持。 （1）约束：是SQL Server提供的自动保持数据库完整性的一种方法。分为：i）空值约束1[CONSTRAINT constraint_name] [NULL/NOT NULL] ii）主键约束1234-- 列级[CONSTRAINT constraint_name] PRIMARY KEY -- 表级[CONSTRAINT constraint_name] PRIMARY KEY(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;]) iii）唯一约束1234-- 列级[CONSTRAINT constraint_name] UNIQUE -- 表级[CONSTRAINT constraint_name] UNIQUE(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;]) 唯一约束和主键约束的区别： （1）在一个基本表中，只能定义在一个主键约束，但可以定义多个唯一约束；（2）两者都为指定但列建立唯一索引，但主键约束限制更为严格，不但不允许有重复值，而且也不允许由空值；（3）唯一约束与主键约束产生但约束可以是聚集索引，也可以是非聚集索引，在缺省情况下，唯一约束产生非聚集索引，主键约束产生聚集索引；（4）不能同时为同一列或者一组列既定义唯一约束，又定义主键约束。 iv）外键约束和参照约束 1[CONSTRAINT constraint_name] [FOREIGN KEY] REFERENCES ref_table (ref_column[&#123;,&lt;trf_column&gt;&#125;]) v）缺省值约束1[CONSTRAINT constraint_name] DEFAULT constraint_expression vi）检查约束1[CONSTRAINT constraint_name] CHECK(logical_expression) 例如：12345678910111213use mastergo ​create table Titles ( title_id varchar(6) constraint pk_title_id primary key, title varchar(80) not null constraint uniq_title unique, [type] char(12) not null constraint def_type default 'UNDECIDED', pub_id char(4), price money constraint chk_price check(price between 5 and 100), ytd_sales int, pub_date datetime not null constraint def_pub_date default getdate()) （2）规则：当向表当某列（或使用与该规则绑定的用户定义数据类型的所有列）插入列或更新数据时，它指定限制输入新值的取值范围。 12345678use mastergo​create rule rule_price as @price &gt;= 5 and @price &lt;= 100go​exec sp_bindrule 'rule_price', 'Titles.price'go （3）缺省：它指定在向数据库中的表插入数据时，如果用户没有明确给出某列的值，SQL Server自动为该列（使用与该缺省绑定的用户定义数据类型的所有列）输入值。 12345678use mastergo​create default def_price as 50go​exec sp_bindefault def_price, 'Titles.price'go 四，事务1，事务的概念 1）事务定义：用户定义的一个数据库操作序列，这些操作要么可全部成功执行，否则，将不执行其中任何一个操作。事务是一个不可分割的工作单元。 2）事务基本性质(ACID) （1）原子性(Atomicity)：事务中包含的所有操作要么全做，要么一个也不做。（2）一致性(Consistency)：定义在数据库上的各种完整性约束。（3）隔离性(Ioslation)：确保事务并发执行后的系统状态与这些事务以某种次序串行执行后的状态是等价的。（4）持久性(Durability)：一个事务一旦成功完成，它对数据库的改变必须是永久的，即使是在系统遇到故障的情况下也不会丢失。 2，事务调度 1）事务调度的定义：在一个大型的DBMS中，可能会同时存在多个事务处理请求，系统需要确定这组事务的执行次序，即每个事务的指令在系统中执行的时间顺序，这称为事务的调度。 2）合法调度须满足以下条件： i）调度必须包含所有的事务的指令；ii）一个事务中指令的顺序在调度中必须保持不变。 3）调度的基本形式 i）串行调度 串行调度：在前一个事务完成之后，在开始另外一个事务，类似与操作系统中的单道批处理作业。 可串行化调度：定义多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，这种调度策略称为可串行化调度。 ii）并行调度 并行调度可串行化：如果一组事务并行调度的执行结果等价于这组事务中所有提交事务的某个串行调度，则称该并行调度可串行化。 级联回滚：由于一个事务的故障而导致一系列其他事务的回滚。 无级联调度：应该对调度做出某种限制以避免级联回滚发生，这样的调度称为无级联调度。 可恢复调度：对每对事务$T_i$和$T_j$，如果$T_j$读取了由$T_i$所写的数据项，则$T_i$必须先于$T_j$提交。 3，事务隔离级别 1）并发操作带来的问题 i）丢失修改：又称写-写错误，两个事务$T_1$和$T_2$读入同一数据并修改，$T_2$提交的结果破坏了$T_1$提交的结果，导致$T_1$的修改被丢失。ii）脏读：又称写-读错误，事务$T_1$修改某一数据，并将其写回磁盘，事务$T_2$读取同一数据后，$T_1$由于某种原因被撤销，这时$T_1$已修改过的数据恢复原值，$T_2$读到的数据就与数据库中的数据不一致，则$T_2$读到的数据即为“脏”数据，即不正确的数据。iii）不可重复读：又称读-写错误，事务$T_1$读取某一数据后，事务$T_2$对其做了修改，当$T_1$再次读取该数据时，得到与前次不同的值。iv）幻想读：事务$T_2$按一定条件读取了某些数据后，事务$T_1$插入（删除）了一些满足这些条件的数据，当$T_2$再次按相同条件读取数据时，发现多（少）了一些记录。 2）事务隔离级别的定义 i）未提交读：又称脏读，允许运行在该隔离级别上的事务读取当前数据页上的任何数据，而不管该数据是否已提交，解决了丢失修改问题。ii）提交读：保证运行在该隔离级别上的事务不会读取其他未提交事务所修改的数据，解决了丢失修改和脏读的问题。iii）可重复读：保证一个事务如果再次访问同一数据，与此前访问相比，数据不会发生修改，解决了丢失修改，脏读和不可重复读问题。iv）可串行化：在这个级别上的一组事务的并发执行与它们的某个串行调度是等价的，解决了并发操作带来的四个不一致问题。 4，SQL Server中的事务定义 1）事务定义模式123456789101112-- 定义BEGIN TRAN[SACTION] [事务名[WITH MARK['事务描述']]]​-- 提交1COMMIT [TRAN[SACTION] [事务名]]-- 提交2COMMIT[WORK]​-- 回滚1ROLLBACK [TRAN[SACTION] [事务名|保存点名]]-- 回滚2COMMIT[WORK] 2）事务执行模式 i）显式事务：每个事务均以 BEGIN TRANSACTION 语句显式开始，以 COMMIT 或者 ROLLBACK 语句显式结束。ii）隐性事务：每个事务无须描述事务的开始，但仍以 COMMIT 或 ROLLBACK语句显式完成。iii）自动提交事务：SQL Server 的默认事务管理模式，意指每条单独的语句都是一个事务。在完成每个 T-SQL 语句时，都被提交或者回滚。 12-- 隐性事务设置方法SET IMPLICIT_TRANSACTIONS &#123;ON|OFF&#125; 3）事务隔离级别的定义1234567set transaction isolation level read uncommitted;​set transaction isolation level read committed;​set transaction isolation level repeatable read;​set transaction isolation level serializable; 4）批处理，触发器的事务 批处理是包含一个或者多个SQL语句的组，从应用程序一次性地发送到服务器执行。服务器将批处理语句编译成一个可执行单元，此单元称为执行计划。 五，并发控制1，相关概念 事务是并发控制的基本单位，事务最基本的特征之一是隔离性。为保证事务的隔离性，系统必须对并发事务之间的相互作用加以控制，这称为并发控制。并发控制的主要技术是封锁。 2，封锁技术 1）封锁：事务$T$在对某个数据库对象操作之前，先向系统发出请求，对其加锁。最基本的封锁模式有排他锁(X锁)和共享锁(S锁)。 i）排他锁：又称写锁，如果事务$T$对数据对象$A$加上$X$锁，则只允许$T$读取和修改$A$，其他任何事务都不能再对$A$加任何类型的锁，直到$T$释放$A$上的锁。申请对$A$的排他锁可表示为$XLOCK(A)$。ii）共享锁：又称读锁，如果事务$T$对数据对象$A$加上$S$锁，则只允许$T$读取$A$但不允许修改$A$，其他事务只能再对$A$加$S$锁而不能加$X$锁，直到$T$释放$A$上的$S$锁。申请对$A$的共享锁可表示为$SLOCK(A)$。 3，事务隔离级别与封锁规则 1）封锁协议（Locking Protocol）：在运用$X$锁和$S$锁这两种基本封锁对数据对象加锁时，还需要约定规则，如何时申请$X$锁或$S$锁，持锁时间，何时释放等，这些规则称为封锁协议。 2）长锁：保持到事务结束的锁；短锁：用完就释放的锁。 4，封锁粒度（MGL） 1）封锁粒度定义：封锁对象的大小称为粒度。 i）多粒度封锁：数据库中被封锁的资源按粒度大小会呈现处一种层次关系，元组隶属于关系，关系隶属于数据库，称为粒度树。当为某结点加上意向锁（$I$锁）时，就表明某些内层结点已发生事实上的封锁，防止其他事务再去封锁该结点，这种封锁方式称为多粒度封锁（Multi Granularity Lock）。ii）意向锁：如果对一个结点加意向锁，则说明该节点的下层结点正在加锁；对任意节点加锁时，必须先对它所在的上层结点加意向锁。 意向共享锁（IS锁）：如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。 意向排他锁（IX锁）：如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。 共享意向排他锁（SIX锁）：如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁。 5，并发控制 1）SQL Server锁模式：共享锁（S锁），更新锁（U锁），排他锁（X锁），意向共享锁（IS锁）， 意向排他锁（IX锁），共享意向排他锁（SIX锁）。 2）SQL Server锁粒度：行级（Row），页面级（Page），表级（Table） 3）强制封锁类型在通常情况下，数据封锁由DBMS控制，对用户是透明的，但可以在SQL语句中加入锁定提示来强制 SQL Server 使用特定类型但锁。 六，数据库恢复技术1，恢复的概念：负责将数据库从故障所造成的错误状态中恢复到某一已知的正确状态（也称为一致性状态或者完整状态）。 2，故障的种类 1）事务故障：指事务的运行没达到预期对象终点就终止，有两种错误可能造成事务执行失败。 i）非预期故障：是指不能由应用程序处理的故障，如运算溢出，但该事务可以在以后但某个时间重新执行。ii）可预期故障：指应用程序可以发现的事务故障，并且可以控制让事务回滚。 2）系统故障：又称软故障，指在硬件故障，软件错误的影响下，导致内存中的数据丢失，并使得事务处理终止，但未破坏外存中数据库。由于硬件错误和软件漏洞致使系统终止，而不破坏外存内容但故障又称为故障-停止假设。 3）介质故障：又称硬故障，指由于磁盘的磁头碰撞，瞬时的强磁场干扰等造成磁盘的损坏，破坏外存上的数据库，并影响正在存取的这部分数据的所有事务。 4）恢复的基本原理是冗余，即数据库中任意部分的数据可以根据存储在系统别处的冗余数据来重建。一般的冗余形式：副本和日志。 3，恢复的实现技术 1）数据转储：DBA定期将整个数据库复制到磁带或者在另一个磁盘上保存起来的过程。 i）静态转储：在系统中无运行事务时进行的转储操作，即转储操作开始的时刻，数据库处于一致性状态，而转储期间不允许对数据库的任何存取，修改活动。ii）动态转储：指在转储期间允许对数据库进行存取或修改，即转储与用户事务可以并发执行。iii）全量转储：每次转储全部数据库。iv）增量转储：每次只转储上一次转储后更新过的数据。 2）登记日志文件 日志是以事务为单位记录数据库每次更新活动的文件，由系统自动记录。遵循以下原则： i）登记的次序严格按并发事务执行的时间次序；ii）必须先写日志文件，然后写数据库。 前像：要撤消事务，日志中必须包含数据库发生变化前的所有记录的备份，这些记录称为前像(Before-Images)。 后像：为了恢复事务，日志中必须包含数据库改变之后的所有记录的备份，这些记录称为后像(After-Images)。 3）基本日志结构 日志是日志记录(Log Records)的序列，主要包含： （1）事务开始标识，如&lt;$T_i$ start&gt;；（2）更新日志记录，描述一次数据库写操作，如&lt;$T_i,X_i,V_1,V_2$&gt; 事务标识$T_i$是执行WRITE操作的事务的唯一标识；数据项标识$X_i$是所写数据项的唯一标识，通常是数据项在磁盘上的位置；更新前数据的旧值$V_1$ (对插入操作而言此项为空值)； 更新后数据的新值$V_2$ (对删除操作而言此项为空值)。（3）事务结束标识&lt;$T_i$ COMMIT&gt;，表示事务$T_i$提交；&lt;$T_i$ ABORT&gt;，表示事务$T_i$中止。 4，SQL Server基于日志的恢复策略 1）事务分类 i）圆满事务：指日志文件中记录了事务的COMMIT标识，说明日志中已经完整地记录下事务所有的更新活动。ii）夭折事务：指日志文件只有事务的开始标识，而无COMMIT标识，说明对事务更新活动的记录是不完整的，无法根据日志来重现事务。 2）基本的恢复操作 i）重做：对圆满事务所做过的修改操作应执行REDO操作，即重新执行该操作，修改对象赋予其新记录值，这种方法称为前滚。ii）撤销：对夭折事务所做过的修改操作应执行UNDO操作，即撤销该操作，修改对象赋予其旧记录值，这种方法又称为回滚。 3）事务故障恢复 i）反向扫描日志文件，查找该事务的更新操作；ii）对该事务的更新操作执行逆操作，即将事务更新前的旧值写入数据库；iii）继续反向扫描日志文件，查找其他事务的其他更新操作，做同样处理；iv）如此处理下去，直至读到该事务的开始标识，事务恢复故障完成。 4）系统故障恢复 i）正向扫描日志文件，找出圆满事务，将其事务标识记入重做队列；找出夭折事务，将其事务标识记入撤销队列；ii）对撤销队列中的各个事务进行撤销处理，即反向扫描日志文件，对每个撤销事务对更新操作执行逆操作；iii）对重做队列中的各个事务进行重做处理，即正向扫描日志文件，对每个重做事务重新执行日志文件登记的操作。 5）介质故障恢复 i）装入最新的数据库后备副本，将数据库恢复到最近一次转储时的一致性状态；ii）装入相应的日志文件副本，重做已完成的事务。 5，SQL Server的备份与恢复 1）SQL Server的备份 i）数据库备份：即完全备份。 设置简单恢复模式： 1alter database master set recovery simple; 执行完全备份： 12345use master;go​-- init:如果已存在bak文件，则首先删除，后执行backup database master to disk='E:\\mater_full.bak' with init; ii）差异备份：只存储上一次完备之后发生改变的数据。 12345use master;go​-- init:如果已存在bak文件，则首先删除，后执行backup database master to disk='E:\\mater_diff.bak' with init, differential; iii）日志备份：数据库的恢复模式必须设为完整恢复模式并且必须在数据更改为完整恢复模式后至少执行一次完整数据库备份。 设置完整恢复模式： 1alter database master set recovery full; 执行日志备份： 1234use master;go​backup log master to disk='E:\\master_log.bak' 2）SQL Server恢复 i）使用SQL Server管理工具还原数据库ii）使用T-SQL语句从简单备份策略还原数据库1restore database master from disk='E:\\master_full.bak'; iii）使用T-SQL语句还原差异备份12restore database master from disk='E:\\master_full.bak' with norecovery;restore database master from disk='E:\\master_diff.bak'; iv）使用T-SQL语句从完整备份策略还原数据库123restore database master from disk='E:\\master_full.bak' with replace, norecovery;restore log master from disk='E:\\master_log1.bak' with norecovery;restore log master from disk='E:\\master_log2.bak';","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库理论","slug":"db-theory","permalink":"https://zhangbc.github.io/tags/db-theory/"}]},{"title":"【数据库理论】数据库的设计与实施","slug":"【数据库理论】数据库的设计与实施","date":"2019-04-14T10:44:12.000Z","updated":"2019-04-14T10:46:42.548Z","comments":true,"path":"2019/04/14/db_design/","link":"","permalink":"https://zhangbc.github.io/2019/04/14/db_design/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据库设计概述数据库技术是信息资源开发，管理和服务的最有效手段，从小型 单项事务处理系统到大型的信息系统都利用了数据库技术来保证系统数据的整体性，完整性和共享性。 1，数据库设计的内容与特点 1）数据库设计包括结构特性设计与行为特性设计。 结构特性设计即数据库框架和数据库结构设计，其结果是得到一个合理的数据模型，以反映真实的事务间的联系，目的是汇总各用户的视图，尽量减少冗余，实现数据共享。结构特性是静态的。 行为特性设计是指应用程序设计，如查询，报表处理等，结构特性必须适应行为特性。 2，数据库设计方法 1）新奥尔良方法：将数据库设计分为需求分析，概念设计，逻辑设计，物理设计。 2）从本质上，规范设计法的基本思想是“反复探寻，逐步求精”。 3，数据库设计的步骤 1）数据库设计的过程：三大阶段六步骤，即：数据库规范设计，需求分析，概念结构设计，逻辑结构设计，物理结构设计，数据库实施与维护（总体规划阶段，系统开发设计阶段，系统运行与维护阶段）。 2）六个步骤： （1）数据规划设计：明确数据库建设的总体目标和技术路线，得出数据库设计项目的可行性分析报告，对数据库设计的进度和人员分工做出安排。（2）需求分析：准确弄清用户要求是数据库设计的基础。（3）概念结构设计：数据库逻辑结构依赖于具体的DBMS。概念结构是各用户关心的系统信息结构，是对现实世界的第一层抽象。（4）逻辑结构设计：使概念结构转换为某个DBMS所支持的数据模型，并进行优化。（5）物理结构设计：设计目标是从一个满足用户要求的已确定的逻辑模型出发，设计一个在限定的软件，硬件条件和应用环境下可实现的，运行效率高的数据库结构。（6）数据库实施与维护 二，数据库规划1，系统调查：搞清楚企业的组织层次，得到企业的组织结构图。 2，可行性分析：分析数据库建设是否具有可行性，即从经济，法律，技术等多方面进行可行性论证分析，在此基础上得到可行性报告。 3，数据库建设的总体目标和数据库建设的实施总安排 三，需求分析1，需求分析的任务 1）需求分析的任务：通过详细调查现实世界要处理的对象，充分了解原系统工作概况，明确各用户需求，在此基础上确定新的功能。 2）需求分析的重点：调查，搜集用户在数据管理中的信息要求，处理要求，安全性与完整性要求。 信息要求是指用户需要从数据库中获取信息的内容和性质，由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据。 处理要求是指用户要求完成什么样的处理功能，对处理的响应时间有什么要求，处理方式是批处理还是联机处理。 安全性要求是指保护数据不被未授权的用户破坏。 完整性要求是指保护数据不被授权的用户破坏。 2，需求分析的方法 1）常用的调查方法 （1）跟班作业（2）开调查会（3）查阅档案资料（4）询问（5）设计调查用表并请用户填写 3，需求分析的步骤 1）分析用户的活动 2）确定系统的边界 3）分析用户活动所设计的数据数据流图（DFD）是描述各处理活动之间数据流动的有力工具，是一种从数据流的角度描述一个组织业务活动的图示。 4）分析系统数据 数据字典（DD）是描述每个数据流，每个文件，每个加工的集合，是对数据流图中出现的所有数据元素给出逻辑定义和描述。 数据字典包括数据项，数据文件，数据流，数据加工处理。 数据项描述={数据项名，别名，数据项含义，数据类型，字节长度，取值范围，取值含义，与其他数据项的逻辑关系} 数据文件描述={数据文件名，所有数据项名，数据存取频度，存取方式} 数据流描述={数据流名称，所有数据项名，数据流来源，数据流去向，平均流量，峰值流量} 数据加工处理描述={加工处理名，说明，输入的数据流名，输出的数据流名，处理要求} 四，概念结构设计概念结构设计阶段是将用户需求抽象为信息结构（概念模型）的过程。 1，局部E-R图的设计 2，全局E-R图的设计 五，逻辑结构设计逻辑模式设计的主要目标是产生一个具体DBMS可处理的数据模型和数据库模式，即把概念设计阶段的全局E-R图转换成DBMS支持的数据模型。一般步骤： （1）将概念结构转换为一般的关系模型，网状模型或层次模型。（2）将转换来的关系模型，网状模型，层次模型向DBMS支持的数据模型转换，变成合适的数据库模式。（3）对模式进行挑战和优化。 六，物理结构设计1）在进行数据库的物理结构设计时，首先确定数据库的物理结构，然后是对所设计的物理结构设计进行评价。2）物理结构设计的重要目标是满足主要应用的性能要求。3）就RDBMS而言，物理结构设计主要内容有：为关系模式选取存取方法，设计关系，索引等数据库文件的物理存储结构。","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库理论","slug":"db-theory","permalink":"https://zhangbc.github.io/tags/db-theory/"}]},{"title":"【数据库理论】关系模式的规范化与查询优化","slug":"【数据库理论】关系模式的规范化与查询优化","date":"2019-04-13T14:31:38.000Z","updated":"2019-04-14T06:10:16.477Z","comments":true,"path":"2019/04/13/db_query_opt/","link":"","permalink":"https://zhangbc.github.io/2019/04/13/db_query_opt/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，问题的提出1，关系模式 关系模式定义：一个关系模式是一个系统，它是有一个五元组$R(U, D, DOM, I, F)$组成，其中，$R$为关系名，$U$是$R$的一组属性集合$\\{ A_1,A_2,A_3,\\dots,A_n \\}$，$D$是$U$中属性的域集合$\\{ D_1,D_2,D_3,\\dots,D_n \\}$，$DOM$为属性$U$到域$D$的映射，$I$为完整性约束集合，$F$为属性间的函数依赖关系。 2，关系 1）关系定义：在关系模式$R( U, D, DOM, I, F )$中，当且仅当$U$上的一个关系$r$足$F$时，$r$称为关系模式$R$的一个关系，记作$R(U)$或$R(U,F)$。 2）关系数据库对关系有一个最起码的要求： 每个属性必须是不可分割的数据项。满足列这个条件的关系模式就属于第一范式（1NF）。 3）数据依赖：通过一个关系中属性间值的相等与否以体现数据间的相互关系，是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。主要有：函数依赖FD，多值依赖MVD。 3，插入异常：表示数据插入时出现问题，即无法在缺少另一个实体实例或者关系实例的情况下表示实体或者实体的信息。 4，删除异常：删除表的某一行来反映某个实体实例或者关系实例消失，会导致丢失另一个不同实例实体或者关系实例的信息。 5，更新异常：更改表所对应的某个实体实例或者关系实例的单个属性，会将多行的相关信息全部更新。 二，关系模式的函数依赖1，函数依赖（FD） 1）函数依赖（FD）定义：设$R(U)$是属性集$U$上的关系模式，$X$，$Y \\subseteq U$。若对$R(U)$的任意一个可能的关系$r$，$r$中有任意两个元组$t_1$和$t_2$，如果$t_1 [ X ] = t_2 [ X ]$，有$t_1[ Y ] = t_2[ Y ]$，则称$X$函数确定$Y$，或者说$Y$函数依赖$X$，记为$X \\rightarrow Y$。 （1）如果$X \\rightarrow Y$，但是$Y \\nsubseteq X$，则称$X \\rightarrow Y$是非平凡的函数依赖；（2）如果$X \\rightarrow Y$，但是$Y \\subseteq X$，则称$X \\rightarrow Y$是平凡的函数依赖；（3）如果$X \\rightarrow Y$，则$X$为这个函数依赖的决定属性集(Determinant)；（4）如果$X \\rightarrow Y$，$Y \\rightarrow X$，则记为$X \\longleftrightarrow Y$；（5） 如果$Y$不函数依赖于$X$，则记为$X \\nrightarrow Y$。 2）完全函数依赖和部分函数依赖设$R(U)$是属性集$U$上的关系模式，如果$X \\rightarrow Y$，并且对于$X$的任何一个真子集$Z$，都有$Z \\nrightarrow Y$，则称$Y$完全依赖于$X$，记$X \\stackrel{f}{\\rightarrow} Y$；若$X \\rightarrow Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记$X \\stackrel{p}{\\rightarrow} Y$。 3）传递函数依赖设$R(U)$是属性集$U$上的关系模式，$X \\subseteq U$，$Y \\subseteq U$，$Z \\subseteq U$，$Z - X$，$Z - Y$，$Y - X$均非空，如果$X \\rightarrow Y(Y \\nsubseteq X)$，$Y \\nrightarrow X$，$Y \\rightarrow Z$，则称$Z$传递依赖于$X$。 2，键 1）候选键：设$R(U)$是属性集$U$上的关系模式，$K \\subseteq U$，如果$K \\stackrel{f}{\\rightarrow} U$，则$K$为$R$的候选键。候选键包含了关系模式的所有属性，称为全键。2）主属性：包含在任意一个候选键中的属性称为主属性。3）非主属性：不包含在任意候选键中的属性称为非主属性或非键属性。4）外键：在关系模式$R$中属性或者属性组$X$并非$R$的候选键，但$X$是另一个关系模式的候选键，则称$X$是$R$的外部键，也称外键。 3，函数依赖的逻辑蕴含 1）阿姆斯特朗公理体系 （1）包含规则：设$R(U)$是属性集$U$上的关系模式，$X \\subseteq U$，$Y \\subseteq U$，且$Y \\subseteq X$，则$X \\rightarrow Y$。 （2）平凡依赖：由包含规则得到的函数依赖都是平凡函数依赖。 （3）逻辑蕴含：设$R(U)$是属性集$U$上的关系模式，$F$是$R$上函数依赖集合，如果$R$的任意关系实例$r$使$F$成立的，函数依赖$X \\rightarrow Y$均成立，则称$F$逻辑蕴含$X \\rightarrow Y$。 （4）阿姆斯特朗公理：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$的一个函数依赖集合，$X \\subseteq U$，$Y \\subseteq U$，$Z \\subseteq U$。包含如下规则： i）包含规则：又称自反律，如果$Y \\subseteq X \\subseteq Z$，则$X \\rightarrow Y$为$F$所蕴含；ii）传递规则：如果$F$蕴含$X \\rightarrow Y$，$Y \\rightarrow Z$，则$X \\rightarrow Z$为$F$所蕴含；iii）增广规则：如果$F$蕴含$X \\rightarrow Y$，且$Z \\subseteq U$，则$XZ \\rightarrow YZ$为$F$所蕴含。 阿姆斯特朗公理包含蕴含规则如下： i）合并规则：如果$X \\rightarrow Y$，$X \\rightarrow Z$，则$X \\rightarrow YZ$；ii）伪传递规则：如果$X \\rightarrow Y$，$WY \\rightarrow Z$，则$WX \\rightarrow Z$；iii）分解规则：如果$X \\rightarrow Y$，$Z \\subseteq Y$，则$X \\rightarrow Z$；iv）集合累积规则：如果$X \\rightarrow YZ$且$Z \\rightarrow W$，则$X \\rightarrow YZW$。 【引理4-1】 $X \\rightarrow A_1A_2A_3 \\dots A_n$ 成立的充分必要条件是$X \\rightarrow A_i（i=1，2，\\dots，n）$成立。 2）闭包，覆盖和最小覆盖 （1）函数依赖的闭包：设$R$是一个具有属性集合$U$的关系模式，$F$是给定的函数依赖的集合，由$F$推导出的所有函数依赖的集合称为$F$的闭包，记作$F^{+}$。 （2）函数依赖集的覆盖：$R$表上的两个函数依赖集合$F$和$G$，如果函数依赖集$G$可以从$F$用蕴含规则推导出来，换言之，如果 $G \\subset F^{+}$，则称$F$ 覆盖 $G$，如果$F$ 覆盖 $G$ 且 $G$ 覆盖 $F$，则称这两个函数依赖集等价，记作$F \\equiv G$。 （3）属性集的闭包：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$上的函数依赖集，$X \\subseteq U$，定义$X$的闭包 $X^+$，作为$X$函数决定的最大属性集$Y$，则最大属性集满足 $X \\rightarrow Y$ 存在于 $F^+$ 中。 【算法4-1】 属性集 $X$ 的闭包 $X^+$ 的迭代算法： i）选$X$作为闭包$X^+$的初始值$X[0]$；ii）由$X[i]$计算$X[i+1]$时，它是由 $X[i]$ 并上属性集合$A$所组成的，其中$A$为$F$中存在的函数依赖 $Y \\rightarrow Z$，而$A \\subseteq Z$，$Y \\subseteq X[i]$。因为$U$是有穷的所以上述过程经过有限步后会达到$X[i] = X[i+1]$，此时$X[i]$为所求的$X^+$。 （4）最小覆盖 i）$F$中任意函数依赖的右部只包含一个属性；ii）不存在这样的函数依赖 $X \\rightarrow A$，使得$F$与 $F- \\{ X \\rightarrow A \\}$ 等价；iii）不存在这样的函数依赖$X \\rightarrow A$，$X$包含真子集$Z(Z \\subset X)$，使得 $(F-\\{ X \\rightarrow A \\} \\cup \\{ Z \\rightarrow A \\})$与$F$等价。如果$F$满足上述条件，则函数依赖$F$称为极小或者最小函数依赖集。 （5）最小覆盖集算法 从函数依赖集$F$构造最小覆盖$M$的算法如下： i）从函数依赖集$F$，创建函数依赖的一个等价集$H$，它的函数依赖的右边只有单个属性（使用分解规则）ii）从函数依赖集$H$，顺次去掉在$H$中非关键的单个函数依赖。一个函数依赖$X \\rightarrow Y$在一个函数依赖集中是非关键的，指如果 $X \\rightarrow Y$ 从$H$中去掉，得到结果$J$，仍然满足$H^+ = J^+$，或者说$H \\equiv J$。iii）从函数依赖集$J$，顺次用左边具有更少属性的函数依赖替换原来的函数依赖，只要不会导致$J^+$改变。iv）从剩下的函数依赖集中收集所有左边相同的函数依赖，使用合并规则创建一个等价的函数依赖集$M$，它的所有依赖的左边是唯一的。 （6）每个函数依赖集$F$都等价于一个极小函数依赖集。 三，关系模式的规范化规范化定义：把一个给定规范模式转化为某种范式的过程称为关系模式的规范过程，简称规范化。 1，第一范式 【定义4-1】 设$R$是一个关系模式，如果$R$的每个属性的值域都是不可分割的简单数据项的集合，则这个模式称为第一范式关系模式，记作1NF。 2，第二范式 【定义4-2】 如果关系模式$R$是第一范式，而且每个非主属性都完全函数依赖于$R$的键，则$R$称为第二范式的关系模式，记作2NF。 3，第三范式 【定义4-3】 设关系模式$R$满足2NF，而且它的任意一个非键属性都不传递依赖于任何候选键，则$R$称为第三范式的关系模式，记作3NF。 4，BCNF 【定义4-4】 设关系模式$R$满足1NF，如果对$R$的每个函数依赖 $X \\rightarrow Y$ 且 $Y \\nsubseteq X$，$X$必为候选键，则$R$满足BCNF，即：在关系模式 $R(U,F)$ 中，如果每个决定因素都包含键，则$R(U,F) \\in BCNF$。 一个满足BCNF的关系模式有如下 条件： i）所有非键属性对每个键都是完全函数依赖；ii）所有的键属性对每个不包含它的键，也是完全函数依赖；iii）没有任何属性完全函数依赖于非键属性的任意一组属性。 5，多值依赖与第四范式 1）多值依赖 （1）多值依赖定义：设 $R(U)$ 是属性集$U$上的一个关系模式，$X$，$Y$，$Z$是$U$的子集，并且 $Z=U-X-Y$，关系模式$R(U)$中多值依赖 $X \\rightarrow \\rightarrow Y$ 成立，当且仅当对$R(U)$的任意关系$r$，给定的一对 $(x，z)$ 值，有一组$Y$的值，这组值仅仅取决于$x$值，而与$z$值无关。 （2）如果 $X \\rightarrow \\rightarrow Y$，而 $Z=\\varnothing$，即$Z$为空，则 $X \\rightarrow \\rightarrow Y$ 称为平凡的多值依赖。 （3）多值依赖的公理（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。） i）对称性规则：如果 $X \\rightarrow \\rightarrow Y$，则 $X \\rightarrow \\rightarrow U-X-Y$；ii）传递性规则：如果 $X \\rightarrow \\rightarrow Y$，$Y \\rightarrow \\rightarrow Z$，则 $X \\rightarrow \\rightarrow Z-Y$；iii）增广规则：如果 $X \\rightarrow \\rightarrow Y$，$V \\subseteq W$，则 $WX \\rightarrow \\rightarrow VY$；iv）替代规则：如果 $X \\rightarrow Y$，则$X \\rightarrow \\rightarrow Y$；v）聚集规则：如果$X \\rightarrow \\rightarrow Y$，$Z \\subseteq Y$，$W \\cap Z = \\varnothing$，$W \\rightarrow Z$，则 $X \\rightarrow Z$。 （4）多值依赖的推导规则（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。） i）合并规则：如果 $X \\rightarrow \\rightarrow Y$， $X \\rightarrow \\rightarrow Z$，则 $X \\rightarrow \\rightarrow YZ$；ii）分解规则：如果 $X \\rightarrow \\rightarrow Y$， $X \\rightarrow \\rightarrow Z$，则 $X \\rightarrow \\rightarrow Y \\cap Z$，$X \\rightarrow \\rightarrow Y-Z$，$X \\rightarrow \\rightarrow Z-Y$；iii）伪传递规则：如果 $X \\rightarrow \\rightarrow Y$，$WY \\rightarrow \\rightarrow Z$，则 $WX \\rightarrow \\rightarrow (Z-WY)$；iv）混合伪传递规则：如果 $X \\rightarrow \\rightarrow Y$，$XY \\rightarrow Z$，则 $X \\rightarrow (Z-Y)$。 （5）在$R(U)$上，如果有 $X \\rightarrow \\rightarrow Y$ 在 $W(W \\subseteq U)$ 上成立，则 $X \\rightarrow \\rightarrow Y$ 称为$R(U)$的嵌入型多值依赖。 2）第四范式 【定义4-5】 设关系模式 $R(U,F) \\in 1NF$，$F$是$R$上的多值依赖集，如果$R$的每个非平凡多值依赖 $X \\rightarrow \\rightarrow Y$（$Y-X \\ne \\varnothing$，$XY$未包含$R$的全部属性），$X$都含有$R$的候选键，则称$R$是第四范式，记为4NF。 6，各范式之间的关系 1）各范式之间的关系 4NF \\subset BCNF \\subset 3NF \\subset 2NF \\subset 1NF2）各范式小结 i）$4NF$：限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖；ii）$3NF \\rightarrow BCNF$：消除主属性对候选关键字的部分和传递函数依赖；iii）$2NF \\rightarrow 3NF$：消除非主属性对候选关键字的传递函数依赖；iv）$1NF \\rightarrow 2NF$：消除非主属性对候选关键字的部分函数依赖。 四，关系模式的分解特性1，关系模式的分解 1）关系模式的分解定义：把一个关系模式分解成若干个关系模式的过程，称为关系模式的分解。 【定义4-6】 关系模式$R(U, F)$ 的分解是指$R$为它的一组子集 $\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 所代替的过程。其中，$U=U_1 \\cup U_2 \\dots \\cup U_k$，并且设 $U_i \\subseteq U_j(1 \\le i,j \\le k)$，$F_i$是$F$在$U$上的投影，即 $F_i = \\{X \\rightarrow Y \\in F^+ \\wedge XY \\subseteq U_i \\}$。 分解后表的连接丢失或者多余元组的分解称为有损分解，或称有损连接分解。 2）关系模式的分解遵守原则： i）无损连接性：信息不失真（不增减信息）；ii）函数依赖保持性：不破坏属性间存在的依赖关系。 2，分解的无损连接性 1）无损连接的概念 【定义4-7】 设$F$是关系模式$R$的函数依赖集，$\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 是$R$ 的一个分解，$r$是$R$的一个关系，定义 m_{\\rho}(r)=\\pi_{U_{1}}(r) \\infty \\pi_{U_{2}}(r) \\infty \\cdots \\infty_{\\pi_{U_{k}}}(r)如果$R$满足$F$的任意关系$r$均有则$r=m_\\rho(r)$，则称分解 $\\rho$ 具有无损连接性。 【引理4-2】 设 $\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 为关系模式$R$的一个分解， $r$是$R$的任一个关系，有 (1) $r \\subseteq m_\\rho(r)$；(2) 如果 $s = m_\\rho(r)$， 则 $\\pi_{U_{i}}(r) = \\pi_{U_{i}}(s)$；(3) $m_\\rho(m_\\rho(r)) = m_\\rho(r)$。 2）进行关系分解的必要性 一个关系模式分解后，可以存放原来所不能存放的信息，通常称为“悬挂”的元组，这是实际所需要的，也是分解的优点。 3）无损连接判定方法 【算法4-2】 (矩阵法)判别一个分解的无损连接性的算法。 (1) 构造初始表：构造一个$k$行$n$列的初始表，其中，每列对应于$R$的一个属性，每行用于表示分解后的一个模式组成。如果属性$A_j$属于关系模式$R_i$，则表示在表的第$i$行第$j$列置符号$a_j$，否则置符号$b_{ij}$。(2) 根据$F$中的函数依赖修改表的内容：考察$F$中的每个函数依赖 $X \\rightarrow Y$，在属性组$X$所在的那些列上寻找具有相同符号的行，如果找到这样的两行或者更多行，则修改这些行，使这些行上属性组$Y$所在的列上元素相同。修改规则是：如果$Y$所在的要修改的行有一个为$a_j$，则这些元素均变成$a_j$；否则改为$b_{mj}$（其中$m$为这些行的最小行号）。(3) 判断分解是否为无损连接：如果通过修改，发现表中有一行变为 $a_1,a_2,\\dots,a_n$，则分解是无损连接的，否则分解不具有无损连接性。 【定理4-1】 （定理法）设 $\\rho = \\{ R_1,R_2 \\}$ 是关系模式$R$的一个分解，$F$是$R$的函数依赖集，$U_1$，$U_2$和$U$分别是$R_1$，$R_2$和$R$的属性集合，那么$\\rho$是$R$(关于$F$)的无损分解的充分必要条件为 (U_1\\cap U_2) \\rightarrow U_1 - U_2 \\in F^+或者 (U_1\\cap U_2) \\rightarrow U_2 - U_1 \\in F^+【定理4-2】 （逐步分解定理）设$F$是关系模式$R$的函数依赖集，$\\rho = \\{ R_1,R_2,\\dots,R_k \\}$ 是$R$关于$F$的一个无损连接。 （1）如果 $\\sigma = \\{ S_1,S_2,\\dots,S_m \\}$ 是 $R_i$ 关于 $F_i$ 的一个无损连接分解，则 $\\varepsilon = \\{ R_1,R_2,\\dots,R_{i-1},S_1,S_2,\\dots,S_m,R_{i+1},\\dots,R_k \\}$ 是$R$关于$F$的无损连接分解，其中，$F_i = \\pi_{R_i}(F)$。（2）设 $\\tau = \\{ R_1,\\dots,R_{k},R_{k+1},\\dots,R_n \\}$ 是 $R$ 的一个分解，其中，$\\tau \\supseteq \\rho$，$\\tau$ 也是$R$关于$F$的无损连接分解。 3）分解的函数依赖保持性 【定义4-8】 设$F$是关系模式$R$的函数依赖集， $\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 为$R$的一个分解，如果 $F_i = \\pi_{R_i}(F)(i=1,2,\\dots,k)$ 的并集 $(F_1 \\cup F_2 \\cup \\dots \\cup F_k)^+ \\equiv F^+$，则称分解 $\\rho$ 具有函数依赖保持性。 3，关系模式分解算法 1）分解的基本要求：分解后的关系模式与分解前的关系模式等价，即分解必须具有无损连接和函数依赖保持性。 2）分解算法的结论 i）如果要求分解具有无损连接性，则分解一定可以达到BCNF； ii）如果要求分解保持函数依赖，则分解可以达到3NF，但不一定能够达到BCNF； iii）如果要求分解既具有无损连接性，又保持函数依赖，则分解可以达到3NF，但不一定能够达到BCNF。 五，关系模式的优化1，水平分解 1）水平分解的定义：水平分解是把关系元组分为若干个子集合，每个子集合定义为一个子关系，以提高系统效率的过程。 2）水平分解的规则： （1）根据“80%与20%原则”，在一个大型关系中，经常使用的数据只是很有限的一部分，可以把经常使用的数据分解出来形成一个子关系。（2）如果关系$R$上具有$n$个事务，而且多数事务存取的数据不相交，则$R$可分解为不大于$n$个子关系，使每个事务存取的数据形成一个关系。 2，垂直分解 1）垂直分解的定义设 $R(A_1,A_2,\\dots,A_k)$ 是关系模式，$R$的一个垂直分解是$n$个关系的集合$\\{ R_1(B_1,B_2,\\dots,B_v),\\dots,R_n(D_1,D_2,\\dots,D_m) \\}$，其中，$\\{B_1,B_2,\\dots,B_v \\},\\dots,\\{ D_1,D_2,\\dots,D_m \\}$ 是 $\\{ A_1,A_2,\\dots,A_k \\}$ 的子集合。 2）垂直分解的基本原则：经常在一起使用的属性从$R$中分解出来形成一个独立的关系。 六，关系查询优化1，关系系统及其查询优化 1）查询优化工作： i）关系数据库内部提供的优化机制；ii）用户通过改变查询的运算次序和建立索引等机制进行优化。 2）关系数据库查询优化的总目标：选择有效的策略，快速求得给定关系表达式的值，以减少查询执行的总开销。 3）查询执行的开销计算 i）在集中式数据库中，总代价=I/O代价+CPU代价ii）在多用户环境下，总代价=I/O代价+CPU代价+内存代价 2，查询优化的一般策略 1）尽量先执行选择运算2）在执行连接前对关系适当地预处理： i）索引连接；ii）排序合并连接 3，关系代数等价变换规则 1）连接，笛卡尔积交换律 E_1 \\times E_2 \\equiv E_2 \\times E_1E_{1} \\infty E_{2} \\equiv E_{2} \\infty E_{1}\\begin{array}{c}{E_{1} \\infty E_{2}} \\\\ {F}\\end{array} \\equiv \\begin{array}{c}{E_{2} \\infty E_{1}} \\\\ {F}\\end{array}2）连接，笛卡尔积结合律 (E_1 \\times E_2) \\times E_3 \\equiv E_1 \\times (E_2 \\times E_3)(E_{1} \\infty E_{2}) \\infty E_{3} \\equiv E_{1} \\infty (E_{2} \\infty E_{3})\\begin{array}{c}{(E_{1} \\infty E_{2}) \\infty E_{3}} \\\\ {F_1} \\quad \\quad {F_2} \\end{array} \\equiv \\begin{array}{c}{E_{1} \\infty (E_{2} \\infty E_{3})} \\\\ {F_1} \\quad \\quad {F_2} \\end{array}3）投影的串接定律 \\pi A_1,A_2,\\dots,A_n(\\pi B_1,B_2,\\dots.B_m(E)) = \\pi A_1,A_2,\\dots,A_n(E)4）选择的串接定律 \\sigma_{F_1}(\\sigma_{F_2}(E)) \\equiv \\sigma_{F_1 \\wedge F_2}(E)5）选择与投影的交换律 F(\\pi A_1,A_2,\\dots,A_n(E)) \\equiv \\pi A_1,A_2,\\dots,A_n(\\sigma_F(E))6）选择与笛卡尔积的交换律 \\sigma_F(E_1 \\times E_2) \\equiv \\sigma_F(E_1) \\times E_2\\sigma_F(E_1 \\times E_2) \\equiv \\sigma_{F_1}(E_1) \\times \\sigma_{F_2}(E_2) （其中F = F_1 \\wedge F_2）\\sigma_F(E_1 \\times E_2) \\equiv \\sigma_{F_2}(\\sigma_{F_1} (E_1) \\times E_2)7）选择与并运算的交换设$E = E_1 \\cup E_2$，$E_1$、$E_2$有相同的属性名，则 \\sigma_F(E_1 \\cup E_2) \\equiv \\sigma_F(E_1) \\cup \\sigma_F(E_2)8）选择与差运算的交换 \\sigma_F(E_1 - E_2) \\equiv \\sigma_F(E_1) - \\sigma_F(E_2)9）投影与笛卡尔积的交换 \\pi A_1,A_2,\\dots,A_n,B_1,B_2,\\dots,B_m(E_1 \\times E_2) \\equiv \\pi A_1,A_2,\\dots,A_n(E_1) \\cup \\pi B_1,B_2,\\dots,B_m(E_2)10）投影与并运算的交换 \\pi A_1,A_2,\\dots,A_n(E_1 \\cup E_2) \\equiv \\pi A_1,A_2,\\dots,A_n(E_1) \\cup \\pi A_1,A_2,\\dots,A_m(E_2)4，关系代数表达式的优化算法 关系系统的查询优化步骤： （1）把查询转换成某种内部表示（2）把语法树转换成标准（优化）形式（3）选择底层的存取路径（4）生成查询计划，选择代价最小的查询计划","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库理论","slug":"db-theory","permalink":"https://zhangbc.github.io/tags/db-theory/"}]},{"title":"【Java基础】Java基础100实例","slug":"【Java基础】Java基础100实例","date":"2019-04-12T14:52:13.000Z","updated":"2019-04-12T15:03:08.080Z","comments":true,"path":"2019/04/12/java_code_100/","link":"","permalink":"https://zhangbc.github.io/2019/04/12/java_code_100/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 通过菜鸟教程-Java教程的初步学习，现将其教程训练代码汇聚成篇。 菜鸟教程-Java Coding学习笔记 Applet应用程序实例 文档注释演示实例 序列化和反序列化 Socket编程—服务端实例 Socket编程—客户端实例 Java进阶知识 遍历演示 Map遍历实例 泛型方法实例 泛型的有界类型参数实例 泛型类实例 类型通配符实例 发邮件(纯文本，HTML文本，附件) 图片二进制转换 JAVA8新特性实例 JAVA操作MYSQL实例 菜鸟教程-Java实例Java 环境设置实例 Java实例 – 如何编译一个Java文件？ Java实例 – Java如何运行一个编译过的类文件？ Java实例 – 如何执行指定class文件目录（classpath）？ Java实例 – 如何查看当前Java运行的版本？ 12$ javac -d . HelloWorld.java$ java com.runoob.HelloWorld Java 字符串 Java 实例 – 字符串比较 Java 实例 - 查找字符串最后一次出现的位置 Java 实例 - 删除字符串中的一个字符 Java 实例 - 字符串替换 Java 实例 - 字符串反转 Java 实例 - 字符串查找 Java 实例 - 字符串分割 Java 实例 - 字符串分割(StringTokenizer) Java 实例 - 字符串大小写转换 Java 实例 - 测试两个字符串区域是否相等 Java 实例 - 字符串性能比较测试 Java 实例 - 字符串优化 Java 实例 - 字符串格式化 Java 实例 - 连接字符串 Java 数组 Java 实例 – 数组排序及元素查找 Java 实例 – 数组添加元素 Java 实例 – 获取数组长度 Java 实例 – 数组反转 Java 实例 – 数组输出 Java 实例 – 数组获取最大和最小值 Java 实例 – 数组合并 Java 实例 – 数组填充 Java 实例 – 数组扩容 Java 实例 – 查找数组中的重复元素 Java 实例 – 删除数组元素 Java 实例 – 数组差集 Java 实例 – 数组交集 Java 实例 – 在数组中查找指定元素 Java 实例 – 判断数组是否相等 Java 实例 - 数组并集 Java 时间处理 Java 实例 - 格式化时间（SimpleDateFormat） Java 实例 - 获取当前时间 Java 实例 - 获取年份、月份等 Java 实例 - 时间戳转换成时间 Java 方法 Java 实例 – 方法重载 Java 实例 – 输出数组元素 Java 实例 – 汉诺塔算法 Java 实例 – 斐波那契数列 Java 实例 – 阶乘 Java 实例 – 方法覆盖 Java 实例 – instanceOf 关键字用法 Java 实例 – break 关键字用法 Java 实例 – continue 关键字用法 Java 实例 – 标签(Label) Java 实例 – enum 和 switch 语句使用 Java 实例 – Enum（枚举）构造函数及方法的使用 Java 实例 – for 和 foreach循环使用 Java 实例 – Varargs 可变参数使用 Java 实例 – 重载(overloading)方法中使用 Varargs 打印图形 Java 实例 – 打印菱形 Java 实例 – 九九乘法表 Java 实例 – 打印三角形 Java 实例 – 打印倒立的三角形 Java 实例 – 打印平行四边形 Java 实例 – 打印矩形 Java 文件操作 Java 实例 - 文件写入 Java 实例 - 读取文件内容 Java 实例 - 删除文件 Java 实例 - 将文件内容复制到另一个文件 Java 实例 - 向文件中追加数据 Java 实例 - 创建临时文件 Java 实例 - 修改文件最后的修改日期 Java 实例 - 获取文件大小 Java 实例 - 文件重命名 Java 实例 - 设置文件只读 Java 实例 - 检测文件是否存在 Java 实例 - 在指定目录中创建文件 Java 实例 - 获取文件修改时间 Java 实例 - 创建文件 Java 实例 - 文件路径比较 Java 目录操作 Java 实例 - 递归创建目录 Java 实例 - 删除目录 Java 实例 - 判断目录是否为空 Java 实例 - 判断文件是否隐藏 Java 实例 - 获取目录大小 Java 实例 - 在指定目录中查找文件 Java 实例 - 获取文件的上级目录 Java 实例 - 获取目录最后修改时间 Java 实例 - 打印目录结构 Java 实例 - 遍历指定目录下的所有目录 Java 实例 - 遍历指定目录下的所有文件 Java 实例 - 在指定目录中查找文件 Java 实例 - 遍历系统根目录 Java 实例 - 查看当前工作目录 Java 实例 - 遍历目录 Java 异常处理 Java 实例 - 异常处理方法 Java 实例 - 多个异常处理（多个catch） Java 实例 - Finally的用法 Java 实例 - 使用 catch 处理异常 Java 实例 - 多线程异常处理 Java 实例 - 获取异常的堆栈信息 Java 实例 - 重载方法异常处理 Java 实例 - 链试异常 Java 实例 - 自定义异常 Java 数据结构 Java 实例 – 数字求和运算 Java 实例 – 利用堆栈将中缀表达式转换成后缀 Java 实例 – 在链表（LinkedList）的开头和结 Java 实例 – 获取链表（LinkedList）的第一个 Java 实例 – 删除链表中的元素 Java 实例 – 获取链表的元素 Java 实例 – 获取向量元素的索引值 Java 实例 – 栈的实现 Java 实例 – 链表元素查找 Java 实例 – 压栈出栈的方法实现字符串反转 Java 实例 – 队列（Queue）用法 Java 实例 – 获取向量的最大元素 Java 实例 – 链表修改 Java 实例 – 旋转向量 Java 集合 Java 实例 – 数组转集合 Java 实例 – 集合比较 Java 实例 – HashMap遍历 Java 实例 – 集合长度 Java 实例 – 集合打乱顺序 Java 实例 – 集合遍历 Java 实例 – 集合反转 Java 实例 – 删除集合中指定元素 Java 实例 – 只读集合 Java 实例 – 集合输出 Java 实例 – 集合转数组 Java 实例 – List 循环移动元素 Java 实例 – 查找 List 中的最大最小值 Java 实例 – 遍历 HashTable 的键值 Java 实例 – 使用 Enumeration 遍历 HashTable Java 实例 – 集合中添加不同类型元素 Java 实例 – List 元素替换 Java 实例 – List 截取 Java 网络实例 Java 实例 – 获取指定主机的IP地址 Java 实例 – 查看端口是否已使用 Java 实例 – 获取本机ip地址及主机名 Java 实例 – 获取远程文件大小 Java 实例 – Socket 实现多线程服务器程序 Java 实例 – 查看主机指定文件的最后修改时间 Java 实例 – 使用 Socket 连接到指定主机 Java 实例 – 网页抓取 Java 实例 – 获取 URL响应头的日期信息 Java 实例 – 获取 URL 响应头信息 Java 实例 – 解析 URL Java 实例 – ServerSocket 和 Socket 通信实例 Java 线程 Java 实例 – 查看线程是否存活 Java 实例 – 获取当前线程名称 Java 实例 – 状态监测 Java 实例 – 线程优先级设置 Java 实例 – 死锁及解决方法 Java 实例 – 获取线程id Java 实例 – 线程挂起 Java 实例 – 终止线程 Java 实例 – 生产者/消费者问题 Java 实例 – 获取线程状态 Java 实例 – 获取所有线程 Java 实例 – 查看线程优先级 Java 实例 – 中断线程 github代码送门: java_projects/runoob 腾讯云coding代码送门: java_project/dev","categories":[{"name":"Java","slug":"java","permalink":"https://zhangbc.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"java-basic","permalink":"https://zhangbc.github.io/tags/java-basic/"}]},{"title":"【Java基础】Java扩展知识","slug":"【Java基础】Java扩展知识","date":"2019-04-12T14:19:34.000Z","updated":"2019-04-12T14:24:20.104Z","comments":true,"path":"2019/04/12/java_extend_knowledge/","link":"","permalink":"https://zhangbc.github.io/2019/04/12/java_extend_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java文档注释1）Java支持三种注释方式，分别是//、/* */、/** */(说明注释)。 2）javadoc标签 标签 描述 示例 @author 标识一个类的作者 @author description @deprecated 指名一个过期的类或成员 @deprecated description {@docRoot} 指明当前文档根目录的路径 Directory Path @exception 标志一个类抛出的异常 @exception exception-name explanation {@inheritDoc} 从直接父类继承的注释 Inherits a comment from the immediate surperclass. {@link} 插入一个到另一个主题的链接 {@link name text} {@linkplain} 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic. @param 说明一个方法的参数 @param parameter-name explanation @return 说明返回值类型 @return explanation @see 指定一个到另一个主题的链接 @see anchor @serial 说明一个序列化属性 @serial description @serialData 明通过writeObject( ) 和 writeExternal( )方法写的数据 @serialData description @serialField 说明一个ObjectStreamField组件 @serialField name type description @since 标记当引入一个特定的变化时 @since release @throws 和 @exception标签一样. The @throws tag has the same meaning as the @exception tag. {@value} 显示常量的值，该常量必须是static属性。 Displays the value of a constant, which must be a static field. @version 指定类的版本 @version info 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.runoob;​​import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;​/** * 文档注释演示实例 * @author zhangbc * @version 1.0 */public class SquareNumber &#123; /** * This method returns the square of number. * This is a multiline description. You can use as many lines as you like. * @param number The value to be squared. * @return number squared. */ public double square(double number) &#123; return number * number; &#125;​ /** * This method input a number from the user. * @return The value input as a double. * @throws IOException in input error * @see IOException */ public double getNumber() throws IOException &#123; InputStreamReader isr = new InputStreamReader(System.in); BufferedReader inData = new BufferedReader(isr); String str; str = inData.readLine(); return Double.parseDouble(str); &#125;​ /** * This method demonstrates square(). * @param args args unused. * @throws IOException on input error. * @see IOException */ public static void main(String[] args) throws IOException &#123; SquareNumber sn = new SquareNumber(); double val; System.out.print(\"Enter value to be squared:\"); val = sn.getNumber(); val = sn.square(val); System.out.println(\"Squared value is : \" + val); &#125;&#125; 2，Java 8 新特性1）Java8(即jdk1.8)新特性 （1）Lambda 表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。（2）方法引用：可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。（3）默认方法：默认方法就是一个在接口里面有了一个实现的方法。（4）新工具：新的编译工具，如：Nashorn引擎jjs、 类依赖分析器jdeps。（5）Stream API：把真正的函数式编程风格引入到Java中。（6）Date Time API：加强对日期与时间的处理。（7）Optional 类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。（8）Nashorn, JavaScript 引擎：允许我们在JVM上运行特定的javascript应用。 3，Java MySQL连接 MysqlDemo.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.runoob;​import java.sql.*;​/** * 连接数据库实例 * @author zhangbc * @version v1.0 * @date 2019/3/28 22:14 */public class MysqlDemo &#123;​ /** * JDBC驱动名及其数据库URL */ static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://127.0.0.1:3306/pyspider_db\";​ /** * 数据库的用户与密码 */ static final String USER = \"root\"; static final String PASSWORD = \"xxxxxx\";​ public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; Class.forName(JDBC_DRIVER); System.out.println(\"连接数据库...\"); conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);​ System.out.println(\"实例化Statement对象...\"); stmt = conn.createStatement(); String sql; sql = \"select id, name, url from websites;\"; ResultSet rs = stmt.executeQuery(sql);​ while (rs.next()) &#123; int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String url = rs.getString(\"url\");​ System.out.printf(\"ID: %d\\t站点名称：%s\\t站点URL：%s\\n\", id, name, url); &#125;​ rs.close(); stmt.close(); conn.close(); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125;​ try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4，Java 9 新特性详情参见：Java 9 新特性","categories":[{"name":"Java","slug":"java","permalink":"https://zhangbc.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"java-basic","permalink":"https://zhangbc.github.io/tags/java-basic/"}]},{"title":"【Java基础】Java网络编程","slug":"【Java基础】Java网络编程","date":"2019-04-12T14:13:28.000Z","updated":"2019-04-12T14:21:49.206Z","comments":true,"path":"2019/04/12/java_net_program/","link":"","permalink":"https://zhangbc.github.io/2019/04/12/java_net_program/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java网络编程1）概述 网络编程：编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net包中J2EE的API包含有类和接口，他们提供低层次的通信细节。主要有： TCP：传输控制协议，保障了两个应用程序之间的可靠通信，通常用于互联网协议，称为TCP/IP； UDP：用户数据报协议，一个无连接的协议，提供了应用程序之间要发送的数据的数据包。 2）Socket编程 套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。 当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 3）ServerSocket类的方法：服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。 4）Socket类的方法：java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。 5）InetAddress类的方法：表示互联网协议（IP）地址。 6）demo实例 GreetingClient.java 1234567891011121314151617181920212223242526272829import java.io.*;import java.net.Socket;/** * Socket编程--客户端实例 * @author zhangbc * @date 2019/3/7 14:26 */public class GreetingClient &#123; public static void main(String[] args) &#123; String serverName = args[0]; int port = Integer.parseInt(args[1]); try &#123; System.out.println(\"连接到主机：\" + serverName + \", 端口号：\" + port); Socket client = new Socket(serverName, port); System.out.println(\"远程主机地址：\" + client.getRemoteSocketAddress()); OutputStream outServer = client.getOutputStream(); DataOutputStream outData = new DataOutputStream(outServer); outData.writeUTF(\"Hello from \" + client.getLocalSocketAddress()); InputStream inFromServer = client.getInputStream(); DataInputStream inData = new DataInputStream(inFromServer); System.out.println(\"服务器响应：\" + inData.readUTF()); client.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; GreetingServer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketTimeoutException;import java.lang.Thread;/** * @author zhangbc * @date 2019/3/7 15:09 */public class GreetingServer extends Thread &#123; private ServerSocket serverSocket; public static void main(String[] args) &#123; int port = Integer.parseInt(args[0]); try &#123; Thread thread = new GreetingServer(port); thread.run(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; public GreetingServer(int port) throws IOException &#123; serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(10000); &#125; public void run() &#123; while (true) &#123; try &#123; System.out.println(\"等待远程连接，端口号为：\" + serverSocket.getLocalPort() + \"...\"); Socket server = serverSocket.accept(); DataInputStream inData = new DataInputStream(server.getInputStream()); System.out.println(inData.readUTF()); DataOutputStream outData = new DataOutputStream(server.getOutputStream()); outData.writeUTF(\"谢谢连接我：\" + server.getLocalSocketAddress() + \"\\nGoodbye!\"); server.close(); &#125; catch (SocketTimeoutException es) &#123; System.out.println(\"Socket timed out!\"); break; &#125; catch (IOException ex) &#123; ex.printStackTrace(); break; &#125; &#125; &#125;&#125; 2，Java发送邮件 SendEmail.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.runoob;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import javax.mail.Message.RecipientType;import java.util.Properties;/** * 发邮件(纯文本，HTML文本，附件) * @author zhangbocheng * @version v1.0 * @date 2019/3/7 20:40 */public class SendEmail &#123; public static void main(String[] args) throws NullPointerException &#123; // 收件人邮箱 String to = \"xxxxxxxxxxxxxxxxx@qq.com\"; // 发件人邮箱 final String from = \"xxxxxxxxxxxxxxxxx@163.com\"; final String pwd = \"xxxxxxxx\"; // 指定发邮件的主机 String host = \"smtp.163.com\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.host\", host); properties.put(\"mail.smtp.auth\", \"true\"); // 获取默认Session对象 Session session = Session.getDefaultInstance(properties, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(from, pwd); &#125; &#125;); try &#123; // 创建默认的MimeMessage对象 MimeMessage message = new MimeMessage(session); // Set From：头部头字段 message.setFrom(new InternetAddress(from)); // Set To：头部头字段 message.addRecipient(RecipientType.TO, new InternetAddress(to)); // Set Subject：头部头字段 message.setSubject(\"This is the Subject Line!\"); // 设置消息体 message.setText(\"This is test text.\"); // 发送HTML消息，可以插入html标签 message.setContent(\"&lt;h1&gt;This is actual message&lt;/h1&gt;\", \"text/html;charset=utf-8\"); // 创建消息部分 BodyPart messageBodyPart = new MimeBodyPart(); // 消息 messageBodyPart.setText(\"This is message body.\"); // 创建多重消息 Multipart multipart = new MimeMultipart(); // 设置文本消息 multipart.addBodyPart(messageBodyPart); // 附件部分 messageBodyPart = new MimeBodyPart(); String fileName = \"/home/projects/java_pro/java_instances_demo/src/main/java/com/runoob/SendEmail.java\"; DataSource source = new FileDataSource(fileName); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(fileName); multipart.addBodyPart(messageBodyPart); // 发送完整部分 message.setContent(multipart); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully.\"); &#125; catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125; 3，Java Applet基础1）Applet基础 Applet是一种Java程序，一般运行在支持Java的Web浏览器内，是一个全功能的Java应用程序。 Java 中 Applet 类继承了 java.applet.Applet 类。 Applet 类没有定义 main()，所以一个 Applet 程序不会调用 main() 方法。 Applet 被设计为嵌入在一个 HTML 页面。 当用户浏览包含 Applet 的 HTML 页面，Applet 的代码就被下载到用户的机器上。 要查看一个 Applet 需要 JVM。 JVM 可以是 Web 浏览器的一个插件，或一个独立的运行时环境。 用户机器上的 JVM 创建一个 Applet 类的实例，并调用 Applet 生命周期过程中的各种方法。 Applet 有 Web 浏览器强制执行的严格的安全规则，Applet 的安全机制被称为沙箱安全。 Applet 需要的其他类可以用 Java 归档（JAR）文件的形式下载下来。 2）Applet的生命周期 Applet 类中的四个方法给我们提供了一个框架： init: 提供所需的任何初始化。在 Applet 标记内的 param 标签被处理后调用该方法。 start: 浏览器调用 init 方法后，该方法被自动调用。每当用户从其他页面返回到包含 Applet 的页面时，则调用该方法。 stop: 当用户从包含 Applet 的页面移除的时候，该方法自动被调用。 destroy: 此方法仅当浏览器正常关闭时调用。 paint: 该方法在 start() 方法之后立即被调用，或者在 Applet 需要重绘在浏览器的时候调用。paint() 方法实际上继承于 java.awt。 3）Applet类 每一个 Applet 都是 java.applet.Applet 类的子类，基础的 Applet 类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。 4）Applet的调用 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello World, Applet&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hr&gt;&lt;applet code=\"HelloWorldApplet.class\" width=\"320\" height=\"120\"&gt;&lt;/applet&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Java","slug":"java","permalink":"https://zhangbc.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"java-basic","permalink":"https://zhangbc.github.io/tags/java-basic/"}]},{"title":"【Java基础】Java进阶编程","slug":"【Java基础】Java进阶编程","date":"2019-04-11T14:05:07.000Z","updated":"2019-04-11T16:14:43.141Z","comments":true,"path":"2019/04/11/java_advance_program/","link":"","permalink":"https://zhangbc.github.io/2019/04/11/java_advance_program/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java数据结构Java工具包提供了强大的数据结构，在Java中的数据结构主要包括以下接口和类：枚举（Enumeration），位集合（BitSet），向量（Vector），栈（Stack），字典（Dictionary），哈希表（Hashtable），属性（Properties）。 1）枚举（Enumeration）：该接口定义了一种从数据结构中取回连续元素的方式。 2）位集合（BitSet）：该类实现了一组可以单独设置和清除的位或标志。 3）向量（Vector）：对象的元素通过索引访问，在创建时不必给对象指定大小，其大小会根据需要动态的变化。 4）栈（Stack）：实现了一个后进先出的数据结构，是Vector的一个子类。 5）字典（Dictionary）：是一个抽象类，定义了键映射到值的数据结构。当想要通过特定的键而不是整数索引来访问数据时，应使用Dictionary。注意：Dictionary类已经过时了，在实际开发中，你可以实现Map接口来获取键/值的存储功能。 6）哈希表（Hashtable）：提供了一种在用户定义键结构的基础上来组织数据的手段。Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。 7）属性（Properties）：继承于 Hashtable.Properties 类表示了一个持久的属性集；属性列表中每个键及其对应值都是一个字符串。 2，Java集合框架1）集合框架设计目标 （1）必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的；（2）允许不同类型的集合，以类似的方式工作，具有高度的互操作性；（3）对一个集合的扩展和适应必须是简单的。 2）Java集合框架图 3）集合框架是一个用来代表和操纵集合的统一架构，包含如下内容： （1）接口：是代表集合的抽象数据类型。例：Collection，List，Set，Map等。（2）实现（类）：是集合接口的具体实现。从本质上，他们是可重复使用的数据结构，例：ArrayList，LinkedList，HashSet，HashMap。（3）算法：是实现集合接口的对象里的方法执行的一些有用的计算，例：搜索和排序，这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。 集合框架的类和接口均在java.util包中。任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 4）集合接口 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。 List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 5）集合实现类（集合类）：Java提供了一套实现了Collection接口的标准集合类。 6）集合算法：集合定义了三个不可改变的静态变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP。Collection Algorithms是一个列表中的所有算法实现。 7）迭代：使用Java Iterator，通过实例列出Iterator和listIterator接口提供的所有方法。 ArrayListDemo.java 123456789101112131415161718192021222324252627282930public class ArrayListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"Hello\"); list.add(\"World\"); list.add(\"Maven\"); list.add(\"Demo\");​ // 遍历1：使用foreach遍历List System.out.println(\"使用foreach遍历List:\"); for (String str: list) &#123; System.out.print(str + \" \"); &#125;​ // 遍历2：把链表变为数组相关的内容进行遍历List String[] strArray = new String[list.size()]; list.toArray(strArray); System.out.println(\"\\n把链表变为数组相关的内容进行遍历List:\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.print(strArray[i] + \" \"); &#125;​ // 遍历3：使用迭代器进行相关遍历List Iterator&lt;String&gt; iterator = list.iterator(); System.out.println(\"\\n使用迭代器进行相关遍历List:\"); while (iterator.hasNext()) &#123; System.out.print(iterator.next() + \" \"); &#125; &#125;&#125; MapDemo.java 1234567891011121314151617181920212223242526272829303132333435public class MapDemo &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"key1\", \"value1\"); map.put(\"key2\", \"value2\"); map.put(\"key3\", \"value3\");​ // 遍历1：通过Map.KeySet遍历 System.out.println(\"通过Map.KeySet遍历key与value：\"); for (String key: map.keySet()) &#123; System.out.println(\"key=\" + key + \", value=\" + map.get(key)); &#125;​ // 遍历2：通过Map.entrySet使用iterator遍历 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(\"key=\" + entry.getKey() + \", value=\" + entry.getValue()); &#125;​ // 遍历3：推荐，通过Map.entrySet遍历 System.out.println(\"通过Map.entrySet遍历key和value:\"); for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; System.out.println(\"key=\" + entry.getKey() + \", value=\" + entry.getValue()); &#125;​ // 遍历4：通过Map.values()遍历 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key：\"); for (String val: map.values()) &#123; System.out.println(\"value=\" + val); &#125; &#125;&#125; 8）比较器：使用 Java Comparator，通过实例列出Comparator接口提供的所有方法。 3，Java泛型1）Java泛型（generics） 是JDK5中引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，即：所操作的数据类型被指定为一个参数。 2）定义泛型方法的规则 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt;E&gt;）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（如int,double,char的等）。 123456789101112131415161718192021222324252627282930/** * 泛型方法实例 */class GenericMethod &#123; public static void main(String[] args) &#123; // 创建不同类型的数组：Integer，Double和Character Integer[] intArray = &#123;1, 2, 3, 4, 5&#125;; Double[] doubleArray = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; Character[] charArray = &#123;'H', 'E', 'L', 'L', '0'&#125;;​ System.out.println(\"整型数组元素为：\"); printArray(intArray); System.out.println(\"双精度小数数组元素为：\"); printArray(doubleArray); System.out.println(\"字符型数组元素为：\"); printArray(charArray); &#125;​ /** * 泛型方法printArray * @param inputArray * @param &lt;E&gt; */ public static &lt;E&gt; void printArray(E[] inputArray) &#123; for (E element: inputArray) &#123; System.out.printf(\"%s \", element); &#125; System.out.println(); &#125;&#125; 3）有界的类型参数：限制那些被允许传递到一个类型参数的类型种类范围。声明首先要列出类型参数的名称，后跟 extends 关键字，最后紧跟它的上界。 123456789101112131415161718192021222324252627/** * 泛型的有界类型参数实例 */class MaxGenericMethod &#123; public static void main(String[] args) &#123; System.out.printf(\"%d,%d和%d中最大的数为%d.\\n\\n\", 3, 4, 5, maximum(3, 4, 5));​ System.out.printf(\"%.2f,%.2f和%.2f中最大的数为%.2f.\\n\\n\", 6.6, 7.7, 8.8, maximum(6.6, 7.7, 8.8));​ System.out.printf(\"%s,%s和%s中最大的数为%s.\\n\\n\", \"pear\", \"apple\", \"orange\", maximum(\"pear\", \"apple\", \"orange\")); &#125;​ public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) &#123; T max = x; if (y.compareTo(max) &gt; 0) &#123; max = y; &#125; if (z.compareTo(max) &gt; 0) &#123; max = z; &#125; return max; &#125;&#125; 4）泛型类：在类名后面添加类型参数声明部分。泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 123456789101112131415161718192021222324/** * 泛型类实例 * @param &lt;T&gt; */class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125;​ public T get() &#123; return t; &#125;​ public static void main(String[] args) &#123; Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); Box&lt;String&gt; stringBox = new Box&lt;&gt;(); integerBox.add(10); stringBox.add(\"菜鸟教程\");​ System.out.printf(\"整型值为：%d\\n\", integerBox.get()); System.out.printf(\"字符串为：%s\\n\", stringBox.get()); &#125;&#125; 5）类型通配符：一般使用?代替具体的类型参数。 （1）类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型；（2）类型通配符下限通过形如List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型。 1234567891011121314151617181920212223242526/** * 类型通配符实例 */class Wildcard &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;&gt;(); List&lt;Number&gt; number = new ArrayList&lt;&gt;();​ name.add(\"icon\"); age.add(18); number.add(314);​ getData(name); getUpperNumber(age); getUpperNumber(number); &#125;​ public static void getData(List&lt;?&gt; data) &#123; System.out.printf(\"data: %s\\n\", data.get(0)); &#125;​ public static void getUpperNumber(List&lt;? extends Number&gt; data) &#123; System.out.println(\"data: \" + data.get(0)); &#125;&#125; 4，Java序列化1）Java序列化：Java提供了一种对象序列化的机制，该机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据，有关对象的类型的信息和存储在对象中数据的类型。 （1）序列化一个对象，并将它发送到输出流。1public final void writeObject(Object x) throws IOException （2）从流中取出下一个对象，并将对象反序列化。1public final void readObject(Object x) throws IOException, ClassNotFundException 2）完整demo实例： Employee.java 12345678910111213141516171819package runoob;​import java.io.*;​/** * Employee类实现Serializable接口 * @author 张伯成 * @date 2019/3/7 12:30 */public class Employee implements Serializable &#123; public String name; public String address; public transient int SSN; public int number;​ public void mailCheck() &#123; System.out.println(\"Mailing a check to \" + name + \" \" + address); &#125;&#125; SerializeDemo.java 12345678910111213141516171819202122232425/** * SerializeDemo类，序列化对象 */class SerializeDemo &#123; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.name = \"Reyan Ali\"; employee.address = \"Phonkka kuan, Ambehta Peer.\"; employee.SSN = 11122333; employee.number = 101;​ try &#123; FileOutputStream fileOut = new FileOutputStream(\"employee.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(employee); out.close(); fileOut.close(); System.out.println(\"Serialized data is saved in employee.ser.\"); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;​ DeserializeDemo.java 123456789101112131415161718192021222324252627/** * DeserializeDemo类，反序列化对象 */class DeserializeDemo &#123; public static void main(String[] args) &#123; Employee employee; try &#123; FileInputStream fileIn = new FileInputStream(\"employee.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); employee = (Employee) in.readObject(); in.close(); fileIn.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); return; &#125; catch (ClassNotFoundException ex) &#123; System.out.println(\"Employee class not found.\"); ex.printStackTrace(); return; &#125; System.out.println(\"Deserialize Employee...\"); System.out.println(\"Name: \" + employee.name); System.out.println(\"Address: \" + employee.address); System.out.println(\"SSN: \" + employee.SSN); System.out.println(\"Number: \" + employee.number); &#125;&#125;","categories":[{"name":"Java","slug":"java","permalink":"https://zhangbc.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"java-basic","permalink":"https://zhangbc.github.io/tags/java-basic/"}]},{"title":"【Java基础】Java面向对象","slug":"【Java基础】Java面向对象","date":"2019-04-11T11:57:07.000Z","updated":"2019-04-11T12:07:56.393Z","comments":true,"path":"2019/04/11/java_object_oriented/","link":"","permalink":"https://zhangbc.github.io/2019/04/11/java_object_oriented/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java 继承1）Java继承的概念：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 2）Java继承类型：Java不支持多继承，但是支持多重继承。3）Java继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 4）Java继承关键字 继承可以使用extends和implements这两个关键字来实现继承，都继承于java.lang.Object，默认继承object祖先类。 （1）extends：只能继承一个类。（2）implements：可以变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口。（3）super：通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。（4）this：指向自己的引用。（5）finally：声明类可以把类定义为不能继承的，即最终类；或用于修饰方法，该方法不能被子类重写。 5）Java构造器 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 ExtendsDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.springboot;​/** * @function: * @author: 张伯成 * @date: 2019/3/3 */public class ExtendsDemo &#123; public static void main(String[] args) &#123; System.out.println(\"==========SubClassOne 类继承===========\"); SubClassOne sc1 = new SubClassOne(); SubClassOne sc2 = new SubClassOne(100); System.out.println(\"==========SubClassTwo 类继承===========\"); SubClassTwo sc3 = new SubClassTwo(); SubClassTwo sc4 = new SubClassTwo(200); &#125;&#125;​​/** * SuperClass 祖先类 */class SuperClass &#123; private int number; SuperClass() &#123; System.out.println(\"SuperClass()\"); &#125;​ SuperClass(int number) &#123; this.number = number; System.out.println(\"SuperClass(int number)\"); &#125;&#125;​​/** * SubClassOne 类继承 */class SubClassOne extends SuperClass &#123; private int number; SubClassOne() &#123; System.out.println(\"SubClassOne()\"); &#125;​ SubClassOne(int number) &#123; super(300); this.number = number; System.out.println(\"SubClassOne(int number): \" + number); &#125;&#125;​​/** * SubClassTwo 类继承 */class SubClassTwo extends SuperClass &#123; private int number; SubClassTwo() &#123; super(300); System.out.println(\"SubClassTwo()\"); &#125;​ SubClassTwo(int number) &#123; this.number = number; System.out.println(\"SubClassTwo(int number): \" + number); &#125;&#125; 2，Java Override/Overload1）重写（Override）重写是子类对父类对允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写。重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。1234567891011121314151617181920212223242526272829/** * Animal类，祖先类 */class Animal &#123; public void move() &#123; System.out.println(\"动物可以移动...\"); &#125;&#125;​​/** * AnimalDog类，继承Animal，并重写父类的move()方法 */class AnimalDog extends Animal &#123; public void move() &#123; super.move(); System.out.println(\"狗可以跑和走.\"); &#125;&#125;​​class DogTest &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); Animal dog = new AnimalDog(); animal.move(); dog.move(); &#125;&#125; 2）方法的重写规则 参数列表必须完全与被重写方法的相同。 返回类型必须完全与被重写方法的返回类型相同。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 3）super：当需要在子类中调用父类的被重写方法时，要使用super关键字。 4）重载（Overload）：在一个类里面，方法名字相同，而参数不同，返回类型可同可不同。 5）重载规则 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载； 无法以返回值类型作为重载函数的区分标准。 OverLoading.java12345678910111213141516171819202122232425262728public class OverLoading &#123; public int test() &#123; System.out.println(\"test()\"); return 1; &#125;​ public void test(int number) &#123; System.out.println(\"test(int)\"); &#125;​ public String test(int number, String str) &#123; System.out.println(\"test(int, String)\"); return \"test(int, String)\"; &#125;​ public String test(String str, int number) &#123; System.out.println(\"test(String,int)\"); return \"test(String,int)\"; &#125;​ public static void main(String[] args) &#123; OverLoading overLoad = new OverLoading(); System.out.println(overLoad.test()); overLoad.test(100); System.out.println(overLoad.test(100, \"test3\")); System.out.println(overLoad.test(\"test\", 100)); &#125;&#125; 6）重写和重载的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 3，Java 多态多态是同一个行为具有多个不同表现形式或形态的能力。多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 1）多态的优点：消除类型之间的耦合关系；可替换性；可扩充性；接口性；灵活性；简化性。 2）多态存在的三个必要条件：继承；重写；父类引用指向子类对象。 PolymorphicDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.example.springboot;​/** * @function: * @author: 张伯成 * @date: 2019/3/3 */public class PolymorphicDemo &#123; public static void main(String[] args) &#123; show(new Cat()); show(new Dog());​ Animals animal = new Cat(); animal.eat();​ Cat cat = (Cat) animal; cat.work(); &#125;​ public static void show(Animals animal) &#123; animal.eat();​ if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.work(); &#125; else if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.work(); &#125; &#125;&#125;​​abstract class Animals &#123; abstract void eat();&#125;​​class Cat extends Animals &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125;​ public void work() &#123; System.out.println(\"抓老鼠\"); &#125;&#125;class Dog extends Animals &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125;​ public void work() &#123; System.out.println(\"看家\"); &#125;&#125; 3）虚函数：虚函数的存在是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。 4）多态的实现方式：重写；接口；抽象类和抽象方法。 4，Java 抽象类在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 1）抽象类：在Java语言中使用abstract class定义抽象类。 2）继承抽象类 3）抽象方法：abstract 关键字可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体；抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 4）抽象类总结规定 （1）抽象类不能被实例化；只有抽象类的非抽象子类可以创建对象；（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能；（4）构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法；（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 5，Java 封装1）在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装 最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 2）封装的优点 （1）两个的封装能够减少耦合；（2）类内部的结构可以自由修改；（3）可以对成员变量进行更精确的控制；（4）隐藏信息，实现细节。 6，Java 接口1）接口概念 接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 2）接口与类相似点 一个接口可以有多个方法。 接口文件保存在.java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 3）接口与类的区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 4）接口特性 接口是隐式的，接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 接口的方法都是公有的。 5）抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 6）接口的声明1234[可见度] interface 接口名称 [extends 其他的接口名名] &#123; // 声明变量 // 抽象方法&#125; 7）接口的实现：当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类；类使用implements关键字实现接口，在类声明中，implements关键字放在class声明后面。 （1）重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 （2）在实现接口的时候，需要注意以下规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 8）接口的继承 9）接口的多继承：在Java中，类的多继承是不合法，但接口允许多继承；在接口的多继承中extenfs关键字只需要用一次，在其后跟着继承接口。 10）标记接口 标记接口是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。 标记接口的作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 标记接口的主要目的：建立一个公共的父接口；向一个类添加数据类型。 7，Java 包（Package） 1）包的作用 （1）把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。（2）如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。（3）包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 总之，Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 2）创建包 3）import语句：为了能够使用某一个包的成员，需要在Java程序中明确导入该包。 4）package的目录结构 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 5）设置CLASSPATH系统变量 用下面的命令显示当前的CLASSPATH变量： 12345# Windows 平台（DOS 命令行下）$ C:\\&gt; set CLASSPATH# UNIX 平台（Bourne shell 下）$ echo $CLASSPATH 删除当前CLASSPATH变量内容： 1234# Windows 平台（DOS 命令行下）$ C:\\&gt; set CLASSPATH=# UNIX 平台（Bourne shell 下）$ unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量： 1234# Windows 平台（DOS 命令行下）$ C:\\&gt; set CLASSPATH=C:\\users\\jack\\java\\classes# UNIX 平台（Bourne shell 下）$ CLASSPATH=/home/jack/java/classes; export CLASSPATH","categories":[{"name":"Java","slug":"java","permalink":"https://zhangbc.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"java-basic","permalink":"https://zhangbc.github.io/tags/java-basic/"}]},{"title":"【Java基础】Java基础知识","slug":"【Java基础】Java基础知识","date":"2019-04-10T16:39:20.000Z","updated":"2019-04-10T17:10:49.729Z","comments":true,"path":"2019/04/11/java_basic_knowledge/","link":"","permalink":"https://zhangbc.github.io/2019/04/11/java_basic_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java基本数据类型变量就是申请内存来存储值。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 Java有两大数据类型：内置数据类型和引用数据类型。 1）内置数据类型 名称 描述 取值范围 默认值 主要用途 byte 8位，有符号的，以二进制补码表示的整数 - $2^7$ ~ $2^7$ -1 0 在大型数组中节约空间，代替整数 short 16位，有符号的，以二进制补码表示的整数 -$2^{15}$~$2^{15}$-1 0 节省空间 int 32位，有符号的，以二进制补码表示的整数 -$2^{31}$~$2^{31}$-1 0 整型变量的默认类型 long 64位，有符号的，以二进制补码表示的整数 -$2^{63}$~$2^{63}$-1 0L 使用在需要比较大整数的系统上 float 单精度、32位、符合IEEE 754标准的浮点数 -$2^{31}$~$2^{31}$-1 0.0f 在存储大型浮点数组时可以节省空间；不能用来表示精确的值 double 双精度、64位、符合IEEE 754标准的浮点数 -$2^{63}$~$2^{63}$-1 0.0d 浮点数变量的默认类型 boolean 表示一位的信息 true,false false 作为一种标记来记录true/false情况 char 单一的 16 位 Unicode 字符 \\u0000~\\uffff(0~$2^{16}$-1) 存储任何字符 2）引用类型 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 3）Java常量：常量在程序运行时，不会被修改，关键字final。通常使用大写字母表示常量。 4）Java类型转换 自动类型转换：转换从低级到高级。 数据类型转换满足的原则：（1）不能对boolean类型进行类型转换；（2）不能把对象类型转换成不相关类的对象；（3）在把容量大的类型转换为容量小的类型时必须使用强制类型转换；（4）转换过程中可能导致溢出或损失精度；（5）浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。 强制类型转换：条件是转换的数据类型必须是兼容的。 隐含强制类型转换 2，Java语句类型1）循环结构 while do...while for foreach 增强型for循环：主要用于数组 demo：1234567891011121314151617public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(\",\"); &#125; System.out.print(\"\\n\"); String [] names =&#123;\"James\", \"Larry\", \"Tom\", \"Lacy\"&#125;; # 增强型for循环 for( String name : names ) &#123; System.out.print( name ); System.out.print(\",\"); &#125; &#125;&#125; 2）break语句：主要用于循环语句或者switch语句中；跳出最里层的循环，并且继续执行该循环下面的语句。 3）continue语句：适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代。 4）分支结构 if：一个if语句包含一个布尔表达式和一条或多条语句。 switch case语句：判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 3，Java基础类1）Number &amp; Math类 2）Math类：包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 3）Character类：对单个字符进行操作。 将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 4）String类 用于获取有关对象的信息的方法称为访问器方法。 5）StringBuffer和StringBuilder类 和String类不同的是，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder类在Java 5中被提出，它和StringBuffer之间的最大不同在于 StringBuilder的方法不是线程安全的（不能同步访问）。 由于StringBuilder相较于StringBuffer有速度优势，所以多数情况下建议使用 StringBuilder类。 在应用程序要求线程安全的情况下，则必须使用 StringBuffer类。 4，Java数组1）声明数组123dataType[] arrayRefVar; // 首选的方法 # ordataType arrayRefVar[]; // 效果相同，但不是首选方法 2）创建数组 1arrayRefVar = new dataType[arraySize]; 3）多维数组1234567891011type[][] typeName = new type[typeLength1][typeLength2]; // 直接为每一维分配空间​// 从最高维开始，分别为每一维分配空间String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String(\"Good\");s[0][1] = new String(\"Luck\");s[1][0] = new String(\"to\");s[1][1] = new String(\"you\");s[1][2] = new String(\"!\"); 4）Arrays类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法，按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 5，Java日期时间java.util包提供了Date类来封装当前的日期和时间。 Date类提供两个构造函数来实例化 Date 对象。第一个构造函数使用当前日期和时间来初始化对象。1Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。1Date(long millisec) 1）获取当前日期时间12345678import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; Date date = new Date(); System.out.println(date.toString()); &#125;&#125; 2）日期比较 getTime()：获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 before(), after(), equals() compareTo()：由Comparable接口定义的，Date类实现了这个接口。 3）格式化日期时间 SimpleDataFormat1234567public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); SimpleDateFormat ft = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(\"当前时间为：\"+ft.format(now)); &#125;&#125; printf1234567891011121314151617public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); //c的使用 System.out.printf(\"全部日期和时间信息：%tc%n\", now); //f的使用 System.out.printf(\"年-月-日格式：%tF%n\", now); //d的使用 System.out.printf(\"月/日/年格式：%tD%n\", now); //r的使用 System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\", now); //t的使用 System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\", now); //R的使用 System.out.printf(\"HH:MM格式（24时制）：%tR\", now); &#125;&#125; 4）Java休眠（Sleep）1234567891011public class SleepDemo &#123; public static void main(String[] args) &#123; try &#123; System.out.println(new Date()+\"\\n\"); Thread.sleep(1000*5); System.out.println(new Date()+\"\\n\"); &#125; catch (Exception ex)&#123; System.out.println(\"Got an exception: \"+ex); &#125; &#125;&#125; 5）Calendar类123456789101112131415161718192021public class DateTestDemo &#123; public static void main(String[] args) &#123; // 创建一个代表系统当前日期的Calendar对象 Calendar now = Calendar.getInstance(); int year = now.get(Calendar.YEAR); int month = now.get(Calendar.MONTH); int day = now.get(Calendar.DAY_OF_WEEK); int date = now.get(Calendar.DATE); int hour = now.get(Calendar.HOUR_OF_DAY); int minute = now.get(Calendar.MINUTE); int second = now.get(Calendar.SECOND);​ System.out.println(now.getTime()); System.out.printf(\"%d-%d-%d %d:%d:%d\\n%d\\n\", year, month, day, hour, minute, second, date);​ // 创建一个表示2009年3月12日的Calendar对象 now.set(2009, 3-1, 12); System.out.println(now.getTime()); &#125;&#125; 6）GregorianCalendar类：实现了公历日历，是Calendar类的一个具体实现。1234567891011public class DateTestDemo &#123; public static void main(String[] args) &#123; GregorianCalendar gCalender = new GregorianCalendar(); int year = gCalender.get(Calendar.YEAR); if (gCalender.isLeapYear(year)) &#123; System.out.println(\"当前年份是闰年！\"); &#125; else &#123; System.out.println(\"当前年份不是闰年！\"); &#125; &#125;&#125; 6，正则表达式1） java.util.regex包主要包括以下三个类： Pattern类：是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类：是对输入字符串进行解释和匹配操作的引擎。 PatternSyntaxException：是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 12345678public class RegexDemo &#123; public static void main(String[] args) &#123; String content = \"I am a student, graduated from HuBei University.\"; String pattern = \".*HuBei.*\"; boolean isMath = Pattern.matches(pattern, content); System.out.println(\"字符串是否包含类'HuBei'子字符串？\"+isMath); &#125;&#125; 2）捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。1234567891011121314151617181920public class RegexDemo &#123; public static void main(String[] args) &#123; String content = \"I am a student, graduated from HuBei University in 2013. \"; String pattern = \"(\\\\D*)(\\\\d+)(.*)\";​ // 创建Pattern对象 Pattern rex = Pattern.compile(pattern);​ // 创建matcher对象 Matcher matcher = rex.matcher(content); if (matcher.find()) &#123; System.out.println(\"Found value: \" + matcher.group(0)); System.out.println(\"Found value: \" + matcher.group(1)); System.out.println(\"Found value: \" + matcher.group(2)); System.out.println(\"Found value: \" + matcher.group(3)); &#125; else &#123; System.out.println(\"No match!!!\"); &#125; &#125;&#125; 7，Java方法1）Java方法定义：Java方法是语句的集合，他们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 2）Java方法的优点 使程序变得更简短而清晰 有利于程序维护 可以提高程序开发的效率 提高了代码的重用性 3）Java方法的命名规则 必须以字母、&#39;_&#39;或&#39;＄&#39;开头（方法名第一个单词应以小写字母开头，后面的单词则用大写字母开头写，不使用连接符）； 可以包括数字，但不能以它开头； 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。 4）Java方法的定义123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 5）Java方法调用1234567891011121314151617public class MaxTest &#123; public static void main(String[] args) &#123; int i = 2, j = 4; int max = getMax(i, j); System.out.printf(\"%d和%d比较，最大值是：%d.\", i, j, max); &#125;​ private static int getMax(int num1, int num2) &#123; int result; if (num1 &gt; num2) result = num1; else result = num2;​ return result; &#125;&#125; 6）void关键字 7）Java方法重载：一个类的两个方法拥有相同的名字，但是有不同的参数列表。 8）变量作用域 9）命令行参数：命令行参数是在执行程序时候紧跟在程序名字后面的信息。 10）构造方法：当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 11）可变参数：JDK1.5开始，Java支持传递同类型的可变参数给一个方法。1typeName... parameterName 在方法声明中，在指定参数类型后加一个省略号(...) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。12345678910111213141516171819202122public class MaxTest &#123; public static void main(String[] args) &#123;​ double max = getMax(1, 2, 3, 4, 5, 6, 7, 8, 0, 1); System.out.printf(\"...numbers中，最大值是：%.2f.\", max); &#125;​ private static double getMax(double... numbers) &#123; if (numbers.length == 0) &#123; System.out.println(\"No argument passed.\"); return -10000000000L; &#125;​ double result = numbers[0]; for (double var: numbers) &#123; if (var &gt; result) &#123; result = var; &#125; &#125; return result; &#125;&#125; 12）finalize()方法：在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。 Java 的内存回收可以由 JVM 来自动完成。 FinalizationDemo.java如下：1234567891011121314151617181920212223public class FinalizationDemo &#123; public static void main(String[] args) &#123; Cake c1 = new Cake(1); Cake c2 = new Cake(2); Cake c3 = new Cake(3);​ c2 = c3 = null; System.gc(); // 调用Java垃圾回收集器 &#125;&#125;​class Cake extends Object &#123; private int id; public Cake(int id) &#123; this.id = id; System.out.println(\"Cake Object \" + id + \" is created.\"); &#125;​ protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"Cake object \" + id + \" is disposed.\"); &#125;&#125; 8，Java流（Stream），文件（File）和IOJava.io包几乎包含了所有操作输入、输出需要的类。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 1）读取控制台输入：Java的控制台输入由System.in完成。1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 2）从控制台读取多字符输入：从BufferedReader对象读取一个字符要使用 read()方法。1int read() throws IOException BRReadLine.java1234567891011public class BRReadLine &#123; public static void main(String[] args) throws IOException &#123; char ch; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"输入字符，按下'q'键退出.\"); do &#123; ch = (char) br.read(); System.out.println(ch); &#125; while (ch != 'q'); &#125;&#125; 3）从控制台读取字符串：从 标准输入读取一个字符要使用BufferedReader的 readLine()方法。1String readLine() throws IOException BRReadLines.java123456789101112public class BRReadLines &#123; public static void main(String[] args) throws IOException &#123; String str; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"Enter lines of text;\"); System.out.println(\"Enter 'end' to quit.\"); do &#123; str = br.readLine(); System.out.println(str); &#125; while (!str.equals(\"end\")); &#125;&#125; 4）控制台输出：控制台的输出由 print() 和 println() 完成。12345678public class WriteDemo &#123; public static void main(String[] args) &#123; int num; num = 'A'; System.out.write(num); System.out.write('\\n'); &#125;&#125; 5）读写文件：一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 6）FileInputStream：该流用于从文件读取数据，它的对象可以用关键字new来创建。12345678910111213141516171819202122232425/** * 把给定的context以二进制写进文件，同时输出控制台 * 但是存在乱码问题 */public class FileStreamTest &#123; public static void main(String[] args) throws IOException &#123; try &#123; byte[] bWrite = &#123;'a', 11, 21, 32, 40, 54&#125;; OutputStream os = new FileOutputStream(\"file_test.txt\"); for (byte var: bWrite) &#123; os.write(var); &#125; os.close();​ InputStream is = new FileInputStream(\"file_test.txt\"); int size = is.available(); for (int i = 0; i &lt; size; i++) &#123; System.out.println((char) is.read() + \" \"); &#125; is.close(); &#125; catch (IOException ex) &#123; System.out.println(\"File InputStream error: \" + ex.toString()); &#125; &#125;&#125; 7）FileOutputStream：该流用来创建一个文件并向文件中写数据，它的对象可以用关键字 new 来创建。1234567891011121314151617181920212223242526272829303132333435/** * 把给定的context以二进制写进文件，同时输出控制台 */public class FileIOStreamTest &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"file_test.txt\");​ // 构建FileOutputStream对象，文件不存在会自动新建 FileOutputStream fop = new FileOutputStream(file);​ // 构建对象，参数可以指定编码，默认为操作系统默认编码，windows是gbk OutputStreamWriter writer = new OutputStreamWriter(fop, \"UTF-8\");​ // 写入到缓冲区 writer.append(\"中文输入\"); writer.append(\"\\r\\n\"); writer.append(\"English input\");​ // 关闭写入流，同时会把缓冲区的内容写入文件 writer.close();​ // 关闭输出流，释放系统资源 fop.close();​ FileInputStream fip = new FileInputStream(file); InputStreamReader reader = new InputStreamReader(fip, \"UTF-8\"); StringBuilder sb = new StringBuilder(); while (reader.ready()) &#123; sb.append((char) reader.read()); &#125; System.out.println(sb.toString()); reader.close(); fip.close(); &#125;&#125; 关于文件和I/O的一些其他类：File Class；FileReader Class；FileWriter Class。 9，Java中的目录1）创建目录File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。 mkdirs()方法创建一个文件夹和它的所有父文件夹。 1234567public class CreateDir &#123; public static void main(String[] args) &#123; String dirName = \"/home/share/java\"; File file = new File(dirName); file.mkdirs(); &#125;&#125; 2）读取目录12345678910111213141516171819202122public class ReadDir &#123; public static void main(String[] args) throws IOException &#123; String dirName = \"/home/share\"; File fp = new File(dirName); if (fp.isDirectory()) &#123; System.out.println(\"目录：\" + dirName); // 提取包含的文件和文件夹的列表 String[] strings = fp.list(); for (int i = 0; i &lt; strings.length; i++) &#123; File tmp = new File(dirName + \"/\" + strings[i]); if (tmp.isDirectory()) &#123; System.out.println(strings[i] + \" 是一个目录.\"); &#125; else &#123; System.out.println(strings[i] + \" 是一个文件.\"); &#125; &#125; &#125; else &#123; System.out.println(dirName + \" 不是一个目录.\"); &#125; &#125;&#125; 3）删除目录或文件：删除文件可以使用java.io.File.delete()方法。123456789101112131415161718192021public class DeleteDir &#123; public static void main(String[] args) &#123; File folder = new File(\"/home/share/java\"); deleteFolder(folder); &#125;​ // 删除文件及目录 private static void deleteFolder(File folder) &#123; File[] files = folder.listFiles(); if (files != null) &#123; for (File fp: files) &#123; if (fp.isDirectory()) &#123; deleteFolder(fp); &#125; else &#123; fp.delete(); &#125; &#125; &#125; folder.delete(); &#125;&#125; 10，Java Scanner类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。基本语法如下：1Scanner scanner = new Scanner(System.in); 1）使用next方法 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next()不能得到带有空格的字符串。 ScannerNext.java12345678910111213public class ScannerNext &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"Next方式接收：\");​ // 判断是否还有输入 if (scan.hasNext()) &#123; String str = scan.next(); System.out.println(\"输入的数据为：\" + str); &#125; scan.close(); &#125;&#125; 2）使用nextLine方法 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 ScannerNextLines.java12345678910111213class ScannerNextLines &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"NextLine方式接收：\");​ // 判断是否还有输入 if (scan.hasNextLine()) &#123; String str = scan.nextLine(); System.out.println(\"输入的数据为：\" + str); &#125; scan.close(); &#125;&#125; 注意：如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取。 ScannerNumbers.java12345678910111213141516171819202122232425262728293031323334public class ScannerNumbers &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in);​ int numberI; float numberF; double numberD; System.out.println(\"输入整数：\"); if (scan.hasNextInt()) &#123; numberI = scan.nextInt(); System.out.println(\"整数是：\" + numberI); &#125; else &#123; System.out.println(\"输入的不是整数！\"); &#125;​ System.out.println(\"输入浮点数：\"); if (scan.hasNextFloat()) &#123; numberF = scan.nextFloat(); System.out.println(\"浮点数是：\" + numberF); &#125; else &#123; System.out.println(\"输入的不是浮点数！\"); &#125;​ System.out.println(\"输入双精度小数：\"); if (scan.hasNextDouble()) &#123; numberD = scan.nextDouble(); System.out.println(\"双精度小数是：\" + numberD); &#125; else &#123; System.out.println(\"输入的不是双精度小数！\"); &#125;​ scan.close(); &#125;&#125; 11，Java异常处理1）理解Java异常处理是如何工作的，需掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。 2）Exception 类的层次 所有的异常类是从 java.lang.Exception 类继承的子类。 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable 类还有一个子类Error 。 Error 用来指示运行时环境发生的错误。例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 在 Java 内置类中，有大部分常用检查性和非检查性异常。 3）Java内置类4）异常方法：主要是Throwable的方法。5）捕获异常123456789101112public class ExceptionDemo &#123; public static void main(String[] args) &#123; try &#123; int[] array = new int[2]; array[0] = 1; System.out.println(\"Access elements three: \" + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println(\"Exception: \" + ex.toString()); &#125; System.out.println(\"Out of the block.\"); &#125;&#125; 6）多重捕获块：一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 7）throws/throw关键字：如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 8）finally关键字：finally 关键字用来创建在 try 代码块后面执行的代码块；无论是否发生异常，finally 代码块中的代码总会被执行；在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 ExceptionDemo.java1234567891011121314public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] array = new int[2]; try &#123; System.out.println(\"Access elements three: \" + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println(\"Exception throw: \" + ex.toString()); &#125; finally &#123; array[0] = 20; System.out.println(\"First element value: \" + array[0]); System.out.println(\"The finally statement is executed.\"); &#125; &#125;&#125; 9）声明自定义异常 所有异常都必须是 Throwable 的子类。 如写一个检查性异常类，则需要继承 Exception 类。 如写一个运行时异常类，那么需要继承 RuntimeException 类。 综合实例 InsufficientFundException.java： 123456789101112/** * 自定义异常，继承Exception类 */public class InsufficientFundException extends Exception &#123; private double amount; public InsufficientFundException(double amount) &#123; this.amount = amount; &#125; public double getAmount() &#123; return amount; &#125;&#125; CheckingAccount.java： 1234567891011121314151617181920212223242526272829303132333435/** * 银行账户基本操作类 */public class CheckingAccount &#123; private double balance; private int number; public CheckingAccount(int number) &#123; this.number = number; &#125;​ // 存钱 public void deposit(double amount) &#123; balance += amount; &#125;​ // 取钱 public void withdraw(double amount) throws InsufficientFundException &#123; if (amount &lt;= balance) &#123; balance -= amount; &#125; else &#123; double needs = amount - balance; throw new InsufficientFundException(needs); &#125; &#125;​ // 返回余额 public double getBalance() &#123; return balance; &#125;​ // 返回账号 public int getNumber() &#123; return number; &#125;&#125; BankDemo.java： 123456789101112131415161718192021** * 模拟银行账户基本操作实例 */class BankDemo &#123; public static void main(String[] args) &#123; CheckingAccount account = new CheckingAccount(6228481); System.out.println(\"Deposit $500...\"); account.deposit(500.00);​ try &#123; System.out.println(\"Withdrawing $100...\"); account.withdraw(100);​ System.out.println(\"Withdrawing $600...\"); account.withdraw(600); &#125; catch (InsufficientFundException ex) &#123; System.out.println(\"Sorry, but you are short $\"+ex.getAmount()); ex.printStackTrace(); &#125; &#125;&#125; 10）通用异常在Java中定义了两种类型的异常和错误： JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","categories":[{"name":"Java","slug":"java","permalink":"https://zhangbc.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"java-basic","permalink":"https://zhangbc.github.io/tags/java-basic/"}]},{"title":"【数据库理论】关系数据库","slug":"【数据库理论】关系数据库","date":"2019-04-10T13:22:51.000Z","updated":"2019-04-10T16:13:32.275Z","comments":true,"path":"2019/04/10/db_rdb/","link":"","permalink":"https://zhangbc.github.io/2019/04/10/db_rdb/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，关系模型的基本概念 关系及基本术语 在关系模型中，表格的第一行称为关系框架，是属性$A_1$，$A_2$，$A_3$，$\\dots$，$A_k$的有限集合。 表中的每行称为关系的一个元组；每列称为属性，它在某个值域上的取值，不同的属性可以在相同的值域上取值。 关系中的属性个数称为元数（Arity），元组个数称为基数。 关键字 超关键字(Super Key)：在关系中能够唯一标识元组的属性集合。 候选关键字(Candidate Key)：如果某一属性集合是超关键字，但去掉其中任意属性后就不再是超关键字，这样的属性称为候选关键字。 候选关键字的诸属性称为主属性，不包含在任何候选关键字中的属性称为非主属性（非码属性）。 主关键字(Primary Key)：如果关系中存在多个候选关键字，用户可选作元组标识的一个候选关键字为主关键字。 合成关键字(Composite Key)：当某个候选关键字包含多个属性时，该候选关键字称为合成关键字。 外部关键字(Foreign Key)：如果关系R的某个（些）属性K不是R中的候选关键字，而是另一个关系S的候选关键字，则K称为R的外部关键字。 二，关系模式 在关系数据库中，关系模式是型，关系是值。 【定义3-1】关系的描述称为关系模式，形式化表示为$R(U, D, DOM, I, F)$其中，$R$为关系名，$U$为组成该关系的属性名集合，$D$是$U$中属性的域，$DOM$为属性到域的映像集合，$I$为完整性约束集合，$F$为属性间数据的依赖关系集合。 ⚠️关系模式中带有下画线的属性集为主关键字。 三，关系模型的完整性 域完整性约束：主要规定属性值必须取自值域，一个属性能否为空值由其语义决定。 实体完整性约束：规定基本关系的所有主属性都不能取空值，而不仅是主属性整体不能取空值。 参照完整性约束：要求“不引用不存在的实体”，考虑的是不同关系之间的或同一关系的不同元组之间的制约。形式定义： 如果属性集K是关系R的主关键字，K也是关系S的外关键字，那么在关系S中，K的取值只允许两种可能，要么为空值，要么等于关系R中某个主关键字的值。关系R称为“参照关系”模式，关系S称为“依赖关系”模式。 用户自定义完整性约束：针对某个具体关系数据库的约束条件。 四，关系代数 关系查询语言分类 关系代数语言：查询操作是以集合操作为基础运算的DML语言。 关系演算语言：查询操作是以谓词演算为基础运算的DML语言。 关系代数的五种基本操作 相等定义：设有同类关系$r_1$和$r_2$，若$r_1$的任何一个元组都是$r_2$的一个元组，则称关系$r_2$包含关系$r1$，记作$r_1$ $\\subseteq$ $r_2$或 $r_2$ $\\supseteq$ $r_1$，如果$r_1$ $\\subseteq$ $r_2$且$r_1$ $\\supseteq$ $r_2$，则称关系$r_1$等于关系$r_2$，记作$r_1$=$r_2$。 【定义3-2】并(Union)：设有同类关系$r_1$[R]和$r_2$[R]，两者的并(Union)运算定义 $r_1$ $\\bigcup$ $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\vee$ $t$ $\\in$ $r_2$ }式中，$\\bigcup$为并运算符。$r_1$ $\\bigcup$ $r_2$的结果关系是$r_1$的所有元组与$r_2$的所有元组的并集（去掉重复元组）。 【定义3-3】差(Difference)：设有同类关系$r_1$[R]和$r_2$[R]，两者的差(Difference)运算定义为 $r_1$ - $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\wedge$ $t$ $\\notin$ $r_2$ }式中，- 为相减运算符。$r_1$ - $r_2$的结果关系是$r_1$的所有元组减去$r_1$与$r_2$相同的元组所剩下的元组的集合。 【定义3-4】笛卡儿积(Difference)：设$r$[R]为$k_1$元关系，$s$[S]为$k_2$元关系，两者的笛卡儿积(Difference)运算定义为 $r$ $\\times$ $s$ = { $t$ $\\mid$ $t$ = &lt;$u,v$&gt; $\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $s$ }。 【定义3-5】投影(Projection)：是对一个关系进行垂直分割，消去某些列，并重新安排列的顺序的操作。设有$r$[R]为$k$元关系，其关系框架R={$A_1$,$A_2$,$\\dots$,$A_k$}，$A_{j_1}$，$A_{j_2}$，$\\dots$，$A_{j_n}$ 为R中互不相同的属性，那么关系$r$在属性（分量）$A_{j_1}$，$A_{j_2}$，$\\dots$，$A_{j_n}$ 上的投影运算定义为 $\\Pi$ $A_{j_1}$,$A_{j_2}$,$\\dots$,$A_{j_n}$ $($ $r$ $)$ = { $u$ $\\mid$ $u$ = &lt; $t$ [$A_{j_1}$],$t$[$A_{j_2}$],$\\dots$,$t$[$A_{j_n}$] &gt; $\\wedge$ $t$ $\\in$ $r$ }式中，$\\Pi$为投影运算符。 【定义3-6】选择(Selection)：根据某些条件对关系进行水平分割，即选取符合条件的元组的操作。条件可用命题公式F表示，由运算对象和运算符组成： 运算对象：常数（用引号括起来）、元组分量（属性名或列的序号） 运算符：算术比较运算符（$\\lt$,$\\le$,$\\gt$,$\\ge$,=,$\\ne$，也称$\\theta$符），逻辑运算符（$\\vee$,$\\wedge$,$\\neg$） 关系R关于公式F的选择操作用$\\sigma$F$($R$)$表示，其定义为：$\\sigma$F $($ R $)$ $\\equiv$ { $t$ $\\mid$ $t$ $\\in$ R $\\wedge$ F($t$)=true}式中，$\\sigma$为选择运算符。$\\sigma$F$($R$)$表示从R中挑选满足公式F为真的元组所构成的关系。 关系代数的其他操作 【定义3-7】交(Intersection)：设有同类关系$r_1$[R]和$r_2$[R]，两者的交(Intersection)运算定义 $r_1$ $\\bigcap$ $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\wedge$ $t$ $\\in$ $r_2$}式中，$\\bigcap$为交运算符。$r_1\\bigcapr_2$的结果关系是$r_1$与$r_2$的所有相同元组构成的集合，显然，$r_1\\bigcapr_2$ 等于$r_1$ - ($r_1$ - $r_2$ )或者$r_2$ - ($r_2$ - $r_1$ )。 【定义3-8】$\\theta$-连接：设$r$[R]、$s$[S]关系框架分别为R = {$A_1$,$A_2$,$\\dots$,$A_n$} 和 {$B_1$,$B_2$,$\\dots$,$B_m$}，那么关系$r$和$s$的$\\theta$-连接（$\\theta$-Join）运算定义为：$r$ $\\Join$ $s$ = { $t$ $\\mid$ $t$ = &lt; $u, v$ &gt;$\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $u$[$A_i$]$\\theta$ $v$[$B_j$]} 【定义3-9】F-连接 ：设$r$[R]、$s$[S]关系框架分别为R = { $A_1$,$A_2$,$\\dots$,$A_n$ }，{ $B_1$,$B_2$,$\\dots$,$B_m$ }，F($A_1$,$A_2$,$\\dots$,$A_n$,$B_1$,$B_2$,$\\dots$,$B_m$)为一公式，那么关系$r$和$s$的F-连接（F-Join）运算定义为：$r$ $\\Join$ $s$ = { $t$ $\\mid$ $t$ = &lt; $u, v$&gt;$\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $s$ $\\wedge$F($u$[$A_1$],$\\dots$,$u$[$A_n$]),$u$[$B_1$],$\\dots$,$u$[$B_m$]) }即：$r$ $\\Join$ $s$ = $\\sigma$F $(r$ $\\times$ $s)$ 【定义3-10】自然连接： Natural Jion是一种特殊的等值连接，它要求关系R和关系S具有相同的属性组B($b_1$,$b_2$,$b_3$,$\\dots$ $\\dots$)，这些属性组的取值是相等的，在最后生成的关系中去掉属性重复的列。其计算过程如下： (1)计算$r$ $\\times$ $s$；(2)设$r$和$s$的公共属性是$A_1$,$A_2$,$\\dots$,$A_m$，选出$r$ $\\times$ $s$中满足$r.A_1$=$s.A_1$,$r.A_2$=$s.A_2$, $\\dots$, $r.A_m$=$s.A_m$的那些元组；(3)去掉$s.A_1$,$s.A_2$,$\\dots$,$s.A_m$这些列。 【定义3-11】除(Division)：给定关系$r$(X,Y)和$s$(Y,Z)，其中，X，Y，Z为属性组，$r$中的Y与$s$中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除(Division)运算得到一个新的关系$p$(X)，$p$是r中满足下列条件的元组在X属性列上的投影，即元组在X上的分量值$x$的像集$Y_x$包含s在Y上投影的集合，记为$r$ $\\div$ $s$ = { $t_r$[X]$\\mid$ $t_r$ $\\in$ $r$ $\\wedge$ $\\pi_y$($s$) $\\subseteq$ $Y_x$ }式中，$Y_x$为$x$在$r$中的像集，$x$=$t_r$[X]。 五，关系演算关系演算是以数理逻辑中的谓词为基础的，按谓词变元的不同，关系演算可以分为元组关系演算和域关系演算。 元组关系演算：以元组为变量。1） 在元组关系演算中，元组关系演算表达式的一般形式为：$\\{t|P(t)\\}$式中，t是元组变量，表示一个元数确定的元组，P是满足一定逻辑条件的公式，公式可以分解为一些原子公式，$\\{t|P(t)\\}$表示满足公式P的所有元组$t$的集合。2）在一个演算公式中，未用存在量词$\\exists$或全称量词$\\forall$符号定义的元组变量，称为自由元组变量，否则称为约束元组变量。 域关系演算：以属性(域)为变量，简称域演算。","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库理论","slug":"db-theory","permalink":"https://zhangbc.github.io/tags/db-theory/"}]},{"title":"【Java基础】Java入门知识","slug":"【Java基础】Java入门知识","date":"2019-04-08T15:52:05.000Z","updated":"2019-08-28T16:05:24.707Z","comments":true,"path":"2019/04/08/java_introductory_knowledge/","link":"","permalink":"https://zhangbc.github.io/2019/04/08/java_introductory_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，java简介 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。 1）Java分为三个体系： JavaSE(J2SE)Java2 Platform Standard Edition，java平台标准版） JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版) 2）Java的主要特性： java语言是简单的； java语言是面向对象的（纯面向对象）； java语言的分布式的； java语言是健壮的（丢弃指针，强类型机制，异常处理，垃圾的自动收集）； java语言是安全的（安全防范机制（类ClassLoader），安全管理机制（类SecurityManager））； java语言是可移植的； java语言是解释型的； java是高性能的； java语言多线程的； java语言是动态的。 3）Java的发展史：诞生于1995年；2014年3月18日，Oracle公司发表Java SE8。 4）Java工具：Java语言尽量保证系统内存在1G以上。 2，Java开发环境配置1）下载JDK工具解压安装，对应不同的系统选择适合的版本。 2）变量设置参数如下： 变量名：JAVA_HOME 变量值：C:\\Program Files (x86)\\Java\\jdk1.8.0_91 // 要根据自己的实际路径配置 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; //记得前面有个”.“ 变量名：Path 变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 3）测试JDK是否安装成功12~ java -version # 输出java安装的版本~ javac -version # 输出javac安装的版本 注意：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。 4）Java开发工具选择 Eclipse IntelliJ IDEA(推荐) 3，Java基础语法1）相关概念 类：类是一个模板，描述一个对象的行为和状态。 java中的类： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 构造方法：每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 创建对象：在Java中，使用关键字new创建一个新的对象，主要有三步：声明，实例化（new），初始化。 对象：对象是一个类的实例，有状态和行为。 在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 方法：方法即行为，一个类可以有很多方法。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 2）编程注意点 大小写敏感 类名每个单词的首字母大写（帕斯卡命名法） 方法名以小写字母开头，之后每个单词首字母大写（驼峰命名法） 源文件名必须和类名相同 主方法入口，所有的Java程序由public static void main(String []args)方法开始执行 3）Java标识符 标识符：类名，变量名及方法名都称为标识符。 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始； 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合； 关键字不能用作标识符； 标识符是大小写敏感的； 合法标识符举例：age、$salary、_value、__1_value； 非法标识符举例：123abc、-salary； 4）Java修饰符 （1）访问控制： default, public, protected, private 修饰符 当前类 同一包内 子孙类（同一包） 子孙类（不同包） 其他包 public Y Y Y Y Y protected Y Y Y Y /N N default Y Y Y N N private Y N N N N protected说明： 子类与基类在同一包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。 （2）访问控制和继承，注意以下原则： 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为 public，不能声明为private。 父类中声明为private的方法，不能够被继承。 （3）非访问控制：final, abstract,static, synchronized,volatile static：创建类方法和类变量； final：修饰类，方法和变量。修饰的类不可被继承；修饰的方法不能被继承的类重新定义；修饰的变量为常量，不可修改。 abstract：创建抽象类和抽象方法； synchronized：用于线程编程，synchronized声明的方法同一时间只能被一个线程访问； transient：序列化的对象包含被 transient修饰的实例变量时，Java虚拟机(JVM)跳过该特定的变量；该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile：用于线程编程， 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值，当成员变量发生变化时，会强制线程将变化值回写到共享内 5）Java变量 局部变量：类的方法中的变量。 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 类变量（静态变量）：独立于方法之外的变量，用static修饰。成员变量（非静态变量）：独立于方法之外的变量，不用static修饰。 6）Java数组：储存在堆上的对象，可以保存多个同类型变量。 7）Java枚举：Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。 8）Java关键字：参见Java关键字列表 9）Java注释 10）Java空行：空白行，或者有注释的行，Java编译器都会忽略掉。 11）Java继承在Java中，一个类可以由其他类派生。被继承的类称为超类（super class），派生类称为子类（subclass）。 12）Java接口：在Java中，接口可以理解为对象间相互通信的协议。 13）源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致 如果一个类定义在某个包中，那么package语句应该在源文件的首行 如果源文件包含import语句，那么应该放在package语句和类定义之间；如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 14）Java包：包主要用来对类和接口进行分类。 15）Import语句 16）Java运算符 算术运算符 关系运算符 位运算符：Java定义类位运算符，应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 逻辑运算符 赋值运算符 其他运算符（instanceof，自增，自减，条件运算符） 17）Java 源程序与编译型运行区别","categories":[{"name":"Java","slug":"java","permalink":"https://zhangbc.github.io/categories/java/"}],"tags":[{"name":"Java基础","slug":"java-basic","permalink":"https://zhangbc.github.io/tags/java-basic/"}]},{"title":"【数据库实战】SQL Server数据库常用脚本","slug":"【数据库实战】SQL-Server数据库常用脚本","date":"2019-04-07T08:40:27.000Z","updated":"2019-04-09T13:11:32.517Z","comments":true,"path":"2019/04/07/sql_used_script/","link":"","permalink":"https://zhangbc.github.io/2019/04/07/sql_used_script/","excerpt":"","text":"1，创建链接远程服务器及其删除12345exec sp_addlinkedserver 'web','','SQLOLEDB','192.168.10.106'exec sp_addlinkedsrvlogin 'web','false',null,'sa','123'--删除链接服务器exec sp_dropserver 'web','droplogins' 2，重置SQLSERVER表的自增列，让自增列重新计数语法：123456DBCC CHECKIDENT( table_name [, &#123; NORESEED | &#123; RESEED [,new_reseed_value ] &#125; &#125; ] ) [ WITH NO_INFOMSGS ] 参数： table_name:是要对其当前标识值进行检查的表名。指定的表必须包含标识列。表名必须符合标识符规则。 NORESEED:指定不应更改当前标识值。 RESEED:指定应该更改当前标识值。 new_reseed_value:用作标识列的当前值的新值。 WITH NO_INFOMSGS:取消显示所有信息性消息。 查看某表当前的种子值，示例：1dbcc checkident('mainTable',noreseed); 123-------------显示如下----------------检查标识信息: 当前标识值 '2707'，当前列值 '2707'。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 重置表mainTable的当前标识值为1，示例：1dbcc checkident('mainTable',reseed,1); 123-------------显示如下----------------检查标识信息: 当前标识值 'NULL'，当前列值 '1'。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 3，几个有用的存储过程 修改xx表中所有值null 123456789101112131415161718192021222324252627282930313233/************************* 功能：修改xx表中所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/if (OBJECT_ID('modifyNull','P') is not null) drop procedure modifyNullgocreate procedure modifyNull(@table char(100))asbegin --定义游标 declare col_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select b.name from sysobjects a inner join syscolumns b on a.id=b.id where a.name=@table --打开游标 open col_cur declare @columnName nvarchar(100) fetch next from col_cur into @columnName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='update ' + @table + ' set ' + @columnName + ' = ISNULL(' + @columnName + ', '''')' exec(@sql) fetch next from col_cur into @columnName end --关闭游标 close col_cur --释放游标 deallocate col_curend 修改数据库中所有表的所有列为null 123456789101112131415161718192021222324252627/************************* 功能：修改数据库中所有表的所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/create procedure [dbo].[modifyAllNull]asbegin declare tab_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select name from sysobjects where xtype='U' --打开游标 open tab_cur declare @tableName nvarchar(100) fetch next from tab_cur into @tableName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='exec dbo.modifyNull ' +'''' + @tableName + '''' exec(@sql) fetch next from tab_cur into @tableName end --关闭游标 close tab_cur --释放游标 deallocate tab_curend","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库实战","slug":"db-actual-combat","permalink":"https://zhangbc.github.io/tags/db-actual-combat/"}]},{"title":"【数据库理论】绪论","slug":"【数据库理论】绪论","date":"2019-04-06T10:42:18.000Z","updated":"2019-04-10T16:56:20.697Z","comments":true,"path":"2019/04/06/db_introduction/","link":"","permalink":"https://zhangbc.github.io/2019/04/06/db_introduction/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据库的概念 数据库定义：数据库（DB）是长期保存在计算机的存储设备上并按照某种模型组织起来的，可以被各种用户或应用共享的数据集合。 数据库分类：关系数据库，层次数据库，网状数据库. 数据库基本特征：1）具有较高的数据独立性；数据独立性是指数据的组织方法和储存方法与应用程序互不依赖，彼此独立的特性，包括物理独立性和逻辑独立性。2）数据库用综合的方法组织数据，保证尽可能高的访问效率；3）具有较小的数据冗余，可以供多个用户共享；4）具有安全控制机制，能够保证数据的安全，可靠；5）数据允许多用户共享，能够有效，及时地处理数据，并能够保证数据的一致性和完整性。 二，数据库管理系统（DBMS） DBMS的定义：DBMS是位于用户与操作系统之间的数据管理软件，数据库在建立，运用和维护时由数据库管理系统统一管理，控制。 DBMS的目标： 1）用户界面友好； 2）功能完备； 3）效率高，DBMS应该具有较高的系统效率和高的用户生产率，其中系统效率包括： （1）计算机内部资源的利用率，即能够充分利用磁盘空间，CPU，设备等资源，并注意使各种资源的负载均衡以提高整个系统的效率；（2）DBMS本身的运行效率，根据系统目标确定恰当的体系结构，数据结构和算法，保证DBMS运行的高效率；用户生产率是指用户设计和开发应用程序的效率； 4）结构清晰：DBMS内部结构清新，层次分明既便于支持其外层开发环境的构造，也便于自身的设计、开发与维护； 5）开放性：DBMS的开放性是指符合标准和规范，如ODBC标准，SQL标准等。 DBMS的基本功能： 1）数据库定义功能：DDL可以定义数据库中数据之间的联系，可以定义数据的完整性约束条件和保证完整性的触发机制等，包括全局逻辑数据结构（模式）的定义，局部逻辑数据结构（外模式）的定义，保密定义等；2）数据库操纵功能：DML可以接收，分析和执行用户提出的访问数据库的各种要求，完成对数据库的各种基本操作，如对数据库的检索，插入，删除和修改等操作，可以重新组织数据的存储结构，可以完成数据库的备份和恢复等操作；3）数据库的控制功能：DCL包括整个数据库系统的运行控制，数据库的完整性控制，数据库的安全性控制及多用户环境下的数据库并发访问控制等；4）数据库的运行管理功能：指DBMS运行机制和管理功能；5）数据库组织和存储管理功能6）数据库的建立和维护功能7）数据库通信功能 DBMS的组成： 1）数据库定义语言及其翻译程序： DDL用于描述数据库中要存储的现实世界实体的语言，包括数据字典中数据库的逻辑结构，完整性约束，物理存储结构的表述，数据库的各种数据操作和数据库的维护管理的各种依据。包括： 模式DDL：定义全局逻辑数据结构(包括所有字段的名称，特征及其相互关系)，数据的完整性，安全性约束；外模式DDL：为用户定义所用的局部逻辑数据结构(包括与用户的应用程序有关的字段名称，特征及其相互关系)，描述外模式到模式之间的映射关系；内模式DDL：用于描述数据在存储介质上的安排和存放方式，描述模式到内模式之间的映射关系； 2）数据库操纵语言及其编译（或解释）程序： DML用于实现对数据库的一些基本操作，如数据检索，数据插入，数据修改和数据删除，其中数据插入，数据修改和数据删除操作又称为数据更新操作。分为： 宿主型DML：本身不能独立使用，必须嵌入到宿主语言中，如C，COLBOL，PASCAL等，因此也称嵌入型DML，仅负责对数据库数据的操纵，其他工作都由宿主语言完成；自主型DML，又称自含型DML，可以独立进行数据查询，数据更新等操作，语法简单，使用方便，适合终端用户使用； 3）数据库运行控制程序：包括系统初启程序(DBMS的神经中枢)，访问控制程序，安全性控制程序，完整性检查程序，并发控制程序，数据存取/更新程序，通信控制程序； 4）数据库服务实用程序：包括数据装入程序，工作日志程序，性能监督程序，数据库重新组织程序，系统恢复程序，转储/编辑/打印程序。 数据库管理与数据库管理员(DBA)： 1）DBA：从事数据库管理工作的人员，不是数据库的“占有者”，而是数据库的“保护者”。 2) DBA职责 在数据库设计开始之前，DBA首先调查数据库的用户需求。 在数据库设计阶段，DBA要负责数据库标准的制定和功用数据字典的研制，要负责各级数据库模式的设计，负责数据库安全，可靠方面的设计，决定文件组织的方法。 在数据库运行阶段，DBA要负责对用户进行数据库方面的培训，负责数据库的转储和恢复，数据维护，用户的使用权限等，负责监控数据库的性能。 三，数据库系统（DBS） DBS定义：指在计算机系统中引入数据库后的系统构成，一般由数据库，数据库系统运行环境，数据库管理系统及其开发工具，数据库管理员和用户组成。 数据库系统的三级模式结构： 1）模式定义：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，而不涉及具体的值。 2）三级模式结构： 外模式：也称子模式或者用户模式，是数据库用户看见和使用的局部数据的逻辑结构和特征的描述，是数据库的用户视图，是和某个应用相关的数据逻辑表示；一个数据库可以有多个外模式； 模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共视图，是数据库的整个逻辑描述，并说明一个数据库所采用的数据模型；一个数据库只有一个模式； 内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据库的内部表示方式；一个数据库只有一个内模式。 二级映像功能和数据独立性： 1）外模式/模式映像：当模式改变时，DBA对各个外模式/模式的映像做出相应改变，使外模式保持不变，从而使应用程序不改变，保证了数据的逻辑独立性； 2）模式/内模式映像：唯一定义了数据全局逻辑结构和存储方式之间的对应关系。当数据库的存储方式改变时，DBA将对模式/内模式映像做出相应的改变，使模式保持不变，从而保证了数据的物理独立性。 数据库系统的体系结构： 1）单用户结构的数据库系统：最早最简单，不能共享数据； 2）主从式结构的数据库系统：结构简单，数据易于维护维护和管理，但系统的可靠性不高； 3）分布式结构的数据库系统：数据在逻辑上上一个整体，但是分布在计算机网络的不同结点上。 4）客户端/服务器结构的数据库系统 数据库系统的工作流程： 1）DBA建立并维护数据库； 2）用户编写应用程序； 3）应用程序在DBMS支持下运行，在模式，外模式，内模式，用户源程序翻译为目标代码后，即可启动目标程序。 四，数据库的发展 人工管理阶段： 1）特点：数据不保存；应用程序管理数据；数据不共享；数据不具有独立性。 文件系统阶段： 1）优点：数据可以长期保存；有专门的软件即文件系统管理数据，文件系统把数据组织成相互独立的数据文件；文件的形式多样化； 2）缺点：数据共享性差，冗余度大；数据独立性差；数据联系弱。 数据库系统阶段 数据库技术的研究，应用领域和发展方向 数据模型 数据库管理系统软件的研制 数据操作 数据库理论：主要集中在关系的规范化理论，关系数据理论等。 代表性的数据库应用领域和发展方向： 因特网上的Web数据库 面向对象数据库 多媒体数据库 并行数据库 人工智能领域的知识库和主动数据库 模糊数据库系统","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库理论","slug":"db-theory","permalink":"https://zhangbc.github.io/tags/db-theory/"}]},{"title":"【数据库理论】数据模型","slug":"【数据库理论】数据模型","date":"2019-04-06T04:48:52.000Z","updated":"2019-04-09T13:11:32.520Z","comments":true,"path":"2019/04/06/db_data_model/","link":"","permalink":"https://zhangbc.github.io/2019/04/06/db_data_model/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据描述 数据的三种范畴 1）现实世界（客观世界）：现实世界所反映的客观存在的事物及其相互之间的联系，指数处理对象最原始的表现形式。 2）信息世界（观念世界）：是现实世界在人们头脑中的反映，经过一定的选择，命名和分类而形成的。以下为相关概念： 实体（Entity）：客观存在的事物在人们头脑中的反映，或说，客观存在并可相互区别的客观事物或抽象事件。 属性（Attribute）：实体所具有的某一方面的特性。 域（Domain）：一个属性可能取的所有属性值的范围称为该属性的域。 码（Key）：唯一标识实体的属性集。 实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（Entity Set）：同一类型实体的集合。 3）机器世界（数据世界或存储世界）数据化后的信息称为数据，所以说数据是信息的符号表示。以下为相关概念： 数据项（字段，Field）：对应于信息世界中的属性。 记录（Record）：对应于每个实体所对应的数据。 记录型（Record Type）：对应于信息世界中的实体型。 文件（File）：对应于信息世界中的实体集。 关键字（Key）：对应于能够唯一标识一个记录的字段集。 实体间的联系 一对一联系：如果实体集A中每个实体，实体集B中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记作1:1； 一对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中至多有一个实体与之联系，则称实体集A与实体集B具有一对多联系，记作1:n； 多对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中有m（m&gt;=0）个实体与之联系，则称实体集A与实体集B具有多对多联系，记作n:m。 二，概念模型与E-R方法 数据模型 1）数据模型应满足以下要求： i）能够比较真实地模拟现实世界；ii）容易为人所理解；iii）便于在计算机上实现。 2）数据模型分类： i）概念模型：即信息模型，是按用户的观点来对数据和信息建模的，主要用于数据设计；ii）基本数据模型：主要包括网状模型，层次模型，关系模型等，是按计算机系统的观点对数据建模的，主要用于DBMS的实现。 数据模型的三要素 1）数据结构：用于描述系统的静态特性。数据结构是所有研究对象类型的集合，这些对象是数据库的组成部分，分为两大类： 与数据类型，内容，性质有关的对象； 与数据之间联系有关的对象。 2）数据操作：用于描述系统的动态特征。数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有检索和修改（插入，删除，更新）两大数据操作。 3）数据完整性约束：是一组完整性规则的集合。完整性规则是给定的数据模型中的数据及其联系所具有的制约和存储规则，用于限制符合数据模型的数据库状态及状态的变化，用于确保数据的正确、有效和相容。 概念数据模型 1）概念模型的定义：按用户的观点对现实世界进行数据建模而形成的，是一种独立于计算机系统的模型，完全不涉及信息在计算机系统中的表示，也不依赖于具体的数据库管理系统，用于描述某个特定组织所关心的信息结构。 2）概念模型的相关基本概念：实体、属性、域、码、实体型和实体集。 3）概念模型的基本关系：在概念模型中主要解决问题是实体间的联系。 E-R图表示法 1）实体型：用矩形表示，矩形框内写明实体名； 2）属性：用椭圆表示，椭圆内写明属性名； 3）联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标注联系的类型（1:1，1:n，n:m）。 E-R模型优点： i）接近人的思想，容易理解；ii）与计算机无关，用户容易接受。 三，传统的三大数据模型 层次模型 1）层次模型定义：用树形结构表示实体之间的联系的模型称为层次模型。 2）建立数据的层次模型需要满足以下条件： i）有且仅有一个结点没有父结点，这个结点即为树根结点；ii）其他数据记录有且仅有一个父结点。 3）层次模型的基本特点：任何一个给定的记录值只有按其路径查看，才能体现它的全部含义，没有一个子记录值能够脱离父记录值而独立存在的。 4）层次模型的最明显特点：层次清晰，构造简单，易于实现，可以很方便地表示一对一和一对多这两种实体之间的联系。 5）层次模型的主要优点： i）层次模型本身比较简单；ii）实体间联系是固定的，且预先定义好的应用系统采用层次模型来实现，其性能优于关系模型的性能，不低于网状模型的性能；iii）层次模型提供了良好的完整性支持。 6）层次模型的主要缺点： i）现实世界中很多联系是非层次性的，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据或创建非自然组织（引入虚结点）来解决；ii）对插入和删除操作的限制比较多；iii）查询子结点必须通过父结点；iv）由于结构严谨，层次命令趋于程序化。 网状模型 1）网状模型的定义： 网状模型是一种有向图，在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型： i）允许一个以上的结点无父结点；ii）一个结点可以有多于一个的父结点。 2）为了描述网状模型的记录之间的联系，引进了系（Set）的概念，所谓系可以理解为命名了的联系，它由一个父记录型和一个或多个子记录型构成。 3）网状数据库的定义：用网状模型设计出来的数据库称为网状数据库。 4）网状模型的主要优点： i）能够更为直接地描述现实世界，如一个结点可以有多个父结点；ii）具有良好的性能，存取效率较高。 5）网状模型的主要缺点： i）结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于用户最终掌握；ii）其DDL，DML语言复杂，用户不易使用。 关系模型 1）关系模型的主要优点： i）数据结构比较简单；ii）具有很高的数据独立性；iii）可以直接处理多对多联系；iv）坚实的理论基础。 2）值域的定义：在关系模型中，一个n元关系有n个属性，属性的取值范围称为值域。 3）关系模型主要缺点：存取路径对用户透明，查询效率往往不如非关系数据模型。 四，数据独立与三层结构 三级模式结构 外模式：又称为用户模式，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看得见和使用的局部数据的逻辑结构和特征描述，是与某一个应用有关的数据的逻辑表示。 模式：可分为概念模式和逻辑模式，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。 一个数据库只有一个模式，其中概念模式可以用实体-联系模型模型来描述，逻辑模式以某种数据模型为基础，综合考虑所有用户的需求，并将其形成全局逻辑结构。 内模式：又称为存储模式，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。 数据的独立性 逻辑数据独立性：当模式改变时，只要对外模式/模式映像做相应的改变，就可以使外模式保持不变，以外模式为依据编写的应用程序就不受影响，从而应用程序不必修改，保证了数据与程序之间的逻辑独立性。 存储数据独立性：当内模式改变时，只要对模式/内模式映像做相应的改变，使模式保持不变，应用程序就不受影响，从而保证了数据与程序之间的物理独立性，称为存储数据独立性。 五，数据库管理系统 DBMS的主要功能 数据库的主要职责就是有效地实现数据库三级模式之间的转换，即把用户或应用程序对数据库的一次访问，从用户级带到概念级，再导向物理级，转换为对存储数据的操作。 1）数据库定义2）数据库操作及查询优化3）数据库控制运行管理4）数据组织，存储和管理5）数据库的恢复和维护6）数据库的多种接口7）其他功能 DBMS的组成 1）DBMS由查询处理器和存储管理器两大部分组成。其中： (1) 查询处理器主要有DDL编译器，DML编译器，嵌入式DML的预编译器及查询运行核心程序；(2) 存储管理器有授权和完整性管理器，事务管理器，文件管理器及缓冲区管理器。 2）查询处理程序：把用较高级的语言所表示的数据库操作（查询、更新等）转换成一系列对数据库的请求。 3）存储管理程序：包括文件管理程序和缓冲区管理程序。 4）事务管理程序：保证数据库中所有事务全部都能正确执行。 用户访问数据库的过程（略）","categories":[{"name":"数据库技术","slug":"database","permalink":"https://zhangbc.github.io/categories/database/"}],"tags":[{"name":"数据库理论","slug":"db-theory","permalink":"https://zhangbc.github.io/tags/db-theory/"}]}]}