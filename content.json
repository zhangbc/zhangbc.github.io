{"meta":{"title":"天堂的鸽子","subtitle":"天道酬勤","description":"每天积累一点，学习一点，只有不坚持的，没有做不到的！","author":"Bocheng Zhang","url":"https://zhangbc.github.io","root":"/"},"pages":[{"title":"","date":"2019-04-09T13:11:32.521Z","updated":"2019-04-09T13:11:32.521Z","comments":true,"path":"404.html","permalink":"https://zhangbc.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2019-04-14T16:25:59.313Z","updated":"2019-04-14T16:25:59.313Z","comments":true,"path":"README.html","permalink":"https://zhangbc.github.io/README.html","excerpt":"","text":"博客目录数据库系列 理论篇 [x] 【数据库理论】绪论 [x] 【数据库理论】数据模型 [x] 【数据库理论】关系数据库 [x] 【数据库理论】关系模式的规范化与查询优化 [x] 【数据库理论】数据库的设计与实施 [x] 【数据库理论】数据库的安全和保护 [ ] 【数据库理论】数据库与SQL Server2005简介 [ ] 【数据库理论】管理数据库 [ ] 【数据库理论】管理表 [ ] 【数据库理论】操作查询 [ ] 【数据库理论】T-SQL语言 [ ] 【数据库理论】存储过程 [ ] 【数据库理论】SQL Server2005高级功能 实战 [x] 【数据库实战】SQL Server数据库常用脚本 Java编程 入门基础篇 [x] 【Java基础】Java入门知识 [x] 【Java基础】Java基础知识 [x] 【Java基础】Java面向对象 [x] 【Java基础】Java进阶编程 [x] 【Java基础】Java网络编程 [x] 【Java基础】Java扩展知识 [x] 【Java基础】Java基础100实例"},{"title":"","date":"2019-04-09T13:11:32.531Z","updated":"2019-04-09T13:11:32.531Z","comments":true,"path":"aboutme.html","permalink":"https://zhangbc.github.io/aboutme.html","excerpt":"","text":"关于作者 学习蜗牛，慢慢向前爬，终有一天会到达目的地； 学习IT，学会学习，独立思考，终有一天，会找到IT的乐趣！"},{"title":"分类","date":"2019-04-07T07:00:02.000Z","updated":"2019-04-10T12:08:59.536Z","comments":true,"path":"categories/index.html","permalink":"https://zhangbc.github.io/categories/index.html","excerpt":"","text":""},{"title":"Schedule","date":"2019-04-12T18:31:33.000Z","updated":"2019-04-12T18:36:21.989Z","comments":true,"path":"schedule/index.html","permalink":"https://zhangbc.github.io/schedule/index.html","excerpt":"","text":"博客目录数据库系列 理论篇 [x] 【数据库理论】绪论 [x] 【数据库理论】数据模型 [x] 【数据库理论】关系数据库 [ ] 【数据库理论】关系模式的规范化与查询优化 [ ] 【数据库理论】数据库的设计与实施 [ ] 【数据库理论】数据库的安全和保护 [ ] 【数据库理论】数据库与SQL Server2005简介 [ ] 【数据库理论】管理数据库 [ ] 【数据库理论】管理表 [ ] 【数据库理论】操作查询 [ ] 【数据库理论】T-SQL语言 [ ] 【数据库理论】存储过程 [ ] 【数据库理论】SQL Server2005高级功能 实战 [x] 【数据库实战】SQL Server数据库常用脚本 Java编程 入门基础篇 [x] 【Java基础】Java入门知识 [x] 【Java基础】Java基础知识 [x] 【Java基础】Java面向对象 [x] 【Java基础】Java进阶编程 [x] 【Java基础】Java网络编程 [x] 【Java基础】Java扩展知识 [x] 【Java基础】Java基础100实例"},{"title":"标签","date":"2019-04-07T06:57:35.000Z","updated":"2019-04-14T11:04:51.007Z","comments":true,"path":"tags/index.html","permalink":"https://zhangbc.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【数据库理论】数据库的安全和保护","slug":"【数据库理论】数据库的安全和保护","date":"2019-04-14T11:05:17.000Z","updated":"2019-04-14T16:20:16.760Z","comments":true,"path":"2019/04/14/db_security/","link":"","permalink":"https://zhangbc.github.io/2019/04/14/db_security/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，安全与保护概述1）数据安全性控制：防止未经授权的用户和存取数据库中的数据，避免数据的泄露，更改或破坏； 2）数据完整性控制：保证数据库中数据及语义的正确性和有效性，防止任何对数据库造成错误的操作； 3）数据库的并发控制：在多用户同时对一个个数据进行操作时，系统应能够加以控制，防止破坏数据库中的数据； 4）数据库的恢复：在数据库遭到破坏或者数据不正确时，系统有能力把数据库恢复到正确的状态。 二，数据库的安全性1，数据库安全性控制 1）用户标识与鉴别：系统提供的最外层的安全保护措施，其方法是由系统提供一定的方式让用户标识自己的名字或身份。 2）存取控制： （1）定义用户权限，并将用户权限等存储在数据字典中。用户权限是指不同等用户对不同对数据对象允许执行对操作权限，这些定义经过编译后存放在数据字典中，这些定义称为安全规则或授权规则；（2）合法权限检查。用户权限定义和合法权限检查机制组成类DBMS的安全子系统。 3）试图机制：数据安全性，逻辑数据独立性和操作简便性。 4）审计：审计追踪是一个对数据库进行更新对日志，还包括一些其他信息，如哪个用户执行了更新和什么时候执行的更新等。 5）数据加密：防止数据库中数据在存储和传输中失密的有效手段。 2，SQL Server的安全性措施 1）SQL Server安全控制概述 （1）操作系统安全验证（网络层）：通过设置安全模式来实现。（2）SQL Server安全验证（服务器）：通过SQL Server服务器登录名管理来实现。（3）SQL Server数据库安全验证：通过SQL Server数据库用户管理来实现。（4）SQL Server数据库对象安全验证（处理权限）：通过权限管理来实现。 2）SQL Server的安全认证模式 （1）身份验证阶段：Windows身份验证，混合模式验证。（2）权限认证阶段（3）设置身份验证 3）登录名和用户管理1234USE &lt;DATABASE NAME&gt;goCREATE USER &lt;new user_name&gt; FOR LOGIN &lt;login name&gt;; 4）权限管理 （1）权限分类：语句权限，对象权限，隐含权限；（2）角色分类：在SQL Server中，组是通过角色来实现的。角色分为服务器角色和数据库角色（预定义的数据库角色，用户自定义数据库角色和应用程序角色）。 三，数据库的完整性1，数据库的完整性定义：数据库的完整性是指数据的正确性（Correctness），有效性（Validity）和相容性（Consistency）。正确性是指数据的合法性；有效性是指数据是否属于所定义的有效范围；相容性是指表示同一事实的两个数据应一致，不一致就是不相容。 完整性检查：在DBMS中，检查数据库中的数据是否满足语义规定的条件。 2，完整性约束条件 1）完整性约束作用的对象可以是列，元组，关系。其中：列的约束主要是列的类型，取值范围，精度，排序等约束条件；元组的约束是元组中各个字段间的联系约束；关系的约束是若干元组间，关系集合上及关系之间的联系约束。 2）静态约束：指数据库在每个确定状态时的数据对象所应满足的约束条件，是反映数据库状态合理性的约束。 （1）静态列级约束：对一个列的取值范围的说明，即对数据类型的约束（数据的类型，长度，单位，精度等），对数据格式的约束，对取值范围或者取值集合的约束，对空值的约束，其他约束。（2）静态元组约束：规定元组的各个列之间的约束关系。（3）静态关系约束：实体完整性约束，参照完整性约束，函数依赖约束，统计约束。 3）动态约束：指数据库从一种状态转变为另一种状态时，新旧值之间所应满足的约束条件，是反映数据库状态变迁的约束。 （1）动态列级约束：修改列定义或者列值时应满足的约束条件。（2）动态元组约束：修改元组中各个字段间需要满足某种约束条件。（3）动态关系约束：加在关系变化前后状态上的限制条件，如事务一致性，原子性等。 3，完整性控制 1）定义功能：提供定义完整性约束条件的机制。 2）检查功能：检查用户发出的操作请求是否违背列完整性约束条件。 3）如果发现用户的操作请求使数据违背了完整性约束条件，则采取恰当的操作。 4，SQL Server的完整性实现 1）声明型数据完整性约束：在 create table 和 alter table 定义中使用约束限制表中的值。 2）过程型数据完整性约束：由缺省，规则和触发器实现，由视图和存储过程支持。 （1）约束：是SQL Server提供的自动保持数据库完整性的一种方法。分为：i）空值约束1[CONSTRAINT constraint_name] [NULL/NOT NULL] ii）主键约束1234-- 列级[CONSTRAINT constraint_name] PRIMARY KEY -- 表级[CONSTRAINT constraint_name] PRIMARY KEY(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;]) iii）唯一约束1234-- 列级[CONSTRAINT constraint_name] UNIQUE -- 表级[CONSTRAINT constraint_name] UNIQUE(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;]) 唯一约束和主键约束的区别： （1）在一个基本表中，只能定义在一个主键约束，但可以定义多个唯一约束；（2）两者都为指定但列建立唯一索引，但主键约束限制更为严格，不但不允许有重复值，而且也不允许由空值；（3）唯一约束与主键约束产生但约束可以是聚集索引，也可以是非聚集索引，在缺省情况下，唯一约束产生非聚集索引，主键约束产生聚集索引；（4）不能同时为同一列或者一组列既定义唯一约束，又定义主键约束。 iv）外键约束和参照约束 1[CONSTRAINT constraint_name] [FOREIGN KEY] REFERENCES ref_table (ref_column[&#123;,&lt;trf_column&gt;&#125;]) v）缺省值约束1[CONSTRAINT constraint_name] DEFAULT constraint_expression vi）检查约束1[CONSTRAINT constraint_name] CHECK(logical_expression) 例如：12345678910111213use mastergo ​create table Titles ( title_id varchar(6) constraint pk_title_id primary key, title varchar(80) not null constraint uniq_title unique, [type] char(12) not null constraint def_type default 'UNDECIDED', pub_id char(4), price money constraint chk_price check(price between 5 and 100), ytd_sales int, pub_date datetime not null constraint def_pub_date default getdate()) （2）规则：当向表当某列（或使用与该规则绑定的用户定义数据类型的所有列）插入列或更新数据时，它指定限制输入新值的取值范围。 12345678use mastergo​create rule rule_price as @price &gt;= 5 and @price &lt;= 100go​exec sp_bindrule 'rule_price', 'Titles.price'go （3）缺省：它指定在向数据库中的表插入数据时，如果用户没有明确给出某列的值，SQL Server自动为该列（使用与该缺省绑定的用户定义数据类型的所有列）输入值。 12345678use mastergo​create default def_price as 50go​exec sp_bindefault def_price, 'Titles.price'go 四，事务1，事务的概念 1）事务定义：用户定义的一个数据库操作序列，这些操作要么可全部成功执行，否则，将不执行其中任何一个操作。事务是一个不可分割的工作单元。 2）事务基本性质(ACID) （1）原子性(Atomicity)：事务中包含的所有操作要么全做，要么一个也不做。（2）一致性(Consistency)：定义在数据库上的各种完整性约束。（3）隔离性(Ioslation)：确保事务并发执行后的系统状态与这些事务以某种次序串行执行后的状态是等价的。（4）持久性(Durability)：一个事务一旦成功完成，它对数据库的改变必须是永久的，即使是在系统遇到故障的情况下也不会丢失。 2，事务调度 1）事务调度的定义：在一个大型的DBMS中，可能会同时存在多个事务处理请求，系统需要确定这组事务的执行次序，即每个事务的指令在系统中执行的时间顺序，这称为事务的调度。 2）合法调度须满足以下条件： i）调度必须包含所有的事务的指令；ii）一个事务中指令的顺序在调度中必须保持不变。 3）调度的基本形式 i）串行调度 串行调度：在前一个事务完成之后，在开始另外一个事务，类似与操作系统中的单道批处理作业。 可串行化调度：定义多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，这种调度策略称为可串行化调度。 ii）并行调度 并行调度可串行化：如果一组事务并行调度的执行结果等价于这组事务中所有提交事务的某个串行调度，则称该并行调度可串行化。 级联回滚：由于一个事务的故障而导致一系列其他事务的回滚。 无级联调度：应该对调度做出某种限制以避免级联回滚发生，这样的调度称为无级联调度。 可恢复调度：对每对事务$T_i$和$T_j$，如果$T_j$读取了由$T_i$所写的数据项，则$T_i$必须先于$T_j$提交。 3，事务隔离级别 1）并发操作带来的问题 i）丢失修改：又称写-写错误，两个事务$T_1$和$T_2$读入同一数据并修改，$T_2$提交的结果破坏了$T_1$提交的结果，导致$T_1$的修改被丢失。ii）脏读：又称写-读错误，事务$T_1$修改某一数据，并将其写回磁盘，事务$T_2$读取同一数据后，$T_1$由于某种原因被撤销，这时$T_1$已修改过的数据恢复原值，$T_2$读到的数据就与数据库中的数据不一致，则$T_2$读到的数据即为“脏”数据，即不正确的数据。iii）不可重复读：又称读-写错误，事务$T_1$读取某一数据后，事务$T_2$对其做了修改，当$T_1$再次读取该数据时，得到与前次不同的值。iv）幻想读：事务$T_2$按一定条件读取了某些数据后，事务$T_1$插入（删除）了一些满足这些条件的数据，当$T_2$再次按相同条件读取数据时，发现多（少）了一些记录。 2）事务隔离级别的定义 i）未提交读：又称脏读，允许运行在该隔离级别上的事务读取当前数据页上的任何数据，而不管该数据是否已提交，解决了丢失修改问题。ii）提交读：保证运行在该隔离级别上的事务不会读取其他未提交事务所修改的数据，解决了丢失修改和脏读的问题。iii）可重复读：保证一个事务如果再次访问同一数据，与此前访问相比，数据不会发生修改，解决了丢失修改，脏读和不可重复读问题。iv）可串行化：在这个级别上的一组事务的并发执行与它们的某个串行调度是等价的，解决了并发操作带来的四个不一致问题。 4，SQL Server中的事务定义 1）事务定义模式123456789101112-- 定义BEGIN TRAN[SACTION] [事务名[WITH MARK['事务描述']]]​-- 提交1COMMIT [TRAN[SACTION] [事务名]]-- 提交2COMMIT[WORK]​-- 回滚1ROLLBACK [TRAN[SACTION] [事务名|保存点名]]-- 回滚2COMMIT[WORK] 2）事务执行模式 i）显式事务：每个事务均以 BEGIN TRANSACTION 语句显式开始，以 COMMIT 或者 ROLLBACK 语句显式结束。ii）隐性事务：每个事务无须描述事务的开始，但仍以 COMMIT 或 ROLLBACK语句显式完成。iii）自动提交事务：SQL Server 的默认事务管理模式，意指每条单独的语句都是一个事务。在完成每个 T-SQL 语句时，都被提交或者回滚。 12-- 隐性事务设置方法SET IMPLICIT_TRANSACTIONS &#123;ON|OFF&#125; 3）事务隔离级别的定义1234567set transaction isolation level read uncommitted;​set transaction isolation level read committed;​set transaction isolation level repeatable read;​set transaction isolation level serializable; 4）批处理，触发器的事务 批处理是包含一个或者多个SQL语句的组，从应用程序一次性地发送到服务器执行。服务器将批处理语句编译成一个可执行单元，此单元称为执行计划。 五，并发控制1，相关概念 事务是并发控制的基本单位，事务最基本的特征之一是隔离性。为保证事务的隔离性，系统必须对并发事务之间的相互作用加以控制，这称为并发控制。并发控制的主要技术是封锁。 2，封锁技术 1）封锁：事务$T$在对某个数据库对象操作之前，先向系统发出请求，对其加锁。最基本的封锁模式有排他锁(X锁)和共享锁(S锁)。 i）排他锁：又称写锁，如果事务$T$对数据对象$A$加上$X$锁，则只允许$T$读取和修改$A$，其他任何事务都不能再对$A$加任何类型的锁，直到$T$释放$A$上的锁。申请对$A$的排他锁可表示为$XLOCK(A)$。ii）共享锁：又称读锁，如果事务$T$对数据对象$A$加上$S$锁，则只允许$T$读取$A$但不允许修改$A$，其他事务只能再对$A$加$S$锁而不能加$X$锁，直到$T$释放$A$上的$S$锁。申请对$A$的共享锁可表示为$SLOCK(A)$。 3，事务隔离级别与封锁规则 1）封锁协议（Locking Protocol）：在运用$X$锁和$S$锁这两种基本封锁对数据对象加锁时，还需要约定规则，如何时申请$X$锁或$S$锁，持锁时间，何时释放等，这些规则称为封锁协议。 2）长锁：保持到事务结束的锁；短锁：用完就释放的锁。 4，封锁粒度（MGL） 1）封锁粒度定义：封锁对象的大小称为粒度。 i）多粒度封锁：数据库中被封锁的资源按粒度大小会呈现处一种层次关系，元组隶属于关系，关系隶属于数据库，称为粒度树。当为某结点加上意向锁（$I$锁）时，就表明某些内层结点已发生事实上的封锁，防止其他事务再去封锁该结点，这种封锁方式称为多粒度封锁（Multi Granularity Lock）。ii）意向锁：如果对一个结点加意向锁，则说明该节点的下层结点正在加锁；对任意节点加锁时，必须先对它所在的上层结点加意向锁。 意向共享锁（IS锁）：如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。 意向排他锁（IX锁）：如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。 共享意向排他锁（SIX锁）：如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁。 5，并发控制 1）SQL Server锁模式：共享锁（S锁），更新锁（U锁），排他锁（X锁），意向共享锁（IS锁）， 意向排他锁（IX锁），共享意向排他锁（SIX锁）。 2）SQL Server锁粒度：行级（Row），页面级（Page），表级（Table） 3）强制封锁类型在通常情况下，数据封锁由DBMS控制，对用户是透明的，但可以在SQL语句中加入锁定提示来强制 SQL Server 使用特定类型但锁。 六，数据库恢复技术1，恢复的概念：负责将数据库从故障所造成的错误状态中恢复到某一已知的正确状态（也称为一致性状态或者完整状态）。 2，故障的种类 1）事务故障：指事务的运行没达到预期对象终点就终止，有两种错误可能造成事务执行失败。 i）非预期故障：是指不能由应用程序处理的故障，如运算溢出，但该事务可以在以后但某个时间重新执行。ii）可预期故障：指应用程序可以发现的事务故障，并且可以控制让事务回滚。 2）系统故障：又称软故障，指在硬件故障，软件错误的影响下，导致内存中的数据丢失，并使得事务处理终止，但未破坏外存中数据库。由于硬件错误和软件漏洞致使系统终止，而不破坏外存内容但故障又称为故障-停止假设。 3）介质故障：又称硬故障，指由于磁盘的磁头碰撞，瞬时的强磁场干扰等造成磁盘的损坏，破坏外存上的数据库，并影响正在存取的这部分数据的所有事务。 4）恢复的基本原理是冗余，即数据库中任意部分的数据可以根据存储在系统别处的冗余数据来重建。一般的冗余形式：副本和日志。 3，恢复的实现技术 1）数据转储：DBA定期将整个数据库复制到磁带或者在另一个磁盘上保存起来的过程。 i）静态转储：在系统中无运行事务时进行的转储操作，即转储操作开始的时刻，数据库处于一致性状态，而转储期间不允许对数据库的任何存取，修改活动。ii）动态转储：指在转储期间允许对数据库进行存取或修改，即转储与用户事务可以并发执行。iii）全量转储：每次转储全部数据库。iv）增量转储：每次只转储上一次转储后更新过的数据。 2）登记日志文件 日志是以事务为单位记录数据库每次更新活动的文件，由系统自动记录。遵循以下原则： i）登记的次序严格按并发事务执行的时间次序；ii）必须先写日志文件，然后写数据库。 前像：要撤消事务，日志中必须包含数据库发生变化前的所有记录的备份，这些记录称为前像(Before-Images)。 后像：为了恢复事务，日志中必须包含数据库改变之后的所有记录的备份，这些记录称为后像(After-Images)。 3）基本日志结构 日志是日志记录(Log Records)的序列，主要包含： （1）事务开始标识，如&lt;$T_i$ start&gt;；（2）更新日志记录，描述一次数据库写操作，如&lt;$T_i,X_i,V_1,V_2$&gt; 事务标识$T_i$是执行WRITE操作的事务的唯一标识；数据项标识$X_i$是所写数据项的唯一标识，通常是数据项在磁盘上的位置；更新前数据的旧值$V_1$ (对插入操作而言此项为空值)； 更新后数据的新值$V_2$ (对删除操作而言此项为空值)。（3）事务结束标识&lt;$T_i$ COMMIT&gt;，表示事务$T_i$提交；&lt;$T_i$ ABORT&gt;，表示事务$T_i$中止。 4，SQL Server基于日志的恢复策略 1）事务分类 i）圆满事务：指日志文件中记录了事务的COMMIT标识，说明日志中已经完整地记录下事务所有的更新活动。ii）夭折事务：指日志文件只有事务的开始标识，而无COMMIT标识，说明对事务更新活动的记录是不完整的，无法根据日志来重现事务。 2）基本的恢复操作 i）重做：对圆满事务所做过的修改操作应执行REDO操作，即重新执行该操作，修改对象赋予其新记录值，这种方法称为前滚。ii）撤销：对夭折事务所做过的修改操作应执行UNDO操作，即撤销该操作，修改对象赋予其旧记录值，这种方法又称为回滚。 3）事务故障恢复 i）反向扫描日志文件，查找该事务的更新操作；ii）对该事务的更新操作执行逆操作，即将事务更新前的旧值写入数据库；iii）继续反向扫描日志文件，查找其他事务的其他更新操作，做同样处理；iv）如此处理下去，直至读到该事务的开始标识，事务恢复故障完成。 4）系统故障恢复 i）正向扫描日志文件，找出圆满事务，将其事务标识记入重做队列；找出夭折事务，将其事务标识记入撤销队列；ii）对撤销队列中的各个事务进行撤销处理，即反向扫描日志文件，对每个撤销事务对更新操作执行逆操作；iii）对重做队列中的各个事务进行重做处理，即正向扫描日志文件，对每个重做事务重新执行日志文件登记的操作。 5）介质故障恢复 i）装入最新的数据库后备副本，将数据库恢复到最近一次转储时的一致性状态；ii）装入相应的日志文件副本，重做已完成的事务。 5，SQL Server的备份与恢复 1）SQL Server的备份 i）数据库备份：即完全备份。 设置简单恢复模式： 1alter database master set recovery simple; 执行完全备份： 12345use master;go​-- init:如果已存在bak文件，则首先删除，后执行backup database master to disk='E:\\mater_full.bak' with init; ii）差异备份：只存储上一次完备之后发生改变的数据。 12345use master;go​-- init:如果已存在bak文件，则首先删除，后执行backup database master to disk='E:\\mater_diff.bak' with init, differential; iii）日志备份：数据库的恢复模式必须设为完整恢复模式并且必须在数据更改为完整恢复模式后至少执行一次完整数据库备份。 设置完整恢复模式： 1alter database master set recovery full; 执行日志备份： 1234use master;go​backup log master to disk='E:\\master_log.bak' 2）SQL Server恢复 i）使用SQL Server管理工具还原数据库ii）使用T-SQL语句从简单备份策略还原数据库1restore database master from disk='E:\\master_full.bak'; iii）使用T-SQL语句还原差异备份12restore database master from disk='E:\\master_full.bak' with norecovery;restore database master from disk='E:\\master_diff.bak'; iv）使用T-SQL语句从完整备份策略还原数据库123restore database master from disk='E:\\master_full.bak' with replace, norecovery;restore log master from disk='E:\\master_log1.bak' with norecovery;restore log master from disk='E:\\master_log2.bak';","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zhangbc.github.io/categories/数据库/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"https://zhangbc.github.io/tags/数据库理论/"}]},{"title":"【数据库理论】数据库的设计与实施","slug":"【数据库理论】数据库的设计与实施","date":"2019-04-14T10:44:12.000Z","updated":"2019-04-14T10:46:42.548Z","comments":true,"path":"2019/04/14/db_design/","link":"","permalink":"https://zhangbc.github.io/2019/04/14/db_design/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据库设计概述数据库技术是信息资源开发，管理和服务的最有效手段，从小型 单项事务处理系统到大型的信息系统都利用了数据库技术来保证系统数据的整体性，完整性和共享性。 1，数据库设计的内容与特点 1）数据库设计包括结构特性设计与行为特性设计。 结构特性设计即数据库框架和数据库结构设计，其结果是得到一个合理的数据模型，以反映真实的事务间的联系，目的是汇总各用户的视图，尽量减少冗余，实现数据共享。结构特性是静态的。 行为特性设计是指应用程序设计，如查询，报表处理等，结构特性必须适应行为特性。 2，数据库设计方法 1）新奥尔良方法：将数据库设计分为需求分析，概念设计，逻辑设计，物理设计。 2）从本质上，规范设计法的基本思想是“反复探寻，逐步求精”。 3，数据库设计的步骤 1）数据库设计的过程：三大阶段六步骤，即：数据库规范设计，需求分析，概念结构设计，逻辑结构设计，物理结构设计，数据库实施与维护（总体规划阶段，系统开发设计阶段，系统运行与维护阶段）。 2）六个步骤： （1）数据规划设计：明确数据库建设的总体目标和技术路线，得出数据库设计项目的可行性分析报告，对数据库设计的进度和人员分工做出安排。（2）需求分析：准确弄清用户要求是数据库设计的基础。（3）概念结构设计：数据库逻辑结构依赖于具体的DBMS。概念结构是各用户关心的系统信息结构，是对现实世界的第一层抽象。（4）逻辑结构设计：使概念结构转换为某个DBMS所支持的数据模型，并进行优化。（5）物理结构设计：设计目标是从一个满足用户要求的已确定的逻辑模型出发，设计一个在限定的软件，硬件条件和应用环境下可实现的，运行效率高的数据库结构。（6）数据库实施与维护 二，数据库规划1，系统调查：搞清楚企业的组织层次，得到企业的组织结构图。 2，可行性分析：分析数据库建设是否具有可行性，即从经济，法律，技术等多方面进行可行性论证分析，在此基础上得到可行性报告。 3，数据库建设的总体目标和数据库建设的实施总安排 三，需求分析1，需求分析的任务 1）需求分析的任务：通过详细调查现实世界要处理的对象，充分了解原系统工作概况，明确各用户需求，在此基础上确定新的功能。 2）需求分析的重点：调查，搜集用户在数据管理中的信息要求，处理要求，安全性与完整性要求。 信息要求是指用户需要从数据库中获取信息的内容和性质，由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据。 处理要求是指用户要求完成什么样的处理功能，对处理的响应时间有什么要求，处理方式是批处理还是联机处理。 安全性要求是指保护数据不被未授权的用户破坏。 完整性要求是指保护数据不被授权的用户破坏。 2，需求分析的方法 1）常用的调查方法 （1）跟班作业（2）开调查会（3）查阅档案资料（4）询问（5）设计调查用表并请用户填写 3，需求分析的步骤 1）分析用户的活动 2）确定系统的边界 3）分析用户活动所设计的数据数据流图（DFD）是描述各处理活动之间数据流动的有力工具，是一种从数据流的角度描述一个组织业务活动的图示。 4）分析系统数据 数据字典（DD）是描述每个数据流，每个文件，每个加工的集合，是对数据流图中出现的所有数据元素给出逻辑定义和描述。 数据字典包括数据项，数据文件，数据流，数据加工处理。 数据项描述={数据项名，别名，数据项含义，数据类型，字节长度，取值范围，取值含义，与其他数据项的逻辑关系} 数据文件描述={数据文件名，所有数据项名，数据存取频度，存取方式} 数据流描述={数据流名称，所有数据项名，数据流来源，数据流去向，平均流量，峰值流量} 数据加工处理描述={加工处理名，说明，输入的数据流名，输出的数据流名，处理要求} 四，概念结构设计概念结构设计阶段是将用户需求抽象为信息结构（概念模型）的过程。 1，局部E-R图的设计 2，全局E-R图的设计 五，逻辑结构设计逻辑模式设计的主要目标是产生一个具体DBMS可处理的数据模型和数据库模式，即把概念设计阶段的全局E-R图转换成DBMS支持的数据模型。一般步骤： （1）将概念结构转换为一般的关系模型，网状模型或层次模型。（2）将转换来的关系模型，网状模型，层次模型向DBMS支持的数据模型转换，变成合适的数据库模式。（3）对模式进行挑战和优化。 六，物理结构设计1）在进行数据库的物理结构设计时，首先确定数据库的物理结构，然后是对所设计的物理结构设计进行评价。2）物理结构设计的重要目标是满足主要应用的性能要求。3）就RDBMS而言，物理结构设计主要内容有：为关系模式选取存取方法，设计关系，索引等数据库文件的物理存储结构。","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"https://zhangbc.github.io/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"https://zhangbc.github.io/tags/数据库理论/"}]},{"title":"【数据库理论】关系模式的规范化与查询优化","slug":"【数据库理论】关系模式的规范化与查询优化","date":"2019-04-13T14:31:38.000Z","updated":"2019-04-14T06:10:16.477Z","comments":true,"path":"2019/04/13/db_query_opt/","link":"","permalink":"https://zhangbc.github.io/2019/04/13/db_query_opt/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，问题的提出1，关系模式 关系模式定义：一个关系模式是一个系统，它是有一个五元组$R(U, D, DOM, I, F)$组成，其中，$R$为关系名，$U$是$R$的一组属性集合$\\{ A_1,A_2,A_3,\\dots,A_n \\}$，$D$是$U$中属性的域集合$\\{ D_1,D_2,D_3,\\dots,D_n \\}$，$DOM$为属性$U$到域$D$的映射，$I$为完整性约束集合，$F$为属性间的函数依赖关系。 2，关系 1）关系定义：在关系模式$R( U, D, DOM, I, F )$中，当且仅当$U$上的一个关系$r$足$F$时，$r$称为关系模式$R$的一个关系，记作$R(U)$或$R(U,F)$。 2）关系数据库对关系有一个最起码的要求： 每个属性必须是不可分割的数据项。满足列这个条件的关系模式就属于第一范式（1NF）。 3）数据依赖：通过一个关系中属性间值的相等与否以体现数据间的相互关系，是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。主要有：函数依赖FD，多值依赖MVD。 3，插入异常：表示数据插入时出现问题，即无法在缺少另一个实体实例或者关系实例的情况下表示实体或者实体的信息。 4，删除异常：删除表的某一行来反映某个实体实例或者关系实例消失，会导致丢失另一个不同实例实体或者关系实例的信息。 5，更新异常：更改表所对应的某个实体实例或者关系实例的单个属性，会将多行的相关信息全部更新。 二，关系模式的函数依赖1，函数依赖（FD） 1）函数依赖（FD）定义：设$R(U)$是属性集$U$上的关系模式，$X$，$Y \\subseteq U$。若对$R(U)$的任意一个可能的关系$r$，$r$中有任意两个元组$t_1$和$t_2$，如果$t_1 [ X ] = t_2 [ X ]$，有$t_1[ Y ] = t_2[ Y ]$，则称$X$函数确定$Y$，或者说$Y$函数依赖$X$，记为$X \\rightarrow Y$。 （1）如果$X \\rightarrow Y$，但是$Y \\nsubseteq X$，则称$X \\rightarrow Y$是非平凡的函数依赖；（2）如果$X \\rightarrow Y$，但是$Y \\subseteq X$，则称$X \\rightarrow Y$是平凡的函数依赖；（3）如果$X \\rightarrow Y$，则$X$为这个函数依赖的决定属性集(Determinant)；（4）如果$X \\rightarrow Y$，$Y \\rightarrow X$，则记为$X \\longleftrightarrow Y$；（5） 如果$Y$不函数依赖于$X$，则记为$X \\nrightarrow Y$。 2）完全函数依赖和部分函数依赖设$R(U)$是属性集$U$上的关系模式，如果$X \\rightarrow Y$，并且对于$X$的任何一个真子集$Z$，都有$Z \\nrightarrow Y$，则称$Y$完全依赖于$X$，记$X \\stackrel{f}{\\rightarrow} Y$；若$X \\rightarrow Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记$X \\stackrel{p}{\\rightarrow} Y$。 3）传递函数依赖设$R(U)$是属性集$U$上的关系模式，$X \\subseteq U$，$Y \\subseteq U$，$Z \\subseteq U$，$Z - X$，$Z - Y$，$Y - X$均非空，如果$X \\rightarrow Y(Y \\nsubseteq X)$，$Y \\nrightarrow X$，$Y \\rightarrow Z$，则称$Z$传递依赖于$X$。 2，键 1）候选键：设$R(U)$是属性集$U$上的关系模式，$K \\subseteq U$，如果$K \\stackrel{f}{\\rightarrow} U$，则$K$为$R$的候选键。候选键包含了关系模式的所有属性，称为全键。2）主属性：包含在任意一个候选键中的属性称为主属性。3）非主属性：不包含在任意候选键中的属性称为非主属性或非键属性。4）外键：在关系模式$R$中属性或者属性组$X$并非$R$的候选键，但$X$是另一个关系模式的候选键，则称$X$是$R$的外部键，也称外键。 3，函数依赖的逻辑蕴含 1）阿姆斯特朗公理体系 （1）包含规则：设$R(U)$是属性集$U$上的关系模式，$X \\subseteq U$，$Y \\subseteq U$，且$Y \\subseteq X$，则$X \\rightarrow Y$。 （2）平凡依赖：由包含规则得到的函数依赖都是平凡函数依赖。 （3）逻辑蕴含：设$R(U)$是属性集$U$上的关系模式，$F$是$R$上函数依赖集合，如果$R$的任意关系实例$r$使$F$成立的，函数依赖$X \\rightarrow Y$均成立，则称$F$逻辑蕴含$X \\rightarrow Y$。 （4）阿姆斯特朗公理：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$的一个函数依赖集合，$X \\subseteq U$，$Y \\subseteq U$，$Z \\subseteq U$。包含如下规则： i）包含规则：又称自反律，如果$Y \\subseteq X \\subseteq Z$，则$X \\rightarrow Y$为$F$所蕴含；ii）传递规则：如果$F$蕴含$X \\rightarrow Y$，$Y \\rightarrow Z$，则$X \\rightarrow Z$为$F$所蕴含；iii）增广规则：如果$F$蕴含$X \\rightarrow Y$，且$Z \\subseteq U$，则$XZ \\rightarrow YZ$为$F$所蕴含。 阿姆斯特朗公理包含蕴含规则如下： i）合并规则：如果$X \\rightarrow Y$，$X \\rightarrow Z$，则$X \\rightarrow YZ$；ii）伪传递规则：如果$X \\rightarrow Y$，$WY \\rightarrow Z$，则$WX \\rightarrow Z$；iii）分解规则：如果$X \\rightarrow Y$，$Z \\subseteq Y$，则$X \\rightarrow Z$；iv）集合累积规则：如果$X \\rightarrow YZ$且$Z \\rightarrow W$，则$X \\rightarrow YZW$。 【引理4-1】 $X \\rightarrow A_1A_2A_3 \\dots A_n$ 成立的充分必要条件是$X \\rightarrow A_i（i=1，2，\\dots，n）$成立。 2）闭包，覆盖和最小覆盖 （1）函数依赖的闭包：设$R$是一个具有属性集合$U$的关系模式，$F$是给定的函数依赖的集合，由$F$推导出的所有函数依赖的集合称为$F$的闭包，记作$F^{+}$。 （2）函数依赖集的覆盖：$R$表上的两个函数依赖集合$F$和$G$，如果函数依赖集$G$可以从$F$用蕴含规则推导出来，换言之，如果 $G \\subset F^{+}$，则称$F$ 覆盖 $G$，如果$F$ 覆盖 $G$ 且 $G$ 覆盖 $F$，则称这两个函数依赖集等价，记作$F \\equiv G$。 （3）属性集的闭包：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$上的函数依赖集，$X \\subseteq U$，定义$X$的闭包 $X^+$，作为$X$函数决定的最大属性集$Y$，则最大属性集满足 $X \\rightarrow Y$ 存在于 $F^+$ 中。 【算法4-1】 属性集 $X$ 的闭包 $X^+$ 的迭代算法： i）选$X$作为闭包$X^+$的初始值$X[0]$；ii）由$X[i]$计算$X[i+1]$时，它是由 $X[i]$ 并上属性集合$A$所组成的，其中$A$为$F$中存在的函数依赖 $Y \\rightarrow Z$，而$A \\subseteq Z$，$Y \\subseteq X[i]$。因为$U$是有穷的所以上述过程经过有限步后会达到$X[i] = X[i+1]$，此时$X[i]$为所求的$X^+$。 （4）最小覆盖 i）$F$中任意函数依赖的右部只包含一个属性；ii）不存在这样的函数依赖 $X \\rightarrow A$，使得$F$与 $F- \\{ X \\rightarrow A \\}$ 等价；iii）不存在这样的函数依赖$X \\rightarrow A$，$X$包含真子集$Z(Z \\subset X)$，使得 $(F-\\{ X \\rightarrow A \\} \\cup \\{ Z \\rightarrow A \\})$与$F$等价。如果$F$满足上述条件，则函数依赖$F$称为极小或者最小函数依赖集。 （5）最小覆盖集算法 从函数依赖集$F$构造最小覆盖$M$的算法如下： i）从函数依赖集$F$，创建函数依赖的一个等价集$H$，它的函数依赖的右边只有单个属性（使用分解规则）ii）从函数依赖集$H$，顺次去掉在$H$中非关键的单个函数依赖。一个函数依赖$X \\rightarrow Y$在一个函数依赖集中是非关键的，指如果 $X \\rightarrow Y$ 从$H$中去掉，得到结果$J$，仍然满足$H^+ = J^+$，或者说$H \\equiv J$。iii）从函数依赖集$J$，顺次用左边具有更少属性的函数依赖替换原来的函数依赖，只要不会导致$J^+$改变。iv）从剩下的函数依赖集中收集所有左边相同的函数依赖，使用合并规则创建一个等价的函数依赖集$M$，它的所有依赖的左边是唯一的。 （6）每个函数依赖集$F$都等价于一个极小函数依赖集。 三，关系模式的规范化规范化定义：把一个给定规范模式转化为某种范式的过程称为关系模式的规范过程，简称规范化。 1，第一范式 【定义4-1】 设$R$是一个关系模式，如果$R$的每个属性的值域都是不可分割的简单数据项的集合，则这个模式称为第一范式关系模式，记作1NF。 2，第二范式 【定义4-2】 如果关系模式$R$是第一范式，而且每个非主属性都完全函数依赖于$R$的键，则$R$称为第二范式的关系模式，记作2NF。 3，第三范式 【定义4-3】 设关系模式$R$满足2NF，而且它的任意一个非键属性都不传递依赖于任何候选键，则$R$称为第三范式的关系模式，记作3NF。 4，BCNF 【定义4-4】 设关系模式$R$满足1NF，如果对$R$的每个函数依赖 $X \\rightarrow Y$ 且 $Y \\nsubseteq X$，$X$必为候选键，则$R$满足BCNF，即：在关系模式 $R(U,F)$ 中，如果每个决定因素都包含键，则$R(U,F) \\in BCNF$。 一个满足BCNF的关系模式有如下 条件： i）所有非键属性对每个键都是完全函数依赖；ii）所有的键属性对每个不包含它的键，也是完全函数依赖；iii）没有任何属性完全函数依赖于非键属性的任意一组属性。 5，多值依赖与第四范式 1）多值依赖 （1）多值依赖定义：设 $R(U)$ 是属性集$U$上的一个关系模式，$X$，$Y$，$Z$是$U$的子集，并且 $Z=U-X-Y$，关系模式$R(U)$中多值依赖 $X \\rightarrow \\rightarrow Y$ 成立，当且仅当对$R(U)$的任意关系$r$，给定的一对 $(x，z)$ 值，有一组$Y$的值，这组值仅仅取决于$x$值，而与$z$值无关。 （2）如果 $X \\rightarrow \\rightarrow Y$，而 $Z=\\varnothing$，即$Z$为空，则 $X \\rightarrow \\rightarrow Y$ 称为平凡的多值依赖。 （3）多值依赖的公理（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。） i）对称性规则：如果 $X \\rightarrow \\rightarrow Y$，则 $X \\rightarrow \\rightarrow U-X-Y$；ii）传递性规则：如果 $X \\rightarrow \\rightarrow Y$，$Y \\rightarrow \\rightarrow Z$，则 $X \\rightarrow \\rightarrow Z-Y$；iii）增广规则：如果 $X \\rightarrow \\rightarrow Y$，$V \\subseteq W$，则 $WX \\rightarrow \\rightarrow VY$；iv）替代规则：如果 $X \\rightarrow Y$，则$X \\rightarrow \\rightarrow Y$；v）聚集规则：如果$X \\rightarrow \\rightarrow Y$，$Z \\subseteq Y$，$W \\cap Z = \\varnothing$，$W \\rightarrow Z$，则 $X \\rightarrow Z$。 （4）多值依赖的推导规则（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。） i）合并规则：如果 $X \\rightarrow \\rightarrow Y$， $X \\rightarrow \\rightarrow Z$，则 $X \\rightarrow \\rightarrow YZ$；ii）分解规则：如果 $X \\rightarrow \\rightarrow Y$， $X \\rightarrow \\rightarrow Z$，则 $X \\rightarrow \\rightarrow Y \\cap Z$，$X \\rightarrow \\rightarrow Y-Z$，$X \\rightarrow \\rightarrow Z-Y$；iii）伪传递规则：如果 $X \\rightarrow \\rightarrow Y$，$WY \\rightarrow \\rightarrow Z$，则 $WX \\rightarrow \\rightarrow (Z-WY)$；iv）混合伪传递规则：如果 $X \\rightarrow \\rightarrow Y$，$XY \\rightarrow Z$，则 $X \\rightarrow (Z-Y)$。 （5）在$R(U)$上，如果有 $X \\rightarrow \\rightarrow Y$ 在 $W(W \\subseteq U)$ 上成立，则 $X \\rightarrow \\rightarrow Y$ 称为$R(U)$的嵌入型多值依赖。 2）第四范式 【定义4-5】 设关系模式 $R(U,F) \\in 1NF$，$F$是$R$上的多值依赖集，如果$R$的每个非平凡多值依赖 $X \\rightarrow \\rightarrow Y$（$Y-X \\ne \\varnothing$，$XY$未包含$R$的全部属性），$X$都含有$R$的候选键，则称$R$是第四范式，记为4NF。 6，各范式之间的关系 1）各范式之间的关系 4NF \\subset BCNF \\subset 3NF \\subset 2NF \\subset 1NF2）各范式小结 i）$4NF$：限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖；ii）$3NF \\rightarrow BCNF$：消除主属性对候选关键字的部分和传递函数依赖；iii）$2NF \\rightarrow 3NF$：消除非主属性对候选关键字的传递函数依赖；iv）$1NF \\rightarrow 2NF$：消除非主属性对候选关键字的部分函数依赖。 四，关系模式的分解特性1，关系模式的分解 1）关系模式的分解定义：把一个关系模式分解成若干个关系模式的过程，称为关系模式的分解。 【定义4-6】 关系模式$R(U, F)$ 的分解是指$R$为它的一组子集 $\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 所代替的过程。其中，$U=U_1 \\cup U_2 \\dots \\cup U_k$，并且设 $U_i \\subseteq U_j(1 \\le i,j \\le k)$，$F_i$是$F$在$U$上的投影，即 $F_i = \\{X \\rightarrow Y \\in F^+ \\wedge XY \\subseteq U_i \\}$。 分解后表的连接丢失或者多余元组的分解称为有损分解，或称有损连接分解。 2）关系模式的分解遵守原则： i）无损连接性：信息不失真（不增减信息）；ii）函数依赖保持性：不破坏属性间存在的依赖关系。 2，分解的无损连接性 1）无损连接的概念 【定义4-7】 设$F$是关系模式$R$的函数依赖集，$\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 是$R$ 的一个分解，$r$是$R$的一个关系，定义 m_{\\rho}(r)=\\pi_{U_{1}}(r) \\infty \\pi_{U_{2}}(r) \\infty \\cdots \\infty_{\\pi_{U_{k}}}(r)如果$R$满足$F$的任意关系$r$均有则$r=m_\\rho(r)$，则称分解 $\\rho$ 具有无损连接性。 【引理4-2】 设 $\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 为关系模式$R$的一个分解， $r$是$R$的任一个关系，有 (1) $r \\subseteq m_\\rho(r)$；(2) 如果 $s = m_\\rho(r)$， 则 $\\pi_{U_{i}}(r) = \\pi_{U_{i}}(s)$；(3) $m_\\rho(m_\\rho(r)) = m_\\rho(r)$。 2）进行关系分解的必要性 一个关系模式分解后，可以存放原来所不能存放的信息，通常称为“悬挂”的元组，这是实际所需要的，也是分解的优点。 3）无损连接判定方法 【算法4-2】 (矩阵法)判别一个分解的无损连接性的算法。 (1) 构造初始表：构造一个$k$行$n$列的初始表，其中，每列对应于$R$的一个属性，每行用于表示分解后的一个模式组成。如果属性$A_j$属于关系模式$R_i$，则表示在表的第$i$行第$j$列置符号$a_j$，否则置符号$b_{ij}$。(2) 根据$F$中的函数依赖修改表的内容：考察$F$中的每个函数依赖 $X \\rightarrow Y$，在属性组$X$所在的那些列上寻找具有相同符号的行，如果找到这样的两行或者更多行，则修改这些行，使这些行上属性组$Y$所在的列上元素相同。修改规则是：如果$Y$所在的要修改的行有一个为$a_j$，则这些元素均变成$a_j$；否则改为$b_{mj}$（其中$m$为这些行的最小行号）。(3) 判断分解是否为无损连接：如果通过修改，发现表中有一行变为 $a_1,a_2,\\dots,a_n$，则分解是无损连接的，否则分解不具有无损连接性。 【定理4-1】 （定理法）设 $\\rho = \\{ R_1,R_2 \\}$ 是关系模式$R$的一个分解，$F$是$R$的函数依赖集，$U_1$，$U_2$和$U$分别是$R_1$，$R_2$和$R$的属性集合，那么$\\rho$是$R$(关于$F$)的无损分解的充分必要条件为 (U_1\\cap U_2) \\rightarrow U_1 - U_2 \\in F^+或者 (U_1\\cap U_2) \\rightarrow U_2 - U_1 \\in F^+【定理4-2】 （逐步分解定理）设$F$是关系模式$R$的函数依赖集，$\\rho = \\{ R_1,R_2,\\dots,R_k \\}$ 是$R$关于$F$的一个无损连接。 （1）如果 $\\sigma = \\{ S_1,S_2,\\dots,S_m \\}$ 是 $R_i$ 关于 $F_i$ 的一个无损连接分解，则 $\\varepsilon = \\{ R_1,R_2,\\dots,R_{i-1},S_1,S_2,\\dots,S_m,R_{i+1},\\dots,R_k \\}$ 是$R$关于$F$的无损连接分解，其中，$F_i = \\pi_{R_i}(F)$。（2）设 $\\tau = \\{ R_1,\\dots,R_{k},R_{k+1},\\dots,R_n \\}$ 是 $R$ 的一个分解，其中，$\\tau \\supseteq \\rho$，$\\tau$ 也是$R$关于$F$的无损连接分解。 3）分解的函数依赖保持性 【定义4-8】 设$F$是关系模式$R$的函数依赖集， $\\rho=\\{R_1(U_1, F_1),R_2(U_2, F_2),\\dots,R_k(U_k, F_k)\\}$ 为$R$的一个分解，如果 $F_i = \\pi_{R_i}(F)(i=1,2,\\dots,k)$ 的并集 $(F_1 \\cup F_2 \\cup \\dots \\cup F_k)^+ \\equiv F^+$，则称分解 $\\rho$ 具有函数依赖保持性。 3，关系模式分解算法 1）分解的基本要求：分解后的关系模式与分解前的关系模式等价，即分解必须具有无损连接和函数依赖保持性。 2）分解算法的结论 i）如果要求分解具有无损连接性，则分解一定可以达到BCNF； ii）如果要求分解保持函数依赖，则分解可以达到3NF，但不一定能够达到BCNF； iii）如果要求分解既具有无损连接性，又保持函数依赖，则分解可以达到3NF，但不一定能够达到BCNF。 五，关系模式的优化1，水平分解 1）水平分解的定义：水平分解是把关系元组分为若干个子集合，每个子集合定义为一个子关系，以提高系统效率的过程。 2）水平分解的规则： （1）根据“80%与20%原则”，在一个大型关系中，经常使用的数据只是很有限的一部分，可以把经常使用的数据分解出来形成一个子关系。（2）如果关系$R$上具有$n$个事务，而且多数事务存取的数据不相交，则$R$可分解为不大于$n$个子关系，使每个事务存取的数据形成一个关系。 2，垂直分解 1）垂直分解的定义设 $R(A_1,A_2,\\dots,A_k)$ 是关系模式，$R$的一个垂直分解是$n$个关系的集合$\\{ R_1(B_1,B_2,\\dots,B_v),\\dots,R_n(D_1,D_2,\\dots,D_m) \\}$，其中，$\\{B_1,B_2,\\dots,B_v \\},\\dots,\\{ D_1,D_2,\\dots,D_m \\}$ 是 $\\{ A_1,A_2,\\dots,A_k \\}$ 的子集合。 2）垂直分解的基本原则：经常在一起使用的属性从$R$中分解出来形成一个独立的关系。 六，关系查询优化1，关系系统及其查询优化 1）查询优化工作： i）关系数据库内部提供的优化机制；ii）用户通过改变查询的运算次序和建立索引等机制进行优化。 2）关系数据库查询优化的总目标：选择有效的策略，快速求得给定关系表达式的值，以减少查询执行的总开销。 3）查询执行的开销计算 i）在集中式数据库中，总代价=I/O代价+CPU代价ii）在多用户环境下，总代价=I/O代价+CPU代价+内存代价 2，查询优化的一般策略 1）尽量先执行选择运算2）在执行连接前对关系适当地预处理： i）索引连接；ii）排序合并连接 3，关系代数等价变换规则 1）连接，笛卡尔积交换律 E_1 \\times E_2 \\equiv E_2 \\times E_1E_{1} \\infty E_{2} \\equiv E_{2} \\infty E_{1}\\begin{array}{c}{E_{1} \\infty E_{2}} \\\\ {F}\\end{array} \\equiv \\begin{array}{c}{E_{2} \\infty E_{1}} \\\\ {F}\\end{array}2）连接，笛卡尔积结合律 (E_1 \\times E_2) \\times E_3 \\equiv E_1 \\times (E_2 \\times E_3)(E_{1} \\infty E_{2}) \\infty E_{3} \\equiv E_{1} \\infty (E_{2} \\infty E_{3})\\begin{array}{c}{(E_{1} \\infty E_{2}) \\infty E_{3}} \\\\ {F_1} \\quad \\quad {F_2} \\end{array} \\equiv \\begin{array}{c}{E_{1} \\infty (E_{2} \\infty E_{3})} \\\\ {F_1} \\quad \\quad {F_2} \\end{array}3）投影的串接定律 \\pi A_1,A_2,\\dots,A_n(\\pi B_1,B_2,\\dots.B_m(E)) = \\pi A_1,A_2,\\dots,A_n(E)4）选择的串接定律 \\sigma_{F_1}(\\sigma_{F_2}(E)) \\equiv \\sigma_{F_1 \\wedge F_2}(E)5）选择与投影的交换律 F(\\pi A_1,A_2,\\dots,A_n(E)) \\equiv \\pi A_1,A_2,\\dots,A_n(\\sigma_F(E))6）选择与笛卡尔积的交换律 \\sigma_F(E_1 \\times E_2) \\equiv \\sigma_F(E_1) \\times E_2\\sigma_F(E_1 \\times E_2) \\equiv \\sigma_{F_1}(E_1) \\times \\sigma_{F_2}(E_2) （其中F = F_1 \\wedge F_2）\\sigma_F(E_1 \\times E_2) \\equiv \\sigma_{F_2}(\\sigma_{F_1} (E_1) \\times E_2)7）选择与并运算的交换设$E = E_1 \\cup E_2$，$E_1$、$E_2$有相同的属性名，则 \\sigma_F(E_1 \\cup E_2) \\equiv \\sigma_F(E_1) \\cup \\sigma_F(E_2)8）选择与差运算的交换 \\sigma_F(E_1 - E_2) \\equiv \\sigma_F(E_1) - \\sigma_F(E_2)9）投影与笛卡尔积的交换 \\pi A_1,A_2,\\dots,A_n,B_1,B_2,\\dots,B_m(E_1 \\times E_2) \\equiv \\pi A_1,A_2,\\dots,A_n(E_1) \\cup \\pi B_1,B_2,\\dots,B_m(E_2)10）投影与并运算的交换 \\pi A_1,A_2,\\dots,A_n(E_1 \\cup E_2) \\equiv \\pi A_1,A_2,\\dots,A_n(E_1) \\cup \\pi A_1,A_2,\\dots,A_m(E_2)4，关系代数表达式的优化算法 关系系统的查询优化步骤： （1）把查询转换成某种内部表示（2）把语法树转换成标准（优化）形式（3）选择底层的存取路径（4）生成查询计划，选择代价最小的查询计划","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"https://zhangbc.github.io/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"https://zhangbc.github.io/tags/数据库理论/"}]},{"title":"【Java基础】Java基础100实例","slug":"【Java基础】Java基础100实例","date":"2019-04-12T14:52:13.000Z","updated":"2019-04-12T15:03:08.080Z","comments":true,"path":"2019/04/12/java_code_100/","link":"","permalink":"https://zhangbc.github.io/2019/04/12/java_code_100/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 通过菜鸟教程-Java教程的初步学习，现将其教程训练代码汇聚成篇。 菜鸟教程-Java Coding学习笔记 Applet应用程序实例 文档注释演示实例 序列化和反序列化 Socket编程—服务端实例 Socket编程—客户端实例 Java进阶知识 遍历演示 Map遍历实例 泛型方法实例 泛型的有界类型参数实例 泛型类实例 类型通配符实例 发邮件(纯文本，HTML文本，附件) 图片二进制转换 JAVA8新特性实例 JAVA操作MYSQL实例 菜鸟教程-Java实例Java 环境设置实例 Java实例 – 如何编译一个Java文件？ Java实例 – Java如何运行一个编译过的类文件？ Java实例 – 如何执行指定class文件目录（classpath）？ Java实例 – 如何查看当前Java运行的版本？ 12$ javac -d . HelloWorld.java$ java com.runoob.HelloWorld Java 字符串 Java 实例 – 字符串比较 Java 实例 - 查找字符串最后一次出现的位置 Java 实例 - 删除字符串中的一个字符 Java 实例 - 字符串替换 Java 实例 - 字符串反转 Java 实例 - 字符串查找 Java 实例 - 字符串分割 Java 实例 - 字符串分割(StringTokenizer) Java 实例 - 字符串大小写转换 Java 实例 - 测试两个字符串区域是否相等 Java 实例 - 字符串性能比较测试 Java 实例 - 字符串优化 Java 实例 - 字符串格式化 Java 实例 - 连接字符串 Java 数组 Java 实例 – 数组排序及元素查找 Java 实例 – 数组添加元素 Java 实例 – 获取数组长度 Java 实例 – 数组反转 Java 实例 – 数组输出 Java 实例 – 数组获取最大和最小值 Java 实例 – 数组合并 Java 实例 – 数组填充 Java 实例 – 数组扩容 Java 实例 – 查找数组中的重复元素 Java 实例 – 删除数组元素 Java 实例 – 数组差集 Java 实例 – 数组交集 Java 实例 – 在数组中查找指定元素 Java 实例 – 判断数组是否相等 Java 实例 - 数组并集 Java 时间处理 Java 实例 - 格式化时间（SimpleDateFormat） Java 实例 - 获取当前时间 Java 实例 - 获取年份、月份等 Java 实例 - 时间戳转换成时间 Java 方法 Java 实例 – 方法重载 Java 实例 – 输出数组元素 Java 实例 – 汉诺塔算法 Java 实例 – 斐波那契数列 Java 实例 – 阶乘 Java 实例 – 方法覆盖 Java 实例 – instanceOf 关键字用法 Java 实例 – break 关键字用法 Java 实例 – continue 关键字用法 Java 实例 – 标签(Label) Java 实例 – enum 和 switch 语句使用 Java 实例 – Enum（枚举）构造函数及方法的使用 Java 实例 – for 和 foreach循环使用 Java 实例 – Varargs 可变参数使用 Java 实例 – 重载(overloading)方法中使用 Varargs 打印图形 Java 实例 – 打印菱形 Java 实例 – 九九乘法表 Java 实例 – 打印三角形 Java 实例 – 打印倒立的三角形 Java 实例 – 打印平行四边形 Java 实例 – 打印矩形 Java 文件操作 Java 实例 - 文件写入 Java 实例 - 读取文件内容 Java 实例 - 删除文件 Java 实例 - 将文件内容复制到另一个文件 Java 实例 - 向文件中追加数据 Java 实例 - 创建临时文件 Java 实例 - 修改文件最后的修改日期 Java 实例 - 获取文件大小 Java 实例 - 文件重命名 Java 实例 - 设置文件只读 Java 实例 - 检测文件是否存在 Java 实例 - 在指定目录中创建文件 Java 实例 - 获取文件修改时间 Java 实例 - 创建文件 Java 实例 - 文件路径比较 Java 目录操作 Java 实例 - 递归创建目录 Java 实例 - 删除目录 Java 实例 - 判断目录是否为空 Java 实例 - 判断文件是否隐藏 Java 实例 - 获取目录大小 Java 实例 - 在指定目录中查找文件 Java 实例 - 获取文件的上级目录 Java 实例 - 获取目录最后修改时间 Java 实例 - 打印目录结构 Java 实例 - 遍历指定目录下的所有目录 Java 实例 - 遍历指定目录下的所有文件 Java 实例 - 在指定目录中查找文件 Java 实例 - 遍历系统根目录 Java 实例 - 查看当前工作目录 Java 实例 - 遍历目录 Java 异常处理 Java 实例 - 异常处理方法 Java 实例 - 多个异常处理（多个catch） Java 实例 - Finally的用法 Java 实例 - 使用 catch 处理异常 Java 实例 - 多线程异常处理 Java 实例 - 获取异常的堆栈信息 Java 实例 - 重载方法异常处理 Java 实例 - 链试异常 Java 实例 - 自定义异常 Java 数据结构 Java 实例 – 数字求和运算 Java 实例 – 利用堆栈将中缀表达式转换成后缀 Java 实例 – 在链表（LinkedList）的开头和结 Java 实例 – 获取链表（LinkedList）的第一个 Java 实例 – 删除链表中的元素 Java 实例 – 获取链表的元素 Java 实例 – 获取向量元素的索引值 Java 实例 – 栈的实现 Java 实例 – 链表元素查找 Java 实例 – 压栈出栈的方法实现字符串反转 Java 实例 – 队列（Queue）用法 Java 实例 – 获取向量的最大元素 Java 实例 – 链表修改 Java 实例 – 旋转向量 Java 集合 Java 实例 – 数组转集合 Java 实例 – 集合比较 Java 实例 – HashMap遍历 Java 实例 – 集合长度 Java 实例 – 集合打乱顺序 Java 实例 – 集合遍历 Java 实例 – 集合反转 Java 实例 – 删除集合中指定元素 Java 实例 – 只读集合 Java 实例 – 集合输出 Java 实例 – 集合转数组 Java 实例 – List 循环移动元素 Java 实例 – 查找 List 中的最大最小值 Java 实例 – 遍历 HashTable 的键值 Java 实例 – 使用 Enumeration 遍历 HashTable Java 实例 – 集合中添加不同类型元素 Java 实例 – List 元素替换 Java 实例 – List 截取 Java 网络实例 Java 实例 – 获取指定主机的IP地址 Java 实例 – 查看端口是否已使用 Java 实例 – 获取本机ip地址及主机名 Java 实例 – 获取远程文件大小 Java 实例 – Socket 实现多线程服务器程序 Java 实例 – 查看主机指定文件的最后修改时间 Java 实例 – 使用 Socket 连接到指定主机 Java 实例 – 网页抓取 Java 实例 – 获取 URL响应头的日期信息 Java 实例 – 获取 URL 响应头信息 Java 实例 – 解析 URL Java 实例 – ServerSocket 和 Socket 通信实例 Java 线程 Java 实例 – 查看线程是否存活 Java 实例 – 获取当前线程名称 Java 实例 – 状态监测 Java 实例 – 线程优先级设置 Java 实例 – 死锁及解决方法 Java 实例 – 获取线程id Java 实例 – 线程挂起 Java 实例 – 终止线程 Java 实例 – 生产者/消费者问题 Java 实例 – 获取线程状态 Java 实例 – 获取所有线程 Java 实例 – 查看线程优先级 Java 实例 – 中断线程 github代码送门: java_projects/runoob 腾讯云coding代码送门: java_project/dev","categories":[{"name":"Java","slug":"Java","permalink":"https://zhangbc.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhangbc.github.io/tags/Java基础/"}]},{"title":"【Java基础】Java扩展知识","slug":"【Java基础】Java扩展知识","date":"2019-04-12T14:19:34.000Z","updated":"2019-04-12T14:24:20.104Z","comments":true,"path":"2019/04/12/java_extend_knowledge/","link":"","permalink":"https://zhangbc.github.io/2019/04/12/java_extend_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java文档注释1）Java支持三种注释方式，分别是//、/* */、/** */(说明注释)。 2）javadoc标签 标签 描述 示例 @author 标识一个类的作者 @author description @deprecated 指名一个过期的类或成员 @deprecated description {@docRoot} 指明当前文档根目录的路径 Directory Path @exception 标志一个类抛出的异常 @exception exception-name explanation {@inheritDoc} 从直接父类继承的注释 Inherits a comment from the immediate surperclass. {@link} 插入一个到另一个主题的链接 {@link name text} {@linkplain} 插入一个到另一个主题的链接，但是该链接显示纯文本字体 Inserts an in-line link to another topic. @param 说明一个方法的参数 @param parameter-name explanation @return 说明返回值类型 @return explanation @see 指定一个到另一个主题的链接 @see anchor @serial 说明一个序列化属性 @serial description @serialData 明通过writeObject( ) 和 writeExternal( )方法写的数据 @serialData description @serialField 说明一个ObjectStreamField组件 @serialField name type description @since 标记当引入一个特定的变化时 @since release @throws 和 @exception标签一样. The @throws tag has the same meaning as the @exception tag. {@value} 显示常量的值，该常量必须是static属性。 Displays the value of a constant, which must be a static field. @version 指定类的版本 @version info 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.runoob;​​import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;​/** * 文档注释演示实例 * @author zhangbc * @version 1.0 */public class SquareNumber &#123; /** * This method returns the square of number. * This is a multiline description. You can use as many lines as you like. * @param number The value to be squared. * @return number squared. */ public double square(double number) &#123; return number * number; &#125;​ /** * This method input a number from the user. * @return The value input as a double. * @throws IOException in input error * @see IOException */ public double getNumber() throws IOException &#123; InputStreamReader isr = new InputStreamReader(System.in); BufferedReader inData = new BufferedReader(isr); String str; str = inData.readLine(); return Double.parseDouble(str); &#125;​ /** * This method demonstrates square(). * @param args args unused. * @throws IOException on input error. * @see IOException */ public static void main(String[] args) throws IOException &#123; SquareNumber sn = new SquareNumber(); double val; System.out.print(\"Enter value to be squared:\"); val = sn.getNumber(); val = sn.square(val); System.out.println(\"Squared value is : \" + val); &#125;&#125; 2，Java 8 新特性1）Java8(即jdk1.8)新特性 （1）Lambda 表达式：Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。（2）方法引用：可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。（3）默认方法：默认方法就是一个在接口里面有了一个实现的方法。（4）新工具：新的编译工具，如：Nashorn引擎jjs、 类依赖分析器jdeps。（5）Stream API：把真正的函数式编程风格引入到Java中。（6）Date Time API：加强对日期与时间的处理。（7）Optional 类：Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。（8）Nashorn, JavaScript 引擎：允许我们在JVM上运行特定的javascript应用。 3，Java MySQL连接 MysqlDemo.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.runoob;​import java.sql.*;​/** * 连接数据库实例 * @author zhangbc * @version v1.0 * @date 2019/3/28 22:14 */public class MysqlDemo &#123;​ /** * JDBC驱动名及其数据库URL */ static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://127.0.0.1:3306/pyspider_db\";​ /** * 数据库的用户与密码 */ static final String USER = \"root\"; static final String PASSWORD = \"xxxxxx\";​ public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try &#123; Class.forName(JDBC_DRIVER); System.out.println(\"连接数据库...\"); conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);​ System.out.println(\"实例化Statement对象...\"); stmt = conn.createStatement(); String sql; sql = \"select id, name, url from websites;\"; ResultSet rs = stmt.executeQuery(sql);​ while (rs.next()) &#123; int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String url = rs.getString(\"url\");​ System.out.printf(\"ID: %d\\t站点名称：%s\\t站点URL：%s\\n\", id, name, url); &#125;​ rs.close(); stmt.close(); conn.close(); &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (stmt != null) &#123; stmt.close(); &#125; &#125; catch (SQLException se) &#123; se.printStackTrace(); &#125;​ try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4，Java 9 新特性详情参见：Java 9 新特性","categories":[{"name":"Java","slug":"Java","permalink":"https://zhangbc.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhangbc.github.io/tags/Java基础/"}]},{"title":"【Java基础】Java网络编程","slug":"【Java基础】Java网络编程","date":"2019-04-12T14:13:28.000Z","updated":"2019-04-12T14:21:49.206Z","comments":true,"path":"2019/04/12/java_net_program/","link":"","permalink":"https://zhangbc.github.io/2019/04/12/java_net_program/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java网络编程1）概述 网络编程：编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。java.net包中J2EE的API包含有类和接口，他们提供低层次的通信细节。主要有： TCP：传输控制协议，保障了两个应用程序之间的可靠通信，通常用于互联网协议，称为TCP/IP； UDP：用户数据报协议，一个无连接的协议，提供了应用程序之间要发送的数据的数据包。 2）Socket编程 套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。 当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 3）ServerSocket类的方法：服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。 4）Socket类的方法：java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。 5）InetAddress类的方法：表示互联网协议（IP）地址。 6）demo实例 GreetingClient.java 1234567891011121314151617181920212223242526272829import java.io.*;import java.net.Socket;/** * Socket编程--客户端实例 * @author zhangbc * @date 2019/3/7 14:26 */public class GreetingClient &#123; public static void main(String[] args) &#123; String serverName = args[0]; int port = Integer.parseInt(args[1]); try &#123; System.out.println(\"连接到主机：\" + serverName + \", 端口号：\" + port); Socket client = new Socket(serverName, port); System.out.println(\"远程主机地址：\" + client.getRemoteSocketAddress()); OutputStream outServer = client.getOutputStream(); DataOutputStream outData = new DataOutputStream(outServer); outData.writeUTF(\"Hello from \" + client.getLocalSocketAddress()); InputStream inFromServer = client.getInputStream(); DataInputStream inData = new DataInputStream(inFromServer); System.out.println(\"服务器响应：\" + inData.readUTF()); client.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; GreetingServer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketTimeoutException;import java.lang.Thread;/** * @author zhangbc * @date 2019/3/7 15:09 */public class GreetingServer extends Thread &#123; private ServerSocket serverSocket; public static void main(String[] args) &#123; int port = Integer.parseInt(args[0]); try &#123; Thread thread = new GreetingServer(port); thread.run(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125; public GreetingServer(int port) throws IOException &#123; serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(10000); &#125; public void run() &#123; while (true) &#123; try &#123; System.out.println(\"等待远程连接，端口号为：\" + serverSocket.getLocalPort() + \"...\"); Socket server = serverSocket.accept(); DataInputStream inData = new DataInputStream(server.getInputStream()); System.out.println(inData.readUTF()); DataOutputStream outData = new DataOutputStream(server.getOutputStream()); outData.writeUTF(\"谢谢连接我：\" + server.getLocalSocketAddress() + \"\\nGoodbye!\"); server.close(); &#125; catch (SocketTimeoutException es) &#123; System.out.println(\"Socket timed out!\"); break; &#125; catch (IOException ex) &#123; ex.printStackTrace(); break; &#125; &#125; &#125;&#125; 2，Java发送邮件 SendEmail.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.runoob;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import javax.mail.Message.RecipientType;import java.util.Properties;/** * 发邮件(纯文本，HTML文本，附件) * @author zhangbocheng * @version v1.0 * @date 2019/3/7 20:40 */public class SendEmail &#123; public static void main(String[] args) throws NullPointerException &#123; // 收件人邮箱 String to = \"xxxxxxxxxxxxxxxxx@qq.com\"; // 发件人邮箱 final String from = \"xxxxxxxxxxxxxxxxx@163.com\"; final String pwd = \"xxxxxxxx\"; // 指定发邮件的主机 String host = \"smtp.163.com\"; // 获取系统属性 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.host\", host); properties.put(\"mail.smtp.auth\", \"true\"); // 获取默认Session对象 Session session = Session.getDefaultInstance(properties, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(from, pwd); &#125; &#125;); try &#123; // 创建默认的MimeMessage对象 MimeMessage message = new MimeMessage(session); // Set From：头部头字段 message.setFrom(new InternetAddress(from)); // Set To：头部头字段 message.addRecipient(RecipientType.TO, new InternetAddress(to)); // Set Subject：头部头字段 message.setSubject(\"This is the Subject Line!\"); // 设置消息体 message.setText(\"This is test text.\"); // 发送HTML消息，可以插入html标签 message.setContent(\"&lt;h1&gt;This is actual message&lt;/h1&gt;\", \"text/html;charset=utf-8\"); // 创建消息部分 BodyPart messageBodyPart = new MimeBodyPart(); // 消息 messageBodyPart.setText(\"This is message body.\"); // 创建多重消息 Multipart multipart = new MimeMultipart(); // 设置文本消息 multipart.addBodyPart(messageBodyPart); // 附件部分 messageBodyPart = new MimeBodyPart(); String fileName = \"/home/projects/java_pro/java_instances_demo/src/main/java/com/runoob/SendEmail.java\"; DataSource source = new FileDataSource(fileName); messageBodyPart.setDataHandler(new DataHandler(source)); messageBodyPart.setFileName(fileName); multipart.addBodyPart(messageBodyPart); // 发送完整部分 message.setContent(multipart); // 发送消息 Transport.send(message); System.out.println(\"Sent message successfully.\"); &#125; catch (MessagingException mex) &#123; mex.printStackTrace(); &#125; &#125;&#125; 3，Java Applet基础1）Applet基础 Applet是一种Java程序，一般运行在支持Java的Web浏览器内，是一个全功能的Java应用程序。 Java 中 Applet 类继承了 java.applet.Applet 类。 Applet 类没有定义 main()，所以一个 Applet 程序不会调用 main() 方法。 Applet 被设计为嵌入在一个 HTML 页面。 当用户浏览包含 Applet 的 HTML 页面，Applet 的代码就被下载到用户的机器上。 要查看一个 Applet 需要 JVM。 JVM 可以是 Web 浏览器的一个插件，或一个独立的运行时环境。 用户机器上的 JVM 创建一个 Applet 类的实例，并调用 Applet 生命周期过程中的各种方法。 Applet 有 Web 浏览器强制执行的严格的安全规则，Applet 的安全机制被称为沙箱安全。 Applet 需要的其他类可以用 Java 归档（JAR）文件的形式下载下来。 2）Applet的生命周期 Applet 类中的四个方法给我们提供了一个框架： init: 提供所需的任何初始化。在 Applet 标记内的 param 标签被处理后调用该方法。 start: 浏览器调用 init 方法后，该方法被自动调用。每当用户从其他页面返回到包含 Applet 的页面时，则调用该方法。 stop: 当用户从包含 Applet 的页面移除的时候，该方法自动被调用。 destroy: 此方法仅当浏览器正常关闭时调用。 paint: 该方法在 start() 方法之后立即被调用，或者在 Applet 需要重绘在浏览器的时候调用。paint() 方法实际上继承于 java.awt。 3）Applet类 每一个 Applet 都是 java.applet.Applet 类的子类，基础的 Applet 类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。 4）Applet的调用 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Hello World, Applet&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;hr&gt;&lt;applet code=\"HelloWorldApplet.class\" width=\"320\" height=\"120\"&gt;&lt;/applet&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhangbc.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhangbc.github.io/tags/Java基础/"}]},{"title":"【Java基础】Java进阶编程","slug":"【Java基础】Java进阶编程","date":"2019-04-11T14:05:07.000Z","updated":"2019-04-11T16:14:43.141Z","comments":true,"path":"2019/04/11/java_advance_program/","link":"","permalink":"https://zhangbc.github.io/2019/04/11/java_advance_program/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java数据结构Java工具包提供了强大的数据结构，在Java中的数据结构主要包括以下接口和类：枚举（Enumeration），位集合（BitSet），向量（Vector），栈（Stack），字典（Dictionary），哈希表（Hashtable），属性（Properties）。 1）枚举（Enumeration）：该接口定义了一种从数据结构中取回连续元素的方式。 2）位集合（BitSet）：该类实现了一组可以单独设置和清除的位或标志。 3）向量（Vector）：对象的元素通过索引访问，在创建时不必给对象指定大小，其大小会根据需要动态的变化。 4）栈（Stack）：实现了一个后进先出的数据结构，是Vector的一个子类。 5）字典（Dictionary）：是一个抽象类，定义了键映射到值的数据结构。当想要通过特定的键而不是整数索引来访问数据时，应使用Dictionary。注意：Dictionary类已经过时了，在实际开发中，你可以实现Map接口来获取键/值的存储功能。 6）哈希表（Hashtable）：提供了一种在用户定义键结构的基础上来组织数据的手段。Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。 7）属性（Properties）：继承于 Hashtable.Properties 类表示了一个持久的属性集；属性列表中每个键及其对应值都是一个字符串。 2，Java集合框架1）集合框架设计目标 （1）必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的；（2）允许不同类型的集合，以类似的方式工作，具有高度的互操作性；（3）对一个集合的扩展和适应必须是简单的。 2）Java集合框架图 3）集合框架是一个用来代表和操纵集合的统一架构，包含如下内容： （1）接口：是代表集合的抽象数据类型。例：Collection，List，Set，Map等。（2）实现（类）：是集合接口的具体实现。从本质上，他们是可重复使用的数据结构，例：ArrayList，LinkedList，HashSet，HashMap。（3）算法：是实现集合接口的对象里的方法执行的一些有用的计算，例：搜索和排序，这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。 集合框架的类和接口均在java.util包中。任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 4）集合接口 Set和List的区别 Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。 List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 5）集合实现类（集合类）：Java提供了一套实现了Collection接口的标准集合类。 6）集合算法：集合定义了三个不可改变的静态变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP。Collection Algorithms是一个列表中的所有算法实现。 7）迭代：使用Java Iterator，通过实例列出Iterator和listIterator接口提供的所有方法。 ArrayListDemo.java 123456789101112131415161718192021222324252627282930public class ArrayListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"Hello\"); list.add(\"World\"); list.add(\"Maven\"); list.add(\"Demo\");​ // 遍历1：使用foreach遍历List System.out.println(\"使用foreach遍历List:\"); for (String str: list) &#123; System.out.print(str + \" \"); &#125;​ // 遍历2：把链表变为数组相关的内容进行遍历List String[] strArray = new String[list.size()]; list.toArray(strArray); System.out.println(\"\\n把链表变为数组相关的内容进行遍历List:\"); for (int i = 0; i &lt; strArray.length; i++) &#123; System.out.print(strArray[i] + \" \"); &#125;​ // 遍历3：使用迭代器进行相关遍历List Iterator&lt;String&gt; iterator = list.iterator(); System.out.println(\"\\n使用迭代器进行相关遍历List:\"); while (iterator.hasNext()) &#123; System.out.print(iterator.next() + \" \"); &#125; &#125;&#125; MapDemo.java 1234567891011121314151617181920212223242526272829303132333435public class MapDemo &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"key1\", \"value1\"); map.put(\"key2\", \"value2\"); map.put(\"key3\", \"value3\");​ // 遍历1：通过Map.KeySet遍历 System.out.println(\"通过Map.KeySet遍历key与value：\"); for (String key: map.keySet()) &#123; System.out.println(\"key=\" + key + \", value=\" + map.get(key)); &#125;​ // 遍历2：通过Map.entrySet使用iterator遍历 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(\"key=\" + entry.getKey() + \", value=\" + entry.getValue()); &#125;​ // 遍历3：推荐，通过Map.entrySet遍历 System.out.println(\"通过Map.entrySet遍历key和value:\"); for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; System.out.println(\"key=\" + entry.getKey() + \", value=\" + entry.getValue()); &#125;​ // 遍历4：通过Map.values()遍历 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key：\"); for (String val: map.values()) &#123; System.out.println(\"value=\" + val); &#125; &#125;&#125; 8）比较器：使用 Java Comparator，通过实例列出Comparator接口提供的所有方法。 3，Java泛型1）Java泛型（generics） 是JDK5中引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，即：所操作的数据类型被指定为一个参数。 2）定义泛型方法的规则 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt;E&gt;）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（如int,double,char的等）。 123456789101112131415161718192021222324252627282930/** * 泛型方法实例 */class GenericMethod &#123; public static void main(String[] args) &#123; // 创建不同类型的数组：Integer，Double和Character Integer[] intArray = &#123;1, 2, 3, 4, 5&#125;; Double[] doubleArray = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;; Character[] charArray = &#123;'H', 'E', 'L', 'L', '0'&#125;;​ System.out.println(\"整型数组元素为：\"); printArray(intArray); System.out.println(\"双精度小数数组元素为：\"); printArray(doubleArray); System.out.println(\"字符型数组元素为：\"); printArray(charArray); &#125;​ /** * 泛型方法printArray * @param inputArray * @param &lt;E&gt; */ public static &lt;E&gt; void printArray(E[] inputArray) &#123; for (E element: inputArray) &#123; System.out.printf(\"%s \", element); &#125; System.out.println(); &#125;&#125; 3）有界的类型参数：限制那些被允许传递到一个类型参数的类型种类范围。声明首先要列出类型参数的名称，后跟 extends 关键字，最后紧跟它的上界。 123456789101112131415161718192021222324252627/** * 泛型的有界类型参数实例 */class MaxGenericMethod &#123; public static void main(String[] args) &#123; System.out.printf(\"%d,%d和%d中最大的数为%d.\\n\\n\", 3, 4, 5, maximum(3, 4, 5));​ System.out.printf(\"%.2f,%.2f和%.2f中最大的数为%.2f.\\n\\n\", 6.6, 7.7, 8.8, maximum(6.6, 7.7, 8.8));​ System.out.printf(\"%s,%s和%s中最大的数为%s.\\n\\n\", \"pear\", \"apple\", \"orange\", maximum(\"pear\", \"apple\", \"orange\")); &#125;​ public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) &#123; T max = x; if (y.compareTo(max) &gt; 0) &#123; max = y; &#125; if (z.compareTo(max) &gt; 0) &#123; max = z; &#125; return max; &#125;&#125; 4）泛型类：在类名后面添加类型参数声明部分。泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 123456789101112131415161718192021222324/** * 泛型类实例 * @param &lt;T&gt; */class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125;​ public T get() &#123; return t; &#125;​ public static void main(String[] args) &#123; Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); Box&lt;String&gt; stringBox = new Box&lt;&gt;(); integerBox.add(10); stringBox.add(\"菜鸟教程\");​ System.out.printf(\"整型值为：%d\\n\", integerBox.get()); System.out.printf(\"字符串为：%s\\n\", stringBox.get()); &#125;&#125; 5）类型通配符：一般使用?代替具体的类型参数。 （1）类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型；（2）类型通配符下限通过形如List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型。 1234567891011121314151617181920212223242526/** * 类型通配符实例 */class Wildcard &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;&gt;(); List&lt;Number&gt; number = new ArrayList&lt;&gt;();​ name.add(\"icon\"); age.add(18); number.add(314);​ getData(name); getUpperNumber(age); getUpperNumber(number); &#125;​ public static void getData(List&lt;?&gt; data) &#123; System.out.printf(\"data: %s\\n\", data.get(0)); &#125;​ public static void getUpperNumber(List&lt;? extends Number&gt; data) &#123; System.out.println(\"data: \" + data.get(0)); &#125;&#125; 4，Java序列化1）Java序列化：Java提供了一种对象序列化的机制，该机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据，有关对象的类型的信息和存储在对象中数据的类型。 （1）序列化一个对象，并将它发送到输出流。1public final void writeObject(Object x) throws IOException （2）从流中取出下一个对象，并将对象反序列化。1public final void readObject(Object x) throws IOException, ClassNotFundException 2）完整demo实例： Employee.java 12345678910111213141516171819package runoob;​import java.io.*;​/** * Employee类实现Serializable接口 * @author 张伯成 * @date 2019/3/7 12:30 */public class Employee implements Serializable &#123; public String name; public String address; public transient int SSN; public int number;​ public void mailCheck() &#123; System.out.println(\"Mailing a check to \" + name + \" \" + address); &#125;&#125; SerializeDemo.java 12345678910111213141516171819202122232425/** * SerializeDemo类，序列化对象 */class SerializeDemo &#123; public static void main(String[] args) &#123; Employee employee = new Employee(); employee.name = \"Reyan Ali\"; employee.address = \"Phonkka kuan, Ambehta Peer.\"; employee.SSN = 11122333; employee.number = 101;​ try &#123; FileOutputStream fileOut = new FileOutputStream(\"employee.ser\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(employee); out.close(); fileOut.close(); System.out.println(\"Serialized data is saved in employee.ser.\"); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;​ DeserializeDemo.java 123456789101112131415161718192021222324252627/** * DeserializeDemo类，反序列化对象 */class DeserializeDemo &#123; public static void main(String[] args) &#123; Employee employee; try &#123; FileInputStream fileIn = new FileInputStream(\"employee.ser\"); ObjectInputStream in = new ObjectInputStream(fileIn); employee = (Employee) in.readObject(); in.close(); fileIn.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); return; &#125; catch (ClassNotFoundException ex) &#123; System.out.println(\"Employee class not found.\"); ex.printStackTrace(); return; &#125; System.out.println(\"Deserialize Employee...\"); System.out.println(\"Name: \" + employee.name); System.out.println(\"Address: \" + employee.address); System.out.println(\"SSN: \" + employee.SSN); System.out.println(\"Number: \" + employee.number); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhangbc.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhangbc.github.io/tags/Java基础/"}]},{"title":"【Java基础】Java面向对象","slug":"【Java基础】Java面向对象","date":"2019-04-11T11:57:07.000Z","updated":"2019-04-11T12:07:56.393Z","comments":true,"path":"2019/04/11/java_object_oriented/","link":"","permalink":"https://zhangbc.github.io/2019/04/11/java_object_oriented/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java 继承1）Java继承的概念：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 2）Java继承类型：Java不支持多继承，但是支持多重继承。3）Java继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 4）Java继承关键字 继承可以使用extends和implements这两个关键字来实现继承，都继承于java.lang.Object，默认继承object祖先类。 （1）extends：只能继承一个类。（2）implements：可以变相地使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口。（3）super：通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。（4）this：指向自己的引用。（5）finally：声明类可以把类定义为不能继承的，即最终类；或用于修饰方法，该方法不能被子类重写。 5）Java构造器 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 ExtendsDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.example.springboot;​/** * @function: * @author: 张伯成 * @date: 2019/3/3 */public class ExtendsDemo &#123; public static void main(String[] args) &#123; System.out.println(\"==========SubClassOne 类继承===========\"); SubClassOne sc1 = new SubClassOne(); SubClassOne sc2 = new SubClassOne(100); System.out.println(\"==========SubClassTwo 类继承===========\"); SubClassTwo sc3 = new SubClassTwo(); SubClassTwo sc4 = new SubClassTwo(200); &#125;&#125;​​/** * SuperClass 祖先类 */class SuperClass &#123; private int number; SuperClass() &#123; System.out.println(\"SuperClass()\"); &#125;​ SuperClass(int number) &#123; this.number = number; System.out.println(\"SuperClass(int number)\"); &#125;&#125;​​/** * SubClassOne 类继承 */class SubClassOne extends SuperClass &#123; private int number; SubClassOne() &#123; System.out.println(\"SubClassOne()\"); &#125;​ SubClassOne(int number) &#123; super(300); this.number = number; System.out.println(\"SubClassOne(int number): \" + number); &#125;&#125;​​/** * SubClassTwo 类继承 */class SubClassTwo extends SuperClass &#123; private int number; SubClassTwo() &#123; super(300); System.out.println(\"SubClassTwo()\"); &#125;​ SubClassTwo(int number) &#123; this.number = number; System.out.println(\"SubClassTwo(int number): \" + number); &#125;&#125; 2，Java Override/Overload1）重写（Override）重写是子类对父类对允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写。重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。1234567891011121314151617181920212223242526272829/** * Animal类，祖先类 */class Animal &#123; public void move() &#123; System.out.println(\"动物可以移动...\"); &#125;&#125;​​/** * AnimalDog类，继承Animal，并重写父类的move()方法 */class AnimalDog extends Animal &#123; public void move() &#123; super.move(); System.out.println(\"狗可以跑和走.\"); &#125;&#125;​​class DogTest &#123; public static void main(String[] args) &#123; Animal animal = new Animal(); Animal dog = new AnimalDog(); animal.move(); dog.move(); &#125;&#125; 2）方法的重写规则 参数列表必须完全与被重写方法的相同。 返回类型必须完全与被重写方法的返回类型相同。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 3）super：当需要在子类中调用父类的被重写方法时，要使用super关键字。 4）重载（Overload）：在一个类里面，方法名字相同，而参数不同，返回类型可同可不同。 5）重载规则 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载； 无法以返回值类型作为重载函数的区分标准。 OverLoading.java12345678910111213141516171819202122232425262728public class OverLoading &#123; public int test() &#123; System.out.println(\"test()\"); return 1; &#125;​ public void test(int number) &#123; System.out.println(\"test(int)\"); &#125;​ public String test(int number, String str) &#123; System.out.println(\"test(int, String)\"); return \"test(int, String)\"; &#125;​ public String test(String str, int number) &#123; System.out.println(\"test(String,int)\"); return \"test(String,int)\"; &#125;​ public static void main(String[] args) &#123; OverLoading overLoad = new OverLoading(); System.out.println(overLoad.test()); overLoad.test(100); System.out.println(overLoad.test(100, \"test3\")); System.out.println(overLoad.test(\"test\", 100)); &#125;&#125; 6）重写和重载的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 3，Java 多态多态是同一个行为具有多个不同表现形式或形态的能力。多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 1）多态的优点：消除类型之间的耦合关系；可替换性；可扩充性；接口性；灵活性；简化性。 2）多态存在的三个必要条件：继承；重写；父类引用指向子类对象。 PolymorphicDemo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.example.springboot;​/** * @function: * @author: 张伯成 * @date: 2019/3/3 */public class PolymorphicDemo &#123; public static void main(String[] args) &#123; show(new Cat()); show(new Dog());​ Animals animal = new Cat(); animal.eat();​ Cat cat = (Cat) animal; cat.work(); &#125;​ public static void show(Animals animal) &#123; animal.eat();​ if (animal instanceof Cat) &#123; Cat cat = (Cat) animal; cat.work(); &#125; else if (animal instanceof Dog) &#123; Dog dog = (Dog) animal; dog.work(); &#125; &#125;&#125;​​abstract class Animals &#123; abstract void eat();&#125;​​class Cat extends Animals &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125;​ public void work() &#123; System.out.println(\"抓老鼠\"); &#125;&#125;class Dog extends Animals &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125;​ public void work() &#123; System.out.println(\"看家\"); &#125;&#125; 3）虚函数：虚函数的存在是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。 4）多态的实现方式：重写；接口；抽象类和抽象方法。 4，Java 抽象类在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 1）抽象类：在Java语言中使用abstract class定义抽象类。 2）继承抽象类 3）抽象方法：abstract 关键字可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体；抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 4）抽象类总结规定 （1）抽象类不能被实例化；只有抽象类的非抽象子类可以创建对象；（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能；（4）构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法；（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 5，Java 封装1）在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装 最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 2）封装的优点 （1）两个的封装能够减少耦合；（2）类内部的结构可以自由修改；（3）可以对成员变量进行更精确的控制；（4）隐藏信息，实现细节。 6，Java 接口1）接口概念 接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 2）接口与类相似点 一个接口可以有多个方法。 接口文件保存在.java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 3）接口与类的区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 4）接口特性 接口是隐式的，接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 public abstract。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 接口的方法都是公有的。 5）抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 6）接口的声明1234[可见度] interface 接口名称 [extends 其他的接口名名] &#123; // 声明变量 // 抽象方法&#125; 7）接口的实现：当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类；类使用implements关键字实现接口，在类声明中，implements关键字放在class声明后面。 （1）重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 （2）在实现接口的时候，需要注意以下规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 8）接口的继承 9）接口的多继承：在Java中，类的多继承是不合法，但接口允许多继承；在接口的多继承中extenfs关键字只需要用一次，在其后跟着继承接口。 10）标记接口 标记接口是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。 标记接口的作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 标记接口的主要目的：建立一个公共的父接口；向一个类添加数据类型。 7，Java 包（Package） 1）包的作用 （1）把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。（2）如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。（3）包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 总之，Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 2）创建包 3）import语句：为了能够使用某一个包的成员，需要在Java程序中明确导入该包。 4）package的目录结构 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 5）设置CLASSPATH系统变量 用下面的命令显示当前的CLASSPATH变量： 12345# Windows 平台（DOS 命令行下）$ C:\\&gt; set CLASSPATH# UNIX 平台（Bourne shell 下）$ echo $CLASSPATH 删除当前CLASSPATH变量内容： 1234# Windows 平台（DOS 命令行下）$ C:\\&gt; set CLASSPATH=# UNIX 平台（Bourne shell 下）$ unset CLASSPATH; export CLASSPATH 设置CLASSPATH变量： 1234# Windows 平台（DOS 命令行下）$ C:\\&gt; set CLASSPATH=C:\\users\\jack\\java\\classes# UNIX 平台（Bourne shell 下）$ CLASSPATH=/home/jack/java/classes; export CLASSPATH","categories":[{"name":"Java","slug":"Java","permalink":"https://zhangbc.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhangbc.github.io/tags/Java基础/"}]},{"title":"【Java基础】Java基础知识","slug":"【Java基础】Java基础知识","date":"2019-04-10T16:39:20.000Z","updated":"2019-04-10T17:10:49.729Z","comments":true,"path":"2019/04/11/java_basic_knowledge/","link":"","permalink":"https://zhangbc.github.io/2019/04/11/java_basic_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java基本数据类型变量就是申请内存来存储值。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 Java有两大数据类型：内置数据类型和引用数据类型。 1）内置数据类型 名称 描述 取值范围 默认值 主要用途 byte 8位，有符号的，以二进制补码表示的整数 - $2^7$ ~ $2^7$ -1 0 在大型数组中节约空间，代替整数 short 16位，有符号的，以二进制补码表示的整数 -$2^{15}$~$2^{15}$-1 0 节省空间 int 32位，有符号的，以二进制补码表示的整数 -$2^{31}$~$2^{31}$-1 0 整型变量的默认类型 long 64位，有符号的，以二进制补码表示的整数 -$2^{63}$~$2^{63}$-1 0L 使用在需要比较大整数的系统上 float 单精度、32位、符合IEEE 754标准的浮点数 -$2^{31}$~$2^{31}$-1 0.0f 在存储大型浮点数组时可以节省空间；不能用来表示精确的值 double 双精度、64位、符合IEEE 754标准的浮点数 -$2^{63}$~$2^{63}$-1 0.0d 浮点数变量的默认类型 boolean 表示一位的信息 true,false false 作为一种标记来记录true/false情况 char 单一的 16 位 Unicode 字符 \\u0000~\\uffff(0~$2^{16}$-1) 存储任何字符 2）引用类型 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 3）Java常量：常量在程序运行时，不会被修改，关键字final。通常使用大写字母表示常量。 4）Java类型转换 自动类型转换：转换从低级到高级。 数据类型转换满足的原则：（1）不能对boolean类型进行类型转换；（2）不能把对象类型转换成不相关类的对象；（3）在把容量大的类型转换为容量小的类型时必须使用强制类型转换；（4）转换过程中可能导致溢出或损失精度；（5）浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。 强制类型转换：条件是转换的数据类型必须是兼容的。 隐含强制类型转换 2，Java语句类型1）循环结构 while do...while for foreach 增强型for循环：主要用于数组 demo：1234567891011121314151617public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(\",\"); &#125; System.out.print(\"\\n\"); String [] names =&#123;\"James\", \"Larry\", \"Tom\", \"Lacy\"&#125;; # 增强型for循环 for( String name : names ) &#123; System.out.print( name ); System.out.print(\",\"); &#125; &#125;&#125; 2）break语句：主要用于循环语句或者switch语句中；跳出最里层的循环，并且继续执行该循环下面的语句。 3）continue语句：适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代。 4）分支结构 if：一个if语句包含一个布尔表达式和一条或多条语句。 switch case语句：判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 3，Java基础类1）Number &amp; Math类 2）Math类：包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 3）Character类：对单个字符进行操作。 将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 4）String类 用于获取有关对象的信息的方法称为访问器方法。 5）StringBuffer和StringBuilder类 和String类不同的是，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder类在Java 5中被提出，它和StringBuffer之间的最大不同在于 StringBuilder的方法不是线程安全的（不能同步访问）。 由于StringBuilder相较于StringBuffer有速度优势，所以多数情况下建议使用 StringBuilder类。 在应用程序要求线程安全的情况下，则必须使用 StringBuffer类。 4，Java数组1）声明数组123dataType[] arrayRefVar; // 首选的方法 # ordataType arrayRefVar[]; // 效果相同，但不是首选方法 2）创建数组 1arrayRefVar = new dataType[arraySize]; 3）多维数组1234567891011type[][] typeName = new type[typeLength1][typeLength2]; // 直接为每一维分配空间​// 从最高维开始，分别为每一维分配空间String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String(\"Good\");s[0][1] = new String(\"Luck\");s[1][0] = new String(\"to\");s[1][1] = new String(\"you\");s[1][2] = new String(\"!\"); 4）Arrays类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法，按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 5，Java日期时间java.util包提供了Date类来封装当前的日期和时间。 Date类提供两个构造函数来实例化 Date 对象。第一个构造函数使用当前日期和时间来初始化对象。1Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。1Date(long millisec) 1）获取当前日期时间12345678import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; Date date = new Date(); System.out.println(date.toString()); &#125;&#125; 2）日期比较 getTime()：获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 before(), after(), equals() compareTo()：由Comparable接口定义的，Date类实现了这个接口。 3）格式化日期时间 SimpleDataFormat1234567public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); SimpleDateFormat ft = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(\"当前时间为：\"+ft.format(now)); &#125;&#125; printf1234567891011121314151617public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); //c的使用 System.out.printf(\"全部日期和时间信息：%tc%n\", now); //f的使用 System.out.printf(\"年-月-日格式：%tF%n\", now); //d的使用 System.out.printf(\"月/日/年格式：%tD%n\", now); //r的使用 System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\", now); //t的使用 System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\", now); //R的使用 System.out.printf(\"HH:MM格式（24时制）：%tR\", now); &#125;&#125; 4）Java休眠（Sleep）1234567891011public class SleepDemo &#123; public static void main(String[] args) &#123; try &#123; System.out.println(new Date()+\"\\n\"); Thread.sleep(1000*5); System.out.println(new Date()+\"\\n\"); &#125; catch (Exception ex)&#123; System.out.println(\"Got an exception: \"+ex); &#125; &#125;&#125; 5）Calendar类123456789101112131415161718192021public class DateTestDemo &#123; public static void main(String[] args) &#123; // 创建一个代表系统当前日期的Calendar对象 Calendar now = Calendar.getInstance(); int year = now.get(Calendar.YEAR); int month = now.get(Calendar.MONTH); int day = now.get(Calendar.DAY_OF_WEEK); int date = now.get(Calendar.DATE); int hour = now.get(Calendar.HOUR_OF_DAY); int minute = now.get(Calendar.MINUTE); int second = now.get(Calendar.SECOND);​ System.out.println(now.getTime()); System.out.printf(\"%d-%d-%d %d:%d:%d\\n%d\\n\", year, month, day, hour, minute, second, date);​ // 创建一个表示2009年3月12日的Calendar对象 now.set(2009, 3-1, 12); System.out.println(now.getTime()); &#125;&#125; 6）GregorianCalendar类：实现了公历日历，是Calendar类的一个具体实现。1234567891011public class DateTestDemo &#123; public static void main(String[] args) &#123; GregorianCalendar gCalender = new GregorianCalendar(); int year = gCalender.get(Calendar.YEAR); if (gCalender.isLeapYear(year)) &#123; System.out.println(\"当前年份是闰年！\"); &#125; else &#123; System.out.println(\"当前年份不是闰年！\"); &#125; &#125;&#125; 6，正则表达式1） java.util.regex包主要包括以下三个类： Pattern类：是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类：是对输入字符串进行解释和匹配操作的引擎。 PatternSyntaxException：是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 12345678public class RegexDemo &#123; public static void main(String[] args) &#123; String content = \"I am a student, graduated from HuBei University.\"; String pattern = \".*HuBei.*\"; boolean isMath = Pattern.matches(pattern, content); System.out.println(\"字符串是否包含类'HuBei'子字符串？\"+isMath); &#125;&#125; 2）捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。1234567891011121314151617181920public class RegexDemo &#123; public static void main(String[] args) &#123; String content = \"I am a student, graduated from HuBei University in 2013. \"; String pattern = \"(\\\\D*)(\\\\d+)(.*)\";​ // 创建Pattern对象 Pattern rex = Pattern.compile(pattern);​ // 创建matcher对象 Matcher matcher = rex.matcher(content); if (matcher.find()) &#123; System.out.println(\"Found value: \" + matcher.group(0)); System.out.println(\"Found value: \" + matcher.group(1)); System.out.println(\"Found value: \" + matcher.group(2)); System.out.println(\"Found value: \" + matcher.group(3)); &#125; else &#123; System.out.println(\"No match!!!\"); &#125; &#125;&#125; 7，Java方法1）Java方法定义：Java方法是语句的集合，他们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 2）Java方法的优点 使程序变得更简短而清晰 有利于程序维护 可以提高程序开发的效率 提高了代码的重用性 3）Java方法的命名规则 必须以字母、&#39;_&#39;或&#39;＄&#39;开头（方法名第一个单词应以小写字母开头，后面的单词则用大写字母开头写，不使用连接符）； 可以包括数字，但不能以它开头； 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。 4）Java方法的定义123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 5）Java方法调用1234567891011121314151617public class MaxTest &#123; public static void main(String[] args) &#123; int i = 2, j = 4; int max = getMax(i, j); System.out.printf(\"%d和%d比较，最大值是：%d.\", i, j, max); &#125;​ private static int getMax(int num1, int num2) &#123; int result; if (num1 &gt; num2) result = num1; else result = num2;​ return result; &#125;&#125; 6）void关键字 7）Java方法重载：一个类的两个方法拥有相同的名字，但是有不同的参数列表。 8）变量作用域 9）命令行参数：命令行参数是在执行程序时候紧跟在程序名字后面的信息。 10）构造方法：当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 11）可变参数：JDK1.5开始，Java支持传递同类型的可变参数给一个方法。1typeName... parameterName 在方法声明中，在指定参数类型后加一个省略号(...) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。12345678910111213141516171819202122public class MaxTest &#123; public static void main(String[] args) &#123;​ double max = getMax(1, 2, 3, 4, 5, 6, 7, 8, 0, 1); System.out.printf(\"...numbers中，最大值是：%.2f.\", max); &#125;​ private static double getMax(double... numbers) &#123; if (numbers.length == 0) &#123; System.out.println(\"No argument passed.\"); return -10000000000L; &#125;​ double result = numbers[0]; for (double var: numbers) &#123; if (var &gt; result) &#123; result = var; &#125; &#125; return result; &#125;&#125; 12）finalize()方法：在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。 Java 的内存回收可以由 JVM 来自动完成。 FinalizationDemo.java如下：1234567891011121314151617181920212223public class FinalizationDemo &#123; public static void main(String[] args) &#123; Cake c1 = new Cake(1); Cake c2 = new Cake(2); Cake c3 = new Cake(3);​ c2 = c3 = null; System.gc(); // 调用Java垃圾回收集器 &#125;&#125;​class Cake extends Object &#123; private int id; public Cake(int id) &#123; this.id = id; System.out.println(\"Cake Object \" + id + \" is created.\"); &#125;​ protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"Cake object \" + id + \" is disposed.\"); &#125;&#125; 8，Java流（Stream），文件（File）和IOJava.io包几乎包含了所有操作输入、输出需要的类。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 1）读取控制台输入：Java的控制台输入由System.in完成。1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 2）从控制台读取多字符输入：从BufferedReader对象读取一个字符要使用 read()方法。1int read() throws IOException BRReadLine.java1234567891011public class BRReadLine &#123; public static void main(String[] args) throws IOException &#123; char ch; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"输入字符，按下'q'键退出.\"); do &#123; ch = (char) br.read(); System.out.println(ch); &#125; while (ch != 'q'); &#125;&#125; 3）从控制台读取字符串：从 标准输入读取一个字符要使用BufferedReader的 readLine()方法。1String readLine() throws IOException BRReadLines.java123456789101112public class BRReadLines &#123; public static void main(String[] args) throws IOException &#123; String str; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"Enter lines of text;\"); System.out.println(\"Enter 'end' to quit.\"); do &#123; str = br.readLine(); System.out.println(str); &#125; while (!str.equals(\"end\")); &#125;&#125; 4）控制台输出：控制台的输出由 print() 和 println() 完成。12345678public class WriteDemo &#123; public static void main(String[] args) &#123; int num; num = 'A'; System.out.write(num); System.out.write('\\n'); &#125;&#125; 5）读写文件：一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 6）FileInputStream：该流用于从文件读取数据，它的对象可以用关键字new来创建。12345678910111213141516171819202122232425/** * 把给定的context以二进制写进文件，同时输出控制台 * 但是存在乱码问题 */public class FileStreamTest &#123; public static void main(String[] args) throws IOException &#123; try &#123; byte[] bWrite = &#123;'a', 11, 21, 32, 40, 54&#125;; OutputStream os = new FileOutputStream(\"file_test.txt\"); for (byte var: bWrite) &#123; os.write(var); &#125; os.close();​ InputStream is = new FileInputStream(\"file_test.txt\"); int size = is.available(); for (int i = 0; i &lt; size; i++) &#123; System.out.println((char) is.read() + \" \"); &#125; is.close(); &#125; catch (IOException ex) &#123; System.out.println(\"File InputStream error: \" + ex.toString()); &#125; &#125;&#125; 7）FileOutputStream：该流用来创建一个文件并向文件中写数据，它的对象可以用关键字 new 来创建。1234567891011121314151617181920212223242526272829303132333435/** * 把给定的context以二进制写进文件，同时输出控制台 */public class FileIOStreamTest &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"file_test.txt\");​ // 构建FileOutputStream对象，文件不存在会自动新建 FileOutputStream fop = new FileOutputStream(file);​ // 构建对象，参数可以指定编码，默认为操作系统默认编码，windows是gbk OutputStreamWriter writer = new OutputStreamWriter(fop, \"UTF-8\");​ // 写入到缓冲区 writer.append(\"中文输入\"); writer.append(\"\\r\\n\"); writer.append(\"English input\");​ // 关闭写入流，同时会把缓冲区的内容写入文件 writer.close();​ // 关闭输出流，释放系统资源 fop.close();​ FileInputStream fip = new FileInputStream(file); InputStreamReader reader = new InputStreamReader(fip, \"UTF-8\"); StringBuilder sb = new StringBuilder(); while (reader.ready()) &#123; sb.append((char) reader.read()); &#125; System.out.println(sb.toString()); reader.close(); fip.close(); &#125;&#125; 关于文件和I/O的一些其他类：File Class；FileReader Class；FileWriter Class。 9，Java中的目录1）创建目录File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。 mkdirs()方法创建一个文件夹和它的所有父文件夹。 1234567public class CreateDir &#123; public static void main(String[] args) &#123; String dirName = \"/home/share/java\"; File file = new File(dirName); file.mkdirs(); &#125;&#125; 2）读取目录12345678910111213141516171819202122public class ReadDir &#123; public static void main(String[] args) throws IOException &#123; String dirName = \"/home/share\"; File fp = new File(dirName); if (fp.isDirectory()) &#123; System.out.println(\"目录：\" + dirName); // 提取包含的文件和文件夹的列表 String[] strings = fp.list(); for (int i = 0; i &lt; strings.length; i++) &#123; File tmp = new File(dirName + \"/\" + strings[i]); if (tmp.isDirectory()) &#123; System.out.println(strings[i] + \" 是一个目录.\"); &#125; else &#123; System.out.println(strings[i] + \" 是一个文件.\"); &#125; &#125; &#125; else &#123; System.out.println(dirName + \" 不是一个目录.\"); &#125; &#125;&#125; 3）删除目录或文件：删除文件可以使用java.io.File.delete()方法。123456789101112131415161718192021public class DeleteDir &#123; public static void main(String[] args) &#123; File folder = new File(\"/home/share/java\"); deleteFolder(folder); &#125;​ // 删除文件及目录 private static void deleteFolder(File folder) &#123; File[] files = folder.listFiles(); if (files != null) &#123; for (File fp: files) &#123; if (fp.isDirectory()) &#123; deleteFolder(fp); &#125; else &#123; fp.delete(); &#125; &#125; &#125; folder.delete(); &#125;&#125; 10，Java Scanner类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。基本语法如下：1Scanner scanner = new Scanner(System.in); 1）使用next方法 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next()不能得到带有空格的字符串。 ScannerNext.java12345678910111213public class ScannerNext &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"Next方式接收：\");​ // 判断是否还有输入 if (scan.hasNext()) &#123; String str = scan.next(); System.out.println(\"输入的数据为：\" + str); &#125; scan.close(); &#125;&#125; 2）使用nextLine方法 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 ScannerNextLines.java12345678910111213class ScannerNextLines &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"NextLine方式接收：\");​ // 判断是否还有输入 if (scan.hasNextLine()) &#123; String str = scan.nextLine(); System.out.println(\"输入的数据为：\" + str); &#125; scan.close(); &#125;&#125; 注意：如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取。 ScannerNumbers.java12345678910111213141516171819202122232425262728293031323334public class ScannerNumbers &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in);​ int numberI; float numberF; double numberD; System.out.println(\"输入整数：\"); if (scan.hasNextInt()) &#123; numberI = scan.nextInt(); System.out.println(\"整数是：\" + numberI); &#125; else &#123; System.out.println(\"输入的不是整数！\"); &#125;​ System.out.println(\"输入浮点数：\"); if (scan.hasNextFloat()) &#123; numberF = scan.nextFloat(); System.out.println(\"浮点数是：\" + numberF); &#125; else &#123; System.out.println(\"输入的不是浮点数！\"); &#125;​ System.out.println(\"输入双精度小数：\"); if (scan.hasNextDouble()) &#123; numberD = scan.nextDouble(); System.out.println(\"双精度小数是：\" + numberD); &#125; else &#123; System.out.println(\"输入的不是双精度小数！\"); &#125;​ scan.close(); &#125;&#125; 11，Java异常处理1）理解Java异常处理是如何工作的，需掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。 2）Exception 类的层次 所有的异常类是从 java.lang.Exception 类继承的子类。 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable 类还有一个子类Error 。 Error 用来指示运行时环境发生的错误。例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 在 Java 内置类中，有大部分常用检查性和非检查性异常。 3）Java内置类4）异常方法：主要是Throwable的方法。5）捕获异常123456789101112public class ExceptionDemo &#123; public static void main(String[] args) &#123; try &#123; int[] array = new int[2]; array[0] = 1; System.out.println(\"Access elements three: \" + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println(\"Exception: \" + ex.toString()); &#125; System.out.println(\"Out of the block.\"); &#125;&#125; 6）多重捕获块：一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 7）throws/throw关键字：如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 8）finally关键字：finally 关键字用来创建在 try 代码块后面执行的代码块；无论是否发生异常，finally 代码块中的代码总会被执行；在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 ExceptionDemo.java1234567891011121314public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] array = new int[2]; try &#123; System.out.println(\"Access elements three: \" + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println(\"Exception throw: \" + ex.toString()); &#125; finally &#123; array[0] = 20; System.out.println(\"First element value: \" + array[0]); System.out.println(\"The finally statement is executed.\"); &#125; &#125;&#125; 9）声明自定义异常 所有异常都必须是 Throwable 的子类。 如写一个检查性异常类，则需要继承 Exception 类。 如写一个运行时异常类，那么需要继承 RuntimeException 类。 综合实例 InsufficientFundException.java： 123456789101112/** * 自定义异常，继承Exception类 */public class InsufficientFundException extends Exception &#123; private double amount; public InsufficientFundException(double amount) &#123; this.amount = amount; &#125; public double getAmount() &#123; return amount; &#125;&#125; CheckingAccount.java： 1234567891011121314151617181920212223242526272829303132333435/** * 银行账户基本操作类 */public class CheckingAccount &#123; private double balance; private int number; public CheckingAccount(int number) &#123; this.number = number; &#125;​ // 存钱 public void deposit(double amount) &#123; balance += amount; &#125;​ // 取钱 public void withdraw(double amount) throws InsufficientFundException &#123; if (amount &lt;= balance) &#123; balance -= amount; &#125; else &#123; double needs = amount - balance; throw new InsufficientFundException(needs); &#125; &#125;​ // 返回余额 public double getBalance() &#123; return balance; &#125;​ // 返回账号 public int getNumber() &#123; return number; &#125;&#125; BankDemo.java： 123456789101112131415161718192021** * 模拟银行账户基本操作实例 */class BankDemo &#123; public static void main(String[] args) &#123; CheckingAccount account = new CheckingAccount(6228481); System.out.println(\"Deposit $500...\"); account.deposit(500.00);​ try &#123; System.out.println(\"Withdrawing $100...\"); account.withdraw(100);​ System.out.println(\"Withdrawing $600...\"); account.withdraw(600); &#125; catch (InsufficientFundException ex) &#123; System.out.println(\"Sorry, but you are short $\"+ex.getAmount()); ex.printStackTrace(); &#125; &#125;&#125; 10）通用异常在Java中定义了两种类型的异常和错误： JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhangbc.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhangbc.github.io/tags/Java基础/"}]},{"title":"【数据库理论】关系数据库","slug":"【数据库理论】关系数据库","date":"2019-04-10T13:22:51.000Z","updated":"2019-04-10T16:13:32.275Z","comments":true,"path":"2019/04/10/db_rdb/","link":"","permalink":"https://zhangbc.github.io/2019/04/10/db_rdb/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，关系模型的基本概念 关系及基本术语 在关系模型中，表格的第一行称为关系框架，是属性$A_1$，$A_2$，$A_3$，$\\dots$，$A_k$的有限集合。 表中的每行称为关系的一个元组；每列称为属性，它在某个值域上的取值，不同的属性可以在相同的值域上取值。 关系中的属性个数称为元数（Arity），元组个数称为基数。 关键字 超关键字(Super Key)：在关系中能够唯一标识元组的属性集合。 候选关键字(Candidate Key)：如果某一属性集合是超关键字，但去掉其中任意属性后就不再是超关键字，这样的属性称为候选关键字。 候选关键字的诸属性称为主属性，不包含在任何候选关键字中的属性称为非主属性（非码属性）。 主关键字(Primary Key)：如果关系中存在多个候选关键字，用户可选作元组标识的一个候选关键字为主关键字。 合成关键字(Composite Key)：当某个候选关键字包含多个属性时，该候选关键字称为合成关键字。 外部关键字(Foreign Key)：如果关系R的某个（些）属性K不是R中的候选关键字，而是另一个关系S的候选关键字，则K称为R的外部关键字。 二，关系模式 在关系数据库中，关系模式是型，关系是值。 【定义3-1】关系的描述称为关系模式，形式化表示为$R(U, D, DOM, I, F)$其中，$R$为关系名，$U$为组成该关系的属性名集合，$D$是$U$中属性的域，$DOM$为属性到域的映像集合，$I$为完整性约束集合，$F$为属性间数据的依赖关系集合。 ⚠️关系模式中带有下画线的属性集为主关键字。 三，关系模型的完整性 域完整性约束：主要规定属性值必须取自值域，一个属性能否为空值由其语义决定。 实体完整性约束：规定基本关系的所有主属性都不能取空值，而不仅是主属性整体不能取空值。 参照完整性约束：要求“不引用不存在的实体”，考虑的是不同关系之间的或同一关系的不同元组之间的制约。形式定义： 如果属性集K是关系R的主关键字，K也是关系S的外关键字，那么在关系S中，K的取值只允许两种可能，要么为空值，要么等于关系R中某个主关键字的值。关系R称为“参照关系”模式，关系S称为“依赖关系”模式。 用户自定义完整性约束：针对某个具体关系数据库的约束条件。 四，关系代数 关系查询语言分类 关系代数语言：查询操作是以集合操作为基础运算的DML语言。 关系演算语言：查询操作是以谓词演算为基础运算的DML语言。 关系代数的五种基本操作 相等定义：设有同类关系$r_1$和$r_2$，若$r_1$的任何一个元组都是$r_2$的一个元组，则称关系$r_2$包含关系$r1$，记作$r_1$ $\\subseteq$ $r_2$或 $r_2$ $\\supseteq$ $r_1$，如果$r_1$ $\\subseteq$ $r_2$且$r_1$ $\\supseteq$ $r_2$，则称关系$r_1$等于关系$r_2$，记作$r_1$=$r_2$。 【定义3-2】并(Union)：设有同类关系$r_1$[R]和$r_2$[R]，两者的并(Union)运算定义 $r_1$ $\\bigcup$ $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\vee$ $t$ $\\in$ $r_2$ }式中，$\\bigcup$为并运算符。$r_1$ $\\bigcup$ $r_2$的结果关系是$r_1$的所有元组与$r_2$的所有元组的并集（去掉重复元组）。 【定义3-3】差(Difference)：设有同类关系$r_1$[R]和$r_2$[R]，两者的差(Difference)运算定义为 $r_1$ - $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\wedge$ $t$ $\\notin$ $r_2$ }式中，- 为相减运算符。$r_1$ - $r_2$的结果关系是$r_1$的所有元组减去$r_1$与$r_2$相同的元组所剩下的元组的集合。 【定义3-4】笛卡儿积(Difference)：设$r$[R]为$k_1$元关系，$s$[S]为$k_2$元关系，两者的笛卡儿积(Difference)运算定义为 $r$ $\\times$ $s$ = { $t$ $\\mid$ $t$ = &lt;$u,v$&gt; $\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $s$ }。 【定义3-5】投影(Projection)：是对一个关系进行垂直分割，消去某些列，并重新安排列的顺序的操作。设有$r$[R]为$k$元关系，其关系框架R={$A_1$,$A_2$,$\\dots$,$A_k$}，$A_{j_1}$，$A_{j_2}$，$\\dots$，$A_{j_n}$ 为R中互不相同的属性，那么关系$r$在属性（分量）$A_{j_1}$，$A_{j_2}$，$\\dots$，$A_{j_n}$ 上的投影运算定义为 $\\Pi$ $A_{j_1}$,$A_{j_2}$,$\\dots$,$A_{j_n}$ $($ $r$ $)$ = { $u$ $\\mid$ $u$ = &lt; $t$ [$A_{j_1}$],$t$[$A_{j_2}$],$\\dots$,$t$[$A_{j_n}$] &gt; $\\wedge$ $t$ $\\in$ $r$ }式中，$\\Pi$为投影运算符。 【定义3-6】选择(Selection)：根据某些条件对关系进行水平分割，即选取符合条件的元组的操作。条件可用命题公式F表示，由运算对象和运算符组成： 运算对象：常数（用引号括起来）、元组分量（属性名或列的序号） 运算符：算术比较运算符（$\\lt$,$\\le$,$\\gt$,$\\ge$,=,$\\ne$，也称$\\theta$符），逻辑运算符（$\\vee$,$\\wedge$,$\\neg$） 关系R关于公式F的选择操作用$\\sigma$F$($R$)$表示，其定义为：$\\sigma$F $($ R $)$ $\\equiv$ { $t$ $\\mid$ $t$ $\\in$ R $\\wedge$ F($t$)=true}式中，$\\sigma$为选择运算符。$\\sigma$F$($R$)$表示从R中挑选满足公式F为真的元组所构成的关系。 关系代数的其他操作 【定义3-7】交(Intersection)：设有同类关系$r_1$[R]和$r_2$[R]，两者的交(Intersection)运算定义 $r_1$ $\\bigcap$ $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\wedge$ $t$ $\\in$ $r_2$}式中，$\\bigcap$为交运算符。$r_1\\bigcapr_2$的结果关系是$r_1$与$r_2$的所有相同元组构成的集合，显然，$r_1\\bigcapr_2$ 等于$r_1$ - ($r_1$ - $r_2$ )或者$r_2$ - ($r_2$ - $r_1$ )。 【定义3-8】$\\theta$-连接：设$r$[R]、$s$[S]关系框架分别为R = {$A_1$,$A_2$,$\\dots$,$A_n$} 和 {$B_1$,$B_2$,$\\dots$,$B_m$}，那么关系$r$和$s$的$\\theta$-连接（$\\theta$-Join）运算定义为：$r$ $\\Join$ $s$ = { $t$ $\\mid$ $t$ = &lt; $u, v$ &gt;$\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $u$[$A_i$]$\\theta$ $v$[$B_j$]} 【定义3-9】F-连接 ：设$r$[R]、$s$[S]关系框架分别为R = { $A_1$,$A_2$,$\\dots$,$A_n$ }，{ $B_1$,$B_2$,$\\dots$,$B_m$ }，F($A_1$,$A_2$,$\\dots$,$A_n$,$B_1$,$B_2$,$\\dots$,$B_m$)为一公式，那么关系$r$和$s$的F-连接（F-Join）运算定义为：$r$ $\\Join$ $s$ = { $t$ $\\mid$ $t$ = &lt; $u, v$&gt;$\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $s$ $\\wedge$F($u$[$A_1$],$\\dots$,$u$[$A_n$]),$u$[$B_1$],$\\dots$,$u$[$B_m$]) }即：$r$ $\\Join$ $s$ = $\\sigma$F $(r$ $\\times$ $s)$ 【定义3-10】自然连接： Natural Jion是一种特殊的等值连接，它要求关系R和关系S具有相同的属性组B($b_1$,$b_2$,$b_3$,$\\dots$ $\\dots$)，这些属性组的取值是相等的，在最后生成的关系中去掉属性重复的列。其计算过程如下： (1)计算$r$ $\\times$ $s$；(2)设$r$和$s$的公共属性是$A_1$,$A_2$,$\\dots$,$A_m$，选出$r$ $\\times$ $s$中满足$r.A_1$=$s.A_1$,$r.A_2$=$s.A_2$, $\\dots$, $r.A_m$=$s.A_m$的那些元组；(3)去掉$s.A_1$,$s.A_2$,$\\dots$,$s.A_m$这些列。 【定义3-11】除(Division)：给定关系$r$(X,Y)和$s$(Y,Z)，其中，X，Y，Z为属性组，$r$中的Y与$s$中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除(Division)运算得到一个新的关系$p$(X)，$p$是r中满足下列条件的元组在X属性列上的投影，即元组在X上的分量值$x$的像集$Y_x$包含s在Y上投影的集合，记为$r$ $\\div$ $s$ = { $t_r$[X]$\\mid$ $t_r$ $\\in$ $r$ $\\wedge$ $\\pi_y$($s$) $\\subseteq$ $Y_x$ }式中，$Y_x$为$x$在$r$中的像集，$x$=$t_r$[X]。 五，关系演算关系演算是以数理逻辑中的谓词为基础的，按谓词变元的不同，关系演算可以分为元组关系演算和域关系演算。 元组关系演算：以元组为变量。1） 在元组关系演算中，元组关系演算表达式的一般形式为：$\\{t|P(t)\\}$式中，t是元组变量，表示一个元数确定的元组，P是满足一定逻辑条件的公式，公式可以分解为一些原子公式，$\\{t|P(t)\\}$表示满足公式P的所有元组$t$的集合。2）在一个演算公式中，未用存在量词$\\exists$或全称量词$\\forall$符号定义的元组变量，称为自由元组变量，否则称为约束元组变量。 域关系演算：以属性(域)为变量，简称域演算。","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"https://zhangbc.github.io/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"https://zhangbc.github.io/tags/数据库理论/"}]},{"title":"【Java基础】Java入门知识","slug":"【Java基础】Java入门知识","date":"2019-04-08T15:52:05.000Z","updated":"2019-04-10T16:56:20.703Z","comments":true,"path":"2019/04/08/java_introductory_knowledge/","link":"","permalink":"https://zhangbc.github.io/2019/04/08/java_introductory_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，java简介 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。 1）Java分为三个体系： JavaSE(J2SE)Java2 Platform Standard Edition，java平台标准版） JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版) 2）Java的主要特性： java语言是简单的； java语言是面向对象的（纯面向对象）； java语言的分布式的； java语言是健壮的（丢弃指针，强类型机制，异常处理，垃圾的自动收集）； java语言是安全的（安全防范机制（类ClassLoader），安全管理机制（类SecurityManager））； java语言是可移植的； java语言是解释型的； java是高性能的； java语言多线程的； java语言是动态的。 3）Java的发展史：诞生于1995年；2014年3月18日，Oracle公司发表Java SE8。 4）Java工具：Java语言尽量保证系统内存在1G以上。 2，Java开发环境配置1）下载JDK工具解压安装，对应不同的系统选择适合的版本。 2）变量设置参数如下： 变量名：JAVA_HOME 变量值：C:\\Program Files (x86)\\Java\\jdk1.8.0_91 // 要根据自己的实际路径配置 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; //记得前面有个”.“ 变量名：Path 变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 3）测试JDK是否安装成功12~ java -version # 输出java安装的版本~ javac -version # 输出javac安装的版本 注意：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。 4）Java开发工具选择 Eclipse IntelliJ IDEA(推荐) 3，Java基础语法1）相关概念 类：类是一个模板，描述一个对象的行为和状态。 java中的类： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 构造方法：每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 创建对象：在Java中，使用关键字new创建一个新的对象，主要有三步：声明，实例化（new），初始化。 对象：对象是一个类的实例，有状态和行为。 在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 方法：方法即行为，一个类可以有很多方法。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 2）编程注意点 大小写敏感 类名每个单词的首字母大写（帕斯卡命名法） 方法名以小写字母开头，之后每个单词首字母大写（驼峰命名法） 源文件名必须和类名相同 主方法入口，所有的Java程序由public static void main(String []args)方法开始执行 3）Java标识符 标识符：类名，变量名及方法名都称为标识符。 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始； 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合； 关键字不能用作标识符； 标识符是大小写敏感的； 合法标识符举例：age、$salary、_value、__1_value； 非法标识符举例：123abc、-salary； 4）Java修饰符 （1）访问控制： default, public, protected, private 修饰符 当前类 同一包内 子孙类（同一包） 子孙类（不同包） 其他包 public Y Y Y Y Y protected Y Y Y Y /N N default Y Y Y N N private Y N N N N protected说明： 子类与基类在同一包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。 （2）访问控制和继承，注意以下原则： 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为 public，不能声明为private。 父类中声明为private的方法，不能够被继承。 （3）非访问控制：final, abstract,static, synchronized,volatile static：创建类方法和类变量； final：修饰类，方法和变量。修饰的类不可被继承；修饰的方法不能被继承的类重新定义；修饰的变量为常量，不可修改。 abstract：创建抽象类和抽象方法； synchronized：用于线程编程，synchronized声明的方法同一时间只能被一个线程访问； transient：序列化的对象包含被 transient修饰的实例变量时，Java虚拟机(JVM)跳过该特定的变量；该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile：用于线程编程， 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值，当成员变量发生变化时，会强制线程将变化值回写到共享内 5）Java变量 局部变量：类的方法中的变量。 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 类变量（静态变量）：独立于方法之外的变量，用static修饰。成员变量（非静态变量）：独立于方法之外的变量，不用static修饰。 6）Java数组：储存在堆上的对象，可以保存多个同类型变量。 7）Java枚举：Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。 8）Java关键字：参见Java关键字列表 9）Java注释 10）Java空行：空白行，或者有注释的行，Java编译器都会忽略掉。 11）Java继承在Java中，一个类可以由其他类派生。被继承的类称为超类（super class），派生类称为子类（subclass）。 12）Java接口：在Java中，接口可以理解为对象间相互通信的协议。 13）源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致 如果一个类定义在某个包中，那么package语句应该在源文件的首行 如果源文件包含import语句，那么应该放在package语句和类定义之间；如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 14）Java包：包主要用来对类和接口进行分类。 15）Import语句 16）Java运算符 算术运算符 关系运算符 位运算符：Java定义类位运算符，应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 逻辑运算符 赋值运算符 其他运算符（instanceof，自增，自减，条件运算符） 17）Java 源程序与编译型运行区别","categories":[{"name":"Java","slug":"Java","permalink":"https://zhangbc.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://zhangbc.github.io/tags/Java基础/"}]},{"title":"【数据库实战】SQL Server数据库常用脚本","slug":"【数据库实战】SQL-Server数据库常用脚本","date":"2019-04-07T08:40:27.000Z","updated":"2019-04-09T13:11:32.517Z","comments":true,"path":"2019/04/07/sql_used_script/","link":"","permalink":"https://zhangbc.github.io/2019/04/07/sql_used_script/","excerpt":"","text":"1，创建链接远程服务器及其删除12345exec sp_addlinkedserver 'web','','SQLOLEDB','192.168.10.106'exec sp_addlinkedsrvlogin 'web','false',null,'sa','123'--删除链接服务器exec sp_dropserver 'web','droplogins' 2，重置SQLSERVER表的自增列，让自增列重新计数语法：123456DBCC CHECKIDENT( table_name [, &#123; NORESEED | &#123; RESEED [,new_reseed_value ] &#125; &#125; ] ) [ WITH NO_INFOMSGS ] 参数： table_name:是要对其当前标识值进行检查的表名。指定的表必须包含标识列。表名必须符合标识符规则。 NORESEED:指定不应更改当前标识值。 RESEED:指定应该更改当前标识值。 new_reseed_value:用作标识列的当前值的新值。 WITH NO_INFOMSGS:取消显示所有信息性消息。 查看某表当前的种子值，示例：1dbcc checkident('mainTable',noreseed); 123-------------显示如下----------------检查标识信息: 当前标识值 '2707'，当前列值 '2707'。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 重置表mainTable的当前标识值为1，示例：1dbcc checkident('mainTable',reseed,1); 123-------------显示如下----------------检查标识信息: 当前标识值 'NULL'，当前列值 '1'。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 3，几个有用的存储过程 修改xx表中所有值null 123456789101112131415161718192021222324252627282930313233/************************* 功能：修改xx表中所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/if (OBJECT_ID('modifyNull','P') is not null) drop procedure modifyNullgocreate procedure modifyNull(@table char(100))asbegin --定义游标 declare col_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select b.name from sysobjects a inner join syscolumns b on a.id=b.id where a.name=@table --打开游标 open col_cur declare @columnName nvarchar(100) fetch next from col_cur into @columnName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='update ' + @table + ' set ' + @columnName + ' = ISNULL(' + @columnName + ', '''')' exec(@sql) fetch next from col_cur into @columnName end --关闭游标 close col_cur --释放游标 deallocate col_curend 修改数据库中所有表的所有列为null 123456789101112131415161718192021222324252627/************************* 功能：修改数据库中所有表的所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/create procedure [dbo].[modifyAllNull]asbegin declare tab_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select name from sysobjects where xtype='U' --打开游标 open tab_cur declare @tableName nvarchar(100) fetch next from tab_cur into @tableName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='exec dbo.modifyNull ' +'''' + @tableName + '''' exec(@sql) fetch next from tab_cur into @tableName end --关闭游标 close tab_cur --释放游标 deallocate tab_curend","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"https://zhangbc.github.io/categories/数据库技术/"}],"tags":[{"name":"数据库实战","slug":"数据库实战","permalink":"https://zhangbc.github.io/tags/数据库实战/"}]},{"title":"【数据库理论】绪论","slug":"【数据库理论】绪论","date":"2019-04-06T10:42:18.000Z","updated":"2019-04-10T16:56:20.697Z","comments":true,"path":"2019/04/06/db_introduction/","link":"","permalink":"https://zhangbc.github.io/2019/04/06/db_introduction/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据库的概念 数据库定义：数据库（DB）是长期保存在计算机的存储设备上并按照某种模型组织起来的，可以被各种用户或应用共享的数据集合。 数据库分类：关系数据库，层次数据库，网状数据库. 数据库基本特征：1）具有较高的数据独立性；数据独立性是指数据的组织方法和储存方法与应用程序互不依赖，彼此独立的特性，包括物理独立性和逻辑独立性。2）数据库用综合的方法组织数据，保证尽可能高的访问效率；3）具有较小的数据冗余，可以供多个用户共享；4）具有安全控制机制，能够保证数据的安全，可靠；5）数据允许多用户共享，能够有效，及时地处理数据，并能够保证数据的一致性和完整性。 二，数据库管理系统（DBMS） DBMS的定义：DBMS是位于用户与操作系统之间的数据管理软件，数据库在建立，运用和维护时由数据库管理系统统一管理，控制。 DBMS的目标： 1）用户界面友好； 2）功能完备； 3）效率高，DBMS应该具有较高的系统效率和高的用户生产率，其中系统效率包括： （1）计算机内部资源的利用率，即能够充分利用磁盘空间，CPU，设备等资源，并注意使各种资源的负载均衡以提高整个系统的效率；（2）DBMS本身的运行效率，根据系统目标确定恰当的体系结构，数据结构和算法，保证DBMS运行的高效率；用户生产率是指用户设计和开发应用程序的效率； 4）结构清晰：DBMS内部结构清新，层次分明既便于支持其外层开发环境的构造，也便于自身的设计、开发与维护； 5）开放性：DBMS的开放性是指符合标准和规范，如ODBC标准，SQL标准等。 DBMS的基本功能： 1）数据库定义功能：DDL可以定义数据库中数据之间的联系，可以定义数据的完整性约束条件和保证完整性的触发机制等，包括全局逻辑数据结构（模式）的定义，局部逻辑数据结构（外模式）的定义，保密定义等；2）数据库操纵功能：DML可以接收，分析和执行用户提出的访问数据库的各种要求，完成对数据库的各种基本操作，如对数据库的检索，插入，删除和修改等操作，可以重新组织数据的存储结构，可以完成数据库的备份和恢复等操作；3）数据库的控制功能：DCL包括整个数据库系统的运行控制，数据库的完整性控制，数据库的安全性控制及多用户环境下的数据库并发访问控制等；4）数据库的运行管理功能：指DBMS运行机制和管理功能；5）数据库组织和存储管理功能6）数据库的建立和维护功能7）数据库通信功能 DBMS的组成： 1）数据库定义语言及其翻译程序： DDL用于描述数据库中要存储的现实世界实体的语言，包括数据字典中数据库的逻辑结构，完整性约束，物理存储结构的表述，数据库的各种数据操作和数据库的维护管理的各种依据。包括： 模式DDL：定义全局逻辑数据结构(包括所有字段的名称，特征及其相互关系)，数据的完整性，安全性约束；外模式DDL：为用户定义所用的局部逻辑数据结构(包括与用户的应用程序有关的字段名称，特征及其相互关系)，描述外模式到模式之间的映射关系；内模式DDL：用于描述数据在存储介质上的安排和存放方式，描述模式到内模式之间的映射关系； 2）数据库操纵语言及其编译（或解释）程序： DML用于实现对数据库的一些基本操作，如数据检索，数据插入，数据修改和数据删除，其中数据插入，数据修改和数据删除操作又称为数据更新操作。分为： 宿主型DML：本身不能独立使用，必须嵌入到宿主语言中，如C，COLBOL，PASCAL等，因此也称嵌入型DML，仅负责对数据库数据的操纵，其他工作都由宿主语言完成；自主型DML，又称自含型DML，可以独立进行数据查询，数据更新等操作，语法简单，使用方便，适合终端用户使用； 3）数据库运行控制程序：包括系统初启程序(DBMS的神经中枢)，访问控制程序，安全性控制程序，完整性检查程序，并发控制程序，数据存取/更新程序，通信控制程序； 4）数据库服务实用程序：包括数据装入程序，工作日志程序，性能监督程序，数据库重新组织程序，系统恢复程序，转储/编辑/打印程序。 数据库管理与数据库管理员(DBA)： 1）DBA：从事数据库管理工作的人员，不是数据库的“占有者”，而是数据库的“保护者”。 2) DBA职责 在数据库设计开始之前，DBA首先调查数据库的用户需求。 在数据库设计阶段，DBA要负责数据库标准的制定和功用数据字典的研制，要负责各级数据库模式的设计，负责数据库安全，可靠方面的设计，决定文件组织的方法。 在数据库运行阶段，DBA要负责对用户进行数据库方面的培训，负责数据库的转储和恢复，数据维护，用户的使用权限等，负责监控数据库的性能。 三，数据库系统（DBS） DBS定义：指在计算机系统中引入数据库后的系统构成，一般由数据库，数据库系统运行环境，数据库管理系统及其开发工具，数据库管理员和用户组成。 数据库系统的三级模式结构： 1）模式定义：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，而不涉及具体的值。 2）三级模式结构： 外模式：也称子模式或者用户模式，是数据库用户看见和使用的局部数据的逻辑结构和特征的描述，是数据库的用户视图，是和某个应用相关的数据逻辑表示；一个数据库可以有多个外模式； 模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共视图，是数据库的整个逻辑描述，并说明一个数据库所采用的数据模型；一个数据库只有一个模式； 内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据库的内部表示方式；一个数据库只有一个内模式。 二级映像功能和数据独立性： 1）外模式/模式映像：当模式改变时，DBA对各个外模式/模式的映像做出相应改变，使外模式保持不变，从而使应用程序不改变，保证了数据的逻辑独立性； 2）模式/内模式映像：唯一定义了数据全局逻辑结构和存储方式之间的对应关系。当数据库的存储方式改变时，DBA将对模式/内模式映像做出相应的改变，使模式保持不变，从而保证了数据的物理独立性。 数据库系统的体系结构： 1）单用户结构的数据库系统：最早最简单，不能共享数据； 2）主从式结构的数据库系统：结构简单，数据易于维护维护和管理，但系统的可靠性不高； 3）分布式结构的数据库系统：数据在逻辑上上一个整体，但是分布在计算机网络的不同结点上。 4）客户端/服务器结构的数据库系统 数据库系统的工作流程： 1）DBA建立并维护数据库； 2）用户编写应用程序； 3）应用程序在DBMS支持下运行，在模式，外模式，内模式，用户源程序翻译为目标代码后，即可启动目标程序。 四，数据库的发展 人工管理阶段： 1）特点：数据不保存；应用程序管理数据；数据不共享；数据不具有独立性。 文件系统阶段： 1）优点：数据可以长期保存；有专门的软件即文件系统管理数据，文件系统把数据组织成相互独立的数据文件；文件的形式多样化； 2）缺点：数据共享性差，冗余度大；数据独立性差；数据联系弱。 数据库系统阶段 数据库技术的研究，应用领域和发展方向 数据模型 数据库管理系统软件的研制 数据操作 数据库理论：主要集中在关系的规范化理论，关系数据理论等。 代表性的数据库应用领域和发展方向： 因特网上的Web数据库 面向对象数据库 多媒体数据库 并行数据库 人工智能领域的知识库和主动数据库 模糊数据库系统","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"https://zhangbc.github.io/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"https://zhangbc.github.io/tags/数据库理论/"}]},{"title":"【数据库理论】数据模型","slug":"【数据库理论】数据模型","date":"2019-04-06T04:48:52.000Z","updated":"2019-04-09T13:11:32.520Z","comments":true,"path":"2019/04/06/db_data_model/","link":"","permalink":"https://zhangbc.github.io/2019/04/06/db_data_model/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据描述 数据的三种范畴 1）现实世界（客观世界）：现实世界所反映的客观存在的事物及其相互之间的联系，指数处理对象最原始的表现形式。 2）信息世界（观念世界）：是现实世界在人们头脑中的反映，经过一定的选择，命名和分类而形成的。以下为相关概念： 实体（Entity）：客观存在的事物在人们头脑中的反映，或说，客观存在并可相互区别的客观事物或抽象事件。 属性（Attribute）：实体所具有的某一方面的特性。 域（Domain）：一个属性可能取的所有属性值的范围称为该属性的域。 码（Key）：唯一标识实体的属性集。 实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（Entity Set）：同一类型实体的集合。 3）机器世界（数据世界或存储世界）数据化后的信息称为数据，所以说数据是信息的符号表示。以下为相关概念： 数据项（字段，Field）：对应于信息世界中的属性。 记录（Record）：对应于每个实体所对应的数据。 记录型（Record Type）：对应于信息世界中的实体型。 文件（File）：对应于信息世界中的实体集。 关键字（Key）：对应于能够唯一标识一个记录的字段集。 实体间的联系 一对一联系：如果实体集A中每个实体，实体集B中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记作1:1； 一对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中至多有一个实体与之联系，则称实体集A与实体集B具有一对多联系，记作1:n； 多对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中有m（m&gt;=0）个实体与之联系，则称实体集A与实体集B具有多对多联系，记作n:m。 二，概念模型与E-R方法 数据模型 1）数据模型应满足以下要求： i）能够比较真实地模拟现实世界；ii）容易为人所理解；iii）便于在计算机上实现。 2）数据模型分类： i）概念模型：即信息模型，是按用户的观点来对数据和信息建模的，主要用于数据设计；ii）基本数据模型：主要包括网状模型，层次模型，关系模型等，是按计算机系统的观点对数据建模的，主要用于DBMS的实现。 数据模型的三要素 1）数据结构：用于描述系统的静态特性。数据结构是所有研究对象类型的集合，这些对象是数据库的组成部分，分为两大类： 与数据类型，内容，性质有关的对象； 与数据之间联系有关的对象。 2）数据操作：用于描述系统的动态特征。数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有检索和修改（插入，删除，更新）两大数据操作。 3）数据完整性约束：是一组完整性规则的集合。完整性规则是给定的数据模型中的数据及其联系所具有的制约和存储规则，用于限制符合数据模型的数据库状态及状态的变化，用于确保数据的正确、有效和相容。 概念数据模型 1）概念模型的定义：按用户的观点对现实世界进行数据建模而形成的，是一种独立于计算机系统的模型，完全不涉及信息在计算机系统中的表示，也不依赖于具体的数据库管理系统，用于描述某个特定组织所关心的信息结构。 2）概念模型的相关基本概念：实体、属性、域、码、实体型和实体集。 3）概念模型的基本关系：在概念模型中主要解决问题是实体间的联系。 E-R图表示法 1）实体型：用矩形表示，矩形框内写明实体名； 2）属性：用椭圆表示，椭圆内写明属性名； 3）联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标注联系的类型（1:1，1:n，n:m）。 E-R模型优点： i）接近人的思想，容易理解；ii）与计算机无关，用户容易接受。 三，传统的三大数据模型 层次模型 1）层次模型定义：用树形结构表示实体之间的联系的模型称为层次模型。 2）建立数据的层次模型需要满足以下条件： i）有且仅有一个结点没有父结点，这个结点即为树根结点；ii）其他数据记录有且仅有一个父结点。 3）层次模型的基本特点：任何一个给定的记录值只有按其路径查看，才能体现它的全部含义，没有一个子记录值能够脱离父记录值而独立存在的。 4）层次模型的最明显特点：层次清晰，构造简单，易于实现，可以很方便地表示一对一和一对多这两种实体之间的联系。 5）层次模型的主要优点： i）层次模型本身比较简单；ii）实体间联系是固定的，且预先定义好的应用系统采用层次模型来实现，其性能优于关系模型的性能，不低于网状模型的性能；iii）层次模型提供了良好的完整性支持。 6）层次模型的主要缺点： i）现实世界中很多联系是非层次性的，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据或创建非自然组织（引入虚结点）来解决；ii）对插入和删除操作的限制比较多；iii）查询子结点必须通过父结点；iv）由于结构严谨，层次命令趋于程序化。 网状模型 1）网状模型的定义： 网状模型是一种有向图，在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型： i）允许一个以上的结点无父结点；ii）一个结点可以有多于一个的父结点。 2）为了描述网状模型的记录之间的联系，引进了系（Set）的概念，所谓系可以理解为命名了的联系，它由一个父记录型和一个或多个子记录型构成。 3）网状数据库的定义：用网状模型设计出来的数据库称为网状数据库。 4）网状模型的主要优点： i）能够更为直接地描述现实世界，如一个结点可以有多个父结点；ii）具有良好的性能，存取效率较高。 5）网状模型的主要缺点： i）结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于用户最终掌握；ii）其DDL，DML语言复杂，用户不易使用。 关系模型 1）关系模型的主要优点： i）数据结构比较简单；ii）具有很高的数据独立性；iii）可以直接处理多对多联系；iv）坚实的理论基础。 2）值域的定义：在关系模型中，一个n元关系有n个属性，属性的取值范围称为值域。 3）关系模型主要缺点：存取路径对用户透明，查询效率往往不如非关系数据模型。 四，数据独立与三层结构 三级模式结构 外模式：又称为用户模式，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看得见和使用的局部数据的逻辑结构和特征描述，是与某一个应用有关的数据的逻辑表示。 模式：可分为概念模式和逻辑模式，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。 一个数据库只有一个模式，其中概念模式可以用实体-联系模型模型来描述，逻辑模式以某种数据模型为基础，综合考虑所有用户的需求，并将其形成全局逻辑结构。 内模式：又称为存储模式，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。 数据的独立性 逻辑数据独立性：当模式改变时，只要对外模式/模式映像做相应的改变，就可以使外模式保持不变，以外模式为依据编写的应用程序就不受影响，从而应用程序不必修改，保证了数据与程序之间的逻辑独立性。 存储数据独立性：当内模式改变时，只要对模式/内模式映像做相应的改变，使模式保持不变，应用程序就不受影响，从而保证了数据与程序之间的物理独立性，称为存储数据独立性。 五，数据库管理系统 DBMS的主要功能 数据库的主要职责就是有效地实现数据库三级模式之间的转换，即把用户或应用程序对数据库的一次访问，从用户级带到概念级，再导向物理级，转换为对存储数据的操作。 1）数据库定义2）数据库操作及查询优化3）数据库控制运行管理4）数据组织，存储和管理5）数据库的恢复和维护6）数据库的多种接口7）其他功能 DBMS的组成 1）DBMS由查询处理器和存储管理器两大部分组成。其中： (1) 查询处理器主要有DDL编译器，DML编译器，嵌入式DML的预编译器及查询运行核心程序；(2) 存储管理器有授权和完整性管理器，事务管理器，文件管理器及缓冲区管理器。 2）查询处理程序：把用较高级的语言所表示的数据库操作（查询、更新等）转换成一系列对数据库的请求。 3）存储管理程序：包括文件管理程序和缓冲区管理程序。 4）事务管理程序：保证数据库中所有事务全部都能正确执行。 用户访问数据库的过程（略）","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"https://zhangbc.github.io/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"https://zhangbc.github.io/tags/数据库理论/"}]}]}