{"meta":{"title":"天堂的鸽子","subtitle":"天道酬勤","description":"每天积累一点，学习一点，只有不坚持的，没有做不到的！","author":"Bocheng Zhang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-04-10T16:37:45.505Z","updated":"2019-04-10T16:37:45.505Z","comments":true,"path":"README.html","permalink":"http://yoursite.com/README.html","excerpt":"","text":"博客目录数据库系列 理论篇 [x] 【数据库理论】绪论 [x] 【数据库理论】数据模型 [x] 【数据库理论】关系数据库 [ ] 【数据库理论】关系模式的规范化与查询优化 [ ] 【数据库理论】数据库的设计与实施 [ ] 【数据库理论】数据库的安全和保护 [ ] 【数据库理论】数据库与SQL Server2005简介 [ ] 【数据库理论】管理数据库 [ ] 【数据库理论】管理表 [ ] 【数据库理论】操作查询 [ ] 【数据库理论】T-SQL语言 [ ] 【数据库理论】存储过程 [ ] 【数据库理论】SQL Server2005高级功能 实战 [x] 【数据库实战】SQL Server数据库常用脚本 Java编程 入门基础篇 [x] 【Java基础】Java入门知识 [x] 【Java基础】Java基础知识 [ ] 【Java基础】Java面向对象 [ ] 【Java基础】Java进阶编程 [ ] 【Java基础】Java网络编程 [ ] 【Java基础】Java扩展知识"},{"title":"","date":"2019-04-09T13:11:32.531Z","updated":"2019-04-09T13:11:32.531Z","comments":true,"path":"aboutme.html","permalink":"http://yoursite.com/aboutme.html","excerpt":"","text":"关于作者 学习蜗牛，慢慢向前爬，终有一天会到达目的地； 学习IT，学会学习，独立思考，终有一天，会找到IT的乐趣！"},{"title":"","date":"2019-04-09T13:11:32.521Z","updated":"2019-04-09T13:11:32.521Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-07T07:00:02.000Z","updated":"2019-04-10T12:08:59.536Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-07T06:57:35.000Z","updated":"2019-04-10T12:10:13.737Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【Java基础】Java基础知识","slug":"【Java基础】Java基础知识","date":"2019-04-10T16:39:20.000Z","updated":"2019-04-10T17:10:49.729Z","comments":true,"path":"2019/04/11/java_basic_knowledge/","link":"","permalink":"http://yoursite.com/2019/04/11/java_basic_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，Java基本数据类型变量就是申请内存来存储值。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。 Java有两大数据类型：内置数据类型和引用数据类型。 1）内置数据类型 名称 描述 取值范围 默认值 主要用途 byte 8位，有符号的，以二进制补码表示的整数 - $2^7$ ~ $2^7$ -1 0 在大型数组中节约空间，代替整数 short 16位，有符号的，以二进制补码表示的整数 -$2^{15}$~$2^{15}$-1 0 节省空间 int 32位，有符号的，以二进制补码表示的整数 -$2^{31}$~$2^{31}$-1 0 整型变量的默认类型 long 64位，有符号的，以二进制补码表示的整数 -$2^{63}$~$2^{63}$-1 0L 使用在需要比较大整数的系统上 float 单精度、32位、符合IEEE 754标准的浮点数 -$2^{31}$~$2^{31}$-1 0.0f 在存储大型浮点数组时可以节省空间；不能用来表示精确的值 double 双精度、64位、符合IEEE 754标准的浮点数 -$2^{63}$~$2^{63}$-1 0.0d 浮点数变量的默认类型 boolean 表示一位的信息 true,false false 作为一种标记来记录true/false情况 char 单一的 16 位 Unicode 字符 \\u0000~\\uffff(0~$2^{16}$-1) 存储任何字符 2）引用类型 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。 对象、数组都是引用数据类型。 所有引用类型的默认值都是null。 一个引用变量可以用来引用与任何与之兼容的类型。 3）Java常量：常量在程序运行时，不会被修改，关键字final。通常使用大写字母表示常量。 4）Java类型转换 自动类型转换：转换从低级到高级。 数据类型转换满足的原则：（1）不能对boolean类型进行类型转换；（2）不能把对象类型转换成不相关类的对象；（3）在把容量大的类型转换为容量小的类型时必须使用强制类型转换；（4）转换过程中可能导致溢出或损失精度；（5）浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。 强制类型转换：条件是转换的数据类型必须是兼容的。 隐含强制类型转换 2，Java语句类型1）循环结构 while do...while for foreach 增强型for循环：主要用于数组 demo：1234567891011121314151617public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(\",\"); &#125; System.out.print(\"\\n\"); String [] names =&#123;\"James\", \"Larry\", \"Tom\", \"Lacy\"&#125;; # 增强型for循环 for( String name : names ) &#123; System.out.print( name ); System.out.print(\",\"); &#125; &#125;&#125; 2）break语句：主要用于循环语句或者switch语句中；跳出最里层的循环，并且继续执行该循环下面的语句。 3）continue语句：适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代。 4）分支结构 if：一个if语句包含一个布尔表达式和一条或多条语句。 switch case语句：判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 3，Java基础类1）Number &amp; Math类 2）Math类：包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 3）Character类：对单个字符进行操作。 将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 4）String类 用于获取有关对象的信息的方法称为访问器方法。 5）StringBuffer和StringBuilder类 和String类不同的是，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder类在Java 5中被提出，它和StringBuffer之间的最大不同在于 StringBuilder的方法不是线程安全的（不能同步访问）。 由于StringBuilder相较于StringBuffer有速度优势，所以多数情况下建议使用 StringBuilder类。 在应用程序要求线程安全的情况下，则必须使用 StringBuffer类。 4，Java数组1）声明数组123dataType[] arrayRefVar; // 首选的方法 # ordataType arrayRefVar[]; // 效果相同，但不是首选方法 2）创建数组 1arrayRefVar = new dataType[arraySize]; 3）多维数组1234567891011type[][] typeName = new type[typeLength1][typeLength2]; // 直接为每一维分配空间​// 从最高维开始，分别为每一维分配空间String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String(\"Good\");s[0][1] = new String(\"Luck\");s[1][0] = new String(\"to\");s[1][1] = new String(\"you\");s[1][2] = new String(\"!\"); 4）Arrays类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法，按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 5，Java日期时间java.util包提供了Date类来封装当前的日期和时间。 Date类提供两个构造函数来实例化 Date 对象。第一个构造函数使用当前日期和时间来初始化对象。1Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。1Date(long millisec) 1）获取当前日期时间12345678import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; Date date = new Date(); System.out.println(date.toString()); &#125;&#125; 2）日期比较 getTime()：获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 before(), after(), equals() compareTo()：由Comparable接口定义的，Date类实现了这个接口。 3）格式化日期时间 SimpleDataFormat1234567public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); SimpleDateFormat ft = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); System.out.println(\"当前时间为：\"+ft.format(now)); &#125;&#125; printf1234567891011121314151617public class DateTestDemo &#123; public static void main(String[] args) &#123; Date now = new Date(); //c的使用 System.out.printf(\"全部日期和时间信息：%tc%n\", now); //f的使用 System.out.printf(\"年-月-日格式：%tF%n\", now); //d的使用 System.out.printf(\"月/日/年格式：%tD%n\", now); //r的使用 System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\", now); //t的使用 System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\", now); //R的使用 System.out.printf(\"HH:MM格式（24时制）：%tR\", now); &#125;&#125; 4）Java休眠（Sleep）1234567891011public class SleepDemo &#123; public static void main(String[] args) &#123; try &#123; System.out.println(new Date()+\"\\n\"); Thread.sleep(1000*5); System.out.println(new Date()+\"\\n\"); &#125; catch (Exception ex)&#123; System.out.println(\"Got an exception: \"+ex); &#125; &#125;&#125; 5）Calendar类123456789101112131415161718192021public class DateTestDemo &#123; public static void main(String[] args) &#123; // 创建一个代表系统当前日期的Calendar对象 Calendar now = Calendar.getInstance(); int year = now.get(Calendar.YEAR); int month = now.get(Calendar.MONTH); int day = now.get(Calendar.DAY_OF_WEEK); int date = now.get(Calendar.DATE); int hour = now.get(Calendar.HOUR_OF_DAY); int minute = now.get(Calendar.MINUTE); int second = now.get(Calendar.SECOND);​ System.out.println(now.getTime()); System.out.printf(\"%d-%d-%d %d:%d:%d\\n%d\\n\", year, month, day, hour, minute, second, date);​ // 创建一个表示2009年3月12日的Calendar对象 now.set(2009, 3-1, 12); System.out.println(now.getTime()); &#125;&#125; 6）GregorianCalendar类：实现了公历日历，是Calendar类的一个具体实现。1234567891011public class DateTestDemo &#123; public static void main(String[] args) &#123; GregorianCalendar gCalender = new GregorianCalendar(); int year = gCalender.get(Calendar.YEAR); if (gCalender.isLeapYear(year)) &#123; System.out.println(\"当前年份是闰年！\"); &#125; else &#123; System.out.println(\"当前年份不是闰年！\"); &#125; &#125;&#125; 6，正则表达式1） java.util.regex包主要包括以下三个类： Pattern类：是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher类：是对输入字符串进行解释和匹配操作的引擎。 PatternSyntaxException：是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 12345678public class RegexDemo &#123; public static void main(String[] args) &#123; String content = \"I am a student, graduated from HuBei University.\"; String pattern = \".*HuBei.*\"; boolean isMath = Pattern.matches(pattern, content); System.out.println(\"字符串是否包含类'HuBei'子字符串？\"+isMath); &#125;&#125; 2）捕获组捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。1234567891011121314151617181920public class RegexDemo &#123; public static void main(String[] args) &#123; String content = \"I am a student, graduated from HuBei University in 2013. \"; String pattern = \"(\\\\D*)(\\\\d+)(.*)\";​ // 创建Pattern对象 Pattern rex = Pattern.compile(pattern);​ // 创建matcher对象 Matcher matcher = rex.matcher(content); if (matcher.find()) &#123; System.out.println(\"Found value: \" + matcher.group(0)); System.out.println(\"Found value: \" + matcher.group(1)); System.out.println(\"Found value: \" + matcher.group(2)); System.out.println(\"Found value: \" + matcher.group(3)); &#125; else &#123; System.out.println(\"No match!!!\"); &#125; &#125;&#125; 7，Java方法1）Java方法定义：Java方法是语句的集合，他们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 2）Java方法的优点 使程序变得更简短而清晰 有利于程序维护 可以提高程序开发的效率 提高了代码的重用性 3）Java方法的命名规则 必须以字母、&#39;_&#39;或&#39;＄&#39;开头（方法名第一个单词应以小写字母开头，后面的单词则用大写字母开头写，不使用连接符）； 可以包括数字，但不能以它开头； 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。 4）Java方法的定义123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 5）Java方法调用1234567891011121314151617public class MaxTest &#123; public static void main(String[] args) &#123; int i = 2, j = 4; int max = getMax(i, j); System.out.printf(\"%d和%d比较，最大值是：%d.\", i, j, max); &#125;​ private static int getMax(int num1, int num2) &#123; int result; if (num1 &gt; num2) result = num1; else result = num2;​ return result; &#125;&#125; 6）void关键字 7）Java方法重载：一个类的两个方法拥有相同的名字，但是有不同的参数列表。 8）变量作用域 9）命令行参数：命令行参数是在执行程序时候紧跟在程序名字后面的信息。 10）构造方法：当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 11）可变参数：JDK1.5开始，Java支持传递同类型的可变参数给一个方法。1typeName... parameterName 在方法声明中，在指定参数类型后加一个省略号(...) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。12345678910111213141516171819202122public class MaxTest &#123; public static void main(String[] args) &#123;​ double max = getMax(1, 2, 3, 4, 5, 6, 7, 8, 0, 1); System.out.printf(\"...numbers中，最大值是：%.2f.\", max); &#125;​ private static double getMax(double... numbers) &#123; if (numbers.length == 0) &#123; System.out.println(\"No argument passed.\"); return -10000000000L; &#125;​ double result = numbers[0]; for (double var: numbers) &#123; if (var &gt; result) &#123; result = var; &#125; &#125; return result; &#125;&#125; 12）finalize()方法：在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。 Java 的内存回收可以由 JVM 来自动完成。 FinalizationDemo.java如下：1234567891011121314151617181920212223public class FinalizationDemo &#123; public static void main(String[] args) &#123; Cake c1 = new Cake(1); Cake c2 = new Cake(2); Cake c3 = new Cake(3);​ c2 = c3 = null; System.gc(); // 调用Java垃圾回收集器 &#125;&#125;​class Cake extends Object &#123; private int id; public Cake(int id) &#123; this.id = id; System.out.println(\"Cake Object \" + id + \" is created.\"); &#125;​ protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"Cake object \" + id + \" is disposed.\"); &#125;&#125; 8，Java流（Stream），文件（File）和IOJava.io包几乎包含了所有操作输入、输出需要的类。一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。 1）读取控制台输入：Java的控制台输入由System.in完成。1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 2）从控制台读取多字符输入：从BufferedReader对象读取一个字符要使用 read()方法。1int read() throws IOException BRReadLine.java1234567891011public class BRReadLine &#123; public static void main(String[] args) throws IOException &#123; char ch; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"输入字符，按下'q'键退出.\"); do &#123; ch = (char) br.read(); System.out.println(ch); &#125; while (ch != 'q'); &#125;&#125; 3）从控制台读取字符串：从 标准输入读取一个字符要使用BufferedReader的 readLine()方法。1String readLine() throws IOException BRReadLines.java123456789101112public class BRReadLines &#123; public static void main(String[] args) throws IOException &#123; String str; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"Enter lines of text;\"); System.out.println(\"Enter 'end' to quit.\"); do &#123; str = br.readLine(); System.out.println(str); &#125; while (!str.equals(\"end\")); &#125;&#125; 4）控制台输出：控制台的输出由 print() 和 println() 完成。12345678public class WriteDemo &#123; public static void main(String[] args) &#123; int num; num = 'A'; System.out.write(num); System.out.write('\\n'); &#125;&#125; 5）读写文件：一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。 6）FileInputStream：该流用于从文件读取数据，它的对象可以用关键字new来创建。12345678910111213141516171819202122232425/** * 把给定的context以二进制写进文件，同时输出控制台 * 但是存在乱码问题 */public class FileStreamTest &#123; public static void main(String[] args) throws IOException &#123; try &#123; byte[] bWrite = &#123;'a', 11, 21, 32, 40, 54&#125;; OutputStream os = new FileOutputStream(\"file_test.txt\"); for (byte var: bWrite) &#123; os.write(var); &#125; os.close();​ InputStream is = new FileInputStream(\"file_test.txt\"); int size = is.available(); for (int i = 0; i &lt; size; i++) &#123; System.out.println((char) is.read() + \" \"); &#125; is.close(); &#125; catch (IOException ex) &#123; System.out.println(\"File InputStream error: \" + ex.toString()); &#125; &#125;&#125; 7）FileOutputStream：该流用来创建一个文件并向文件中写数据，它的对象可以用关键字 new 来创建。1234567891011121314151617181920212223242526272829303132333435/** * 把给定的context以二进制写进文件，同时输出控制台 */public class FileIOStreamTest &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"file_test.txt\");​ // 构建FileOutputStream对象，文件不存在会自动新建 FileOutputStream fop = new FileOutputStream(file);​ // 构建对象，参数可以指定编码，默认为操作系统默认编码，windows是gbk OutputStreamWriter writer = new OutputStreamWriter(fop, \"UTF-8\");​ // 写入到缓冲区 writer.append(\"中文输入\"); writer.append(\"\\r\\n\"); writer.append(\"English input\");​ // 关闭写入流，同时会把缓冲区的内容写入文件 writer.close();​ // 关闭输出流，释放系统资源 fop.close();​ FileInputStream fip = new FileInputStream(file); InputStreamReader reader = new InputStreamReader(fip, \"UTF-8\"); StringBuilder sb = new StringBuilder(); while (reader.ready()) &#123; sb.append((char) reader.read()); &#125; System.out.println(sb.toString()); reader.close(); fip.close(); &#125;&#125; 关于文件和I/O的一些其他类：File Class；FileReader Class；FileWriter Class。 9，Java中的目录1）创建目录File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。 mkdirs()方法创建一个文件夹和它的所有父文件夹。 1234567public class CreateDir &#123; public static void main(String[] args) &#123; String dirName = \"/home/share/java\"; File file = new File(dirName); file.mkdirs(); &#125;&#125; 2）读取目录12345678910111213141516171819202122public class ReadDir &#123; public static void main(String[] args) throws IOException &#123; String dirName = \"/home/share\"; File fp = new File(dirName); if (fp.isDirectory()) &#123; System.out.println(\"目录：\" + dirName); // 提取包含的文件和文件夹的列表 String[] strings = fp.list(); for (int i = 0; i &lt; strings.length; i++) &#123; File tmp = new File(dirName + \"/\" + strings[i]); if (tmp.isDirectory()) &#123; System.out.println(strings[i] + \" 是一个目录.\"); &#125; else &#123; System.out.println(strings[i] + \" 是一个文件.\"); &#125; &#125; &#125; else &#123; System.out.println(dirName + \" 不是一个目录.\"); &#125; &#125;&#125; 3）删除目录或文件：删除文件可以使用java.io.File.delete()方法。123456789101112131415161718192021public class DeleteDir &#123; public static void main(String[] args) &#123; File folder = new File(\"/home/share/java\"); deleteFolder(folder); &#125;​ // 删除文件及目录 private static void deleteFolder(File folder) &#123; File[] files = folder.listFiles(); if (files != null) &#123; for (File fp: files) &#123; if (fp.isDirectory()) &#123; deleteFolder(fp); &#125; else &#123; fp.delete(); &#125; &#125; &#125; folder.delete(); &#125;&#125; 10，Java Scanner类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。基本语法如下：1Scanner scanner = new Scanner(System.in); 1）使用next方法 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next()不能得到带有空格的字符串。 ScannerNext.java12345678910111213public class ScannerNext &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"Next方式接收：\");​ // 判断是否还有输入 if (scan.hasNext()) &#123; String str = scan.next(); System.out.println(\"输入的数据为：\" + str); &#125; scan.close(); &#125;&#125; 2）使用nextLine方法 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 ScannerNextLines.java12345678910111213class ScannerNextLines &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"NextLine方式接收：\");​ // 判断是否还有输入 if (scan.hasNextLine()) &#123; String str = scan.nextLine(); System.out.println(\"输入的数据为：\" + str); &#125; scan.close(); &#125;&#125; 注意：如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取。 ScannerNumbers.java12345678910111213141516171819202122232425262728293031323334public class ScannerNumbers &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in);​ int numberI; float numberF; double numberD; System.out.println(\"输入整数：\"); if (scan.hasNextInt()) &#123; numberI = scan.nextInt(); System.out.println(\"整数是：\" + numberI); &#125; else &#123; System.out.println(\"输入的不是整数！\"); &#125;​ System.out.println(\"输入浮点数：\"); if (scan.hasNextFloat()) &#123; numberF = scan.nextFloat(); System.out.println(\"浮点数是：\" + numberF); &#125; else &#123; System.out.println(\"输入的不是浮点数！\"); &#125;​ System.out.println(\"输入双精度小数：\"); if (scan.hasNextDouble()) &#123; numberD = scan.nextDouble(); System.out.println(\"双精度小数是：\" + numberD); &#125; else &#123; System.out.println(\"输入的不是双精度小数！\"); &#125;​ scan.close(); &#125;&#125; 11，Java异常处理1）理解Java异常处理是如何工作的，需掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。 2）Exception 类的层次 所有的异常类是从 java.lang.Exception 类继承的子类。 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable 类还有一个子类Error 。 Error 用来指示运行时环境发生的错误。例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 在 Java 内置类中，有大部分常用检查性和非检查性异常。 3）Java内置类4）异常方法：主要是Throwable的方法。5）捕获异常123456789101112public class ExceptionDemo &#123; public static void main(String[] args) &#123; try &#123; int[] array = new int[2]; array[0] = 1; System.out.println(\"Access elements three: \" + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println(\"Exception: \" + ex.toString()); &#125; System.out.println(\"Out of the block.\"); &#125;&#125; 6）多重捕获块：一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 7）throws/throw关键字：如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 8）finally关键字：finally 关键字用来创建在 try 代码块后面执行的代码块；无论是否发生异常，finally 代码块中的代码总会被执行；在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 ExceptionDemo.java1234567891011121314public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] array = new int[2]; try &#123; System.out.println(\"Access elements three: \" + array[2]); &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; System.out.println(\"Exception throw: \" + ex.toString()); &#125; finally &#123; array[0] = 20; System.out.println(\"First element value: \" + array[0]); System.out.println(\"The finally statement is executed.\"); &#125; &#125;&#125; 9）声明自定义异常 所有异常都必须是 Throwable 的子类。 如写一个检查性异常类，则需要继承 Exception 类。 如写一个运行时异常类，那么需要继承 RuntimeException 类。 综合实例 InsufficientFundException.java： 123456789101112/** * 自定义异常，继承Exception类 */public class InsufficientFundException extends Exception &#123; private double amount; public InsufficientFundException(double amount) &#123; this.amount = amount; &#125; public double getAmount() &#123; return amount; &#125;&#125; CheckingAccount.java： 1234567891011121314151617181920212223242526272829303132333435/** * 银行账户基本操作类 */public class CheckingAccount &#123; private double balance; private int number; public CheckingAccount(int number) &#123; this.number = number; &#125;​ // 存钱 public void deposit(double amount) &#123; balance += amount; &#125;​ // 取钱 public void withdraw(double amount) throws InsufficientFundException &#123; if (amount &lt;= balance) &#123; balance -= amount; &#125; else &#123; double needs = amount - balance; throw new InsufficientFundException(needs); &#125; &#125;​ // 返回余额 public double getBalance() &#123; return balance; &#125;​ // 返回账号 public int getNumber() &#123; return number; &#125;&#125; BankDemo.java： 123456789101112131415161718192021** * 模拟银行账户基本操作实例 */class BankDemo &#123; public static void main(String[] args) &#123; CheckingAccount account = new CheckingAccount(6228481); System.out.println(\"Deposit $500...\"); account.deposit(500.00);​ try &#123; System.out.println(\"Withdrawing $100...\"); account.withdraw(100);​ System.out.println(\"Withdrawing $600...\"); account.withdraw(600); &#125; catch (InsufficientFundException ex) &#123; System.out.println(\"Sorry, but you are short $\"+ex.getAmount()); ex.printStackTrace(); &#125; &#125;&#125; 10）通用异常在Java中定义了两种类型的异常和错误： JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"【数据库理论】关系数据库","slug":"【数据库理论】关系数据库","date":"2019-04-10T13:22:51.000Z","updated":"2019-04-10T16:13:32.275Z","comments":true,"path":"2019/04/10/db_rdb/","link":"","permalink":"http://yoursite.com/2019/04/10/db_rdb/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，关系模型的基本概念 关系及基本术语 在关系模型中，表格的第一行称为关系框架，是属性$A_1$，$A_2$，$A_3$，$\\dots$，$A_k$的有限集合。 表中的每行称为关系的一个元组；每列称为属性，它在某个值域上的取值，不同的属性可以在相同的值域上取值。 关系中的属性个数称为元数（Arity），元组个数称为基数。 关键字 超关键字(Super Key)：在关系中能够唯一标识元组的属性集合。 候选关键字(Candidate Key)：如果某一属性集合是超关键字，但去掉其中任意属性后就不再是超关键字，这样的属性称为候选关键字。 候选关键字的诸属性称为主属性，不包含在任何候选关键字中的属性称为非主属性（非码属性）。 主关键字(Primary Key)：如果关系中存在多个候选关键字，用户可选作元组标识的一个候选关键字为主关键字。 合成关键字(Composite Key)：当某个候选关键字包含多个属性时，该候选关键字称为合成关键字。 外部关键字(Foreign Key)：如果关系R的某个（些）属性K不是R中的候选关键字，而是另一个关系S的候选关键字，则K称为R的外部关键字。 二，关系模式 在关系数据库中，关系模式是型，关系是值。 【定义3-1】关系的描述称为关系模式，形式化表示为$R(U, D, DOM, I, F)$其中，$R$为关系名，$U$为组成该关系的属性名集合，$D$是$U$中属性的域，$DOM$为属性到域的映像集合，$I$为完整性约束集合，$F$为属性间数据的依赖关系集合。 ⚠️关系模式中带有下画线的属性集为主关键字。 三，关系模型的完整性 域完整性约束：主要规定属性值必须取自值域，一个属性能否为空值由其语义决定。 实体完整性约束：规定基本关系的所有主属性都不能取空值，而不仅是主属性整体不能取空值。 参照完整性约束：要求“不引用不存在的实体”，考虑的是不同关系之间的或同一关系的不同元组之间的制约。形式定义： 如果属性集K是关系R的主关键字，K也是关系S的外关键字，那么在关系S中，K的取值只允许两种可能，要么为空值，要么等于关系R中某个主关键字的值。关系R称为“参照关系”模式，关系S称为“依赖关系”模式。 用户自定义完整性约束：针对某个具体关系数据库的约束条件。 四，关系代数 关系查询语言分类 关系代数语言：查询操作是以集合操作为基础运算的DML语言。 关系演算语言：查询操作是以谓词演算为基础运算的DML语言。 关系代数的五种基本操作 相等定义：设有同类关系$r_1$和$r_2$，若$r_1$的任何一个元组都是$r_2$的一个元组，则称关系$r_2$包含关系$r1$，记作$r_1$ $\\subseteq$ $r_2$或 $r_2$ $\\supseteq$ $r_1$，如果$r_1$ $\\subseteq$ $r_2$且$r_1$ $\\supseteq$ $r_2$，则称关系$r_1$等于关系$r_2$，记作$r_1$=$r_2$。 【定义3-2】并(Union)：设有同类关系$r_1$[R]和$r_2$[R]，两者的并(Union)运算定义 $r_1$ $\\bigcup$ $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\vee$ $t$ $\\in$ $r_2$ }式中，$\\bigcup$为并运算符。$r_1$ $\\bigcup$ $r_2$的结果关系是$r_1$的所有元组与$r_2$的所有元组的并集（去掉重复元组）。 【定义3-3】差(Difference)：设有同类关系$r_1$[R]和$r_2$[R]，两者的差(Difference)运算定义为 $r_1$ - $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\wedge$ $t$ $\\notin$ $r_2$ }式中，- 为相减运算符。$r_1$ - $r_2$的结果关系是$r_1$的所有元组减去$r_1$与$r_2$相同的元组所剩下的元组的集合。 【定义3-4】笛卡儿积(Difference)：设$r$[R]为$k_1$元关系，$s$[S]为$k_2$元关系，两者的笛卡儿积(Difference)运算定义为 $r$ $\\times$ $s$ = { $t$ $\\mid$ $t$ = &lt;$u,v$&gt; $\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $s$ }。 【定义3-5】投影(Projection)：是对一个关系进行垂直分割，消去某些列，并重新安排列的顺序的操作。设有$r$[R]为$k$元关系，其关系框架R={$A_1$,$A_2$,$\\dots$,$A_k$}，$A_{j_1}$，$A_{j_2}$，$\\dots$，$A_{j_n}$ 为R中互不相同的属性，那么关系$r$在属性（分量）$A_{j_1}$，$A_{j_2}$，$\\dots$，$A_{j_n}$ 上的投影运算定义为 $\\Pi$ $A_{j_1}$,$A_{j_2}$,$\\dots$,$A_{j_n}$ $($ $r$ $)$ = { $u$ $\\mid$ $u$ = &lt; $t$ [$A_{j_1}$],$t$[$A_{j_2}$],$\\dots$,$t$[$A_{j_n}$] &gt; $\\wedge$ $t$ $\\in$ $r$ }式中，$\\Pi$为投影运算符。 【定义3-6】选择(Selection)：根据某些条件对关系进行水平分割，即选取符合条件的元组的操作。条件可用命题公式F表示，由运算对象和运算符组成： 运算对象：常数（用引号括起来）、元组分量（属性名或列的序号） 运算符：算术比较运算符（$\\lt$,$\\le$,$\\gt$,$\\ge$,=,$\\ne$，也称$\\theta$符），逻辑运算符（$\\vee$,$\\wedge$,$\\neg$） 关系R关于公式F的选择操作用$\\sigma$F$($R$)$表示，其定义为：$\\sigma$F $($ R $)$ $\\equiv$ { $t$ $\\mid$ $t$ $\\in$ R $\\wedge$ F($t$)=true}式中，$\\sigma$为选择运算符。$\\sigma$F$($R$)$表示从R中挑选满足公式F为真的元组所构成的关系。 关系代数的其他操作 【定义3-7】交(Intersection)：设有同类关系$r_1$[R]和$r_2$[R]，两者的交(Intersection)运算定义 $r_1$ $\\bigcap$ $r_2$ = { $t$ $\\mid$ $t$ $\\in$ $r_1$ $\\wedge$ $t$ $\\in$ $r_2$}式中，$\\bigcap$为交运算符。$r_1\\bigcapr_2$的结果关系是$r_1$与$r_2$的所有相同元组构成的集合，显然，$r_1\\bigcapr_2$ 等于$r_1$ - ($r_1$ - $r_2$ )或者$r_2$ - ($r_2$ - $r_1$ )。 【定义3-8】$\\theta$-连接：设$r$[R]、$s$[S]关系框架分别为R = {$A_1$,$A_2$,$\\dots$,$A_n$} 和 {$B_1$,$B_2$,$\\dots$,$B_m$}，那么关系$r$和$s$的$\\theta$-连接（$\\theta$-Join）运算定义为：$r$ $\\Join$ $s$ = { $t$ $\\mid$ $t$ = &lt; $u, v$ &gt;$\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $u$[$A_i$]$\\theta$ $v$[$B_j$]} 【定义3-9】F-连接 ：设$r$[R]、$s$[S]关系框架分别为R = { $A_1$,$A_2$,$\\dots$,$A_n$ }，{ $B_1$,$B_2$,$\\dots$,$B_m$ }，F($A_1$,$A_2$,$\\dots$,$A_n$,$B_1$,$B_2$,$\\dots$,$B_m$)为一公式，那么关系$r$和$s$的F-连接（F-Join）运算定义为：$r$ $\\Join$ $s$ = { $t$ $\\mid$ $t$ = &lt; $u, v$&gt;$\\wedge$ $u$ $\\in$ $r$ $\\wedge$ $v$ $\\in$ $s$ $\\wedge$F($u$[$A_1$],$\\dots$,$u$[$A_n$]),$u$[$B_1$],$\\dots$,$u$[$B_m$]) }即：$r$ $\\Join$ $s$ = $\\sigma$F $(r$ $\\times$ $s)$ 【定义3-10】自然连接： Natural Jion是一种特殊的等值连接，它要求关系R和关系S具有相同的属性组B($b_1$,$b_2$,$b_3$,$\\dots$ $\\dots$)，这些属性组的取值是相等的，在最后生成的关系中去掉属性重复的列。其计算过程如下： (1)计算$r$ $\\times$ $s$；(2)设$r$和$s$的公共属性是$A_1$,$A_2$,$\\dots$,$A_m$，选出$r$ $\\times$ $s$中满足$r.A_1$=$s.A_1$,$r.A_2$=$s.A_2$, $\\dots$, $r.A_m$=$s.A_m$的那些元组；(3)去掉$s.A_1$,$s.A_2$,$\\dots$,$s.A_m$这些列。 【定义3-11】除(Division)：给定关系$r$(X,Y)和$s$(Y,Z)，其中，X，Y，Z为属性组，$r$中的Y与$s$中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除(Division)运算得到一个新的关系$p$(X)，$p$是r中满足下列条件的元组在X属性列上的投影，即元组在X上的分量值$x$的像集$Y_x$包含s在Y上投影的集合，记为$r$ $\\div$ $s$ = { $t_r$[X]$\\mid$ $t_r$ $\\in$ $r$ $\\wedge$ $\\pi_y$($s$) $\\subseteq$ $Y_x$ }式中，$Y_x$为$x$在$r$中的像集，$x$=$t_r$[X]。 五，关系演算关系演算是以数理逻辑中的谓词为基础的，按谓词变元的不同，关系演算可以分为元组关系演算和域关系演算。 元组关系演算：以元组为变量。1） 在元组关系演算中，元组关系演算表达式的一般形式为：$\\{t|P(t)\\}$式中，t是元组变量，表示一个元数确定的元组，P是满足一定逻辑条件的公式，公式可以分解为一些原子公式，$\\{t|P(t)\\}$表示满足公式P的所有元组$t$的集合。2）在一个演算公式中，未用存在量词$\\exists$或全称量词$\\forall$符号定义的元组变量，称为自由元组变量，否则称为约束元组变量。 域关系演算：以属性(域)为变量，简称域演算。","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"http://yoursite.com/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"http://yoursite.com/tags/数据库理论/"}]},{"title":"【Java基础】Java入门知识","slug":"【Java基础】Java入门知识","date":"2019-04-08T15:52:05.000Z","updated":"2019-04-10T16:56:20.703Z","comments":true,"path":"2019/04/08/java_introductory_knowledge/","link":"","permalink":"http://yoursite.com/2019/04/08/java_introductory_knowledge/","excerpt":"","text":"【学习参考资料】：菜鸟教程-Java教程 1，java简介 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。 1）Java分为三个体系： JavaSE(J2SE)Java2 Platform Standard Edition，java平台标准版） JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版) 2）Java的主要特性： java语言是简单的； java语言是面向对象的（纯面向对象）； java语言的分布式的； java语言是健壮的（丢弃指针，强类型机制，异常处理，垃圾的自动收集）； java语言是安全的（安全防范机制（类ClassLoader），安全管理机制（类SecurityManager））； java语言是可移植的； java语言是解释型的； java是高性能的； java语言多线程的； java语言是动态的。 3）Java的发展史：诞生于1995年；2014年3月18日，Oracle公司发表Java SE8。 4）Java工具：Java语言尽量保证系统内存在1G以上。 2，Java开发环境配置1）下载JDK工具解压安装，对应不同的系统选择适合的版本。 2）变量设置参数如下： 变量名：JAVA_HOME 变量值：C:\\Program Files (x86)\\Java\\jdk1.8.0_91 // 要根据自己的实际路径配置 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; //记得前面有个”.“ 变量名：Path 变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 3）测试JDK是否安装成功12~ java -version # 输出java安装的版本~ javac -version # 输出javac安装的版本 注意：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。 4）Java开发工具选择 Eclipse IntelliJ IDEA(推荐) 3，Java基础语法1）相关概念 类：类是一个模板，描述一个对象的行为和状态。 java中的类： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 构造方法：每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 创建对象：在Java中，使用关键字new创建一个新的对象，主要有三步：声明，实例化（new），初始化。 对象：对象是一个类的实例，有状态和行为。 在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。 方法：方法即行为，一个类可以有很多方法。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 2）编程注意点 大小写敏感 类名每个单词的首字母大写（帕斯卡命名法） 方法名以小写字母开头，之后每个单词首字母大写（驼峰命名法） 源文件名必须和类名相同 主方法入口，所有的Java程序由public static void main(String []args)方法开始执行 3）Java标识符 标识符：类名，变量名及方法名都称为标识符。 所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始； 首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合； 关键字不能用作标识符； 标识符是大小写敏感的； 合法标识符举例：age、$salary、_value、__1_value； 非法标识符举例：123abc、-salary； 4）Java修饰符 （1）访问控制： default, public, protected, private 修饰符 当前类 同一包内 子孙类（同一包） 子孙类（不同包） 其他包 public Y Y Y Y Y protected Y Y Y Y /N N default Y Y Y N N private Y N N N N protected说明： 子类与基类在同一包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。 （2）访问控制和继承，注意以下原则： 父类中声明为public的方法在子类中也必须为public。 父类中声明为protected的方法在子类中要么声明为protected，要么声明为 public，不能声明为private。 父类中声明为private的方法，不能够被继承。 （3）非访问控制：final, abstract,static, synchronized,volatile static：创建类方法和类变量； final：修饰类，方法和变量。修饰的类不可被继承；修饰的方法不能被继承的类重新定义；修饰的变量为常量，不可修改。 abstract：创建抽象类和抽象方法； synchronized：用于线程编程，synchronized声明的方法同一时间只能被一个线程访问； transient：序列化的对象包含被 transient修饰的实例变量时，Java虚拟机(JVM)跳过该特定的变量；该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 volatile：用于线程编程， 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值，当成员变量发生变化时，会强制线程将变化值回写到共享内 5）Java变量 局部变量：类的方法中的变量。 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 类变量（静态变量）：独立于方法之外的变量，用static修饰。成员变量（非静态变量）：独立于方法之外的变量，不用static修饰。 6）Java数组：储存在堆上的对象，可以保存多个同类型变量。 7）Java枚举：Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。 8）Java关键字：参见Java关键字列表 9）Java注释 10）Java空行：空白行，或者有注释的行，Java编译器都会忽略掉。 11）Java继承在Java中，一个类可以由其他类派生。被继承的类称为超类（super class），派生类称为子类（subclass）。 12）Java接口：在Java中，接口可以理解为对象间相互通信的协议。 13）源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致 如果一个类定义在某个包中，那么package语句应该在源文件的首行 如果源文件包含import语句，那么应该放在package语句和类定义之间；如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 14）Java包：包主要用来对类和接口进行分类。 15）Import语句 16）Java运算符 算术运算符 关系运算符 位运算符：Java定义类位运算符，应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。 逻辑运算符 赋值运算符 其他运算符（instanceof，自增，自减，条件运算符） 17）Java 源程序与编译型运行区别","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"【数据库实战】SQL Server数据库常用脚本","slug":"【数据库实战】SQL-Server数据库常用脚本","date":"2019-04-07T08:40:27.000Z","updated":"2019-04-09T13:11:32.517Z","comments":true,"path":"2019/04/07/sql_used_script/","link":"","permalink":"http://yoursite.com/2019/04/07/sql_used_script/","excerpt":"","text":"1，创建链接远程服务器及其删除12345exec sp_addlinkedserver 'web','','SQLOLEDB','192.168.10.106'exec sp_addlinkedsrvlogin 'web','false',null,'sa','123'--删除链接服务器exec sp_dropserver 'web','droplogins' 2，重置SQLSERVER表的自增列，让自增列重新计数语法：123456DBCC CHECKIDENT( table_name [, &#123; NORESEED | &#123; RESEED [,new_reseed_value ] &#125; &#125; ] ) [ WITH NO_INFOMSGS ] 参数： table_name:是要对其当前标识值进行检查的表名。指定的表必须包含标识列。表名必须符合标识符规则。 NORESEED:指定不应更改当前标识值。 RESEED:指定应该更改当前标识值。 new_reseed_value:用作标识列的当前值的新值。 WITH NO_INFOMSGS:取消显示所有信息性消息。 查看某表当前的种子值，示例：1dbcc checkident('mainTable',noreseed); 123-------------显示如下----------------检查标识信息: 当前标识值 &apos;2707&apos;，当前列值 &apos;2707&apos;。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 重置表mainTable的当前标识值为1，示例：1dbcc checkident('mainTable',reseed,1); 123-------------显示如下----------------检查标识信息: 当前标识值 &apos;NULL&apos;，当前列值 &apos;1&apos;。--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。 3，几个有用的存储过程 修改xx表中所有值null 123456789101112131415161718192021222324252627282930313233/************************* 功能：修改xx表中所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/if (OBJECT_ID('modifyNull','P') is not null) drop procedure modifyNullgocreate procedure modifyNull(@table char(100))asbegin --定义游标 declare col_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select b.name from sysobjects a inner join syscolumns b on a.id=b.id where a.name=@table --打开游标 open col_cur declare @columnName nvarchar(100) fetch next from col_cur into @columnName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='update ' + @table + ' set ' + @columnName + ' = ISNULL(' + @columnName + ', '''')' exec(@sql) fetch next from col_cur into @columnName end --关闭游标 close col_cur --释放游标 deallocate col_curend 修改数据库中所有表的所有列为null 123456789101112131415161718192021222324252627/************************* 功能：修改数据库中所有表的所有列为NULL='' 作者：by zhangbc 时间：2015-10-19*************************/create procedure [dbo].[modifyAllNull]asbegin declare tab_cur cursor scroll dynamic --scroll表示可以向前或向后移动 dynamic：表示可写也可读 for select name from sysobjects where xtype='U' --打开游标 open tab_cur declare @tableName nvarchar(100) fetch next from tab_cur into @tableName declare @sql nvarchar(1000) while (@@FETCH_STATUS=0) begin set @sql='exec dbo.modifyNull ' +'''' + @tableName + '''' exec(@sql) fetch next from tab_cur into @tableName end --关闭游标 close tab_cur --释放游标 deallocate tab_curend","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"http://yoursite.com/categories/数据库技术/"}],"tags":[{"name":"数据库实战","slug":"数据库实战","permalink":"http://yoursite.com/tags/数据库实战/"}]},{"title":"【数据库理论】绪论","slug":"【数据库理论】绪论","date":"2019-04-06T10:42:18.000Z","updated":"2019-04-10T16:56:20.697Z","comments":true,"path":"2019/04/06/db_introduction/","link":"","permalink":"http://yoursite.com/2019/04/06/db_introduction/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据库的概念 数据库定义：数据库（DB）是长期保存在计算机的存储设备上并按照某种模型组织起来的，可以被各种用户或应用共享的数据集合。 数据库分类：关系数据库，层次数据库，网状数据库. 数据库基本特征：1）具有较高的数据独立性；数据独立性是指数据的组织方法和储存方法与应用程序互不依赖，彼此独立的特性，包括物理独立性和逻辑独立性。2）数据库用综合的方法组织数据，保证尽可能高的访问效率；3）具有较小的数据冗余，可以供多个用户共享；4）具有安全控制机制，能够保证数据的安全，可靠；5）数据允许多用户共享，能够有效，及时地处理数据，并能够保证数据的一致性和完整性。 二，数据库管理系统（DBMS） DBMS的定义：DBMS是位于用户与操作系统之间的数据管理软件，数据库在建立，运用和维护时由数据库管理系统统一管理，控制。 DBMS的目标： 1）用户界面友好； 2）功能完备； 3）效率高，DBMS应该具有较高的系统效率和高的用户生产率，其中系统效率包括： （1）计算机内部资源的利用率，即能够充分利用磁盘空间，CPU，设备等资源，并注意使各种资源的负载均衡以提高整个系统的效率；（2）DBMS本身的运行效率，根据系统目标确定恰当的体系结构，数据结构和算法，保证DBMS运行的高效率；用户生产率是指用户设计和开发应用程序的效率； 4）结构清晰：DBMS内部结构清新，层次分明既便于支持其外层开发环境的构造，也便于自身的设计、开发与维护； 5）开放性：DBMS的开放性是指符合标准和规范，如ODBC标准，SQL标准等。 DBMS的基本功能： 1）数据库定义功能：DDL可以定义数据库中数据之间的联系，可以定义数据的完整性约束条件和保证完整性的触发机制等，包括全局逻辑数据结构（模式）的定义，局部逻辑数据结构（外模式）的定义，保密定义等；2）数据库操纵功能：DML可以接收，分析和执行用户提出的访问数据库的各种要求，完成对数据库的各种基本操作，如对数据库的检索，插入，删除和修改等操作，可以重新组织数据的存储结构，可以完成数据库的备份和恢复等操作；3）数据库的控制功能：DCL包括整个数据库系统的运行控制，数据库的完整性控制，数据库的安全性控制及多用户环境下的数据库并发访问控制等；4）数据库的运行管理功能：指DBMS运行机制和管理功能；5）数据库组织和存储管理功能6）数据库的建立和维护功能7）数据库通信功能 DBMS的组成： 1）数据库定义语言及其翻译程序： DDL用于描述数据库中要存储的现实世界实体的语言，包括数据字典中数据库的逻辑结构，完整性约束，物理存储结构的表述，数据库的各种数据操作和数据库的维护管理的各种依据。包括： 模式DDL：定义全局逻辑数据结构(包括所有字段的名称，特征及其相互关系)，数据的完整性，安全性约束；外模式DDL：为用户定义所用的局部逻辑数据结构(包括与用户的应用程序有关的字段名称，特征及其相互关系)，描述外模式到模式之间的映射关系；内模式DDL：用于描述数据在存储介质上的安排和存放方式，描述模式到内模式之间的映射关系； 2）数据库操纵语言及其编译（或解释）程序： DML用于实现对数据库的一些基本操作，如数据检索，数据插入，数据修改和数据删除，其中数据插入，数据修改和数据删除操作又称为数据更新操作。分为： 宿主型DML：本身不能独立使用，必须嵌入到宿主语言中，如C，COLBOL，PASCAL等，因此也称嵌入型DML，仅负责对数据库数据的操纵，其他工作都由宿主语言完成；自主型DML，又称自含型DML，可以独立进行数据查询，数据更新等操作，语法简单，使用方便，适合终端用户使用； 3）数据库运行控制程序：包括系统初启程序(DBMS的神经中枢)，访问控制程序，安全性控制程序，完整性检查程序，并发控制程序，数据存取/更新程序，通信控制程序； 4）数据库服务实用程序：包括数据装入程序，工作日志程序，性能监督程序，数据库重新组织程序，系统恢复程序，转储/编辑/打印程序。 数据库管理与数据库管理员(DBA)： 1）DBA：从事数据库管理工作的人员，不是数据库的“占有者”，而是数据库的“保护者”。 2) DBA职责 在数据库设计开始之前，DBA首先调查数据库的用户需求。 在数据库设计阶段，DBA要负责数据库标准的制定和功用数据字典的研制，要负责各级数据库模式的设计，负责数据库安全，可靠方面的设计，决定文件组织的方法。 在数据库运行阶段，DBA要负责对用户进行数据库方面的培训，负责数据库的转储和恢复，数据维护，用户的使用权限等，负责监控数据库的性能。 三，数据库系统（DBS） DBS定义：指在计算机系统中引入数据库后的系统构成，一般由数据库，数据库系统运行环境，数据库管理系统及其开发工具，数据库管理员和用户组成。 数据库系统的三级模式结构： 1）模式定义：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，而不涉及具体的值。 2）三级模式结构： 外模式：也称子模式或者用户模式，是数据库用户看见和使用的局部数据的逻辑结构和特征的描述，是数据库的用户视图，是和某个应用相关的数据逻辑表示；一个数据库可以有多个外模式； 模式：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共视图，是数据库的整个逻辑描述，并说明一个数据库所采用的数据模型；一个数据库只有一个模式； 内模式：也称存储模式，是数据物理结构和存储方式的描述，是数据库的内部表示方式；一个数据库只有一个内模式。 二级映像功能和数据独立性： 1）外模式/模式映像：当模式改变时，DBA对各个外模式/模式的映像做出相应改变，使外模式保持不变，从而使应用程序不改变，保证了数据的逻辑独立性； 2）模式/内模式映像：唯一定义了数据全局逻辑结构和存储方式之间的对应关系。当数据库的存储方式改变时，DBA将对模式/内模式映像做出相应的改变，使模式保持不变，从而保证了数据的物理独立性。 数据库系统的体系结构： 1）单用户结构的数据库系统：最早最简单，不能共享数据； 2）主从式结构的数据库系统：结构简单，数据易于维护维护和管理，但系统的可靠性不高； 3）分布式结构的数据库系统：数据在逻辑上上一个整体，但是分布在计算机网络的不同结点上。 4）客户端/服务器结构的数据库系统 数据库系统的工作流程： 1）DBA建立并维护数据库； 2）用户编写应用程序； 3）应用程序在DBMS支持下运行，在模式，外模式，内模式，用户源程序翻译为目标代码后，即可启动目标程序。 四，数据库的发展 人工管理阶段： 1）特点：数据不保存；应用程序管理数据；数据不共享；数据不具有独立性。 文件系统阶段： 1）优点：数据可以长期保存；有专门的软件即文件系统管理数据，文件系统把数据组织成相互独立的数据文件；文件的形式多样化； 2）缺点：数据共享性差，冗余度大；数据独立性差；数据联系弱。 数据库系统阶段 数据库技术的研究，应用领域和发展方向 数据模型 数据库管理系统软件的研制 数据操作 数据库理论：主要集中在关系的规范化理论，关系数据理论等。 代表性的数据库应用领域和发展方向： 因特网上的Web数据库 面向对象数据库 多媒体数据库 并行数据库 人工智能领域的知识库和主动数据库 模糊数据库系统","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"http://yoursite.com/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"http://yoursite.com/tags/数据库理论/"}]},{"title":"【数据库理论】数据模型","slug":"【数据库理论】数据模型","date":"2019-04-06T04:48:52.000Z","updated":"2019-04-09T13:11:32.520Z","comments":true,"path":"2019/04/06/db_data_model/","link":"","permalink":"http://yoursite.com/2019/04/06/db_data_model/","excerpt":"","text":"本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。 一，数据描述 数据的三种范畴 1）现实世界（客观世界）：现实世界所反映的客观存在的事物及其相互之间的联系，指数处理对象最原始的表现形式。 2）信息世界（观念世界）：是现实世界在人们头脑中的反映，经过一定的选择，命名和分类而形成的。以下为相关概念： 实体（Entity）：客观存在的事物在人们头脑中的反映，或说，客观存在并可相互区别的客观事物或抽象事件。 属性（Attribute）：实体所具有的某一方面的特性。 域（Domain）：一个属性可能取的所有属性值的范围称为该属性的域。 码（Key）：唯一标识实体的属性集。 实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（Entity Set）：同一类型实体的集合。 3）机器世界（数据世界或存储世界）数据化后的信息称为数据，所以说数据是信息的符号表示。以下为相关概念： 数据项（字段，Field）：对应于信息世界中的属性。 记录（Record）：对应于每个实体所对应的数据。 记录型（Record Type）：对应于信息世界中的实体型。 文件（File）：对应于信息世界中的实体集。 关键字（Key）：对应于能够唯一标识一个记录的字段集。 实体间的联系 一对一联系：如果实体集A中每个实体，实体集B中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记作1:1； 一对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中至多有一个实体与之联系，则称实体集A与实体集B具有一对多联系，记作1:n； 多对多联系：如果实体集A中每个实体，实体集B中有n（n&gt;=0）个实体与之联系，反之，实体集B中每个实体，实体集A中有m（m&gt;=0）个实体与之联系，则称实体集A与实体集B具有多对多联系，记作n:m。 二，概念模型与E-R方法 数据模型 1）数据模型应满足以下要求： i）能够比较真实地模拟现实世界；ii）容易为人所理解；iii）便于在计算机上实现。 2）数据模型分类： i）概念模型：即信息模型，是按用户的观点来对数据和信息建模的，主要用于数据设计；ii）基本数据模型：主要包括网状模型，层次模型，关系模型等，是按计算机系统的观点对数据建模的，主要用于DBMS的实现。 数据模型的三要素 1）数据结构：用于描述系统的静态特性。数据结构是所有研究对象类型的集合，这些对象是数据库的组成部分，分为两大类： 与数据类型，内容，性质有关的对象； 与数据之间联系有关的对象。 2）数据操作：用于描述系统的动态特征。数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有检索和修改（插入，删除，更新）两大数据操作。 3）数据完整性约束：是一组完整性规则的集合。完整性规则是给定的数据模型中的数据及其联系所具有的制约和存储规则，用于限制符合数据模型的数据库状态及状态的变化，用于确保数据的正确、有效和相容。 概念数据模型 1）概念模型的定义：按用户的观点对现实世界进行数据建模而形成的，是一种独立于计算机系统的模型，完全不涉及信息在计算机系统中的表示，也不依赖于具体的数据库管理系统，用于描述某个特定组织所关心的信息结构。 2）概念模型的相关基本概念：实体、属性、域、码、实体型和实体集。 3）概念模型的基本关系：在概念模型中主要解决问题是实体间的联系。 E-R图表示法 1）实体型：用矩形表示，矩形框内写明实体名； 2）属性：用椭圆表示，椭圆内写明属性名； 3）联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标注联系的类型（1:1，1:n，n:m）。 E-R模型优点： i）接近人的思想，容易理解；ii）与计算机无关，用户容易接受。 三，传统的三大数据模型 层次模型 1）层次模型定义：用树形结构表示实体之间的联系的模型称为层次模型。 2）建立数据的层次模型需要满足以下条件： i）有且仅有一个结点没有父结点，这个结点即为树根结点；ii）其他数据记录有且仅有一个父结点。 3）层次模型的基本特点：任何一个给定的记录值只有按其路径查看，才能体现它的全部含义，没有一个子记录值能够脱离父记录值而独立存在的。 4）层次模型的最明显特点：层次清晰，构造简单，易于实现，可以很方便地表示一对一和一对多这两种实体之间的联系。 5）层次模型的主要优点： i）层次模型本身比较简单；ii）实体间联系是固定的，且预先定义好的应用系统采用层次模型来实现，其性能优于关系模型的性能，不低于网状模型的性能；iii）层次模型提供了良好的完整性支持。 6）层次模型的主要缺点： i）现实世界中很多联系是非层次性的，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据或创建非自然组织（引入虚结点）来解决；ii）对插入和删除操作的限制比较多；iii）查询子结点必须通过父结点；iv）由于结构严谨，层次命令趋于程序化。 网状模型 1）网状模型的定义： 网状模型是一种有向图，在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型： i）允许一个以上的结点无父结点；ii）一个结点可以有多于一个的父结点。 2）为了描述网状模型的记录之间的联系，引进了系（Set）的概念，所谓系可以理解为命名了的联系，它由一个父记录型和一个或多个子记录型构成。 3）网状数据库的定义：用网状模型设计出来的数据库称为网状数据库。 4）网状模型的主要优点： i）能够更为直接地描述现实世界，如一个结点可以有多个父结点；ii）具有良好的性能，存取效率较高。 5）网状模型的主要缺点： i）结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于用户最终掌握；ii）其DDL，DML语言复杂，用户不易使用。 关系模型 1）关系模型的主要优点： i）数据结构比较简单；ii）具有很高的数据独立性；iii）可以直接处理多对多联系；iv）坚实的理论基础。 2）值域的定义：在关系模型中，一个n元关系有n个属性，属性的取值范围称为值域。 3）关系模型主要缺点：存取路径对用户透明，查询效率往往不如非关系数据模型。 四，数据独立与三层结构 三级模式结构 外模式：又称为用户模式，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看得见和使用的局部数据的逻辑结构和特征描述，是与某一个应用有关的数据的逻辑表示。 模式：可分为概念模式和逻辑模式，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。 一个数据库只有一个模式，其中概念模式可以用实体-联系模型模型来描述，逻辑模式以某种数据模型为基础，综合考虑所有用户的需求，并将其形成全局逻辑结构。 内模式：又称为存储模式，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。 数据的独立性 逻辑数据独立性：当模式改变时，只要对外模式/模式映像做相应的改变，就可以使外模式保持不变，以外模式为依据编写的应用程序就不受影响，从而应用程序不必修改，保证了数据与程序之间的逻辑独立性。 存储数据独立性：当内模式改变时，只要对模式/内模式映像做相应的改变，使模式保持不变，应用程序就不受影响，从而保证了数据与程序之间的物理独立性，称为存储数据独立性。 五，数据库管理系统 DBMS的主要功能 数据库的主要职责就是有效地实现数据库三级模式之间的转换，即把用户或应用程序对数据库的一次访问，从用户级带到概念级，再导向物理级，转换为对存储数据的操作。 1）数据库定义2）数据库操作及查询优化3）数据库控制运行管理4）数据组织，存储和管理5）数据库的恢复和维护6）数据库的多种接口7）其他功能 DBMS的组成 1）DBMS由查询处理器和存储管理器两大部分组成。其中： (1) 查询处理器主要有DDL编译器，DML编译器，嵌入式DML的预编译器及查询运行核心程序；(2) 存储管理器有授权和完整性管理器，事务管理器，文件管理器及缓冲区管理器。 2）查询处理程序：把用较高级的语言所表示的数据库操作（查询、更新等）转换成一系列对数据库的请求。 3）存储管理程序：包括文件管理程序和缓冲区管理程序。 4）事务管理程序：保证数据库中所有事务全部都能正确执行。 用户访问数据库的过程（略）","categories":[{"name":"数据库技术","slug":"数据库技术","permalink":"http://yoursite.com/categories/数据库技术/"}],"tags":[{"name":"数据库理论","slug":"数据库理论","permalink":"http://yoursite.com/tags/数据库理论/"}]}]}