<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天堂的鸽子</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangbc.github.io/"/>
  <updated>2019-04-26T16:09:59.802Z</updated>
  <id>https://zhangbc.github.io/</id>
  
  <author>
    <name>Bocheng Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Python编码规范】Python编码入门</title>
    <link href="https://zhangbc.github.io/2019/04/25/python_code91_01/"/>
    <id>https://zhangbc.github.io/2019/04/25/python_code91_01/</id>
    <published>2019-04-25T14:56:39.000Z</published>
    <updated>2019-04-26T16:09:59.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。</p></blockquote><p><strong>温馨提醒</strong>：在阅读本书之前，强烈建议先仔细阅读：<a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener"><strong>PEP</strong>规范</a>，增强代码的可阅读性，配合优雅的<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">pycharm</a>编辑器(开启<code>pep8</code>检查)写出规范代码，是<code>Python</code>入门的第一步。</p><blockquote><p><em>本书主要内容</em></p><blockquote><p>1）容易被忽视的重要概念和常识，如代码的布局和编写函数的原则等；<br>2）编写<code>Python</code>程序管用的方法，如利用<code>assert</code>语句去发现问题，使用<code>enumerate()</code>获取序列迭代的索引和值等；<br>3）语法中的关键条款，如有节制地使用<code>from…import</code>语句，异常处理的几点基本原则等；<br>4）常见库的使用，如按需选择<code>sort()</code>或者<code>sorted()</code>，使用<code>Queue</code>使多线程更安全等；<br>5）<code>Python</code>设计模式的使用，如用发布订阅模式实现松耦合，用状态模式美化代码等；<br>6）<code>Python</code>内部机制，如名字查找机制，描述符机制等；<br>7）开发工具的使用，如<code>pip</code>等各种开发工具的使用，各种代码测试用具的使用等；<br>8）<code>Python</code>代码的性能分析，优化的原则，工具，技巧，以及常见性能问题的解决等。</p></blockquote></blockquote><h2 id="建议1：理解Pythonic概念"><a href="#建议1：理解Pythonic概念" class="headerlink" title="建议1：理解Pythonic概念"></a>建议1：理解Pythonic概念</h2><p>1）<strong><code>Pythonic</code>的定义</strong>：充分体现<code>Python</code>自身特色的代码风格。</p><ul><li><code>The Zen of Python</code>(<code>Python</code>之禅)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>快速排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_quick</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string">    :param array:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    less = list()</span><br><span class="line">    greater = list()</span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    pivot = array.pop()</span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(array):</span><br><span class="line">        <span class="keyword">if</span> item &lt;= pivot:</span><br><span class="line">            less.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            greater.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sort_quick(less) + [pivot] + sort_quick(greater)</span><br></pre></td></tr></table></figure><p>2）<strong>代码风格</strong></p><ul><li>交换两个变量的值，<code>packaging/unpackaging</code>机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2</span></span><br><span class="line">y = <span class="number">3</span></span><br><span class="line">x, y = y, x</span><br><span class="line"><span class="keyword">print</span> x, y</span><br></pre></td></tr></table></figure><ul><li>容器遍历</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(items):</span><br><span class="line">    do_sth_with(item)</span><br></pre></td></tr></table></figure><ul><li>列表逆序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">str_c = <span class="string">'abcdef'</span></span><br><span class="line">print(list(reversed(list_a)))</span><br><span class="line">print(list(reversed(str_c)))</span><br></pre></td></tr></table></figure><ul><li>标准库</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串格式化</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Hello %(name)s!'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Tom'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>注解</strong>：<code>%</code>是非常影响可读性的，因为数量多了之后，很难清除哪一个占位符对应哪一个实参。</p><ul><li><code>str.format()</code>：<code>Python</code>最为推荐达到字符串格式化方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串格式化, 替代%</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Hello &#123;name&#125;!'</span>.format(name=<span class="string">'Tom'</span>)</span><br></pre></td></tr></table></figure><p>3）<strong><code>Python</code>的包和模块结构</strong></p><blockquote><p>(1) 包和模块的命名采用小写，单数形式且短小；<br>(2)包通常作为命名空间，如只包含空的<code>__init__.py</code>文件。</p></blockquote><h2 id="建议2：编写pythonic代码"><a href="#建议2：编写pythonic代码" class="headerlink" title="建议2：编写pythonic代码"></a>建议2：编写pythonic代码</h2><p>1）<strong>要避免劣化代码</strong></p><blockquote><p>(1)避免只用大小写来区分不同的对象；<br>(2)避免使用容易引起混淆的名称；<br>(3)不要害怕过长的变量名。</p></blockquote><ul><li>实例1（函数名称，变量名意义均不明）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span><span class="params">(list_items, num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param list_items: </span></span><br><span class="line"><span class="string">    :param num: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> list_items:</span><br><span class="line">        <span class="keyword">if</span> num == element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>实例2（<strong>推荐</strong>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_num</span><span class="params">(list_search, num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param list_search:</span></span><br><span class="line"><span class="string">    :param num:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(list_search):</span><br><span class="line">        <span class="keyword">if</span> num == value:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>2）<strong><code>pep8</code>检测工具</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;pip install -U pep8</span><br><span class="line">C:\Users\Administrator\Desktop\zxt&gt;pep8 --first database.py</span><br><span class="line">database.py:83:1: E302 expected 2 blank lines, found 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">pep8 --show-source --show-pep8 waijiao.py</span></span><br></pre></td></tr></table></figure><p>3）<strong>深入认识<code>Python</code>有助于编写<code>Pythonic</code>代码</strong></p><blockquote><ul><li>掌握<code>Python</code>提供的所有特性，包括语言特性和库特性；</li><li>跟进学习<code>Python</code>的最新版本提供的新特性，掌握其变化趋势；</li><li>深入学习公认比较<code>Pythonic</code>的代码，例如<code>Flask</code>、<code>gevent</code>、<code>requests</code>等。</li></ul></blockquote><h2 id="建议3：理解python与C语言的不同之处"><a href="#建议3：理解python与C语言的不同之处" class="headerlink" title="建议3：理解python与C语言的不同之处"></a>建议3：理解python与C语言的不同之处</h2><p>1）<strong>“缩进” 与 “<code>{}</code>“</strong><br><code>Python</code>中使用严格的代码缩进方式分隔代码块，应养成良好的习惯，统一缩进风格，不要混用<code>Tab</code>键和空格。</p><p>2）<strong><code>&#39;</code> 与 <code>&quot;</code></strong><br>在<code>C</code>语言中，二者有严格的区分，但是在<code>Python</code>中，区别较小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.10</span> (default, Jul <span class="number">15</span> <span class="number">2017</span>, <span class="number">17</span>:<span class="number">16</span>:<span class="number">57</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">"He said, \"Hello!\""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">'He said, "Hello!"'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1</span><br><span class="line"><span class="string">'He said, "Hello!"'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2</span><br><span class="line"><span class="string">'He said, "Hello!"'</span></span><br></pre></td></tr></table></figure><p>3）<strong>三元操作符 <code>?:</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span></span><br><span class="line">y = <span class="number">-2</span></span><br><span class="line">print(x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y)</span><br><span class="line"><span class="number">-2</span></span><br></pre></td></tr></table></figure><p>4）<strong><code>switch...case</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = raw_input(<span class="string">"please input a number:"</span>)</span><br><span class="line"><span class="keyword">if</span> n == <span class="string">"0"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"You typed zero."</span></span><br><span class="line"><span class="keyword">elif</span> n == <span class="string">"1"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"You are in top."</span></span><br><span class="line"><span class="keyword">elif</span> n == <span class="string">"2"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"N is an even number."</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Error!"</span></span><br></pre></td></tr></table></figure><ul><li>用跳转也可以实现：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"0"</span>:  <span class="string">"You typed zero."</span>,</span><br><span class="line">        <span class="string">"1"</span>:  <span class="string">"You are in top."</span>,</span><br><span class="line">        <span class="string">"2"</span>:  <span class="string">"N is an even number."</span></span><br><span class="line">    &#125;.get(n, <span class="string">"Error!"</span>)</span><br></pre></td></tr></table></figure><h2 id="建议4：在代码中适当添加注释"><a href="#建议4：在代码中适当添加注释" class="headerlink" title="建议4：在代码中适当添加注释"></a>建议4：在代码中适当添加注释</h2><p><code>Python</code>有3种形式的代码注释：<code>块注释</code>，<code>行注释</code>，<code>文档注释(docstring)</code>。</p><blockquote><p>(1）使用块或者行注释的时候仅注释复杂的操作，算法，难以理解的技巧或者不够一目了然的代码；<br>(2）注释和代码隔开一定的距离；<br>(3）给外部可访问的函数和方法添加文档注释(<code>docstring</code>)（<code>&quot;&quot;&quot; &quot;&quot;&quot;</code>）；<br>(4）推荐文件头部包含<code>copyright</code>申明，模块描述等。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Requests HTTP library</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">Requests is an HTTP library, written in Python, for human beings. Basic GET</span></span><br><span class="line"><span class="string">usage:</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; import requests</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; r = requests.get('https://www.python.org')</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; r.status_code</span></span><br><span class="line"><span class="string">   200</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; 'Python is a programming language' in r.content</span></span><br><span class="line"><span class="string">   True</span></span><br><span class="line"><span class="string"><span class="meta">... </span>or POST:</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; payload = dict(key1='value1', key2='value2')</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; r = requests.post('http://httpbin.org/post', data=payload)</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; print(r.text)</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">     ...</span></span><br><span class="line"><span class="string">     "form": &#123;</span></span><br><span class="line"><span class="string">       "key2": "value2",</span></span><br><span class="line"><span class="string">       "key1": "value1"</span></span><br><span class="line"><span class="string">     &#125;,</span></span><br><span class="line"><span class="string">     ...</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">The other HTTP methods are supported - see `requests.api`. Full documentation</span></span><br><span class="line"><span class="string">is at &lt;http://python-requests.org&gt;.</span></span><br><span class="line"><span class="string">:copyright: (c) 2015 by Kenneth Reitz.</span></span><br><span class="line"><span class="string">:license: Apache 2.0, see LICENSE for more details.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="建议5：通过适当添加空行使代码布局更为优雅，合理"><a href="#建议5：通过适当添加空行使代码布局更为优雅，合理" class="headerlink" title="建议5：通过适当添加空行使代码布局更为优雅，合理"></a>建议5：通过适当添加空行使代码布局更为优雅，合理</h2><p><strong><code>Python</code>代码布局应当遵循以下基本规则</strong>：<br>1）在一组代码表达完一个完整的思路之后，应该用空白行进行间隔；</p><ul><li>反例（多余空行）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> guess == number:</span><br><span class="line">    print(<span class="string">"Good job!"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Nope"</span>)</span><br></pre></td></tr></table></figure><p>2）尽量保持上下文语义的易理解性(如调用函数写在被调用函数之上)；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    B()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>3）避免过长的代码行，每行最好不要超过80个字符，超过的部分可以用圆括号、方括号、花括号等进行连接，并保存行连接的元素垂直对齐；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="string">'This is a verey long string.'</span></span><br><span class="line">     <span class="string">'It is used for testing line limited characters'</span>)</span><br></pre></td></tr></table></figure><p>4）不要为了保持水平对齐而使用多余的空格，同时也不要在一行有多个命令；</p><ul><li>反例（多余的空格）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x =                    <span class="number">5</span></span><br><span class="line">Year =                 <span class="number">2013</span></span><br><span class="line">name =                 <span class="string">"Jam"</span></span><br><span class="line">d2 = &#123;<span class="string">'spam'</span>: <span class="number">2</span>, <span class="string">'eggs'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>反例（一行中多个命令）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">1</span>; Y = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>5）空格的使用要能在需要强调的时候警示读者：<br>（1）二元运算符、比较、布尔运算的左右两边应该有空格；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>（2）逗号和分号前不要使用空格；</p><ul><li>推荐</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="number">4</span>:</span><br><span class="line">    print(x, y)</span><br><span class="line"></span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><ul><li>反例（不推荐）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="number">4</span> :</span><br><span class="line">    print(x , y)</span><br><span class="line"></span><br><span class="line">x , y = y , x</span><br></pre></td></tr></table></figure><p>（3）函数名和左右括号之间，序列索引操作时序列名和<code>[ ]</code>之间不要空格，函数默认参数两侧不需要空格；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_quick</span><span class="params">(array, if_print=<span class="number">0</span>)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">arrays = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure><p>（4）强调前面的操作符的时候使用空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-2</span> - <span class="number">5</span></span><br><span class="line">b*b + a*a</span><br></pre></td></tr></table></figure><h2 id="建议6：编写函数的4个原则"><a href="#建议6：编写函数的4个原则" class="headerlink" title="建议6：编写函数的4个原则"></a>建议6：编写函数的4个原则</h2><p><strong><code>函数</code></strong> 能够带来最大化的代码重用和最小化的代码冗余，不仅可以提高程序的健壮性，还可以增强可读性，减少维护成本。</p><p>1）<strong>函数设计尽量短小，嵌套层次不宜过深(最好控制在3层以内)</strong>；</p><p>2）<strong>函数声明应该做到合理，简单，易于使用</strong>；</p><p>3）<strong>函数参数设计应该考虑向下兼容</strong>；</p><p>4）<strong>一个函数只做一件事，尽量保证函数语句粒度的一致性</strong>。</p><h2 id="建议7：将常量集中到一个文件"><a href="#建议7：将常量集中到一个文件" class="headerlink" title="建议7：将常量集中到一个文件"></a>建议7：将常量集中到一个文件</h2><p><code>Python</code>使用常量：</p><blockquote><p>通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下画线连接各个单词；<br>通过自定义的类实现常量功能。</p></blockquote><ul><li>示例：<code>const.py</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_const</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConstError</span><span class="params">(TypeError)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConstCaseError</span><span class="params">(ConstError)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__dict__.has_key(name):</span><br><span class="line">            <span class="keyword">raise</span> self.ConstError, <span class="string">"Can't change const.&#123;name&#125;"</span>.format(name=name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.isupper():</span><br><span class="line">            <span class="keyword">raise</span> self.ConstCaseError, <span class="string">'const name "&#123;name&#125;" is not all uppercase'</span>.format(name=name)</span><br><span class="line">        self.__dict__[name] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys.modules[__name__] = _const()</span><br></pre></td></tr></table></figure><ul><li>调用实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> const</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const.COMPANY = <span class="string">"IBM"</span></span><br><span class="line">print(const.COMPANY)</span><br><span class="line"></span><br><span class="line">const.COMPANY = <span class="string">"IBM2"</span></span><br></pre></td></tr></table></figure><ul><li>上述调用会报错，因为代码中的常量一旦生成便不可更改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/algorithm_sort.py"</span>, line <span class="number">40</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    const.COMPANY = <span class="string">"IBM2"</span></span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/const.py"</span>, line <span class="number">18</span>, <span class="keyword">in</span> __setattr__</span><br><span class="line">    <span class="keyword">raise</span> self.ConstError, <span class="string">"Can't change const.&#123;name&#125;"</span>.format(name=name)</span><br><span class="line">const.ConstError: Can<span class="string">'t change const.COMPANY</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在阅读本书之前，强烈建议先仔细阅读：&lt;a href=&quot;https://legacy.py
      
    
    </summary>
    
      <category term="Python" scheme="https://zhangbc.github.io/categories/python/"/>
    
    
      <category term="Python编码规范" scheme="https://zhangbc.github.io/tags/python-coding-convention/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（七）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_08/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_08/</id>
    <published>2019-04-22T14:53:30.000Z</published>
    <updated>2019-04-22T15:00:36.255Z</updated>
    
    <content type="html"><![CDATA[<p>弹指一瞬，已是四年没有更新这个系列的东西，想说的太多却欲言又止，生活的磨练快让我认不得从前的自己了，今日此时此刻翻阅了一下以前的关于自己的想法与历程，觉得有必要继续这个系列的话题了，以记录自己最真实的生活状态，人生旅程漫漫，不能没有梦，不能忘了原有的动力，即使穷生活也得还原生活的本真，揭开虚伪的面纱，还自己一个最真实的人生。</p><p>大学毕业快五年，我一直没有忘记思考自己想要什么样的生活？其实我还是没有想太明白，从不怕被人抛弃，也不怕人笑话，其实我对金钱一直是比较抵触的，但当听说很多朋友已买房的时候，我开始慢慢怀疑自己是不是有点另类了，多少人为了一套房子煞费苦心，得到了之后却并没觉得开心？虽然他们负债累累，谨小慎微的过着余生可数的日子，但是他们实现了人生一个小小的目标，而且时间不算太长。再回头审视自己，从学校出来，拿着微薄的薪水，带着一颗自卑的心，一直就这么撑着，因为身体的原因，还有倔强的性格，一丝丝不甘心的愿望，顿时觉得自己被时代抛弃了美好的青春年华。殊不知是自己缺少一颗闯进的心，缺少一个真正的规划的人生目标，2014年错失了一次从头再来的机会，那些所谓贷款的还款计划，今日想起来，着实应证了那句话，贫困限制了你的视野。穷怕了，连一个利息钱都不想多付一分，如果时时刻刻算着自己的经济账，那如何超脱自己，达到不受金钱的束缚？</p><p>毕业就知道，三年一个小坎，五年一个大坎，跳过了就成功了，没有跳过注定平庸，至少一段相当长的时期会过着不是自己想要的生活。其实毕业这五年，我算是平庸得不能在平庸了，但是至始至终有一颗不甘平庸的心。2013年得力于同窗的举荐进了一家不大不小的医药物流企业做ERP技术支持，从零开始，从维护一个简易的电商平台再到一个分公司ERP业务系统再到整个公司ERP系统，不足一年就已完全掌控，对ERP流程优化，业务系统改造，与部门有效沟通均出了应有之力。尽管如此，对当时的生活状态还是不满意，工资低不说，主要感觉还是无法满足自己的学习欲望，于是乎，各种倒腾自己的业余生活尝试新技术的学习，还是想做一名合格的码农。2014年4月同事离职，两个人的工作推到了我一个人身上，经一个月的调整，也算平稳过渡，就这么撑到了2015年4月离开。其实对我来说得到了极大了锻炼价值，从中慢慢体会了许多东西，什么事情分轻重缓急，哪些任务需要主次分明，哪些工作项得有条不紊，只有亲身体验了方可知其中的奥妙。在这家公司，让我学会了做事，技术没有收获多少，做事的思维大有提升。2015年4月离职，去了上海，原本是拜师傅去的，仅仅半个月由于自己基础实在是太薄弱，最后夭折，开始寻下一份工作。这辈子一定要尝试自己想做的工作，想过的日子，哪怕没钱，哪怕遭无数人鄙视，一定要去做，必须去满足自己小小的虚荣心，哪怕只有一天，无论付出多大的代价。这是我拜师最大的收获，认识了一位开发大神（也是我同乡），后来离开也拒绝了他给我的半个月薪水，不为别的，就为一个承若：干不好，分文不取，拍屁股走人。他给了我很多建议，受益匪浅，时至今日，我们依然保持着联系，我依然能感受他对我无微不至的关怀。花了一个月的时间，拿到两个比较中意的offer，因不想重拾ERP技术，拒绝了业界许多好心人的推荐，当时的想法就是宁可无工作也不去走老路，一定要坚持自己的信念。经过两家工作性质对比思考，最终选择了薪资较低而且极为陌生的领域，开始决定摸爬滚打。技术用上了我业余的学习所得，当然也没有排除我之前掌握的核心技术栈。说是开发工程师，其实进来才发现也不是那么回事，各种杂活脏活还是由我一个人做，创业公司嘛，坑不少，想想能锻炼人，能感受一波创业的辛酸史，便留下了断了其他念头，老板在吃喝玩乐方面也比较阔气。在这家公司最大的感受就是，创业不易，且行且珍惜，要有危机意识，时时刻刻保持一颗清醒的头脑，一句话谨记，逆水行舟不进则退。其实生活工作亦如此。后来，感觉老板心态变了，不断画饼(平生最恶此举)，我就离开了。期间认识了不少人，见识了不少场合，逢场作戏太多，越来越觉得当初毕业拒绝考虑医院单位是明智之举。2015年5月至2017年4月，就这样结束了我的第二份工作，即将有幸迎来我的第三份工作—我在一家互联网金融的创业公司担任爬虫工程师，算是一个真正入门的coder，又一个全新的挑战。从上海转战武汉，回武汉也是我的一个想法—离家进了一小步，故人在，朋友常聚，情谊永存，工作之外，还需要倒腾一下生活，我是一个极度恋旧情的人，很难和新朋友结交为知己。很赞赏那句“人生得一知己足矣”，但是心里还是不乐意这么去想，我始终坚持人之初性本善的理念，只要敞开心扉，就能拥抱世界，拥抱未来。</p><p>面对一个真实的自己，细细回味着自己走过的路，顿时发现自己还是那么的倔强，尝试混迹于各种领域，生活却多了几分艰辛，坚决不留后路，至于生活到底过得如何，我还是靠着勇气战胜了自己，若能克服自卑的心理，或许我的各种尝试才会体现其应有的价值。浪费青春也罢，折腾生活也好，我无怨无悔，我会一如既往地带着人生最初的问题走下去。牛人，就是走到哪里都有可用武之地，都有金钱可挥霍，都有很多有意义的事情等着他去完成。我不是牛人，但我相信这样的人生理念，从一个小白做起，不怕丢失工作，唯恐没有勇气胜任工作。</p><p>by zhangbc<br>2018-04-24</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;弹指一瞬，已是四年没有更新这个系列的东西，想说的太多却欲言又止，生活的磨练快让我认不得从前的自己了，今日此时此刻翻阅了一下以前的关于自己的想法与历程，觉得有必要继续这个系列的话题了，以记录自己最真实的生活状态，人生旅程漫漫，不能没有梦，不能忘了原有的动力，即使穷生活也得还原
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（六）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_07/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_07/</id>
    <published>2019-04-22T14:39:55.000Z</published>
    <updated>2019-04-22T14:51:53.849Z</updated>
    
    <content type="html"><![CDATA[<p>晃晃悠悠又是一年时，该到了总结与反思的时候了。想想当初的豪情壮志，如今却被时间磨平了，淡化了，可笑？可恨？可惜？可怜？这一年，不知道用什么言语表达，用什么词汇来描绘，单单是工作那么简单，抑或生活的平淡无奇，或许吧，生性贪婪而又好懒的我，真的不知道怎么总结这一年的得失？该是静下来好好思索思索的时候了，人无远虑，必有近忧。我始终认为人之所以与一般动物有别，就在于思维，靠着自己的思考实现自己应有的价值，思维的宽度决定了人的高度，思维的深度决定了人的价值。活着，本身就体现了一种非凡的价值。基于这个信念，我觉得有必要坦诚地面对现实，做好自己，别人的永远不会是自己的，但是世界是属于每个人的，不要忘却拼搏，终有一天会得到应有的回报。</p><p>这一年，从生活上得到的，工作中学到的，自己充电了解到的，都或多或少懂得了一些东西，少了一些面对未来的恐惧，多了一些生活的切身感悟，不再感怀生活，隐隐约约感到了一种无形的压力，迫使我继续前进，管他前面什么玩意儿，只要知道自己在干什么就足够了。规划赶不上变化，这不叫规划，凡是有成就的人，无不例外的实现了自己的既定目标，按着规划一步一步地去实践了，最后得以收获。所以，像我这样的小罗罗，注定成就不了所谓的事业，至少目前的这种态度，因为现实生活告诉我，成功容不得半点借口，今天计划的事情拖到明天，请问时间会倒流吗？对照一下13年的计划（参见13年终总结《2013与2014之流水》），顿时感慨良多。</p><p>1，补2013的读书空白。</p><p>这个做了一些，但还是严重不足，零零散散涉足了七八本（PDF，包括在读的），接触了Python，MySQL，学习不够深入。</p><p>2，每天坚持听一下VOA，抽点时间学习一下英语；(这一点做得非常差，逢考必败的根源所在) </p><p>这个做的稀烂，死活坚持不下来，不是没有用，订阅的SQLServerCentral没有研读过，稍微看过几篇，东西确实不错，老外就是老外，干货多多。IT不学真不行，永远了解不了最新的东西，最实在的东西。</p><p>3， 计划一次旅行。</p><p>玩嘛，我想这个毫无疑问实现了，时间虽短，但也算是达到了预期的效果，开开眼界，找找年轻疯狂的感觉，我想应该知足了，有游记见证，但是还欠一篇拙作，关于看电影引发的个人思考。</p><p>4，深入SQL学习，做一个SQL学习系列，这也是14年部门分下的培训任务。 </p><p>这个系列没有做，多多少少学了一些，缺乏系统性，至于什么原因，我不想辩解，多说无益。部门人员异动，所谓的培训任务也就不了了之。</p><p>5，独立开发一到两个有价值的系统。 </p><p>初生牛犊不怕邪，尽管雄心勃勃的做了个小系统（博客为证），由于种种原因，还是没有最终使用。这也没干好，那也没有做成，我究竟干了些什么呢？ </p><p>1，同事四月辞职，当时对业务系统还是没有多少头绪，交接的时候很多事情还是模棱两可，两个人的事情突然让我一个新手来做，顿时感到惶惶不可终日，不能怠慢了各路”神仙“，否则吃不了兜着走。 经过一个月的挣扎，算是基本搞定，平稳过渡，工作从开始的畏手畏脚到现在有的放矢。这或许就是所谓的成长吧，要想彻底的深入掌握ERP，我想还远远不够格，技术需要的不多，其实真正高大上的东西未必能普及到企业中去，ERP关键在于对业务的梳理，流程的理解，随业务的变化而变化，认识—&gt;理解—&gt;掌握—&gt;优化，看起来极其容易，做起来却百般不易。在维护的过程中，我逐渐明白一个道理，呆呆地坐在电脑前是开发不了用户满意的软件的，只有现场勘查，调研，充分理解用户实在的需求，站在用户的角度去探究解决问题的模型，我想即使做不到优秀，至少可以让用户用得满意，用得舒心。切忌，空对空的进行需求交流，分析，这是达不到效果的，最终的结果只会陷入bug—&gt;modify—&gt;bug—&gt;modify的泥潭。</p><p>2，生活，其实这没什么好说的，平淡无奇，掀不起半点涟漪。中秋，看了下同学，顺道和亲人过个团圆节，国庆，游了下西湖，走访了一位对我非常有影响力的叔叔，可以这么说，从小学到初中，我从他身上学到了不少东西，跟我讲作业，陪我玩象棋，与我谈未来，每逢寒暑假，只要他在家，我几乎是没有离开过他，对我的生活起着潜移默化的作用。 有这样一位指引者，我是多么的幸运啊！成年了，我们再也不是小孩子了，正因为如此，我们开始忙碌起来，忘记与亲人联系，忘记与朋友聊天，老婆老公，房子车子等一系列话题开始渐入我们的生活，心随之浮躁起来，开始了一些功利化的行为，从此联系似乎带了一种色彩，不再单纯了。疏于亲人，远于儿时最好的玩伴，只要不要同一个城市，作为朋友遗忘的概率极大，新建一个圈子，开始一种新的生活。或许我是一个比较喜欢恋旧的人的缘故吧，总感觉这样不太好，但是又不知如何是好？歌词唱得好：结交了新朋友，别忘了老朋友。感情，是个神奇的东西，它能牵动一个人的每根神经，或远或近，总有一种思念，偶尔总会情不自禁地拿起手中的电话拨拨最熟悉的号码，如果有一天不再联系，我无法想象我的生活有多么凄凉，不会聊谈了，嘴笨了，也许号码就不知不觉地没了，生活与感情，随缘吧。整个年度中，基本保证每周跟外公一次通话，跟父母一次通话，其他亲朋好友随机打，每个月电话费不低于100元，有些人常年未通电话，并非代表我们之间缘分已尽。</p><p>3，关于学习，这点确实做得很糟糕，博客数数几篇，寥寥几语，没有含金量，怎么能这样么？Python学习了基本语法，MySQL写点增删改查，多多接触，多多益善，这是个大忌。贪多必失， 用不到，学得多，忘得快，这个经典教训，一定要要牢记。多做笔记，做做分享，向大牛看齐，选一个切入点深入进去，真正学会融会贯通，做好知识储备，经历了一年的摸索，该是清醒的时候了。</p><p>4，关于经济目标，14年的规划是一年搞定助学贷款，今年实际完成是50%，弥补了去年的负债，再者向家里还了一笔债务，回家过年备点，基本上一年微薄的薪水就OK了， 存钱是没戏了，毕业三年内，我没有希望能存多少，但愿没有虚度光阴，实际还是虚度了一年。</p><p>2014年就这么过去了，总之是离目标有很大差距，主要原因是自己自制力不够，计划过于完美，难以实现。展望2015，希望有一个不一样的收获，所以，规划还是要有的。基于自己贪婪的性格，有必要重新审视一下，计划规划不能是一纸空文。走过的路，见过的人，做过的事，尽量留留痕迹，免得回头追问时间又去哪儿了？延续大四后期的坏习惯，看了大量的战争片，2015年再也不能这样了，否则真的玩完了。</p><p>谨记于此，以警示自己，误入歧途不能自拔，2015年应该没有什么大风浪，没有什么大动作，平平静静，充实365天，多多努力才是王道。</p><p>by zhangbc<br>2014-12-30</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;晃晃悠悠又是一年时，该到了总结与反思的时候了。想想当初的豪情壮志，如今却被时间磨平了，淡化了，可笑？可恨？可惜？可怜？这一年，不知道用什么言语表达，用什么词汇来描绘，单单是工作那么简单，抑或生活的平淡无奇，或许吧，生性贪婪而又好懒的我，真的不知道怎么总结这一年的得失？该是静
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（五）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_06/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_06/</id>
    <published>2019-04-22T14:28:05.000Z</published>
    <updated>2019-04-22T14:35:43.822Z</updated>
    
    <content type="html"><![CDATA[<p>上班已有几天了，可是思绪似乎还是停留在十一之行，也许是没有长大的表现，也许是该为这次的所见所闻记下点什么，一种发自内心的声音不停告诉自己，利用有限的时间，拿起一支拙劣的笔，为那个时刻，为已流失的光阴做一些补救脚印吧。此次杭州之行，收获还是蛮大的，且不说杭州风景，杭州美女，我只想说说杭州给我烙下的一个又一个印象。美丽杭州，说得一点也不过，或许在杭州，让我真真切切地感受到了中国梦的一步步逼近。当然，遇到的某些奇葩，我也就不提了，权且当他们小市民无知吧。</p><p>十一，我们花了一整天的时间，沿着西湖的河堤走了很长很长的一段路，西湖如西子，杭州佳人多，风景确实很美，感受在心灵，风景的描述及其感受，恕难从笔，我不擅长优美的散文故事。此篇所探讨的是国庆遇到的一系列的故事。早上，八点出发，坐7路公交，人多拥挤，这是每个城市的最大亮点。提到公交，我不得不感叹下武汉的公交，车猛，两车之间几乎可以保持零距离，人更猛，即使夹在门缝也不愿意下车，真正是做到了“敢为人先”的大无畏精神。相对于武汉，杭州公交略显宽松一点，我们在来回西湖的路上还能找个座位坐坐，恐怕这个待遇在武汉难得，至少我的印象很少，尤其在火车站赶坐公交，或者校门口坐公交，基本都是一路站到底。这或许就是城市生活，几许烦恼几多喜吧。这次出行，让我彻底感到无语的公交是在湖州长兴县城，一下子让我回到了高中时代的县城公交，破就不多说了，可恨的是25分钟一趟，沿途不报站，招手即停，更让你意想不到的是终点站还是高铁站。高铁都有了，还没钱改善一下公交么？从高铁站下来，遇上这样的公交，让我产生无限联想，县城企业无数，高大上的政府大楼（据说30亿建成），我还能说些什么呢？遇到这样的县城，只能是为该城百姓哀其不幸了。想想我们那个穷乡僻壤的小县城，这点还算是好的，年年在改善中，变化中……总体来说，杭州的公交还算不是太拥挤，或许我们赶上最疯狂的那一路吧，暂且留个好印象。</p><p>十一晚上，由于一切临时决定，算是做到了随心所欲，疯到了极点，到处招手打的，各路的士哥都把我们给拒绝了，原因是我们离我们所去之处比较近，不愿意送我们，还好心跟我们顺便指了一下方向。我们靠着导航瞎摸也不是个事儿，最后还是让两辆超破的摩的小坑了一把，以每人10元送我们去电影院，也在这里遇到了奇葩，姑且让我作个怪吧，建议出行尽量少做摩的，每个地方的摩的都不是省油的灯。十一点打的，由于是第一次，怕踩大坑，问了是打表还是一口价，说是打表，那没得说了，毕竟我们三个人都是第一次来这里，随便吧，反正我是抱着被坑的心态上车的，再说时候也不早了，离订房处还有一段相当的路程。为什么我是这种心态？说实在的，我对这些司机的故事早有耳闻，打表绕着走，一口价近道飞奔。四年前，在深圳，就这么深深地被坑了一次。上车和司机寒暄了几句，感觉司机人还算靠谱，下车20元，不算坑，毕竟快凌晨了，在某些地方，我想司机肯定会狠狠宰我们一次，毕竟一看我们就是外来主儿。相比摩的，我心里舒坦多了。接下来的三次的士都是这个价，路程不算太近，想到回家过年问起的士价格，真的感觉自己就是一个外乡人，被宰的主儿。从与司机的寒暄中，感受到了杭州人的生存压力，浙江富有，温州老板遍布神州大地，“5~6万的房价楼盘一天被抢空”，这话不管是不是含水分，含多少水分，但是能让我真正感受到杭州的生活成本不会太低，建筑极具特色。城市公共设施建设比较好，电影院随处可见，第一天费劲地找了两三家，第二天顺眼目睹了两三家。有住的就有吃的，有吃的就有乐的，有乐的就有游的，这或许就是杭州给我的一个印象吧。还有一点收获，是在钱塘江边上无意的收获，那就是漂流书屋，公共书屋，城市中能看到长廊边有这样的书亭设施，恐怕不多见，可以默默地感受一下杭州的城市文化建设。很多时候，谈及文化建设都感觉是知识分子的事情，老百姓能温饱就不错了。其实生活离不开文化，与人交流，感受生活，文化无处不在，与大师交流，心里豁然开明，与同龄人畅谈生，人生向往无限，与父辈交心，真真实实感受生活的酸甜苦辣，作为新一代的穷屌丝，文化不应该成为高大上的东西，我觉得有必要丰富一下自己的文化美餐，应该让文化实实在在地融入我们的日常生活，生活有向往，有期待，才有源源不断的奋斗的动力。但是杭州书亭美中不足的是，有书屋，书很陈旧，很少有人去翻阅，我随手翻看了一本书叫《麻雀》，屠格列夫著，这是当年小学四年级的一篇课文，讲述了一篇关于母爱的故事，印象非常深。记得当时读不懂，老师从教案中跟我们朗读课文中省去的那一部分时，我们更是一股脑的傻了。母爱，是一个伟大的话题，我很庆幸，我有一位勤恳和善仁慈，任劳任怨的母亲，只是感觉亏欠她太多太多……再次，翻开这篇课文，想到昨日的电影，心情顿时沉重了不少。</p><p>本次国庆之行，算是毕业后比较满意的一次旅行，杭州，长兴，两个不同的城市，两种不同的心境，收获却不是二的。浮浮躁躁的心，不知道又丢失了多少瞬间的灵感，不巧赶上工作的繁忙季，又不想丢失这些美好的记忆，所以还是记下来吧。写着写着，不曾想成了一篇回忆之作。</p><p>by zhangbc<br>2014-10-09</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上班已有几天了，可是思绪似乎还是停留在十一之行，也许是没有长大的表现，也许是该为这次的所见所闻记下点什么，一种发自内心的声音不停告诉自己，利用有限的时间，拿起一支拙劣的笔，为那个时刻，为已流失的光阴做一些补救脚印吧。此次杭州之行，收获还是蛮大的，且不说杭州风景，杭州美女，我
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（四）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_05/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_05/</id>
    <published>2019-04-22T14:06:46.000Z</published>
    <updated>2019-04-22T14:36:41.331Z</updated>
    
    <content type="html"><![CDATA[<p>水光潋滟晴方好，山色空蒙雨亦奇。<br>欲把西湖比西子，浓妆淡抹总相宜。<br>    ———-苏轼.《饮湖上初晴后雨》</p><p>一次疯狂的旅行，一次没有规划的旅行，一群不靠谱的靠谱的旅行， 除此之外，我实在是找不到什么适合的言语来表达这次国庆之行了。岁月总是在不经意的手指尖划过，用心去捕捉生活一瞬间的美，认认真真地感受其中的乐趣，我想这才是我所期盼的生活吧。写作的灵感也就来源于那一刹那之间，仔细回想学生时代，每当写作文的时候，真的就是这么一回事，其实生活亦如此，此次的国庆之行更是如此。</p><p>关于国庆之行的最初构想，是由大学班长何伟同志提出的，我只是从旁提提意见，准备十一回武汉聚聚，然后找个景点游哉悠哉。毕业一年了，大家是该聚聚的时候了，说长不长的一年，相信大家经历了很多，也收获了很多，相互叨叨，未必没人不期待吧。为此还特地，班长建了一个群，叫“十一去哪儿”，刚开始那会，激情四起，我心中甚喜，提前了一个月跟部门老大说十一想请假（要知道节前假后请个假有多么困难）。临近九月中旬，再次确定人数的时候，发现就不是原来那么回事了，各有各的忙，离别时难聚更难，相聚是多么不容易啊！没有闲人，既然如此，不必强求，也无须介怀，匆匆之间的生活，理解万岁。说实在话，我的内心依然不甘，计划的十一出行难道真的就要被不能班聚而葬送吗？思来想去，还是不甘心，十一不出行又能干嘛呢？他们都忙， 我闲人一个，那就一个人漂泊了，避远就近，人在苏州，苏杭苏杭，那就杭州了。所以一个人就默默地买好票了。原本不想打扰别人已有的安排，这实在不是我的风格，不强求于人，一切随心所愿的好。可我还是没有忍住，问了下何伟，令我意想不到的是他已经买好回家票了，三言两语，他也改签了去往杭州的高铁票，谁叫我们是好哥们呢？算是坑，也愿跳。9月13日，杭州的票就这么定了，最坏的打算是两个爷们独闯杭州，不为别的，只为西湖。期间，我们也各自咨询了很多亲们，问有没有意向去？回复都是模棱两可的，一句话，不靠谱。不靠谱就不靠谱吧，希望与现实总是存在差距的，那就算一次不靠谱的旅行吧。但是我依然没有放弃寻求伙伴的机会，直到9月27日，一条好友的说说振奋了我，平时少聊天，这次竟然答应得如此爽快，让我惊喜让我意外，此次旅行总算不是纯爷们的队伍了，振奋人心啊！杭州附近的城市，费费劲还是搞到了30日的火车票，算是尘埃落定了。</p><p>30日下午，三人分别从不同的三个城市（无锡，杭州，马鞍山）出发，经历火车时间也差不多（5H），就这么开始这次疯子旅行。说是一群疯子，其实也不过，列几个事实，疯不疯，看着说吧：</p><p>一，30日晚上相聚约九点，找个餐馆就餐，边吃边聊，彼此熟悉熟悉，然后开始找房子。都说人多不好找，我们也确实找了一阵子，十点多找到了。</p><p>二，第二天八点出发，临时看公交，上车，游西湖，随身没有一张地图，只是问了一下团价，觉得太贵，没报，索性两腿跑西湖，一天下来，跑的地点有：三潭印月，博物馆，雷峰塔（人多，没有买门票），钱王祠，苏堤（2.8公里，没走完），花巷观鱼，曲院风荷。小有遗憾，六点多出大门未见音乐喷泉。西湖之景，美不胜收，知足就行，开心便罢。开始寻找吃饭的地方，疯疯癫癫地走了不少路，耗时不少，总算找到一家快餐自助餐厅了。</p><p>三，原想着，吃罢饭，该找住的地方，十一游客特多，房子有限，没想到<em>*</em>来了一句，我们去看电影吧。快八点了，我们连电影院都不知道在哪儿，两部手机开始疯狂地搜索，好不容易找到号称浙江省最大的电影院——胜利剧院，话说今天没票了。不达目的决不罢休。又一次次探索，功夫不有心人，错过了《黄金时代》，迎来了《亲爱的》，九点25分准时上演了。</p><p>四，看完电影，十一点二十分了。我们还能找到住宿吗？我们真的要睡大街吗？我们真的要夜行杭州城吗？真的，这点着实让人担心，又是两部手机的开始漫无目标地搜寻，电话咨询，我的电话下午就关机了，电源准备不足（出行的亲们，引以为戒）。时至凌晨，我们找到价格不高不低的房子，说实在的，个人感觉杭州的租房价格有点奇葩，单间竟然和标准间一个价，或许我孤陋寡闻了吧。</p><p>五，第二天一觉睡到八九点，去了钱塘江，真不是时候，空荡荡的。然后，我们又开始找吃的，不能白来杭州，游的（西湖），乐的（亲爱的），就剩吃喝了。 找了一家比较远的自助餐人均价69元/人，对于我们这几个穷屌丝而言还是可以接受的。下午五点陆续离开杭州，杭州，我们不虚此行。</p><p>一篇流水记，即将尾声。写的总是没有亲身经历的来得实在，来得刺激，来得更有价值。许多事情看起来就那么回事，实际上做起来还真不是那么回事，其中的付出，艰辛与快乐并存，恐怕只有当事人才能真真切切地感受了。用朋友的一句话，那就是——一切尽在不言之中。十一行，算是圆满了，完成了我2014年的旅游计划，聚聚聊聊的目的也算达到了，在此特别感谢二位至亲的鼎力相助，我们共同实现了”西湖梦”。这一次疯子旅行，不靠谱的旅行，给我的收获远不止这些，疯疯狂狂的旅行，简简单单的生活，实实在在的人生，何忧之有？</p><p>最后，来一张具有纪念意义而且大家都见过的小照，以此证明我们的西湖之行：</p><p><img src="/images/myself_04_20190422.jpeg" alt="三潭映月"></p><p>by zhangbc<br>2014-10-06</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;水光潋滟晴方好，山色空蒙雨亦奇。&lt;br&gt;欲把西湖比西子，浓妆淡抹总相宜。&lt;br&gt;    ———-苏轼.《饮湖上初晴后雨》&lt;/p&gt;
&lt;p&gt;一次疯狂的旅行，一次没有规划的旅行，一群不靠谱的靠谱的旅行， 除此之外，我实在是找不到什么适合的言语来表达这次国庆之行了。岁月总是在不经意
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（三）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_04/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_04/</id>
    <published>2019-04-22T14:02:55.000Z</published>
    <updated>2019-04-22T14:06:07.377Z</updated>
    
    <content type="html"><![CDATA[<p>”露从今夜白，月是故乡明。“</p><p>不知道多少个中秋没有和家人在一起过了，大概是童年的记忆了，也渐渐淡忘了这个团圆佳节，不过，或者一个人默默地过。每到中秋，端午，七夕这样的传统佳节，我都会不停地在打电话，或许只有这样才能弥补我思念的空缺，这也许就是我的生活，注定在寂寞中努力寻找属于自己的一丝丝慰藉，成为我平凡人生中一段看似不平凡的征程罢了。</p><p>毕业一年有余，每天除了工作之外几乎没有什么业余生活，偶尔心中不免有些内疚，生活为什么不能洒脱一些，主动一些，在物欲横流的今天，难道没有钱真的就得被逼上绝路吗？或许性格原因，或许五体不勤的缘故，我总是找不出一条合适的理由说服自己，活个范儿，管别人爱说咋说呢！ 在学校感受不到假期有多长，有多宝贵，所以大多数时间都是无为地被挥霍了，上班了，才渐渐明白，假期是多么地来之不易，春节从一个月或者更长一下子缩短到一周，尤其对一个回乡途中要耗上两天的漂泊浪子来说，其中的感受无以言表。又是一年中秋时，公司放假三天，所以我想不能再挥霍了，临时决定出去走走，向来没有长远计划，说干就干的劲儿还是有的，也许是上天可怜无规划之人吧，每次都能成事。去年十一回校探友也是9月28、29日临时买的票，一次简单的旅行，还是达到了预期的目的。要走的想法有了，可是接下来还是得仔细考虑考虑，去哪儿和谁做什么等等。仅仅一个想法还是不行的，周全规划一下，方使行动成功，所以一个想法只能算是一个成功的萌芽，并不是开始。三天，不可能走得太远，苏州附近的亲朋好友屈指可数，所以很快锁定了目标，探望一下朋友，随便找个地方玩玩，想法简简单单，仅此而已，人生亦应如此。</p><p>中秋三日假，总的来说，还是蛮愉快的。逛了一个景点——昆山周庄，看到古朴的建筑，虽然人少，缺少点氛围，但是总体印象还是不错的，七点回到朋友的住处，临时买菜做饭，两个人的饭菜不一会儿就上桌了，吃着香喷喷的饭菜，仿佛找到了一种久违的感觉。生活就应该这样的，自己动手，丰衣足食，不久的将来有一个新家，开始这样的生活，想想就是一种无比的期待。人的一生终究图个什么，我不知道，但是我应该很清楚地意识到，把握每一个稍纵即逝的幸福时刻，等到踏上黄泉路那一天能够微笑地离开，这或许就是我所理解的人生吧。买菜做饭，虽是一件普通的不能在普通的事，但在这个特殊的时刻，让我陷入了一次思考：生活不就是柴米油盐酱醋吗？为什么很多时候我们无法看清楚它的真面目，不会过日子呢？算一个小账，一顿饭，外面买一顿至少得15元吧，（炒饭另外）两顿就是30元，都说菜价米价上涨，其实去市场走一遭，30元买两顿的饭菜那是绰绰有余的，份量绝对够足，不像外面炒个肉丝，只见青椒不见肉块，其次如果手艺好点，味道也不差，吃着自己做的，心里本来就是美滋滋的。精打细算，学会过日子，否则就是有金山银山也是经不起折腾的。现在生活富裕了，我们的节约意识的确淡薄了不少，想不到这些生活的琐碎，每天只会不停地想，我的工资什么时候涨？或是我的工资都去哪儿了？想起读书那会，尤其是大一的时候，自己拿着一个小本子记录着自己的每一笔开销，小到一个笔记本，牙刷的钱，隔了一个月回头看看清晰的账目，多半会是露出满意的笑脸，俗语说得好，“用钱要用在刀口子”。并不是说要无限制地节约节省，记下来是为了让自己知道钱都花到哪儿去了，不至于花钱花得稀里糊涂，道不出所以然来。一直以来，我好像真没有吝啬过花钱，但是我比较清楚自己的钱都去哪儿了，管理自己的账目应该还算清楚吧。</p><p>完了一天，吃罢饭，九点有余，临时找住处，一切还算顺利，第二天一觉睡到十点半，天热没有安排出行，又做了一顿美食。中午就从朋友住处离开了，转战下一个目标。又是一个临时电话搞定一个新行程——去看看舅舅表哥一家人，打工在外，实属不易。从昆山转战苏北，车多行程非常顺利，虽然天气很热，但还是挡不住我心中的热火，想着第二天就是中秋佳节，应该去走走。去年就想着要去看看他们的，一直不想走动，所以未能如心所愿。和一大家子亲人过个中秋，也算是团圆了，看到舅舅舅母脸上的笑容，夹着额头一丝丝皱纹，顿感心中某种不快，上一辈为我们操劳得太多了，而我们呢？偶尔连他们一个小小的心愿都未能满足，这或许所谓的生活之苦吧，再一次让我深深体会带到：经济基础决定上层建筑，有什么样的工作就有什么样的生活。生活充满了太多的无奈，每一个人的境遇所有不同，但是生活的使命却是一致的，照顾上辈，操劳下辈。中华名族的传统美德，牵扯了太多太多的故事……今年的中秋，才让我知道了中秋的滋味，都说好散好聚，我不得不说散得容易，聚之不易。一个牵动无数家庭心的中秋，总是几多欢笑几多愁，看到的是笑脸，诉不出的却是悲愁，你又何谈一个“佳”字？中秋佳节倍思亲，十五的月亮十六圆，希望终有一天，我心中的月亮也能圆，生活虽不易，但是脚下的路还得继续，一条漫漫无尽头的路，路上有亲朋好友的陪伴，不曾寂寞，不曾落单，希望能加快步伐，不负青春，带着微笑向前去。中秋，往常一个人过，电话多多，今年也不另外，但和亲人相聚，私有时间自然有所减少，未能尽可能多的问候，或许这样的日子以后还会越来越多，各位至亲，理解万岁，不曾问候，思念依旧，没有前世的缘分，哪有现在的你们，又怎么会有今生我的福分？</p><p>中秋过去已久，很久没有提笔，不知所云，以纪念今年不一样的中秋，以上次说说作结，算是给自己一个交代，“莫等闲，白了少年头，空悲切。”生活与责任，人生与使命，记住生活的美，才有源源不断的动力！ 记住以下五点，也不枉过一个美好的中秋：<br>一，旅行是人生的必修课，规划很重要，随机应变往往决定了一件事能成与否;<br>二，可口的饭菜是自己做的，靠山靠水不靠天，学会过日子，生活无处不精彩；<br>三，经济基础决定上层建筑，有什么样的工作就有什么样的生活；<br>四，身在他乡，和亲人过一个节，这才是家的感觉。<br>五，节日的问候，时光渐变，我有可能慢慢疏忽这一点，各位至亲见谅。</p><p>by zhangbc<br>2014-09-15</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;”露从今夜白，月是故乡明。“&lt;/p&gt;
&lt;p&gt;不知道多少个中秋没有和家人在一起过了，大概是童年的记忆了，也渐渐淡忘了这个团圆佳节，不过，或者一个人默默地过。每到中秋，端午，七夕这样的传统佳节，我都会不停地在打电话，或许只有这样才能弥补我思念的空缺，这也许就是我的生活，注定在寂
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（二）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_03/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_03/</id>
    <published>2019-04-22T13:54:02.000Z</published>
    <updated>2019-04-22T13:58:58.303Z</updated>
    
    <content type="html"><![CDATA[<p>大学以来几乎没有碰过什么文学著作，心里想法太多，不能成为现实，这或许就是痴人说梦吧。梦，哦，对了，这是2013年整年最火的一个词儿，习总书记登台，让国人看到了希望，看到了一个中国梦，随着个人梦，青春梦，民族梦……应运而生。我也经常在追问自己：自己到底有没有一个梦，有没有一个明确的方向，该往何处去？</p><p>记得刚毕业那会，找工作犹豫过，想做开发，能力明显不足，懂点语言的皮毛，偶尔也会在朋友们中间调侃几句；有人建议做实施，深入实践，懂得用户真正需要的东西，然后转做开发，由于种种原因，未能实现，后来转战到今天的这家不大的公司做运维（并非真正意义上的运维，算是简单的技术支持吧），很幸运，得到了同学的帮助，领导的赏识，慢慢成熟起来。叔叔曾问我：在公司感觉怎么样？我跟他详聊了一些情况，他说，还是要多学习，对一个行业的前景估量很重要，如果不是自己想要的，就得早作打算。很清楚地记得，他跟我说起过他一个关于对行业的前景估量的故事，坚持自己的正确选择，坚定不移的走下去。不知道为什么，时至今日，我都无法看到一个清晰的方向，IT，一个令人向往而又难以令人琢磨的东西，让人几分陶醉，也让人几分忧伤，陶醉的是自己可以在其中发现自己的兴趣，为她彻夜狂欢也不是不可能，新技术层层不穷，激发我们的求知欲，可以借以免去我们的生活烦忧；忧伤的是担心自己看不清方向，一股头脑热，摘了芝麻丢了西瓜，学不到真正的东西。技术是有助于人的，偶尔也会害了人。看到很多人对IT丧失了信心，开发的转测试，测试的转销售，IT的技术更新，IT人的不断更替，真的让我很难预料以后的道路如何？</p><p>在这个部门，不到一年的时间里，我目睹了几拨人马，匆匆而来又匆匆而去，说句实话，心里不知道什么滋味，或许这就是IT界的一个缩影吧。跳槽，年轻人的专利，也是年轻的资本，出来拼的，图的不是稳定，而是快乐与生活的充实。如果我想图一份安逸的生活，我去年毕业就有可能呆在乡镇医院信息科，而且专业也对口，但是我没有，我不想这样的生活，至少不是我前半生想要的生活，给得了我安逸，却给不了我心灵的满足。根据自身的处境，身上的责任，我现在还不敢轻言跳槽，或许我资本不够，来之前，我就想过，我是来学习的，学不到东西，积累不到资本，我去何处都一样。记得有一次和朋友讨论过这个话题，跳槽，跳来跳去，手上没有筹码，在哪儿都一样。我认真思考过，我还是一个新手，什么都不会的新手，加强学习是我的第一要务。再说了，毕业前三年，我有两件事情要做：一，还贷，二，为未完成的梦做最后一搏。没有特殊情况，我是不会轻易的去改变的，即使我愿意付出更多的时间，我会为自己的想法付出行动，无论多么高的代价。这个五月应该是对我有着特殊意义的，感谢猴哥，让我搞掉了第一笔，作为低薪一族，我不觉得钱对我有多么重要，我对它从来不报任何希望，只要生活是自己想要的，没钱日子照样过。现在的生活虽不是很好，但足以让初生牛犊的我好好磨练磨练，值得熬一熬，抹掉我最初的梦想，也许会唤醒我另一个梦。</p><p>在中国梦大浪潮之下，追寻一个真实的自己，需要克服种种阻扰，来自心里的，来自家庭的，来自社会的，如果在乎多了，也就茫然了，不应该不尊重自己心中的想法，一个人如果没有强烈的金钱欲望，我想总会有平静的时刻。静心想想，我是否追随了中国梦而滋生了自己的个人梦，是否付出了行动？做一个会思考的人，在探索中前进，我想终有一天会过上属于自己想要的生活。 </p><p>by zhangbc<br>2014-05-17</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大学以来几乎没有碰过什么文学著作，心里想法太多，不能成为现实，这或许就是痴人说梦吧。梦，哦，对了，这是2013年整年最火的一个词儿，习总书记登台，让国人看到了希望，看到了一个中国梦，随着个人梦，青春梦，民族梦……应运而生。我也经常在追问自己：自己到底有没有一个梦，有没有一个
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】贫困，不能阻碍你的梦</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_02/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_02/</id>
    <published>2019-04-22T13:36:27.000Z</published>
    <updated>2019-04-22T13:58:38.745Z</updated>
    
    <content type="html"><![CDATA[<p>在考研期间，遇到了几个比我低一届的同学存在的困惑，本想尽早写下这篇日志作为答复，由于考研，所以一直耽搁到了现在，现在想结合自己一路走过来的经历谈谈我个人的一些想法，由于涉及家庭因素，所以只能特殊处理。如果是本人看到的，请原谅我的直述，希望不要介怀。</p><p>一个土生土长的农村娃子，经历了太多太多的遭遇，时常会为没钱的日子发愁，是的，我不可否认，农村送出一个大学生的确不容易，本来经济来源相当有限，吃了这顿还得打算下顿。 清苦，节俭，朴素等这些耳熟能详的词语似乎一个一个不但扎根于我们的脑海中，而且我们也是这么走过来的。看看家庭经济比较宽裕的同伴的生活，我们曾经羡慕过，嫉妒过，也抱怨过上天的不公正待遇……因为贫困，眼见了一个个伙伴辍学，很早就迈入了残酷的现实的社会大门；因为贫困，无数父母背井离乡，过着听人使唤的卖苦力的生活，作为子女，当然不希望父母这样，于是一些“懂事”的孩子于心不忍，即使认为自己有能力的也过早地放弃了读书梦。在一次交流中，一位学弟告诉我，他想考研，但又不想读研，顾虑重重，我问其原因。他说主要是家里供不起。还有一位学弟告诉我，他为考研与否一直在纠结，因为家中有个弟弟在读书，家庭超负。这两位哥们其实面对的是同一个经济问题，在经济问题后面应该还有一个更重要的思想问题。烦不烦，很多时候不是取决问题的本身，而是看一个人会不会去思索，能不能去积极主动地面对现实，一味地抱怨只会让你更烦更纠结。</p><p>想考研，是为以后生活得更好，这无可厚非，大学生嘛，想实现自己的人生价值，有点野心未必不是好事；想考研，是为赚大钱，拿高薪，这是一种普众心理行为，在现行的社会制度下，晋级，职称无不与学历挂钩，每个人的职业生活压力都很大，也是完全可以理解的；想考研，是想做一项研究，追随自己的兴趣与爱好，立志于科研事业，这应该是考研的最高境界。单单是为赚钱而考研，我不太赞同，一，很多高薪职位并非需要很高的学历；二，考研应该是一笔物力，财力的巨大投资，是一笔青春代价的付出，而且这种投资与付出未必会收到你所期待的结果。如果你把考研的目的这个首要而且又具有决定性的问题想清楚了，那么对你后期的复习会有更大促进作用。考研，应该说一笔风险投资。你想以后要干什么？报什么专业？考什么档次的学校？这三个问题非常重要，关系着你的复习成效。报考的学校档次应该与投资的风险系数是呈正相关的。现在的研究生经费虽然非常高，但是各种补助也是相当丰厚的。关于经费，我想说的是，这不是重点，只要你足够优秀，上帝会偏袒你的，关键是你努力如何，有几分胜算？现在国家教育投资年年在增加，投资范围逐步扩大，你就认定自己有那么差吗？绿色通道，助学贷款，各种社会资助，就在你身边，就看你主不主动。想到四年的我，曾经也为此发愁过，选学校选专业时，优先挑选较便宜的。就在我感到无助的时候，一个从天而降的好消息来了，我们县城第一次提供生源地助学贷款，这对一个需要帮助的家庭来说，不能不说是雪中送炭啊！来到县教委办理手续时，又得到了一笔助学金，而后在大学里，在同学们的帮助与信任之下，得到了四年的高额助学金。四年的大学，你都走过来了，你还怕什么？又担心什么？你是贫困生，应该享受到了一定的资助，平时省吃节用一点点，有什么困难不能克服呢？     0</p><p>贫困，不能阻碍我们的梦。鲤鱼跳龙门，农村出来的人都应该铭记这句话，这应该是我们读书初衷吧。如果我们不去尝试，怎么可能走出山旮旯？大山窝虽美，虽山清水秀，仁和心善，可是在经济与信息技术高速发展的今天，我们的经济从哪里来？难道还要死守农村自家的一亩三分地过日子吗？为了理想的生活，我们只有一条出路，那就是排除杂念，能走多久走多远，走得越远越好。起点高，不但可以改变生活，创造机会，更重要的是可以实现自己的人生价值。我们从农村走来，应该克服农村人比较狭隘的眼光，但不能说是轻视农民，不是他们无能，而是条件受限，应该用发展的、智慧的眼光正视我们的处境，没有优越感那就得靠自己的十二分努力去打拼、去创造，为不辜负乡亲们对我们的殷殷期望，必须拼。吃点苦算什么，我们又不是没有干过农活，比起插秧收割等田地间的耕作，我们要说有多幸福就有多幸福，不是吗？</p><p>贫困，不是我们的错，不能阻碍我们的梦。贫困，这是个可以改变的事实，真心希望有经济困惑的后生们，不要顾虑太多，用你们的青春做资本去追梦吧！ </p><p>by zhangbc<br>2013-01-08</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在考研期间，遇到了几个比我低一届的同学存在的困惑，本想尽早写下这篇日志作为答复，由于考研，所以一直耽搁到了现在，现在想结合自己一路走过来的经历谈谈我个人的一些想法，由于涉及家庭因素，所以只能特殊处理。如果是本人看到的，请原谅我的直述，希望不要介怀。&lt;/p&gt;
&lt;p&gt;一个土生土
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】面对现实，做好自己（一）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_01/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_01/</id>
    <published>2019-04-22T13:23:38.000Z</published>
    <updated>2019-04-22T13:33:08.677Z</updated>
    
    <content type="html"><![CDATA[<p>毕业这么长时间，没有写下一则像样的日记，没有关注VOA的动态，没有规划学习，每天除了工作，简单不断重复的工作，余下的时间在双手之间悄悄溜走，从不觉得心痛，从不觉得自己有多么厚颜，感觉自己被某一种可怕的东西不断迁就着，不回头，也不想回头，偶尔还有一种可恶的念头：人活着，怎么活都是一辈子，干嘛非得拼命似的生活？勤一生，堕一生，两者之间无非就是别人的闲言碎语而已。当一个像我这样拥有此种邪恶念头的人，大概真的忘记了什么是厚颜无耻了？是的，人活着，这一生究竟为了什么，这是一个大话题，不是凭头论足就能下结论的，需要亲身实践，正所谓“纸上得来终觉浅，绝知此事要躬行”嘛。一介草民，无能把此话题说破抑或道明，但是真的有时候得想想，否则只会让自己越陷越深，越走越迷茫。</p><p>2013年7月踏出生活四年的大学校门，这次有着非凡的意义。母校，一个平时看不起眼的名称，在那一段时间，一些特定的场合，却总是让我的心在隐隐作痛。小学，初中，高中，大学，经历了这么多次，此次感受最深。这次，离开了母校或许就永远没有下一个母校了，离开虽不是生死离别，但却摆脱不了一种欲言又止的忧伤，轻轻而来，却又悄悄而去，何况还要拜别恩师，道别老乡，送别同窗，这一别就再也找到重逢的那一天了。我的确不知道重逢的那一天去哪儿了？</p><p>这一次走出校门，意味着开始肩负起一份独立的使命，独立生活，独立经济，独立承担责任，来自家庭，事业，还有不远的未来。不远的未来，追逐爱情，抚育下一代，赡养父母……这不是归宿，仅仅是预设的开始，不是来与不来的问题，而是一个时间问题，为了这份使命，你准备了些什么呢？面对毕业，面对当下，我有点开始hold不住了，2013年毕业生699万，毕业不是就业，所以为了生计，解决就业难题才是关键，就业不成，何谈使命，连最起码的经济独立都做不到，还有什么资格空谈人生？一日三顿饱，这是最起码的生活保障。说实在的，当时有很多人为我的就业问题着急了，包括我的父母，我的亲属，我的朋友，我的恩师，社会很现实，将才干才多了去，不缺一个有生理缺陷的残疾人，我最终还是以平常之心坦然面对，走过了，也就习惯了，没有遗憾，没有怨言，从多次面试的经历来看，还是自己的所学甚少，残疾的头衔影响不是很大，毕竟社会还是有一定良知的，相信社会是美好的，你的心才会豁然开朗起来。在此处，也奉劝一些即将就业的后生们，人这一生，自信最重要，实力须有社会实践检测，找准方向，不可人云亦云尔。</p><p>毕业后，虽有一些小波折，但是不算太大，最终还是在苏州落定尘埃，高薪谈不上，至少自保了，也算是实现了经济上的基本独立。“上有天堂，下有苏杭”，说实在的，对我一个宅男而言，没有什么特别的感触，苏州的气候的确宜居，其实我所在的是苏州的一个小小的角落，距离苏州城区还有一定的距离。 毕业工作之余，偶尔回头想想自己的最初打算，顿时觉得有些不可思议，几乎没有办法实现，毕业了，如前所述，来自家庭的压力随之剧增，各种想法铺天盖地卷来，真的，有时候觉得无力从心，但又不得不为。对自己失言了，只能姑且一次次原谅而不了了之。一年内搞定助学贷款不是梦，可是预备的考研梦不得不破之，俗话说得好：鱼与熊掌不可兼得。一个人，不能把美事都想尽了，有得必有失，尊重现实，这才是生存的法则。不过不排除大牛们，若觉这是谬言，就权当过眼烟云。</p><p>2013年过去了很久，却又历历在目，经历了一些比较特殊的事情，真正从梦中把我拉回了现实，脚踏实地才是王道。毕业就业，工作是什么？我始终认为工作不应该成为一种累赘，即使一种累赘，无法改变之时，我们不妨换一种态度去坦然面对之。把痛苦变成一种乐趣，聊以自慰也未尝不可。工作的心态直接影响你的生活态度，与其对着宝马哭，还不如对着自行车笑。宝马显示了你的富有与尊贵，但是他也让你失去了锻炼身体的机会，脚踏车虽卑微，但偶尔也足可以让你感受兜风的乐趣。家中建设，让我开始感受做为家庭的一员，应尽家庭之义务，即使你未婚，谁说未婚的你就可以对家事不闻不问？压力再大，该承担的不该承担都应倾其所能地去承担，再说了，一家之事，何来你不担当之理？亲人的离世，或许你会说这有什么可说的，是的，生死离别，人之常事嘛。可是，这一次很不同，我的表弟，英年早逝，白发人送黑发人，你见得多吗？我是第二次经历，第一次发生2006年的夏天，不足周岁的亲妹妹的离世，那年，我没法忘记，估计是忘不了的，什么是残酷，这就是残酷，不是天意，而是现实。去年，接到舅舅的电话，听到噩耗的瞬间，我愕然了。不敢相信但又不得不相信 ，人死不能复生，这一既定的事实，就是所谓的上帝（本人不信佛，勿怪）也难以挽回，而且根本无法挽回。一个23岁的小伙子，说没就没了，怎么敢叫人轻言相信？23岁，我们都在干什么啊？在读书，正值青春，正当规划人生并为之奋斗的黄金时刻，说在此处，我不得不为每年高校的命案感到震惊。懂得珍惜生命，或许是活着的我们对已逝的人的最好的敬意吧。逝者已矣，活着美好，且行且珍惜。</p><p>以此作文，深知不是写作的料，警示自己误入歧途，越陷越深。</p><p>by zhangbc<br>2014-04-15</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;毕业这么长时间，没有写下一则像样的日记，没有关注VOA的动态，没有规划学习，每天除了工作，简单不断重复的工作，余下的时间在双手之间悄悄溜走，从不觉得心痛，从不觉得自己有多么厚颜，感觉自己被某一种可怕的东西不断迁就着，不回头，也不想回头，偶尔还有一种可恶的念头：人活着，怎么活
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【数据库实践】T-SQL语言及其存储过程</title>
    <link href="https://zhangbc.github.io/2019/04/22/db_tsql_procedure/"/>
    <id>https://zhangbc.github.io/2019/04/22/db_tsql_procedure/</id>
    <published>2019-04-22T00:35:17.000Z</published>
    <updated>2019-04-22T11:37:46.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p><blockquote><p>课本第11～13章主要知识点</p></blockquote></blockquote><h2 id="一，T-SQL语言"><a href="#一，T-SQL语言" class="headerlink" title="一，T-SQL语言"></a>一，T-SQL语言</h2><p><code>T-SQL</code>语言是<code>Microsoft</code>公司在关系型数据库管理系统<code>SQL Server</code>中的<code>SQL-3</code>标准的实现，是<code>Microsoft</code>公司对结构化查询语言(<code>SQL</code>)的扩展。<code>T-SQL</code>语言是一种交互式的语言，具有功能强大，容易理解和掌握等特点。</p><p>1，<strong>数据定义语言(<code>DDL</code>)</strong>：<code>DDL</code>是指用于定义和管理数据库及数据库中各种对象的语句，包括<code>create</code>，<code>alter</code>，<code>drop</code>等。</p><ul><li><p>创建表的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure></li><li><p>增加列的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 列的描述</span><br></pre></td></tr></table></figure></li><li><p>删除列的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">column</span> 列名</span><br></pre></td></tr></table></figure></li><li><p>修改列定义为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">alter</span> <span class="keyword">column</span> 列名 列的描述</span><br></pre></td></tr></table></figure></li><li><p>删除表的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure></li></ul><p>2，<strong>数据操纵语言(<code>DML</code>)</strong>：<code>DML</code>是指用于查询，添加，修改和删除数据库中数据的语句，包括<code>select</code>，<code>insert</code>，<code>update</code>，<code>delete</code>等。</p><p>3，<strong>数据控制语言(<code>DCL</code>)</strong>：<code>DCL</code>是指用于设置或更改数据库用户或者角色权限的语句，包括<code>grant</code>，<code>revoke</code>，<code>deny</code>等。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给所有用户授予select权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> student <span class="keyword">to</span> <span class="keyword">public</span></span><br><span class="line"><span class="keyword">go</span> </span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 给指定用户授予特定权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span> <span class="keyword">on</span> student <span class="keyword">to</span> LiMing,ZhangBin</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 联级授权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">update</span> <span class="keyword">on</span> student <span class="keyword">to</span> <span class="keyword">user</span> <span class="keyword">with</span> [<span class="keyword">admin</span>] <span class="keyword">option</span>;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">from</span> ZhangWei;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> sc <span class="keyword">from</span> <span class="keyword">User</span>;</span><br><span class="line">deny <span class="keyword">select</span>, <span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span> <span class="keyword">on</span> student <span class="keyword">to</span> LiMing,ZhangBin;</span><br></pre></td></tr></table></figure><p>4，<strong>其他语言元素(<code>ALE</code>)</strong></p><p>1）<strong><code>注释</code></strong>：程序代码中不执行的文本字符串（也称<code>注解</code>），有：<code>--</code>和<code>/* */</code>。</p><p>2）<strong>变量(<code>@</code>)</strong>：局部变量（<code>@</code>），全局变量（<code>@@</code>）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">declare</span> @<span class="keyword">row</span> <span class="built_in">int</span> </span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">row</span>=(<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student)</span><br></pre></td></tr></table></figure><p>3）<strong>运算符</strong></p><blockquote><ul><li>算术运算符：<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>；</li><li>赋值运算符：<code>=</code>；</li><li>位运算符：<code>&amp;</code>，<code>|</code>，<code>^</code>；</li><li>比较运算符：也称关系运算符，用于比较两个表达式的大小或者是否相同，其比较结果是布尔值<code>TRUE</code>，<code>FALSE</code>，<code>UNKNOWN</code>；</li><li>逻辑运算符：<code>and</code>，<code>or</code>，<code>not</code>。优先级别：<code>not</code> &gt; <code>and</code> &gt; <code>or</code>；</li><li>字符串串联运算符：允许通过加号(<code>+</code>)进行字符串串联，这个加号称为<code>字符串串联运算符</code>。</li></ul></blockquote><p>4）<strong>函数</strong></p><p>在<code>T-SQL</code>语言中，<code>函数</code>用于执行一些特殊的运算以支持<code>SQL Server</code>的标准命令。</p><ul><li><p><code>行集函数</code>：在<code>T-SQL</code>语句中当成表引用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> openquery(<span class="keyword">local</span>, <span class="string">'select * from student;'</span>) ta;</span><br></pre></td></tr></table></figure></li><li><p><code>聚合函数</code>：用于对一组值进行计算并返回一个单一的值。除<code>count</code>之外，聚合函数忽略空值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_score,<span class="keyword">sum</span>(score) <span class="keyword">as</span> total_score <span class="keyword">from</span> sc;</span><br></pre></td></tr></table></figure></li><li><p><code>Ranking函数</code>：为查询结果数据集分区中的每行返回一个序列值。有：<code>rank</code>，<code>dense_rank</code>，<code>ntile</code>，<code>row_number</code>。</p></li><li><p><code>标量函数</code>：用于对传递给它的一个或多个参数值进行处理和计算，并返回一个单一的值。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">标量函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">配置函数</td><td style="text-align:left">返回当前的配置信息</td></tr><tr><td style="text-align:left">游标函数</td><td style="text-align:left">返回有关游标的信息</td></tr><tr><td style="text-align:left">日期和时间函数</td><td style="text-align:left">对日期和时间输入值进行处理</td></tr><tr><td style="text-align:left">数学函数</td><td style="text-align:left">对作为函数参数提供的输入值执行计算</td></tr><tr><td style="text-align:left">元数据函数</td><td style="text-align:left">返回有关数据库和数据库对象的信息</td></tr><tr><td style="text-align:left">安全函数</td><td style="text-align:left">返回有关用户和角色的信息</td></tr><tr><td style="text-align:left">字符串函数</td><td style="text-align:left">对字符串(char或者varchar)输入值执行操作</td></tr><tr><td style="text-align:left">系统函数</td><td style="text-align:left">执行操作并返回有关SQL Server中的值、对象和设置的信息</td></tr><tr><td style="text-align:left">系统统计函数</td><td style="text-align:left">返回系统的统计信息</td></tr><tr><td style="text-align:left">文本和图像函数</td><td style="text-align:left">对文本或者图像输入值或者列执行操作，返回有关这些值的信息</td></tr></tbody></table></div><p>5）<strong>流程控制语句</strong></p><ul><li><p><code>if-else</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">from</span> sc;</span><br><span class="line">if (<span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">from</span> sc) &lt; <span class="number">60</span></span><br><span class="line">print <span class="string">'很抱歉，你没有通过考试！'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">print <span class="string">'祝贺你，考试通过了！'</span></span><br></pre></td></tr></table></figure></li><li><p><code>begin-end</code>语句：能够将多个<code>T-SQL</code>语句组合成一个语句块，并将它们视为一个单元处理。</p></li><li><p><code>go</code>语句：批的结束语句。<code>批</code>是一起提交并作为一个组执行的若干<code>T-SQL</code>语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> @msg <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line"><span class="keyword">set</span> @msg=<span class="string">'Hello world!'</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure></li><li><p><code>case</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">select</span> <span class="string">'score'</span> = </span><br><span class="line"><span class="keyword">case</span></span><br><span class="line">   <span class="keyword">when</span> score <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="string">'没有成绩'</span></span><br><span class="line">   <span class="keyword">when</span> score &lt; <span class="number">60</span> <span class="keyword">then</span> <span class="string">'不及格'</span></span><br><span class="line">   <span class="keyword">when</span> score &lt; <span class="number">85</span> <span class="keyword">and</span> score &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'良好'</span></span><br><span class="line">   <span class="keyword">else</span> <span class="string">'优秀'</span> </span><br><span class="line"><span class="keyword">end</span>, </span><br><span class="line">  <span class="keyword">cast</span>(sno <span class="keyword">as</span> <span class="built_in">varchar</span>(<span class="number">20</span>)) <span class="keyword">as</span> sno </span><br><span class="line"><span class="keyword">from</span> sc <span class="keyword">where</span> cno = <span class="string">'C03'</span> <span class="keyword">order</span> <span class="keyword">by</span> score;</span><br></pre></td></tr></table></figure></li><li><p><code>while-continue-break</code>语句</p></li><li><p><code>goto</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goto label</span><br><span class="line">...</span><br><span class="line">label:</span><br></pre></td></tr></table></figure></li><li><p><code>waitfor</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waitfor [delay 'time'|time 'time']</span><br></pre></td></tr></table></figure></li><li><p><code>return</code>语句</p></li></ul><h2 id="二，存储过程"><a href="#二，存储过程" class="headerlink" title="二，存储过程"></a>二，存储过程</h2><p>1，<strong><code>存储过程</code>定义</strong>：几乎包含了所有的<code>T-SQL</code>语句，是为了完成特定功能而汇集在一起的一组<code>SQL</code>程序语句，经编译后存储在数据库中。</p><p>2，<strong>存储过程的调用方法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec proc 存储过程名</span><br><span class="line">exec proc 存储过程名  参数值[,参数值...]</span><br></pre></td></tr></table></figure><p>3，<strong>存储过程分类</strong></p><blockquote><p>i）系统存储过程（前缀为<code>SP_</code>）；<br>ii）扩展存储过程（前缀为<code>XP_</code>）；<br>iii）用户自定义存储过程。</p></blockquote><p>4，<strong>存储过程的创建和执行</strong></p><ul><li><p>创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dbo.pro_sc_insert</span><br><span class="line">@sno <span class="built_in">char</span>(<span class="number">10</span>),@cno <span class="built_in">char</span>(<span class="number">2</span>),@score <span class="built_in">real</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc(sno, cno, score) <span class="keyword">values</span>(@sno, @cno, @score)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure></li><li><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec pro_sc_insert '2010009', 'C1', 88</span><br></pre></td></tr></table></figure></li></ul><p>5，<strong>存储过程中的游标</strong></p><p>1）<code>游标</code>的定义：可以把游标看成一种数据类型，用于遍历结果集，相当于指针，或是数组中的下标，分为<code>局部游标(local)</code>和<code>全局游标(global)</code>。</p><p>2）游标的使用方法</p><ul><li><p>创建游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认为global；</span></span><br><span class="line"><span class="comment">-- forward_only(默认值)：游标只能前进的，只能从头到尾提取记录；</span></span><br><span class="line"><span class="comment">-- scoll：可以在行间来回跳转。</span></span><br><span class="line"><span class="keyword">declare</span> 游标名 <span class="keyword">cursor</span> [<span class="keyword">local</span>|<span class="keyword">global</span>] [forward_only|scoll]</span><br><span class="line"><span class="keyword">for</span> </span><br><span class="line"><span class="keyword">select</span> 查询语句</span><br></pre></td></tr></table></figure></li><li><p>使用游标：增加了服务器的负担，使用游标的效果远没有使用默认结果集的效率高，因此，能不用游标尽量不要用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> cur_select_name <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> sname <span class="keyword">from</span> student;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">declare</span> @<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">open</span> cur_select_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> cur_select_name <span class="keyword">into</span> @<span class="keyword">name</span></span><br><span class="line"><span class="comment">-- fetch_status取值：0正常执行；-1超出了结果集；-2所指向的行已不存在。</span></span><br><span class="line">  <span class="keyword">while</span>(@@fetch_status = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">print <span class="string">'姓名：'</span> + @<span class="keyword">name</span></span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> cur_select_name <span class="keyword">into</span> @<span class="keyword">name</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">close</span> cur_select_name</span><br><span class="line"><span class="keyword">deallocate</span> cur_select_name</span><br></pre></td></tr></table></figure></li></ul><p>6，<strong>自动执行的存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line">exec sp_procoption <span class="string">'存储过程名'</span>, <span class="string">'startup'</span>, <span class="string">'on'</span></span><br></pre></td></tr></table></figure><p>7，<strong>存储过程的查看，修改和删除</strong></p><p>1）查看存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示存储过程的参数及其数据类型</span></span><br><span class="line">sp_help[[@name=]name]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 显示存储过程的源代码</span></span><br><span class="line">sp_helptext[[@objname=]name]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 显示和存储过程相关的数据库对象</span></span><br><span class="line">sp_depends[@objname=]'object'</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 返回当前数据库中的存储过程列表</span></span><br><span class="line">sp_stored_procedures[[@sp_name=]'name']</span><br><span class="line">[,[@sp_owner=]'owner']</span><br><span class="line">[,[@sp_qualifier=]'sp_qualifier']</span><br></pre></td></tr></table></figure><p>2）修改存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">procedure</span> stu_info</span><br><span class="line"><span class="keyword">with</span> encryption</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> sno, age <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>3）删除存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> &#123;<span class="keyword">procedure</span>&#125;[, ...n]</span><br></pre></td></tr></table></figure><p>8，<strong><code>扩展存储过程</code></strong>：<code>SQL Server</code> 动态装载并执行的动态链接库（<code>DDL</code>），只能添加到<code>master</code>数据库中。</p><h2 id="三，触发器及其应用"><a href="#三，触发器及其应用" class="headerlink" title="三，触发器及其应用"></a>三，触发器及其应用</h2><p>1，<strong>触发器的概念和工作原理</strong></p><p>1）<strong><code>触发器</code>的概念</strong>：<code>触发器</code>是一种特殊类型的存储过程，在执行语言事件时自动生效。其<code>特殊性</code>表现：它是在执行某些<code>T-SQL</code>语句时自动生效的。</p><p>2）<strong><code>DML</code>触发器</strong>：在数据库中发生<code>DML</code>事件时启动。将触发器和触发它的语句作为可在触发器内回滚的单个事务对待，如果检测到错误，则整个事务即自动回滚。</p><p>3）<strong><code>DDL</code>触发器</strong>：是<code>SQL Server 2005</code>的新功能，当服务器或者数据库中发生<code>DDL</code>事件时将调用这些触发器。</p><p>2，<strong>创建触发器</strong></p><p>1）<code>DML</code>触发器<strong>主要优点</strong></p><blockquote><p>i）<code>DML</code>触发器可通过数据库中相关表实现联级更改；<br>ii）<code>DML</code>触发器可以防止恶意或者错误的<code>INSERT</code>，<code>UPDATE</code>及<code>DELETE</code>操作，并强制执行比<code>CHECK</code>约束定义的限制更为复杂的其他限制；<br>iii）<code>DML</code>触发器可以评估数据修改前后表的状态，并根据该差异采取措施。</p></blockquote><p>2）<code>insert</code>型<code>DML</code>触发器：通常用于更新时间标记字段，或者验证被触发器监控的字段中数据满足要求的标准，以确保数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检测sc表添加数据的合法性，即添加的数据与student表的数据不匹配时，将删除此数据. */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_sc_ins <span class="keyword">on</span> sc</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> @sno <span class="built_in">char</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">select</span> @sno=inserted.sno <span class="keyword">from</span> inserted </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> sno <span class="keyword">from</span> student <span class="keyword">where</span> student.sno=@sno)</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> sc <span class="keyword">where</span> sno=@sno</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>3）<code>update</code>型<code>DML</code>触发器：当在一个有<code>update</code>触发器的表中修改记录时，表中原来的记录被移动到删除表中，修改过的记录插入到了插入表中，触发器可以参考删除表和插入表及被修改的表，以确定如何完成数据库操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 防止用户修改SC表的成绩 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_sc_update <span class="keyword">on</span> sc</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">update</span>(scorce)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    raiserror(<span class="string">'不能修改成绩！'</span>, <span class="number">16</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">rollback</span> <span class="keyword">transaction</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>4）<code>delete</code>型<code>DML</code>触发器</p><blockquote><ul><li>为了防止确实需要删除但会引起数据一致性问题的记录的删除；</li><li>执行可删除主记录的子记录的级联删除操作。</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当删除student表中的记录时，自动删除sc表对应学号的记录. */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_del_sc </span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> @sno <span class="built_in">char</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">select</span> @sno=deleted.sno <span class="keyword">from</span> deleted</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> sc <span class="keyword">where</span> sno=@sno</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>5）<strong><code>DDL</code>触发器</strong></p><ul><li><code>DDL</code>触发器目的：<blockquote><p>i）防止对数据库架构进行某些更改；<br>ii）希望数据库中发生某种情况以响应数据库架构中的更改；<br>iii）要记录数据库架构中的更改或者事件。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 防止数据库中的任意表被修改或者删除. */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_safety</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">database</span></span><br><span class="line"><span class="keyword">for</span> drop_table, alter_table</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">print <span class="string">'You must disable trigger "tri_safety" to drop or alter tables!'</span></span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 防止在数据库中创建表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_ban_create</span><br><span class="line"><span class="keyword">in</span> <span class="keyword">database</span></span><br><span class="line"><span class="keyword">for</span> create_table</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">print <span class="string">'create table issued.'</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">eventdata</span>().value(<span class="string">'(/event_instance/TSQLCommand/CommandText)[1]'</span>, <span class="string">'nvarchar(max)'</span>)</span><br><span class="line">raiserror(<span class="string">'New tables cannot be created in this database.'</span>, <span class="number">16</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><p>3，<strong>查看，修改和删除触发器</strong></p><p>1）查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查看触发器的一般信息，如触发器的名称，属性，类型和创建时间 */</span></span><br><span class="line">sp_help 'trigger_name'</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看触发器的正文信息 */</span></span><br><span class="line">sp_helptext 'trigger_name'</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看指定触发器所引用的表或者指定的表涉及的所有触发器 */</span></span><br><span class="line">sp_depends 'trigger_name'</span><br><span class="line">sp_depends 'table_name'</span><br></pre></td></tr></table></figure><p>2）修改触发器<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_rename oldname, newname</span><br></pre></td></tr></table></figure></p><p>3）删除触发器<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> &#123;<span class="keyword">trigger</span>&#125;[, ...n]</span><br></pre></td></tr></table></figure></p><p>4，<strong>触发器的用途</strong></p><blockquote><p>1）可以实现比约束更为复杂的数据约束；<br>2）可以检查SQL所做的操作是否被允许；<br>3）当一个SQL语句对数据表进行操作时，触发器可以根据该SQL语句的操作情况对另一个数据表进行操作；<br>4）约束的本身是不能调用存储过程的，但是触发器可以调用一个或者多个存储过程；<br>5）在执行完SQL语句之后，触发器可以判断更改过的记录是否达到一定条件，如果达到，触发器可以自动调用SQL Mail来发邮件；<br>6）约束不能返回信息，而触发器可以返回信息；<br>7）可以修改原本要操作的SQL语句；<br>8）为了保护已经建好的数据表，触发器可以在接收到以drop和alter开头的SQL语句中，不进行对数据表的操作。</p></blockquote><h2 id="四，嵌入式SQL"><a href="#四，嵌入式SQL" class="headerlink" title="四，嵌入式SQL"></a>四，嵌入式SQL</h2><p>1，<strong>嵌入式<code>SQL</code>简介</strong></p><p>1）<code>嵌入式SQL</code>定义：<code>嵌入式SQL</code>是一种将<code>SQL</code>语句直接写入<code>C</code>语言，<code>COLBOL</code>，<code>FORTRAN</code>，<code>Ada</code>等编程语言的源代码中的方法。将<code>SQL</code>语句嵌入的目标源码的语言称为<code>宿主语言</code>。</p><p>2，<strong>嵌入式<code>SQL</code>的工作原理</strong></p><blockquote><p>提供对于嵌入式SQL的支持，需要数据库厂商除了提供DBMS之外，还必须提供一些工具。为了实现对于嵌入式SQL的支持，技术上必须解决以下4个问题:</p><blockquote><p>1.宿主语言的编译器不可能识别和接受SQL文，需要解决如何将SQL的宿主语言源代码编译成可执行码;<br>2.宿主语言的应用程序如何与DBMS之间传递数据和消息;<br>3.如何把对数据的查询结果逐次赋值给宿主语言程序中的变量以供其处理;<br>4.数据库的数据类型与宿主语言的数据类型有时不完全对应或等价，如何解决必要的数据类型转换问题。<br>嵌入式SQL源码的处理流程 为了解决上述这些问题，数据库厂商需要提供一个嵌入式SQL的预编译器，把包含有嵌入式SQL文的宿主语言源码转换成纯宿主语言的代码。这样一来，源码即可使用宿主语言对应的编译器进行编译。通常情况下，经过嵌入式SQL的预编译之后，原有的嵌入式SQL会被转换成一系列函数调用。因此，数据库厂商还需要提供一系列函数库，以确保链接器能够把代码中的函数调用与对应的实现链接起来。</p></blockquote></blockquote><p>3，<strong>嵌入式<code>SQL</code>的一般形式</strong></p><blockquote><ul><li>预编译</li><li>修改和扩充主语言使之能处理<code>SQL</code>语句</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课本第11～13章主要知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，T-SQL语言&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库实践" scheme="https://zhangbc.github.io/tags/db-practice/"/>
    
  </entry>
  
  <entry>
    <title>【数据库实践】 数据表及其SQL基本操作</title>
    <link href="https://zhangbc.github.io/2019/04/21/db_table_sql/"/>
    <id>https://zhangbc.github.io/2019/04/21/db_table_sql/</id>
    <published>2019-04-21T12:05:44.000Z</published>
    <updated>2019-04-21T12:36:46.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p><blockquote><p>课本第09～10章主要知识点</p></blockquote></blockquote><h2 id="一，表的概述"><a href="#一，表的概述" class="headerlink" title="一，表的概述"></a>一，表的概述</h2><p>1，<strong><code>表</code>的定义</strong>：表是包含 <code>SQL Server 2005</code>数据库中的所有数据的对象。表定义是一个列集合。</p><p>2，<strong><code>表</code>的类型</strong></p><blockquote><p>1）<code>分区表</code>：将数据水平划分为多个单元的表，这些单元可以分布到数据库中的多个文件组中。<br>2）<code>系统表</code>：存储服务器配置及其所有表的数据。<br>3）<code>用户表</code>：用户自己创建的数据表和表示示例数据表，用于存储用户的信息，用户可以随意更改。<br>4）<code>临时表</code>：分为<code>本地临时表</code>和<code>全局临时表</code>，存储在<code>tempdb</code>中，当不再使用临时表时会自动将其删除。</p></blockquote><h2 id="二，创建表"><a href="#二，创建表" class="headerlink" title="二，创建表"></a>二，创建表</h2><p>1，<strong>表列的数据类型</strong></p><p>1）精确数字型</p><ul><li>整数类型（<code>bigint</code>，<code>int</code>，<code>smallint</code>，<code>tinyint</code>）</li></ul><blockquote><ul><li><code>bigint</code>：存储范围为 $-2^{63}$~$2^{63}-1$；占用8个字节。</li><li><code>int</code>：存储范围为 $-2^{31}$~$2^{31}-1$；占用4个字节。</li><li><code>smallint</code>：存储范围为 $-2^{15}$~$2^{15}-1$；占用2个字节。</li><li><code>tinyint</code>：存储范围为 0~255；占用1个字节。</li></ul></blockquote><ul><li>位数据类型（<code>bit</code>）</li></ul><blockquote><ul><li><code>bit</code>：存储范围是0和1，占用1个字节。常作为逻辑变量使用，用于表示真、假或者是、否等二值选择。</li></ul></blockquote><ul><li>数值类型（<code>decimal</code>，<code>numeric</code>）</li></ul><blockquote><ul><li><code>decimal</code>：和<code>numeric</code>一样，可以用2～17个字节来存储$-10^{38}+1$到$10^{38}-1$之间但是固定精度和小数位数位的数字。表示形式<code>decimal(p,s)</code>，其中<code>p</code>确定精确的总位数，默认为18位；<code>s</code>确定小数位数，默认为0。</li></ul></blockquote><ul><li>货币类型（<code>money</code>，<code>smallmoney</code>）：必须在有效位置前加一个货币单位符号。</li></ul><blockquote><ul><li><code>money</code>：用于存储货币值，数值分为一个正数和一个小数分别存储在两个4字节的整型值中，存储范围为$-2^{63}$~$2^{63}-1$，精确到货币单位的千分之一。</li><li><code>smallmoney</code>：与<code>money</code>数据类型相似，但是存储范为$-2^{31}$~$2^{31}-1$。</li></ul></blockquote><p>2）近似数据类型：<code>real</code>，<code>float</code>。</p><blockquote><ul><li><code>real</code>：存储十进制数值，最大可以为7位精确位数。存储范围为$-3.40 \times 10^{-38}$ ~ $3.40 \times 10^{38}$，占用4个字节。</li><li><code>float</code>：可以精确到15位小数。存储范围为$-1.79 \times 10^{-308}$ ~ $1.79 \times 10^{308}$，占用8个字节。<code>float(n)</code>：<code>n</code>指定<code>float</code>数据的精度，<code>n</code>为1～15的整数值。当<code>n</code>为1～7时，实际上是定义了一个<code>real</code>类型的数据，占用4个字节；当<code>n</code>为8～15时，系统认为其是<code>float</code>类型，占用8个字节。</li></ul></blockquote><p>3）日期和时间数据类型：<code>datetime</code>和<code>smalldatetime</code>。</p><blockquote><ul><li><code>datetime</code>：存储日期和时间的结合体，存储从1753年1月1日0时到9999年12月31日23时59分59秒，其精确度可以达到三百分之一秒，即3.33ms。占用8个字节，日期和时间分别占用4个字节。默认格式为 <code>MM DD YYYY hh:mm A.M./P.M.</code>。</li><li><code>smalldatetime</code>：与<code>datetime</code>类型相似，但是存储范围为1900年1月1日至2079年6月6日。占用4个字节，时间和日期分别占用2个字节，精确度为1min。</li></ul></blockquote><p>4）字符数据类型：<code>char</code>，<code>varchar</code>，<code>text</code>。</p><blockquote><ul><li><code>char</code>：定义形式为<code>char(n)</code>，<code>n</code>表示所有字符占用的存储空间，其取值为1～8000，默认值为1。如果输入数据的字符串长度小于<code>n</code>，则系统自动在其后面添加空格来填充；如果输入的数据过长，将会截掉其超出部分。如果定义一个<code>char</code>数据类型，且允许该列为空，则该字段被当成<code>varchar</code>来处理。</li><li><code>varchar</code>：定义形式为<code>varchar(n)</code>，可存储长达8000个字符的客人变长度字符串。其存储空间是根据存储在表的每列值的字符数变化的。</li><li><code>text</code>：用于存储文本数据，其容量理论上为 1~$2^{31}-1$，实际应用根据硬盘的存储空间而定。</li></ul></blockquote><p>5）<code>unicode</code>字符数据类型：<code>nchar</code>，<code>nvarchar</code>，<code>ntext</code>。</p><blockquote><ul><li><code>nchar</code>：定义形式为<code>nchar(n)</code>，<code>n</code>的取值为1～4000。与<code>char</code>类似，但采用<code>unicode</code>标准字符集，<code>unicode</code>标准用2个字节为1个存储单位。</li><li><code>nvarchar</code>：定义形式为<code>nvarchar(n)</code>，<code>n</code>的取值为1～4000。与<code>varchar</code>类似，但采用<code>unicode</code>标准字符集。</li><li><code>ntext</code>：理论上容量为$2^{30}-1$，与<code>text</code>类似，但采用<code>unicode</code>标准字符集。</li></ul></blockquote><p>6）二进制数据类型：<code>binary</code>，<code>varbinary</code>，<code>image</code>。</p><blockquote><ul><li><code>binary</code>：定义形式为<code>binary(n)</code>，数据存储长度是固定的，即n+4个字节。当输入的二进制数据长度小于n时，余下部分填充0。二进制数据类型的最大长度为8000，常用于存储图像等数据。</li><li><code>varbinary</code>：定义形式为<code>varbinary(n)</code>，数据存储长度是变化的，为实际输入数据的长度加上4个字节，其他类似<code>binary</code>。</li><li><code>image</code>：用于存储图像数据，其理论容量为$2^{31}-1$个字节。</li></ul></blockquote><p>7）其他数据类型：<code>sql_variant</code>，<code>table</code>，<code>timestamp</code>，<code>uniqueidentifier</code>，<code>xml</code>，<code>cursor</code>等。</p><blockquote><ul><li><code>sql_variant</code>：用于存储除文本、图形数据和<code>timestamp</code>类型数据外的其他任何合法的<code>SQL Server 2005</code>数据。</li><li><code>table</code>：用于存储对表或者视图处理后的结果集。</li><li><code>timestamp</code>：时间戳数据类型，提供数据库范围内的唯一值。</li><li><code>uniqueidentifier</code>：用于存储一个16字节长的二进制数据类型，是<code>SQL Server 2005</code>根据计算机网络适配器地址和<code>CPU</code>时钟产生的全局唯一标识符代码（<code>GUID</code>），通过调用 <code>SQL Server 2005</code> 的<code>NEWID()</code>函数获取。</li><li><code>xml</code>：存储<code>xml</code>类型的数据，其数据容量不能超过2GB。</li><li><code>cursor</code>：是变量或者存储过程<code>OUTPUT</code>参数的一种数据类型，这些参数包含对游标的引用。</li></ul></blockquote><p>8）用户自定义数据类型</p><ul><li>语法格式如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_addtype [@typename=]type, [@phystype=]system_data_type[, [@nulltype=]'null_type'][, [@owner=]'owner_name']</span><br></pre></td></tr></table></figure><ul><li>举例：自定义一个地址(<code>address</code>)数据类型。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addtype address, 'varchar(80)', 'not null'</span><br></pre></td></tr></table></figure><p>2，<strong>列的其他属性</strong></p><p>1）<code>NULL</code>，<code>NOT NULL</code>和默认值<br>在数据库中，<code>NULL</code>是一个特殊值，表示未知值的概念。默认值是指如果插入行时没有为列指定值，默认值则指定列中使用的值。</p><p>2）<code>IDENTITY</code>属性：实现标识符列。</p><blockquote><ul><li>一个表只能有一个使用<code>IDENTITY</code>属性定义的列，且必须通过使用<code>bigint</code>，<code>int</code>，<code>smallint</code>，<code>tinyint</code>或者<code>decimal</code>，<code>numeric</code>数据类型类定义该列；</li><li>可指定种子和增量，两者的默认值均为1；</li><li>标识符列不允许为空值，也不能包含<code>default</code>定义或者对象；</li><li>在设置<code>IDENTITY</code>属性后，可以使用<code>$IDENTITY</code>关键字在选择列表中引用该列，也可以通过名称引用该列；</li><li><code>objectproperty</code>函数可以用于确定一个表是否具有<code>IDENTITY</code>列，<code>columnproperty</code>函数可以确定<code>IDENTITY</code>列的名称；</li><li>通过使值能显示插入，<code>set identity_insert</code>可以用于禁用该列的<code>IDENTITY</code>属性。</li></ul></blockquote><p>3，<strong>表的创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">(</span><br><span class="line">studentID <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">studentName <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">depart <span class="built_in">char</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">yearClass <span class="built_in">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="三，维护表"><a href="#三，维护表" class="headerlink" title="三，维护表"></a>三，维护表</h2><p>1，<strong>修改表名与表结构</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表名，将studentcourse修改为course</span></span><br><span class="line">exec sp_rename 'studentcourse', 'course';</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 修改表结构</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> sex <span class="built_in">char</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> yearClass;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">alter</span> <span class="keyword">column</span> studentName <span class="built_in">char</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>2，<strong>删除表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> course;</span><br></pre></td></tr></table></figure><p>3，<strong>表数据的维护</strong></p><p>1）添加数据（<code>insert</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span>(<span class="string">'10015'</span>, <span class="string">'计算机网络'</span>, <span class="string">'张三'</span>, <span class="number">2</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>2）更新表数据（<code>update</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> cname=<span class="string">'计算机组成原理'</span> <span class="keyword">where</span> cno=<span class="string">'10015'</span>;</span><br></pre></td></tr></table></figure><p>3）删除表数据（<code>delete</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> sno=<span class="number">200901020023</span>;</span><br></pre></td></tr></table></figure><h2 id="四，表数据完整性"><a href="#四，表数据完整性" class="headerlink" title="四，表数据完整性"></a>四，表数据完整性</h2><p>1，<strong><code>SQL Server</code>提供的数据类型完整性组件</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">完整性类型</th><th style="text-align:left">组件</th></tr></thead><tbody><tr><td style="text-align:left">实体完整性</td><td style="text-align:left">索引，unique约束，primary key约束和identity属性</td></tr><tr><td style="text-align:left">域完整性</td><td style="text-align:left">foreign key约束，check约束，default定义，not null定义和规则</td></tr><tr><td style="text-align:left">参照完整性</td><td style="text-align:left">foreign key约束，check约束和触发器</td></tr><tr><td style="text-align:left">用户定义完整性</td><td style="text-align:left">create table中的所有列级和表级约束，存储过程和触发器</td></tr></tbody></table></div><p>2，<strong><code>primary key</code>约束</strong></p><p>表通常具有一列或者一组列可以用于唯一标识表中的一行，这样的一列或者多列称为表的<code>主键</code>（<code>PK</code>），用于强制表的实体完整性。</p><p>3，<strong><code>foreign key</code>约束</strong></p><p><code>外键</code>是用于建立和加强两个表数据之间的链接的一列或者多列，用于强制参照完整性。</p><blockquote><ul><li>一个表 中最多可以有253个参照表，因此每个表最多可以有253个<code>foreign key</code>约束；</li><li>在<code>foreign key</code>约束中，只能参照同一个数据库中的表；</li><li><code>foreign key</code>子句中的列数目和每个列指定的数据类型必须和<code>reference</code>子句中的相同；</li><li><code>foreign key</code>约束不能自动创建索引；</li><li>参照同一个表中的列时，必须只使用<code>reference</code>子句，而不能使用<code>foreign key</code>子句；</li><li>在临时表中，不能使用<code>foreign key</code>约束。</li></ul></blockquote><p>4，<strong><code>check</code>约束</strong>：通过限制列可接受的值，<code>check</code>约束可以强制域的完整性。</p><p>5，<strong>表关系</strong>：显示某个表中的列如何链接到另一个表的列；可以防止出现冗余数据。</p><h2 id="五，视图"><a href="#五，视图" class="headerlink" title="五，视图"></a>五，视图</h2><p>1，<strong>视图概述</strong></p><p>1）<code>视图</code>是一个虚拟表，是由若干个表或者视图中导出的表，其结构和数据是建立在对表的查询基础上的，其内容由查询定义。</p><p>2）视图的<strong>主要优点</strong>和<strong>作用</strong>：</p><blockquote><p>i）着重于特定数据：视图使用户能够着重于他们所感兴趣的特定数据和所负责的特定任务，不必要的数据或者敏感数据可以不出现在视图中；<br>ii）简化数据操作：视图可以简化用户处理数据的方式；<br>iii）提供向后兼容性：视图能够在表的架构更改时为表创建向后兼容接口；<br>iv）自定义数据：视图允许用户以不同方式查看数据，即使在他们同时使用相同的数据时也是如此；<br>v）导出和导入数据：可使用视图将数据导出到其他应用程序；<br>vi）跨服务器组合分区数据：使用分区视图，可以使用多个服务器对数据进行分区。</p></blockquote><p>3）视图<strong>分类</strong>：</p><blockquote><p>i）标准视图：组合了一个或者多个表中的数据，可以获得使用视图的大多数好处，包括将重点放在特定数据上及简化数据操作。<br>ii）索引视图：被具体化了的视图，即它已经经过计算并存储，可以为视图创建唯一的聚集索引。<br>iii）分区视图：在一台或者多台服务器间水平连接一组成员表的分区数据。</p></blockquote><p>2，<strong>创建视图</strong></p><p>1）创建视图<strong>原则</strong></p><blockquote><p>i) 只能在当前数据库中创建视图；<br>ii) 视图名称必须遵循标志符的规则，且对每个用户必须唯一；<br>iii) 可以在其他视图和引用视图的过程之上创建视图；<br>iv) 定义视图的查询不能包括<code>order by</code>，<code>compute</code>，<code>compute by</code>子句或者<code>into</code>关键字；<br>v) 不能在视图上定义全文索引定义；<br>vi) 不能创建临时视图，也不能在临时表上创建视图；<br>vii) 不能对视图执行全文查询，但是如果查询所引用的表被配置为支持全文索引，就可以在视图定义中包含全文查询。</p></blockquote><ul><li>举例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_teacher_choice <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> b.tname, a.chsu <span class="keyword">from</span> course a, teacher b <span class="keyword">where</span> a.tid=b.tid;</span><br></pre></td></tr></table></figure><p>3，<strong>使用视图</strong></p><p>1）使用视图进行数据检索</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> view_teacher_choice;</span><br></pre></td></tr></table></figure><p>2）通过视图修改数据</p><blockquote><ul><li>如果在视图定义中使用了<code>with check option</code>子句，则所有在视图上执行的数据修改语句都必须符合定义视图的<code>select</code>语句中所设定的条件。</li><li><code>SQL Server</code> 必须能够明确地解析对视图所引用基表中的特定行所做的修改操作。</li><li>对基表中须更新而又不允许空值的所有列，其值在<code>insert</code>语句或者<code>default</code>定义中指定。</li><li>如果在视图删除数据，在视图定义的<code>from</code>子句中只能列出一个表。</li><li>视图修图数据通过<code>insert</code>，<code>update</code>，<code>delete</code>语句来完成。</li></ul></blockquote><p>4，<strong>修改视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_teacher_choice <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> b.tname, a.chsu <span class="keyword">from</span> course a, teacher b <span class="keyword">where</span> a.tid=b.tid <span class="keyword">and</span> a.chsu &gt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>5，<strong>重命名视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_rename 'view_teacher_choice', 'view_teacher_choice_total';</span><br></pre></td></tr></table></figure><p>6，<strong>查看视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line">exec sp_helptext <span class="string">'view_teacher_choice_total'</span>;</span><br></pre></td></tr></table></figure><p>7，<strong>删除视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_teacher_choice_total;</span><br></pre></td></tr></table></figure><h2 id="六，索引"><a href="#六，索引" class="headerlink" title="六，索引"></a>六，索引</h2><p>1，<strong>索引概述</strong></p><p>1）<strong><code>索引</code>定义</strong>：<code>索引</code>是对数据库表中一个或者多个列的值进行排序而创建的一种存储结构。</p><p>2）索引分类：</p><blockquote><p>i）<code>聚集索引(clustered)</code>：保证数据库表中记录的物理顺序与索引顺序相同，一个表只能有一个聚集索引。<br>ii）<code>非聚集索引(nonclustered)</code>：数据库表中记录的物理顺序与索引顺序可以不相同，一个表可以有多个非聚集索引。<br>iii）<strong>唯一索引(<code>unique</code>)</strong>：表示表中的任何两个记录的索引值都不相同，与表的主键类似，确保索引列不包括重复的值；<br>iv）<strong>组合索引</strong>：将两个或者多个字段组合起来的索引，而单独的字段允许不是唯一的值。</p></blockquote><p>2，<strong>创建索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_time <span class="keyword">in</span> course(choice_time <span class="keyword">asc</span>);</span><br></pre></td></tr></table></figure><p>3，<strong>查看索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_helpindex idx_time;</span><br></pre></td></tr></table></figure><p>4，<strong>删除索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> course.idx_time;</span><br></pre></td></tr></table></figure><h2 id="七，SQL操作查询"><a href="#七，SQL操作查询" class="headerlink" title="七，SQL操作查询"></a>七，SQL操作查询</h2><p>1，<strong>简单查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,sn,age <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sno <span class="keyword">from</span> course;</span><br><span class="line"><span class="keyword">select</span> sn <span class="keyword">as</span> sname,sno,age <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> sn,age<span class="number">-5</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(age) <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>2，<strong>带条件的列查询</strong></p><blockquote><ul><li>比较大小和确定范围</li><li>部分匹配查询</li><li>查询的排序</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,score <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'C01'</span>;</span><br><span class="line"><span class="keyword">select</span> sno,cno,score <span class="keyword">from</span> sc <span class="keyword">where</span> score&gt;<span class="number">80</span>;</span><br><span class="line"><span class="keyword">select</span> sno,cno,score <span class="keyword">from</span> sc <span class="keyword">where</span> (cno=<span class="string">'C01'</span> <span class="keyword">or</span> cno=<span class="string">'C02'</span>) <span class="keyword">and</span> score&gt;<span class="number">80</span>;</span><br><span class="line"><span class="keyword">select</span> sno,sn <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> sno,sn,cno <span class="keyword">from</span> student <span class="keyword">where</span> score <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> sno,cno,score <span class="keyword">from</span> sc <span class="keyword">where</span> cno <span class="keyword">in</span>(<span class="string">'C01'</span>, <span class="string">'C02'</span>);</span><br><span class="line"><span class="keyword">select</span> sno,sn <span class="keyword">from</span> student <span class="keyword">where</span> sn <span class="keyword">like</span> <span class="string">'李%'</span>;</span><br><span class="line"><span class="keyword">select</span> sno,score <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'C01'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(score) <span class="keyword">as</span> total_score, <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_score <span class="keyword">from</span> sc <span class="keyword">where</span> sno=<span class="string">'0001'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(score) <span class="keyword">as</span> max_score,<span class="keyword">min</span>(score) <span class="keyword">as</span> min_score,<span class="keyword">max</span>(score)-<span class="keyword">min</span>(score) <span class="keyword">as</span> diff <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'C01'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> dept) <span class="keyword">as</span> dept_num <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> sno,<span class="keyword">sum</span>(score) aas total_score <span class="keyword">from</span> sc <span class="keyword">where</span> score &gt;= <span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> sno <span class="keyword">having</span>(*) &gt;= <span class="number">3</span> <span class="keyword">order</span> bu <span class="keyword">sum</span>(score) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>3，<strong>多表查询</strong></p><p>所谓<code>多表查询</code>，即在两个或者两个以上的表中进行的查询操作，分为：<code>连接查询</code>和<code>子查询</code>（<code>嵌套查询</code>）。</p><ul><li><strong>连接查询</strong></li></ul><blockquote><p>1）内连接</p><blockquote><ul><li><code>等值连接</code>：在连接条件中使用等于号(<code>=</code>)运算符，与被连接列的列值进行比较，在查询结果中列出被连接表中的所有列，包括其中的重复列。</li><li><code>不等连接</code>：在连接条件中使用除等于号(<code>=</code>)以外的其他比较运算符，与被连接列的列值进行比较，这些运算符包括<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>!&gt;</code>，<code>!&lt;</code>，<code>&lt;&gt;</code>。</li><li><code>自然连接</code>：在连接条件中使用等于号(<code>=</code>)运算符，与被连接列的列值进行比较，在查询结果中列出被连接表中的所有列，但会删除其中的重复列。</li></ul></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student a <span class="keyword">inner</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br></pre></td></tr></table></figure><blockquote><p>2）交叉连接（笛卡尔积）：两个关系中所有元组的任意组合。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">cross</span> <span class="keyword">join</span> sc;</span><br></pre></td></tr></table></figure><blockquote><p>3）自连接：如果在一个连接查询中，涉及的两个表都是同一张表，这种查询称为<code>自连接查询</code>。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">inner</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.cno=b.cno <span class="keyword">and</span> b.sno=<span class="string">'20090701027'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>4）外连接：其查询结果既包含那些满足条件的行，又包含其中某个表的全部行。</p><blockquote><ul><li>左外连接（<code>left join</code>）</li><li>右外连接（<code>right join</code>）</li><li>全外连接（<code>full join</code>）</li></ul></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.sno,a.sname,a.class,a.cno,b.score <span class="keyword">from</span> student a <span class="keyword">left</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br><span class="line"><span class="keyword">select</span> a.sno,a.sname,a.class,a.cno,b.score <span class="keyword">from</span> student a <span class="keyword">right</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br><span class="line"><span class="keyword">select</span> a.sno,a.sname,a.class,a.cno,b.score <span class="keyword">from</span> student a <span class="keyword">full</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br></pre></td></tr></table></figure><ul><li><strong>子查询</strong></li></ul><blockquote><ul><li>在where子句中包含一个形如select-from-where的查询块，此查询称为<code>子查询</code>或者<code>嵌套查询</code>，包含子查询的语句称为<code>父查询</code>或者<code>外部查询</code>。<br>基本关键字：<code>any</code>，<code>in</code>，<code>all</code>，<code>exists</code></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tname <span class="keyword">from</span> teacher <span class="keyword">where</span> tno=<span class="keyword">any</span>(<span class="keyword">select</span> tno <span class="keyword">from</span> tc <span class="keyword">where</span> cno=<span class="string">'C05'</span>);</span><br><span class="line"><span class="keyword">select</span> tname <span class="keyword">from</span> teacher <span class="keyword">where</span> tno <span class="keyword">in</span> (<span class="keyword">select</span> tno <span class="keyword">from</span> tc <span class="keyword">where</span> cno=<span class="string">'C05'</span>);</span><br><span class="line"><span class="keyword">select</span> tname,sal <span class="keyword">from</span> teacher <span class="keyword">where</span> sal&gt;<span class="keyword">all</span>(<span class="keyword">select</span> sal <span class="keyword">from</span> teacher <span class="keyword">where</span> dept=<span class="string">'电力系'</span>) <span class="keyword">and</span> dept!=<span class="string">'电力系'</span>;</span><br><span class="line"><span class="keyword">select</span> tname <span class="keyword">from</span> teacher <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> tc <span class="keyword">where</span> teacher.tno=tc.tno <span class="keyword">and</span> cno=<span class="string">'C05'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课本第09～10章主要知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，表的概述&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库实践" scheme="https://zhangbc.github.io/tags/db-practice/"/>
    
  </entry>
  
  <entry>
    <title>【数据库实践】 数据库及其管理</title>
    <link href="https://zhangbc.github.io/2019/04/17/db_table_manager/"/>
    <id>https://zhangbc.github.io/2019/04/17/db_table_manager/</id>
    <published>2019-04-17T15:32:38.000Z</published>
    <updated>2019-04-18T11:37:54.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p><blockquote><p>课本第07～08章主要知识点</p></blockquote></blockquote><h2 id="一，SQL-Server-2005概述"><a href="#一，SQL-Server-2005概述" class="headerlink" title="一，SQL Server 2005概述"></a>一，SQL Server 2005概述</h2><p>1，<strong><code>SQL Server 2005</code> 新特性</strong></p><p><code>SQL Server</code> 是一个全面的，集成的数据库解决方案，为企业中的用户提供了用于企业数据管理和商业智能的一个安全，可靠和高效的平台。</p><p>1）<code>Service Broker</code></p><blockquote><ul><li>提供了一个功能强大的，异步编程的新模型。数据库应用程序通常使用异步编程来缩短交互式响应时间，并增加应用程序总吞吐量。</li><li>帮助数据库开发人员生成可靠且可扩展的应用程序。</li><li>在<code>SQL Server</code>实例之间提供可靠的消息传递服务。</li></ul></blockquote><p>2）<code>CLR</code>集成<br>3）专用管理员<code>DAC</code>：<code>SQL Server 2005</code>为管理员提供了一种特殊的诊断连接，以供在无法与服务器建立标准连接时使用。<br>4）用户与架构分离</p><blockquote><ul><li>简化删除数据库用户的操作</li><li>多个用户可以用户同一个架构</li></ul></blockquote><p>5）分区：<code>分区</code>是大型数据表和索引采取的优化存储性能和数据存储的技术。</p><p>2，<strong><code>SQL Server 2005</code> 体系结构</strong><br><img src="/images/db_table_manager_architecture_20190417.png" alt="SQL Server体系结构"></p><p>1）<strong>数据库引擎组件</strong>：为数据存储、处理和安全实现高可伸缩性和高可用性服务。<br>2）<strong>报表组件服务组件</strong>：提供了全面的报表解决方案，可创建、管理和发布传统的、可打印的报表和交互性的、基于<code>Web</code>的报表。<br>3）<strong>分析服务组件</strong>：提供数据分析服务。利用分析服务开发人员设计、创建和管理多种数据源和多种数据结构，通过数据分析规律，获取数据知识。<br>4）<strong>集成服务组件</strong>：用于构建高性能数据集成解决方案（包括为数据仓库提取、转换和加载（<code>ETL</code>）包）的平台。<br>5）<strong>其他组件</strong>：复制服务组件，通知服务组件，服务代理组件，全文搜索。</p><p>3，<strong><code>SQL Server 2005</code>安装</strong></p><p>1）<strong><code>SQL Server 2005</code>版本选择</strong></p><blockquote><ul><li><code>SQL Server 2005</code>企业版：支持<code>32位</code>和<code>64位</code>系统，适合超大型企业。包括联机事务处理，高度复杂的数据分析，数据仓库系统和网站所需的基本功能。</li><li><code>SQL Server 2005</code>标准版：支持<code>32位</code>和<code>64位</code>系统，适合中小型企业。包括电子商务，数据仓库和业务流解决方案所需的基本功能。</li><li><code>SQL Server 2005</code>工作组版：仅支持<code>32位</code>系统，适合小型企业使用。包括<code>SQL Server</code>产品系列的核心数据库功能，可升级至标准版或者企业版。</li><li><code>SQL Server 2005</code>开发版：支持<code>32位</code>和<code>64位</code>系统，仅适合于开发和测试系统使用。具备和企业版完全一样的功能，但有许可限制，只能用于开发和测试。</li><li><code>SQL Server 2005</code>简易版：仅支持<code>32位</code>系统，是一个免费的，使用简单，易于管理的数据库。</li><li><code>SQL Server 2005</code>精简版：仅支持<code>32位</code>系统，适合在移动智能设备上使用。</li></ul></blockquote><h2 id="二，数据库的类型"><a href="#二，数据库的类型" class="headerlink" title="二，数据库的类型"></a>二，数据库的类型</h2><p>1，<strong>系统数据库</strong></p><p><code>数据库</code>是表、视图、索引、存储过程等对象的集合，是数据库管理系统的核心，数据库与管理它的数据库管理系统统一组成数据库服务器。</p><p> 1）<strong><code>master</code></strong>：记录了<code>SQL Server</code>系统的所有服务器的系统信息，包括实例范围的元数据，端点，链接服务器和系统配置设置。</p><p> 2）<strong><code>model</code></strong>：用于在<code>SQL Server</code>实例上创建的所有数据库的模板。</p><p> 3）<strong><code>msdb</code></strong>：提供给<code>SQL Server</code>代理服务器使用的数据库，主要用于为警报，作业，任务调度及记录操作员的操作提供相应的支持。</p><p> 4）<strong><code>tempdb</code></strong>：连接到<code>SQL Server</code>实例的所有用户都可用的全局资源，保存所有临时表和临时存储过程。</p><p> 5）<strong><code>resource</code></strong>：是一个隐藏的只读数据库，包含了<code>SQL Server</code>中的所有系统对象，但不包含用户数据或者用户元数据。</p><p>2，<strong>用户数据库</strong></p><ul><li>数据库<code>命名规则</code>如下：<blockquote><ul><li>第一个字符必须是字母<code>a～z</code>和<code>A~Z</code>、汉字或者下画线(<code>_</code>)、符号<code>@</code>，<code>#</code>；</li><li>后续字符可以是字母<code>a～z</code>和<code>A~Z</code>、汉字、数字或者下画线(<code>_</code>)、符号<code>@</code>，<code>$</code>、数字符号；</li><li>标识符不能是<code>T-SQL</code>的保留字；</li><li>长度不能超过128。</li></ul></blockquote></li></ul><p>3，<strong>数据库快照</strong></p><p>1）<strong><code>数据库快照</code>的定义</strong>：<code>数据库快照</code>是用户数据库的只读、静态视图，不包括未提交的事务。</p><p>2）<strong><code>数据库快照</code>的特点</strong>：</p><blockquote><ul><li>反映某个时刻（完成数据库快照创建的时刻）数据库的数据；</li><li>不允许更新；</li><li>一个用户数据库可以创建多个数据库快照，并且必须与数据库在同一个服务器实例上。</li></ul></blockquote><h2 id="三，数据库存储文件"><a href="#三，数据库存储文件" class="headerlink" title="三，数据库存储文件"></a>三，数据库存储文件</h2><p><code>SQL Server 2005</code>数据库<strong>文件名称</strong>包括：</p><blockquote><ul><li><code>逻辑文件名</code>：在所有 <code>T-SQL</code> 语句中引用物理文件时所使用的名称，必须符合<code>SQL Server</code> 标识符规则，而且是唯一的。</li><li><code>物理文件名</code>：包括目录路径的物理文件名称，必须符合操作系统文件命名规则。</li></ul></blockquote><p><code>SQL Server 2005</code>数据库<strong>操作系统文件</strong>包括：</p><blockquote><ul><li><code>数据文件</code>：包括数据和对象，如表、索引、存储过程和视图。</li><li><code>日志文件</code>：包含恢复数据库中的所有事务所需的信息。</li></ul></blockquote><p>1，<strong>数据库文件</strong></p><blockquote><ul><li><strong>主要数据库文件（<code>.mdf</code>）</strong>：数据库的起点，包括数据库的启动信息，并指向数据库中其他文件。</li><li><strong>次要数据库文件（<code>.ndf</code>）</strong>：是可选的，由用户定义并存储用户数据。</li><li><strong>事务日志文件（<code>.ldf</code>）</strong>：用于恢复数据库的日志信息。</li></ul></blockquote><p>2，<strong>数据库文件组</strong></p><blockquote><ul><li><strong>主文件组</strong>：包含主要数据文件和任何没有明确分配给其他文件组的其他文件。<code>系统表</code>的所有页均分配在主文件组中。</li><li><strong>用户定义文件组</strong>：通过在 <code>create database</code> 或者 <code>alter database</code> 语句中使用 <code>filegroup</code> 关键字指定的任何文件组。</li><li><strong>默认文件组（<code>primary</code>文件组）</strong>：如果在数据库中创建对象时没有指定对象所属的文件组，对象将被分配给默认文件组。</li></ul></blockquote><p><strong><code>注意</code></strong>：日志文件包括在文件组内。</p><h2 id="四，数据库的对象"><a href="#四，数据库的对象" class="headerlink" title="四，数据库的对象"></a>四，数据库的对象</h2><p>1，<strong>数据库关系图</strong>：以<code>图形</code>方式来表示表之间的关系。</p><p>2，<strong>表</strong>：组织和存储数据。</p><p>3，<strong>索引</strong>：提高数据检索速度，但增加了系统存储空间的开销。</p><p>4，<strong>视图</strong>：实现用户对数据对查询，但是视图的结构和数据是建立在对表的查询基础上的。</p><p>5，<strong>存储过程和触发器</strong>：数据库中的对编程对象。</p><blockquote><ul><li><code>存储过程</code>独立于表，存储在服务器上，供客户端调用，提供应用程序的效率。</li><li><code>触发器</code>是一种特殊的存储过程，可以大大增强应用程序的健壮性，数据的可恢复性和可管理性。</li></ul></blockquote><p>6，<strong>规则和约束</strong>：对能够放入表中的内容进行限定。</p><blockquote><ul><li><code>规则</code>：用于在用户定义数据类型上加以限制。</li><li><code>约束</code>：本身并非实际的对象，而只是描述特定表的元数据。</li></ul></blockquote><p>7，<strong>默认值</strong>：</p><ul><li><code>默认值</code>有两种类型：<blockquote><ul><li>默认值默认其本身是一个对象；</li><li>默认值不是实际的对象，只描述表特定列的元数据。</li></ul></blockquote></li></ul><p>8，<strong>全文目录</strong>：<code>全文目录</code>是数据的映射，以加速对启用了全文搜索的列中特定文本块的搜索。</p><h2 id="五，创建数据库"><a href="#五，创建数据库" class="headerlink" title="五，创建数据库"></a>五，创建数据库</h2><ul><li>一个<code>SQL Server</code>实例，最多可以创建<code>32767</code>个数据库。</li></ul><p>1，<strong>使用<code>SQL Server</code>管理工具创建</strong></p><p>2，<strong>使用<code>T-SQL</code>创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> xsxk </span><br><span class="line"><span class="keyword">on</span> primary                   <span class="comment">-- 建立主要数据文件</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_data'</span>,         <span class="comment">-- 逻辑名称</span></span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_data.mdf'</span>,   <span class="comment">-- 物理文件路径和名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">1024</span>KB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="keyword">unlimited</span>,   <span class="comment">-- 最大尺寸为无限大</span></span><br><span class="line">    filegrowth = <span class="number">10</span>%       <span class="comment">-- 增长速度</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">log</span> <span class="keyword">on</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_log'</span>,         <span class="comment">-- 建立日志文件</span></span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_log.ldf'</span>,   <span class="comment">-- 物理文件路径和名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">1024</span>KB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="number">5120</span>KB,  </span><br><span class="line">    filegrowth = <span class="number">1024</span>KB</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><h2 id="六，维护数据库"><a href="#六，维护数据库" class="headerlink" title="六，维护数据库"></a>六，维护数据库</h2><p>1，<strong>查看数据库状态</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,state,state_desc <span class="keyword">from</span> sys.databases;</span><br></pre></td></tr></table></figure><p>2，<strong>修改数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> xsxk </span><br><span class="line"><span class="keyword">modify</span> <span class="keyword">file</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_data'</span>,         <span class="comment">-- 逻辑名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">5</span>MB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="number">50</span>MB,   </span><br><span class="line">    filegrowth = <span class="number">2</span>%       <span class="comment">-- 增长速度</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> xsxk</span><br><span class="line"><span class="keyword">log</span> <span class="keyword">on</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_log'</span>,         <span class="comment">-- 建立日志文件</span></span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_log.ldf'</span>,   <span class="comment">-- 物理文件路径和名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">1024</span>KB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="number">5120</span>KB,  </span><br><span class="line">    filegrowth = <span class="number">2</span>MB</span><br><span class="line"> )</span><br><span class="line"> <span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>3，<strong>删除数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> xsxk;</span><br></pre></td></tr></table></figure><p>4，<strong>分离和附加数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分离数据库</span></span><br><span class="line">sp_detach_db xsxk;</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 附加数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> xsxk <span class="keyword">on</span></span><br><span class="line">(</span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_data.mdf'</span></span><br><span class="line">),(</span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_log.ldf'</span></span><br><span class="line">)</span><br><span class="line">    <span class="keyword">for</span> attach;</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>5，<strong>其他操作</strong></p><p>1）<strong>脱机用户数据库</strong></p><p>2）<strong>联机用户数据库</strong></p><p>3）<strong>重命名数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> xsxk <span class="keyword">modify</span> <span class="keyword">name</span> = xsxks</span><br></pre></td></tr></table></figure><p>4）<strong>收缩数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将userDB用户数据库中的文件减小，以使userDB中的文件有10%的可用空间</span></span><br><span class="line">dbcc sharinkdatabases(userDB, 10)</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 将userDB用户数据库中名为DataFile的文件大小收缩到7M</span></span><br><span class="line">DBCC shrinkfile(DataFile, 7)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课本第07～08章主要知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，SQL-Server-2005概述
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库实践" scheme="https://zhangbc.github.io/tags/db-practice/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】数据库的安全和保护</title>
    <link href="https://zhangbc.github.io/2019/04/14/db_security/"/>
    <id>https://zhangbc.github.io/2019/04/14/db_security/</id>
    <published>2019-04-14T11:05:17.000Z</published>
    <updated>2019-04-14T16:43:26.612Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，安全与保护概述"><a href="#一，安全与保护概述" class="headerlink" title="一，安全与保护概述"></a>一，安全与保护概述</h2><p>1）<strong><code>数据安全性控制</code></strong>：防止未经授权的用户和存取数据库中的数据，避免数据的泄露，更改或破坏；</p><p>2）<strong><code>数据完整性控制</code></strong>：保证数据库中数据及语义的正确性和有效性，防止任何对数据库造成错误的操作；</p><p>3）<strong><code>数据库的并发控制</code></strong>：在多用户同时对一个个数据进行操作时，系统应能够加以控制，防止破坏数据库中的数据；</p><p>4）<strong><code>数据库的恢复</code></strong>：在数据库遭到破坏或者数据不正确时，系统有能力把数据库恢复到正确的状态。</p><h2 id="二，数据库的安全性"><a href="#二，数据库的安全性" class="headerlink" title="二，数据库的安全性"></a>二，数据库的安全性</h2><p>1，<strong>数据库安全性控制</strong></p><p>1）<strong>用户标识与鉴别</strong>：系统提供的最外层的安全保护措施，其方法是由系统提供一定的方式让用户标识自己的名字或身份。</p><p> 2）<strong>存取控制</strong>：</p><blockquote><p>（1）<code>定义用户权限</code>，并将用户权限等存储在数据字典中。<code>用户权限</code>是指不同等用户对不同对数据对象允许执行对操作权限，这些定义经过编译后存放在数据字典中，这些定义称为<code>安全规则</code>或<code>授权规则</code>；<br>（2）<code>合法权限检查</code>。用户权限定义和合法权限检查机制组成类<code>DBMS</code>的安全子系统。</p></blockquote><p>3）<strong>试图机制</strong>：数据安全性，逻辑数据独立性和操作简便性。</p><p>4）<strong>审计</strong>：<code>审计追踪</code>是一个对数据库进行更新对日志，还包括一些其他信息，如哪个用户执行了更新和什么时候执行的更新等。</p><p>5）<strong>数据加密</strong>：防止数据库中数据在存储和传输中失密的有效手段。</p><p>2，<strong>SQL Server的安全性措施</strong></p><p>1）<strong><code>SQL Server</code>安全控制概述</strong></p><blockquote><p>（1）操作系统安全验证（网络层）：通过设置安全模式来实现。<br>（2）<code>SQL Server</code>安全验证（服务器）：通过<code>SQL Server</code>服务器登录名管理来实现。<br>（3）<code>SQL Server</code>数据库安全验证：通过<code>SQL Server</code>数据库用户管理来实现。<br>（4）<code>SQL Server</code>数据库对象安全验证（处理权限）：通过权限管理来实现。</p></blockquote><p>2）<strong><code>SQL Server</code>的安全认证模式</strong></p><blockquote><p>（1）身份验证阶段：Windows身份验证，混合模式验证。<br>（2）权限认证阶段<br>（3）设置身份验证</p></blockquote><p>3）<strong>登录名和用户管理</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> &lt;<span class="keyword">DATABASE</span> <span class="keyword">NAME</span>&gt;</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &lt;<span class="keyword">new</span> user_name&gt; <span class="keyword">FOR</span> LOGIN &lt;login <span class="keyword">name</span>&gt;;</span><br></pre></td></tr></table></figure></p><p>4）<strong>权限管理</strong></p><blockquote><p>（1）<strong>权限分类</strong>：<code>语句权限</code>，<code>对象权限</code>，<code>隐含权限</code>；<br>（2）<strong>角色分类</strong>：在<code>SQL Server</code>中，组是通过角色来实现的。角色分为<code>服务器角色</code>和<code>数据库角色</code>（预定义的数据库角色，用户自定义数据库角色和应用程序角色）。</p></blockquote><h2 id="三，数据库的完整性"><a href="#三，数据库的完整性" class="headerlink" title="三，数据库的完整性"></a>三，数据库的完整性</h2><p>1，<strong><code>数据库的完整性</code>定义</strong>：<code>数据库的完整性</code>是指数据的正确性（<code>Correctness</code>），有效性（<code>Validity</code>）和相容性（<code>Consistency</code>）。<code>正确性</code>是指数据的合法性；<code>有效性</code>是指数据是否属于所定义的有效范围；<code>相容性</code>是指表示同一事实的两个数据应一致，不一致就是不相容。</p><p><code>完整性检查</code>：在<code>DBMS</code>中，检查数据库中的数据是否满足语义规定的条件。</p><p>2，<strong>完整性约束条件</strong></p><p>1）<strong>完整性约束作用的对象</strong>可以是<code>列</code>，<code>元组</code>，<code>关系</code>。其中：<code>列的约束</code>主要是列的类型，取值范围，精度，排序等约束条件；<code>元组的约束</code>是元组中各个字段间的联系约束；<code>关系的约束</code>是若干元组间，关系集合上及关系之间的联系约束。</p><p>2）<strong><code>静态约束</code></strong>：指数据库在每个确定状态时的数据对象所应满足的约束条件，是反映数据库状态合理性的约束。</p><blockquote><p>（1）<code>静态列级约束</code>：对一个列的取值范围的说明，即对数据类型的约束（数据的类型，长度，单位，精度等），对数据格式的约束，对取值范围或者取值集合的约束，对空值的约束，其他约束。<br>（2）<code>静态元组约束</code>：规定元组的各个列之间的约束关系。<br>（3）<code>静态关系约束</code>：实体完整性约束，参照完整性约束，函数依赖约束，统计约束。</p></blockquote><p>3）<strong><code>动态约束</code></strong>：指数据库从一种状态转变为另一种状态时，新旧值之间所应满足的约束条件，是反映数据库状态变迁的约束。</p><blockquote><p>（1）<code>动态列级约束</code>：修改列定义或者列值时应满足的约束条件。<br>（2）<code>动态元组约束</code>：修改元组中各个字段间需要满足某种约束条件。<br>（3）<code>动态关系约束</code>：加在关系变化前后状态上的限制条件，如事务一致性，原子性等。</p></blockquote><p>3，<strong>完整性控制</strong></p><p>1）<strong>定义功能</strong>：提供定义完整性约束条件的机制。</p><p>2）<strong>检查功能</strong>：检查用户发出的操作请求是否违背列完整性约束条件。</p><p>3）如果发现用户的操作请求使数据违背了完整性约束条件，则采取恰当的操作。</p><p>4，<strong><code>SQL Server</code>的完整性实现</strong></p><p>1）<strong>声明型数据完整性约束</strong>：在 <code>create table</code> 和 <code>alter table</code> 定义中使用约束限制表中的值。</p><p>2）<strong>过程型数据完整性约束</strong>：由缺省，规则和触发器实现，由视图和存储过程支持。</p><p>（1）<strong><code>约束</code></strong>：是SQL Server提供的自动保持数据库完整性的一种方法。分为：<br>i）<code>空值约束</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] [NULL/NOT NULL]</span><br></pre></td></tr></table></figure></p><p>ii）<code>主键约束</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列级</span></span><br><span class="line">[CONSTRAINT constraint_name] PRIMARY KEY  </span><br><span class="line"><span class="comment">-- 表级</span></span><br><span class="line">[CONSTRAINT constraint_name] PRIMARY KEY(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;])</span><br></pre></td></tr></table></figure></p><p>iii）<code>唯一约束</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列级</span></span><br><span class="line">[CONSTRAINT constraint_name] UNIQUE  </span><br><span class="line"><span class="comment">-- 表级</span></span><br><span class="line">[CONSTRAINT constraint_name] UNIQUE(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;])</span><br></pre></td></tr></table></figure></p><ul><li><code>唯一约束</code>和<code>主键约束</code>的区别：<blockquote><p>（1）在一个基本表中，只能定义在一个主键约束，但可以定义多个唯一约束；<br>（2）两者都为指定但列建立唯一索引，但主键约束限制更为严格，不但不允许有重复值，而且也不允许由空值；<br>（3）唯一约束与主键约束产生但约束可以是聚集索引，也可以是非聚集索引，在缺省情况下，唯一约束产生非聚集索引，主键约束产生聚集索引；<br>（4）不能同时为同一列或者一组列既定义唯一约束，又定义主键约束。</p></blockquote></li></ul><p>iv）<code>外键约束和参照约束</code><br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] [FOREIGN KEY] REFERENCES ref_table (ref_column[&#123;,&lt;trf_column&gt;&#125;])</span><br></pre></td></tr></table></figure></p><p>v）<code>缺省值约束</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] DEFAULT constraint_expression</span><br></pre></td></tr></table></figure></p><p>vi）<code>检查约束</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] <span class="keyword">CHECK</span>(logical_expression)</span><br></pre></td></tr></table></figure></p><ul><li>例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line"><span class="keyword">go</span> </span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Titles </span><br><span class="line">(</span><br><span class="line">    title_id <span class="built_in">varchar</span>(<span class="number">6</span>) <span class="keyword">constraint</span> pk_title_id primary <span class="keyword">key</span>,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">80</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">constraint</span> uniq_title <span class="keyword">unique</span>,</span><br><span class="line">    [<span class="keyword">type</span>] <span class="built_in">char</span>(<span class="number">12</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">constraint</span> def_type <span class="keyword">default</span> <span class="string">'UNDECIDED'</span>,</span><br><span class="line">    pub_id <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">    price money <span class="keyword">constraint</span> chk_price <span class="keyword">check</span>(price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">100</span>),</span><br><span class="line">    ytd_sales <span class="built_in">int</span>,</span><br><span class="line">    pub_date datetime <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">constraint</span> def_pub_date <span class="keyword">default</span> <span class="keyword">getdate</span>()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>（2）<strong><code>规则</code></strong>：当向表当某列（或使用与该规则绑定的用户定义数据类型的所有列）插入列或更新数据时，它指定限制输入新值的取值范围。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> rule rule_price <span class="keyword">as</span> @price &gt;= <span class="number">5</span> <span class="keyword">and</span> @price &lt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line">exec sp_bindrule <span class="string">'rule_price'</span>, <span class="string">'Titles.price'</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>（3）<strong><code>缺省</code></strong>：它指定在向数据库中的表插入数据时，如果用户没有明确给出某列的值，<code>SQL Server</code>自动为该列（使用与该缺省绑定的用户定义数据类型的所有列）输入值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">default</span> def_price <span class="keyword">as</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line">exec sp_bindefault def_price, <span class="string">'Titles.price'</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure><h2 id="四，事务"><a href="#四，事务" class="headerlink" title="四，事务"></a>四，事务</h2><p>1，<strong>事务的概念</strong></p><p>1）<strong><code>事务</code>定义</strong>：用户定义的一个数据库操作序列，这些操作要么可全部成功执行，否则，将不执行其中任何一个操作。事务是一个不可分割的工作单元。</p><p>2）<strong>事务基本性质(<code>ACID</code>)</strong></p><blockquote><p>（1）<strong><code>原子性(Atomicity)</code></strong>：事务中包含的所有操作要么全做，要么一个也不做。<br>（2）<strong><code>一致性(Consistency)</code></strong>：定义在数据库上的各种完整性约束。<br>（3）<strong><code>隔离性(Ioslation)</code></strong>：确保事务并发执行后的系统状态与这些事务以某种次序串行执行后的状态是等价的。<br>（4）<strong><code>持久性(Durability)</code></strong>：一个事务一旦成功完成，它对数据库的改变必须是永久的，即使是在系统遇到故障的情况下也不会丢失。</p></blockquote><p>2，<strong>事务调度</strong></p><p>1）<code>事务调度</code>的定义：在一个大型的<code>DBMS</code>中，可能会同时存在多个事务处理请求，系统需要确定这组事务的执行次序，即每个事务的指令在系统中执行的时间顺序，这称为<code>事务的调度</code>。</p><p>2）<code>合法调度</code>须满足以下条件：</p><blockquote><p>i）调度必须包含所有的事务的指令；<br>ii）一个事务中指令的顺序在调度中必须保持不变。</p></blockquote><p>3）调度的<strong>基本形式</strong></p><p>i）<code>串行调度</code></p><blockquote><ul><li><code>串行调度</code>：在前一个事务完成之后，在开始另外一个事务，类似与操作系统中的单道批处理作业。</li><li><code>可串行化调度</code>：定义多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，这种调度策略称为<code>可串行化调度</code>。</li></ul></blockquote><p>ii）<code>并行调度</code></p><blockquote><ul><li><code>并行调度可串行化</code>：如果一组事务并行调度的执行结果等价于这组事务中所有提交事务的某个串行调度，则称该<code>并行调度可串行化</code>。</li><li><code>级联回滚</code>：由于一个事务的故障而导致一系列其他事务的回滚。</li><li><code>无级联调度</code>：应该对调度做出某种限制以避免级联回滚发生，这样的调度称为<code>无级联调度</code>。</li><li><code>可恢复调度</code>：对每对事务$T_i$和$T_j$，如果$T_j$读取了由$T_i$所写的数据项，则$T_i$必须先于$T_j$提交。</li></ul></blockquote><p>3，<strong>事务隔离级别</strong></p><p>1）<strong>并发操作带来的问题</strong></p><blockquote><p>i）<code>丢失修改</code>：又称<code>写-写错误</code>，两个事务$T_1$和$T_2$读入同一数据并修改，$T_2$提交的结果破坏了$T_1$提交的结果，导致$T_1$的修改被丢失。<br>ii）<code>脏读</code>：又称<code>写-读错误</code>，事务$T_1$修改某一数据，并将其写回磁盘，事务$T_2$读取同一数据后，$T_1$由于某种原因被撤销，这时$T_1$已修改过的数据恢复原值，$T_2$读到的数据就与数据库中的数据不一致，则$T_2$读到的数据即为<code>“脏”数据</code>，即<code>不正确的数据</code>。<br>iii）<code>不可重复读</code>：又称<code>读-写错误</code>，事务$T_1$读取某一数据后，事务$T_2$对其做了修改，当$T_1$再次读取该数据时，得到与前次不同的值。<br>iv）<code>幻想读</code>：事务$T_2$按一定条件读取了某些数据后，事务$T_1$插入（删除）了一些满足这些条件的数据，当$T_2$再次按相同条件读取数据时，发现多（少）了一些记录。</p></blockquote><p>2）<strong>事务隔离级别的定义</strong></p><blockquote><p>i）<code>未提交读</code>：又称<code>脏读</code>，允许运行在该隔离级别上的事务读取当前数据页上的任何数据，而不管该数据是否已提交，解决了<code>丢失修改</code>问题。<br>ii）<code>提交读</code>：保证运行在该隔离级别上的事务不会读取其他未提交事务所修改的数据，解决了<code>丢失修改</code>和<code>脏读</code>的问题。<br>iii）<code>可重复读</code>：保证一个事务如果再次访问同一数据，与此前访问相比，数据不会发生修改，解决了<code>丢失修改</code>，<code>脏读</code>和<code>不可重复读</code>问题。<br>iv）<code>可串行化</code>：在这个级别上的一组事务的并发执行与它们的某个串行调度是等价的，解决了并发操作带来的四个不一致问题。</p></blockquote><p>4，<strong><code>SQL Server</code>中的事务定义</strong></p><p>1）<strong>事务定义模式</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN[SACTION] [事务名[<span class="keyword">WITH</span> MARK[<span class="string">'事务描述'</span>]]]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 提交1</span></span><br><span class="line"><span class="keyword">COMMIT</span> [TRAN[SACTION] [事务名]]</span><br><span class="line"><span class="comment">-- 提交2</span></span><br><span class="line"><span class="keyword">COMMIT</span>[<span class="keyword">WORK</span>]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 回滚1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> [TRAN[SACTION] [事务名|保存点名]]</span><br><span class="line"><span class="comment">-- 回滚2</span></span><br><span class="line"><span class="keyword">COMMIT</span>[<span class="keyword">WORK</span>]</span><br></pre></td></tr></table></figure></p><p>2）<strong>事务执行模式</strong></p><blockquote><p>i）<code>显式事务</code>：每个事务均以 <code>BEGIN TRANSACTION</code> 语句显式开始，以 <code>COMMIT</code> 或者 <code>ROLLBACK</code> 语句显式结束。<br>ii）<code>隐性事务</code>：每个事务无须描述事务的开始，但仍以 <code>COMMIT</code> 或 <code>ROLLBACK</code>语句显式完成。<br>iii）<code>自动提交事务</code>：<code>SQL Server</code> 的默认事务管理模式，意指每条单独的语句都是一个事务。在完成每个 <code>T-SQL</code> 语句时，都被提交或者回滚。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐性事务设置方法</span></span><br><span class="line"><span class="keyword">SET</span> IMPLICIT_TRANSACTIONS &#123;<span class="keyword">ON</span>|<span class="keyword">OFF</span>&#125;</span><br></pre></td></tr></table></figure><p>3）<strong>事务隔离级别的定义</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure></p><p>4）<strong>批处理，触发器的事务</strong></p><p><code>批处理</code>是包含一个或者多个<code>SQL</code>语句的组，从应用程序一次性地发送到服务器执行。服务器将批处理语句编译成一个可执行单元，此单元称为<code>执行计划</code>。</p><h2 id="五，并发控制"><a href="#五，并发控制" class="headerlink" title="五，并发控制"></a>五，并发控制</h2><p>1，<strong>相关概念</strong></p><p><code>事务</code>是并发控制的基本单位，<code>事务</code>最基本的特征之一是<code>隔离性</code>。为保证事务的隔离性，系统必须对并发事务之间的相互作用加以控制，这称为<code>并发控制</code>。并发控制的主要技术是<code>封锁</code>。</p><p>2，<strong>封锁技术</strong></p><p>1）<code>封锁</code>：事务$T$在对某个数据库对象操作之前，先向系统发出请求，对其加锁。<strong>最基本</strong>的封锁模式有<code>排他锁(X锁)</code>和<code>共享锁(S锁)</code>。</p><blockquote><p>i）<code>排他锁</code>：又称<code>写锁</code>，如果事务$T$对数据对象$A$加上$X$锁，则只允许$T$读取和修改$A$，其他任何事务都不能再对$A$加任何类型的锁，直到$T$释放$A$上的锁。申请对$A$的排他锁可表示为$XLOCK(A)$。<br>ii）<code>共享锁</code>：又称<code>读锁</code>，如果事务$T$对数据对象$A$加上$S$锁，则只允许$T$读取$A$但不允许修改$A$，其他事务只能再对$A$加$S$锁而不能加$X$锁，直到$T$释放$A$上的$S$锁。申请对$A$的共享锁可表示为$SLOCK(A)$。</p></blockquote><p>3，<strong>事务隔离级别与封锁规则</strong></p><p>1）<code>封锁协议（Locking Protocol）</code>：在运用$X$锁和$S$锁这两种基本封锁对数据对象加锁时，还需要约定规则，如何时申请$X$锁或$S$锁，持锁时间，何时释放等，这些规则称为<code>封锁协议</code>。</p><p>2）<code>长锁</code>：保持到事务结束的锁；<code>短锁</code>：用完就释放的锁。</p><p>4，<strong>封锁粒度（<code>MGL</code>）</strong></p><p>1）<code>封锁粒度</code>定义：封锁对象的大小称为<code>粒度</code>。</p><blockquote><p>i）<code>多粒度封锁</code>：数据库中被封锁的资源按粒度大小会呈现处一种层次关系，元组隶属于关系，关系隶属于数据库，称为<code>粒度树</code>。当为某结点加上意向锁（$I$锁）时，就表明某些内层结点已发生事实上的封锁，防止其他事务再去封锁该结点，这种封锁方式称为<code>多粒度封锁（Multi Granularity Lock）</code>。<br>ii）<code>意向锁</code>：如果对一个结点加意向锁，则说明该节点的下层结点正在加锁；对任意节点加锁时，必须先对它所在的上层结点加意向锁。</p><blockquote><ul><li><code>意向共享锁（IS锁）</code>：如果对一个数据对象加<code>IS</code>锁，表示它的后裔结点拟（意向）加<code>S</code>锁。</li><li><code>意向排他锁（IX锁）</code>：如果对一个数据对象加<code>IX</code>锁，表示它的后裔结点拟（意向）加<code>X</code>锁。</li><li><code>共享意向排他锁（SIX锁）</code>：如果对一个数据对象加<code>SIX</code>锁，表示对它加<code>S</code>锁，再加<code>IX</code>锁。</li></ul></blockquote></blockquote><p>5，<strong>并发控制</strong></p><p>1）<strong><code>SQL Server</code>锁模式</strong>：共享锁（<code>S</code>锁），更新锁（<code>U</code>锁），排他锁（<code>X</code>锁），意向共享锁（<code>IS</code>锁）， 意向排他锁（<code>IX</code>锁），共享意向排他锁（<code>SIX</code>锁）。</p><p>2）<strong><code>SQL Server</code>锁粒度</strong>：行级（<code>Row</code>），页面级（<code>Page</code>），表级（<code>Table</code>）</p><p>3）<strong>强制封锁类型</strong><br>在通常情况下，数据封锁由<code>DBMS</code>控制，对用户是透明的，但可以在<code>SQL</code>语句中加入锁定提示来强制 <code>SQL Server</code> 使用特定类型但锁。</p><h2 id="六，数据库恢复技术"><a href="#六，数据库恢复技术" class="headerlink" title="六，数据库恢复技术"></a>六，数据库恢复技术</h2><p>1，<strong><code>恢复</code>的概念</strong>：负责将数据库从故障所造成的错误状态中恢复到某一已知的正确状态（也称为一致性状态或者完整状态）。</p><p>2，<strong>故障的种类</strong></p><p>1）<code>事务故障</code>：指事务的运行没达到预期对象终点就终止，有两种错误可能造成事务执行失败。</p><blockquote><p>i）<code>非预期故障</code>：是指不能由应用程序处理的故障，如运算溢出，但该事务可以在以后但某个时间重新执行。<br>ii）<code>可预期故障</code>：指应用程序可以发现的事务故障，并且可以控制让事务回滚。</p></blockquote><p>2）<code>系统故障</code>：又称<code>软故障</code>，指在硬件故障，软件错误的影响下，导致内存中的数据丢失，并使得事务处理终止，但未破坏外存中数据库。<br>由于硬件错误和软件漏洞致使系统终止，而不破坏外存内容但故障又称为<code>故障-停止假设</code>。</p><p>3）<code>介质故障</code>：又称<code>硬故障</code>，指由于磁盘的磁头碰撞，瞬时的强磁场干扰等造成磁盘的损坏，破坏外存上的数据库，并影响正在存取的这部分数据的所有事务。</p><p>4）恢复的<strong>基本原理</strong>是<code>冗余</code>，即数据库中任意部分的数据可以根据存储在系统别处的冗余数据来重建。一般的冗余形式：<code>副本</code>和<code>日志</code>。</p><p>3，<strong>恢复的实现技术</strong></p><p>1）<strong><code>数据转储</code></strong>：<code>DBA</code>定期将整个数据库复制到磁带或者在另一个磁盘上保存起来的过程。</p><blockquote><p>i）<code>静态转储</code>：在系统中无运行事务时进行的转储操作，即转储操作开始的时刻，数据库处于一致性状态，而转储期间不允许对数据库的任何存取，修改活动。<br>ii）<code>动态转储</code>：指在转储期间允许对数据库进行存取或修改，即转储与用户事务可以并发执行。<br>iii）全量转储：每次转储全部数据库。<br>iv）增量转储：每次只转储上一次转储后更新过的数据。</p></blockquote><p>2）<strong>登记日志文件</strong></p><p><code>日志</code>是以<code>事务</code>为单位记录数据库每次更新活动的文件，由系统自动记录。遵循以下<strong>原则</strong>：</p><blockquote><p>i）登记的次序严格按并发事务执行的时间次序；<br>ii）必须先写日志文件，然后写数据库。</p></blockquote><p><code>前像</code>：要撤消事务，日志中必须包含数据库发生变化前的所有记录的备份，这些记录称为<code>前像(Before-Images)</code>。</p><p><code>后像</code>：为了恢复事务，日志中必须包含数据库改变之后的所有记录的备份，这些记录称为<code>后像(After-Images)</code>。</p><p>3）<strong>基本日志结构</strong></p><p><code>日志</code>是日志记录(<code>Log Records</code>)的序列，主要包含：</p><blockquote><p>（1）事务开始标识，如&lt;$T_i$ start&gt;；<br>（2）更新日志记录，描述一次数据库写操作，如&lt;$T_i,X_i,V_1,V_2$&gt;</p><blockquote><p>事务标识$T_i$是执行WRITE操作的事务的唯一标识；<br>数据项标识$X_i$是所写数据项的唯一标识，通常是数据项在磁盘上的位置；<br>更新前数据的旧值$V_1$ (对插入操作而言此项为空值)；<br> 更新后数据的新值$V_2$ (对删除操作而言此项为空值)。<br>（3）事务结束标识<br>&lt;$T_i$ COMMIT&gt;，表示事务$T_i$提交；<br>&lt;$T_i$ ABORT&gt;，表示事务$T_i$中止。</p></blockquote></blockquote><p>4，<strong><code>SQL Server</code>基于日志的恢复策略</strong></p><p>1）<strong>事务分类</strong></p><blockquote><p>i）<code>圆满事务</code>：指日志文件中记录了事务的<code>COMMIT</code>标识，说明日志中已经完整地记录下事务所有的更新活动。<br>ii）<code>夭折事务</code>：指日志文件只有事务的开始标识，而无<code>COMMIT</code>标识，说明对事务更新活动的记录是不完整的，无法根据日志来重现事务。</p></blockquote><p>2）<strong>基本的恢复操作</strong></p><blockquote><p>i）<code>重做</code>：对圆满事务所做过的修改操作应执行<code>REDO</code>操作，即重新执行该操作，修改对象赋予其新记录值，这种方法称为<code>前滚</code>。<br>ii）<code>撤销</code>：对夭折事务所做过的修改操作应执行<code>UNDO</code>操作，即撤销该操作，修改对象赋予其旧记录值，这种方法又称为<code>回滚</code>。</p></blockquote><p>3）<strong>事务故障恢复</strong></p><blockquote><p>i）反向扫描日志文件，查找该事务的更新操作；<br>ii）对该事务的更新操作执行逆操作，即将事务更新前的旧值写入数据库；<br>iii）继续反向扫描日志文件，查找其他事务的其他更新操作，做同样处理；<br>iv）如此处理下去，直至读到该事务的开始标识，事务恢复故障完成。</p></blockquote><p>4）<strong>系统故障恢复</strong></p><blockquote><p>i）正向扫描日志文件，找出圆满事务，将其事务标识记入重做队列；找出夭折事务，将其事务标识记入撤销队列；<br>ii）对撤销队列中的各个事务进行撤销处理，即反向扫描日志文件，对每个撤销事务对更新操作执行逆操作；<br>iii）对重做队列中的各个事务进行重做处理，即正向扫描日志文件，对每个重做事务重新执行日志文件登记的操作。</p></blockquote><p>5）<strong>介质故障恢复</strong></p><blockquote><p>i）装入最新的数据库后备副本，将数据库恢复到最近一次转储时的一致性状态；<br>ii）装入相应的日志文件副本，重做已完成的事务。</p></blockquote><p>5，<strong><code>SQL Server</code>的备份与恢复</strong></p><p>1）<strong><code>SQL Server</code>的备份</strong></p><blockquote><p>i）数据库备份：即<code>完全备份</code>。</p></blockquote><ul><li><p>设置简单恢复模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">set</span> <span class="keyword">recovery</span> simple;</span><br></pre></td></tr></table></figure></li><li><p>执行完全备份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- init:如果已存在bak文件，则首先删除，后执行</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">to</span> disk=<span class="string">'E:\mater_full.bak'</span> <span class="keyword">with</span> init;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>ii）<code>差异备份</code>：只存储上一次完备之后发生改变的数据。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- init:如果已存在bak文件，则首先删除，后执行</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">to</span> disk=<span class="string">'E:\mater_diff.bak'</span> <span class="keyword">with</span> init, differential;</span><br></pre></td></tr></table></figure><blockquote><p>iii）<code>日志备份</code>：数据库的恢复模式必须设为完整恢复模式并且必须在数据更改为完整恢复模式后至少执行一次完整数据库备份。</p></blockquote><ul><li><p>设置完整恢复模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">set</span> <span class="keyword">recovery</span> <span class="keyword">full</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行日志备份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">log</span> <span class="keyword">master</span> <span class="keyword">to</span> disk=<span class="string">'E:\master_log.bak'</span></span><br></pre></td></tr></table></figure></li></ul><p>2）<strong><code>SQL Server</code>恢复</strong></p><blockquote><p>i）使用<code>SQL Server</code>管理工具还原数据库<br>ii）使用<code>T-SQL</code>语句从简单备份策略还原数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_full.bak'</span>;</span><br></pre></td></tr></table></figure></p><p>iii）使用<code>T-SQL</code>语句还原差异备份<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_full.bak'</span> <span class="keyword">with</span> norecovery;</span><br><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_diff.bak'</span>;</span><br></pre></td></tr></table></figure></p><p>iv）使用<code>T-SQL</code>语句从完整备份策略还原数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_full.bak'</span> <span class="keyword">with</span> <span class="keyword">replace</span>, norecovery;</span><br><span class="line"><span class="keyword">restore</span> <span class="keyword">log</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_log1.bak'</span> <span class="keyword">with</span> norecovery;</span><br><span class="line"><span class="keyword">restore</span> <span class="keyword">log</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_log2.bak'</span>;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，安全与保护概述&quot;&gt;&lt;a href=&quot;#一，安全与保护概述&quot; class=&quot;headerlink&quot; title=&quot;一，安全与保护概述&quot;
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】数据库的设计与实施</title>
    <link href="https://zhangbc.github.io/2019/04/14/db_design/"/>
    <id>https://zhangbc.github.io/2019/04/14/db_design/</id>
    <published>2019-04-14T10:44:12.000Z</published>
    <updated>2019-04-14T10:46:42.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，数据库设计概述"><a href="#一，数据库设计概述" class="headerlink" title="一，数据库设计概述"></a>一，数据库设计概述</h2><p><code>数据库技术</code>是信息资源开发，管理和服务的最有效手段，从小型 单项事务处理系统到大型的信息系统都利用了数据库技术来保证系统数据的整体性，完整性和共享性。</p><p>1，<strong>数据库设计的内容与特点</strong></p><p>1）<strong>数据库设计</strong>包括<code>结构特性设计</code>与<code>行为特性设计</code>。</p><blockquote><ul><li><code>结构特性设计</code>即数据库框架和数据库结构设计，其结果是得到一个合理的数据模型，以反映真实的事务间的联系，目的是汇总各用户的视图，尽量减少冗余，实现数据共享。结构特性是<code>静态的</code>。</li><li><code>行为特性设计</code>是指应用程序设计，如查询，报表处理等，结构特性必须适应行为特性。</li></ul></blockquote><p>2，<strong>数据库设计方法</strong></p><p>1）<code>新奥尔良方法</code>：将数据库设计分为需求分析，概念设计，逻辑设计，物理设计。</p><p>2）从本质上，规范设计法的<strong>基本思想</strong>是“<code>反复探寻，逐步求精</code>”。</p><p>3，<strong>数据库设计的步骤</strong></p><p>1）<strong>数据库设计的过程</strong>：<code>三大阶段六步骤</code>，即：数据库规范设计，需求分析，概念结构设计，逻辑结构设计，物理结构设计，数据库实施与维护（总体规划阶段，系统开发设计阶段，系统运行与维护阶段）。</p><p>2）<strong>六个步骤</strong>：</p><blockquote><p>（1）<code>数据规划设计</code>：明确数据库建设的总体目标和技术路线，得出数据库设计项目的可行性分析报告，对数据库设计的进度和人员分工做出安排。<br>（2）<code>需求分析</code>：准确弄清用户要求是数据库设计的基础。<br>（3）<code>概念结构设计</code>：数据库逻辑结构依赖于具体的<code>DBMS</code>。概念结构是各用户关心的系统信息结构，是对现实世界的第一层抽象。<br>（4）<code>逻辑结构设计</code>：使概念结构转换为某个<code>DBMS</code>所支持的数据模型，并进行优化。<br>（5）<code>物理结构设计</code>：设计目标是从一个满足用户要求的已确定的逻辑模型出发，设计一个在限定的软件，硬件条件和应用环境下可实现的，运行效率高的数据库结构。<br>（6）<code>数据库实施与维护</code></p></blockquote><h2 id="二，数据库规划"><a href="#二，数据库规划" class="headerlink" title="二，数据库规划"></a>二，数据库规划</h2><p>1，<strong>系统调查</strong>：搞清楚企业的组织层次，得到企业的组织结构图。</p><p>2，<strong>可行性分析</strong>：分析数据库建设是否具有可行性，即从经济，法律，技术等多方面进行可行性论证分析，在此基础上得到可行性报告。</p><p>3，<strong>数据库建设的总体目标和数据库建设的实施总安排</strong></p><h2 id="三，需求分析"><a href="#三，需求分析" class="headerlink" title="三，需求分析"></a>三，需求分析</h2><p>1，<strong>需求分析的任务</strong></p><p>1）<code>需求分析</code>的<strong>任务</strong>：通过详细调查现实世界要处理的对象，充分了解原系统工作概况，明确各用户需求，在此基础上确定新的功能。</p><p>2）<code>需求分析</code>的<strong>重点</strong>：调查，搜集用户在数据管理中的信息要求，处理要求，安全性与完整性要求。</p><blockquote><ul><li><code>信息要求</code>是指用户需要从数据库中获取信息的内容和性质，由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据。</li><li><code>处理要求</code>是指用户要求完成什么样的处理功能，对处理的响应时间有什么要求，处理方式是批处理还是联机处理。</li><li><code>安全性要求</code>是指保护数据不被未授权的用户破坏。</li><li><code>完整性要求</code>是指保护数据不被授权的用户破坏。</li></ul></blockquote><p>2，<strong>需求分析的方法</strong></p><p>1）常用的调查方法</p><blockquote><p>（1）跟班作业<br>（2）开调查会<br>（3）查阅档案资料<br>（4）询问<br>（5）设计调查用表并请用户填写</p></blockquote><p>3，<strong>需求分析的步骤</strong></p><p>1）<strong>分析用户的活动</strong></p><p>2）<strong>确定系统的边界</strong></p><p>3）<strong>分析用户活动所设计的数据</strong><br><code>数据流图（DFD）</code>是描述各处理活动之间数据流动的有力工具，是一种从数据流的角度描述一个组织业务活动的图示。</p><p>4）<strong>分析系统数据</strong></p><p><code>数据字典（DD）</code>是描述每个数据流，每个文件，每个加工的集合，是对数据流图中出现的所有数据元素给出逻辑定义和描述。</p><p><code>数据字典</code>包括<code>数据项</code>，<code>数据文件</code>，<code>数据流</code>，<code>数据加工处理</code>。</p><blockquote><ul><li><code>数据项描述</code>={数据项名，别名，数据项含义，数据类型，字节长度，取值范围，取值含义，与其他数据项的逻辑关系}</li><li><code>数据文件描述</code>={数据文件名，所有数据项名，数据存取频度，存取方式}</li><li><code>数据流描述</code>={数据流名称，所有数据项名，数据流来源，数据流去向，平均流量，峰值流量}</li><li><code>数据加工处理描述</code>={加工处理名，说明，输入的数据流名，输出的数据流名，处理要求}</li></ul></blockquote><h2 id="四，概念结构设计"><a href="#四，概念结构设计" class="headerlink" title="四，概念结构设计"></a>四，概念结构设计</h2><p><code>概念结构设计阶段</code>是将用户需求抽象为信息结构（概念模型）的过程。</p><p>1，<strong>局部E-R图的设计</strong></p><p>2，<strong>全局E-R图的设计</strong></p><h2 id="五，逻辑结构设计"><a href="#五，逻辑结构设计" class="headerlink" title="五，逻辑结构设计"></a>五，逻辑结构设计</h2><p>逻辑模式设计的<strong>主要目标</strong>是产生一个具体<code>DBMS</code>可处理的数据模型和数据库模式，即把概念设计阶段的全局<code>E-R</code>图转换成<code>DBMS</code>支持的数据模型。一般步骤： </p><blockquote><p>（1）将概念结构转换为一般的关系模型，网状模型或层次模型。<br>（2）将转换来的关系模型，网状模型，层次模型向<code>DBMS</code>支持的数据模型转换，变成合适的数据库模式。<br>（3）对模式进行挑战和优化。</p></blockquote><h2 id="六，物理结构设计"><a href="#六，物理结构设计" class="headerlink" title="六，物理结构设计"></a>六，物理结构设计</h2><p>1）在进行数据库的物理结构设计时，首先确定数据库的物理结构，然后是对所设计的物理结构设计进行评价。<br>2）物理结构设计的重要目标是满足主要应用的性能要求。<br>3）就<code>RDBMS</code>而言，物理结构设计主要内容有：为关系模式选取存取方法，设计关系，索引等数据库文件的物理存储结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，数据库设计概述&quot;&gt;&lt;a href=&quot;#一，数据库设计概述&quot; class=&quot;headerlink&quot; title=&quot;一，数据库设计概述&quot;
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】关系模式的规范化与查询优化</title>
    <link href="https://zhangbc.github.io/2019/04/13/db_query_opt/"/>
    <id>https://zhangbc.github.io/2019/04/13/db_query_opt/</id>
    <published>2019-04-13T14:31:38.000Z</published>
    <updated>2019-04-14T06:10:16.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，问题的提出"><a href="#一，问题的提出" class="headerlink" title="一，问题的提出"></a>一，问题的提出</h2><p>1，<strong>关系模式</strong></p><p><code>关系模式</code>定义：一个关系模式是一个系统，它是有一个五元组$R(U, D, DOM, I, F)$组成，其中，$R$为关系名，$U$是$R$的一组属性集合$\{ A_1,A_2,A_3,\dots,A_n \}$，$D$是$U$中属性的域集合$\{ D_1,D_2,D_3,\dots,D_n \}$，$DOM$为属性$U$到域$D$的映射，$I$为完整性约束集合，$F$为属性间的函数依赖关系。</p><p>2，<strong>关系</strong></p><p>1）<code>关系</code>定义：在关系模式$R( U, D, DOM, I, F )$中，当且仅当$U$上的一个关系$r$足$F$时，$r$称为关系模式$R$的一个关系，记作$R(U)$或$R(U,F)$。</p><p>2）关系数据库对关系有一个<strong>最起码的要求</strong>： 每个属性必须是不可分割的数据项。满足列这个条件的关系模式就属于<code>第一范式（1NF）</code>。</p><p>3）<code>数据依赖</code>：通过一个关系中属性间值的相等与否以体现数据间的相互关系，是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。主要有：<code>函数依赖FD</code>，<code>多值依赖MVD</code>。</p><p>3，<strong>插入异常</strong>：表示数据插入时出现问题，即无法在缺少另一个实体实例或者关系实例的情况下表示实体或者实体的信息。</p><p>4，<strong>删除异常</strong>：删除表的某一行来反映某个实体实例或者关系实例消失，会导致丢失另一个不同实例实体或者关系实例的信息。</p><p>5，<strong>更新异常</strong>：更改表所对应的某个实体实例或者关系实例的单个属性，会将多行的相关信息全部更新。</p><h2 id="二，关系模式的函数依赖"><a href="#二，关系模式的函数依赖" class="headerlink" title="二，关系模式的函数依赖"></a>二，关系模式的函数依赖</h2><p>1，<strong>函数依赖（<code>FD</code>）</strong></p><p>1）<code>函数依赖（FD）</code>定义：设$R(U)$是属性集$U$上的关系模式，$X$，$Y \subseteq U$。若对$R(U)$的任意一个可能的关系$r$，$r$中有任意两个元组$t_1$和$t_2$，如果$t_1 [ X ] = t_2 [ X ]$，有$t_1[ Y ] = t_2[ Y ]$，则称$X$函数确定$Y$，或者说$Y$函数依赖$X$，记为$X \rightarrow Y$。</p><blockquote><p>（1）如果$X \rightarrow Y$，但是$Y \nsubseteq X$，则称$X \rightarrow Y$是<code>非平凡的函数依赖</code>；<br>（2）如果$X \rightarrow Y$，但是$Y \subseteq X$，则称$X \rightarrow Y$是<code>平凡的函数依赖</code>；<br>（3）如果$X \rightarrow Y$，则$X$为这个函数依赖的<code>决定属性集(Determinant)</code>；<br>（4）如果$X \rightarrow Y$，$Y \rightarrow X$，则记为$X \longleftrightarrow Y$；<br>（5） 如果$Y$不函数依赖于$X$，则记为$X \nrightarrow Y$。</p></blockquote><p>2）<code>完全函数依赖</code>和<code>部分函数依赖</code><br>设$R(U)$是属性集$U$上的关系模式，如果$X \rightarrow Y$，并且对于$X$的任何一个真子集$Z$，都有$Z \nrightarrow Y$，则称$Y$完全依赖于$X$，记$X \stackrel{f}{\rightarrow} Y$；若$X \rightarrow Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记$X \stackrel{p}{\rightarrow} Y$。</p><p>3）<code>传递函数依赖</code><br>设$R(U)$是属性集$U$上的关系模式，$X \subseteq U$，$Y \subseteq U$，$Z \subseteq U$，$Z - X$，$Z - Y$，$Y - X$均非空，如果$X \rightarrow Y(Y \nsubseteq X)$，$Y \nrightarrow X$，$Y \rightarrow Z$，则称$Z$传递依赖于$X$。</p><p>2，<strong>键</strong></p><blockquote><p>1）<code>候选键</code>：设$R(U)$是属性集$U$上的关系模式，$K \subseteq U$，如果$K \stackrel{f}{\rightarrow}  U$，则$K$为$R$的<code>候选键</code>。<br>候选键包含了关系模式的所有属性，称为<code>全键</code>。<br>2）<code>主属性</code>：包含在任意一个候选键中的属性称为<code>主属性</code>。<br>3）<code>非主属性</code>：不包含在任意候选键中的属性称为<code>非主属性</code>或<code>非键属性</code>。<br>4）<code>外键</code>：在关系模式$R$中属性或者属性组$X$并非$R$的候选键，但$X$是另一个关系模式的候选键，则称$X$是$R$的<code>外部键</code>，也称<code>外键</code>。</p></blockquote><p>3，<strong>函数依赖的逻辑蕴含</strong></p><p>1）<strong>阿姆斯特朗公理体系</strong></p><p>   （1）<code>包含规则</code>：设$R(U)$是属性集$U$上的关系模式，$X \subseteq U$，$Y \subseteq U$，且$Y \subseteq X$，则$X \rightarrow Y$。</p><p>   （2）<code>平凡依赖</code>：由包含规则得到的函数依赖都是平凡函数依赖。</p><p>   （3）<code>逻辑蕴含</code>：设$R(U)$是属性集$U$上的关系模式，$F$是$R$上函数依赖集合，如果$R$的任意关系实例$r$使$F$成立的，函数依赖$X \rightarrow Y$均成立，则称$F$逻辑蕴含$X \rightarrow Y$。</p><p>   （4）<code>阿姆斯特朗公理</code>：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$的一个函数依赖集合，$X \subseteq U$，$Y \subseteq U$，$Z \subseteq U$。包含如下规则：</p><blockquote><p>i）<code>包含规则</code>：又称<code>自反律</code>，如果$Y \subseteq X \subseteq Z$，则$X \rightarrow Y$为$F$所蕴含；<br>ii）<code>传递规则</code>：如果$F$蕴含$X \rightarrow Y$，$Y \rightarrow Z$，则$X \rightarrow Z$为$F$所蕴含；<br>iii）<code>增广规则</code>：如果$F$蕴含$X \rightarrow Y$，且$Z \subseteq U$，则$XZ \rightarrow YZ$为$F$所蕴含。</p></blockquote><p><code>阿姆斯特朗公理</code>包含蕴含规则如下：</p><blockquote><p>i）<code>合并规则</code>：如果$X \rightarrow Y$，$X \rightarrow Z$，则$X \rightarrow YZ$；<br>ii）<code>伪传递规则</code>：如果$X \rightarrow Y$，$WY \rightarrow Z$，则$WX \rightarrow Z$；<br>iii）<code>分解规则</code>：如果$X \rightarrow Y$，$Z \subseteq Y$，则$X \rightarrow Z$；<br>iv）<code>集合累积规则</code>：如果$X \rightarrow YZ$且$Z \rightarrow W$，则$X \rightarrow YZW$。</p></blockquote><p><strong>【<code>引理4-1</code>】</strong> $X \rightarrow A_1A_2A_3 \dots A_n$ 成立的充分必要条件是$X \rightarrow A_i（i=1，2，\dots，n）$成立。</p><p>2）<strong>闭包，覆盖和最小覆盖</strong></p><p>（1）<code>函数依赖的闭包</code>：设$R$是一个具有属性集合$U$的关系模式，$F$是给定的函数依赖的集合，由$F$推导出的所有函数依赖的集合称为$F$的<code>闭包</code>，记作$F^{+}$。</p><p>（2）<code>函数依赖集的覆盖</code>：$R$表上的两个函数依赖集合$F$和$G$，如果函数依赖集$G$可以从$F$用<code>蕴含规则</code>推导出来，换言之，如果 $G \subset  F^{+}$，则称$F$ <code>覆盖</code> $G$，如果$F$ 覆盖 $G$ 且 $G$ 覆盖 $F$，则称这两个<code>函数依赖集等价</code>，记作$F \equiv G$。</p><p>（3）<code>属性集的闭包</code>：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$上的函数依赖集，$X \subseteq U$，定义$X$的<code>闭包</code> $X^+$，作为$X$函数决定的最大属性集$Y$，则最大属性集满足 $X \rightarrow Y$ 存在于 $F^+$ 中。</p><p><strong>【<code>算法4-1</code>】</strong> 属性集 $X$ 的闭包 $X^+$ 的迭代算法：</p><blockquote><p>i）选$X$作为闭包$X^+$的初始值$X[0]$；<br>ii）由$X[i]$计算$X[i+1]$时，它是由 $X[i]$ 并上属性集合$A$所组成的，其中$A$为$F$中存在的函数依赖 $Y \rightarrow Z$，而$A \subseteq Z$，$Y \subseteq X[i]$。因为$U$是有穷的所以上述过程经过有限步后会达到$X[i] = X[i+1]$，此时$X[i]$为所求的$X^+$。</p></blockquote><p>（4）<code>最小覆盖</code></p><blockquote><p>i）$F$中任意函数依赖的右部只包含一个属性；<br>ii）不存在这样的函数依赖 $X \rightarrow A$，使得$F$与 $F- \{ X \rightarrow A \}$ 等价；<br>iii）不存在这样的函数依赖$X \rightarrow A$，$X$包含真子集$Z(Z \subset X)$，使得 $(F-\{ X \rightarrow A \} \cup \{ Z \rightarrow A \})$与$F$等价。<br>如果$F$满足上述条件，则函数依赖$F$称为<code>极小或者最小函数依赖集</code>。</p></blockquote><p>（5）<code>最小覆盖集算法</code></p><p>从函数依赖集$F$构造最小覆盖$M$的算法如下：</p><blockquote><p>i）从函数依赖集$F$，创建函数依赖的一个等价集$H$，它的函数依赖的右边只有单个属性（使用<code>分解规则</code>）<br>ii）从函数依赖集$H$，顺次去掉在$H$中非关键的单个函数依赖。一个函数依赖$X \rightarrow Y$在一个函数依赖集中是非关键的，指如果 $X \rightarrow Y$ 从$H$中去掉，得到结果$J$，仍然满足$H^+ = J^+$，或者说$H \equiv J$。<br>iii）从函数依赖集$J$，顺次用左边具有更少属性的函数依赖替换原来的函数依赖，只要不会导致$J^+$改变。<br>iv）从剩下的函数依赖集中收集所有左边相同的函数依赖，使用<code>合并规则</code>创建一个等价的函数依赖集$M$，它的所有依赖的左边是<code>唯一</code>的。</p></blockquote><p>（6）每个函数依赖集$F$都等价于一个极小函数依赖集。</p><h2 id="三，关系模式的规范化"><a href="#三，关系模式的规范化" class="headerlink" title="三，关系模式的规范化"></a>三，关系模式的规范化</h2><p><code>规范化</code>定义：把一个给定规范模式转化为某种范式的过程称为<code>关系模式的规范过程</code>，简称<code>规范化</code>。</p><p>1，<strong>第一范式</strong></p><p><strong>【<code>定义4-1</code>】</strong> 设$R$是一个关系模式，如果$R$的每个属性的值域都是<strong>不可分割</strong>的简单数据项的集合，则这个模式称为<code>第一范式关系模式</code>，记作<code>1NF</code>。</p><p>2，<strong>第二范式</strong></p><p><strong>【<code>定义4-2</code>】</strong> 如果关系模式$R$是<code>第一范式</code>，而且每个非主属性都<strong>完全函数依赖</strong>于$R$的键，则$R$称为<code>第二范式的关系模式</code>，记作<code>2NF</code>。</p><p>3，<strong>第三范式</strong></p><p><strong>【<code>定义4-3</code>】</strong> 设关系模式$R$满足<code>2NF</code>，而且它的任意一个非键属性都<strong>不传递依赖</strong>于任何候选键，则$R$称为<code>第三范式的关系模式</code>，记作<code>3NF</code>。</p><p>4，<strong>BCNF</strong></p><p><strong>【<code>定义4-4</code>】</strong> 设关系模式$R$满足<code>1NF</code>，如果对$R$的每个函数依赖 $X \rightarrow Y$ 且 $Y \nsubseteq X$，$X$必为<code>候选键</code>，则$R$满足<code>BCNF</code>，即：在关系模式 $R(U,F)$ 中，如果每个决定因素都包含键，则$R(U,F) \in BCNF$。</p><p><em>一个满足<code>BCNF</code>的关系模式有如下</em> <strong>条件</strong>：</p><blockquote><p>i）所有非键属性对每个键都是完全函数依赖；<br>ii）所有的键属性对每个不包含它的键，也是完全函数依赖；<br>iii）没有任何属性完全函数依赖于非键属性的任意一组属性。</p></blockquote><p>5，<strong>多值依赖与第四范式</strong></p><p>1）<strong>多值依赖</strong></p><p>   （1）<code>多值依赖</code>定义：设 $R(U)$ 是属性集$U$上的一个关系模式，$X$，$Y$，$Z$是$U$的子集，并且 $Z=U-X-Y$，关系模式$R(U)$中多值依赖 $X \rightarrow \rightarrow Y$ 成立，当且仅当对$R(U)$的任意关系$r$，给定的一对 $(x，z)$ 值，有一组$Y$的值，这组值仅仅取决于$x$值，而与$z$值无关。</p><p>   （2）如果 $X \rightarrow \rightarrow Y$，而 $Z=\varnothing$，即$Z$为空，则 $X \rightarrow \rightarrow Y$ 称为<code>平凡的多值依赖</code>。</p><p>   （3）<code>多值依赖的公理</code>（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。）</p><blockquote><p>i）<code>对称性规则</code>：如果 $X \rightarrow \rightarrow Y$，则 $X  \rightarrow \rightarrow U-X-Y$；<br>ii）<code>传递性规则</code>：如果 $X \rightarrow \rightarrow Y$，$Y  \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow Z-Y$；<br>iii）<code>增广规则</code>：如果 $X \rightarrow \rightarrow Y$，$V \subseteq W$，则 $WX  \rightarrow \rightarrow VY$；<br>iv）<code>替代规则</code>：如果 $X  \rightarrow Y$，则$X \rightarrow \rightarrow Y$；<br>v）<code>聚集规则</code>：如果$X \rightarrow \rightarrow Y$，$Z \subseteq Y$，$W \cap Z = \varnothing$，$W \rightarrow Z$，则 $X \rightarrow Z$。</p></blockquote><p>   （4）<code>多值依赖的推导规则</code>（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。）</p><blockquote><p>i）<code>合并规则</code>：如果 $X \rightarrow \rightarrow Y$， $X \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow YZ$；<br>ii）<code>分解规则</code>：如果 $X \rightarrow \rightarrow Y$， $X \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow Y \cap Z$，$X \rightarrow \rightarrow Y-Z$，$X \rightarrow \rightarrow Z-Y$；<br>iii）<code>伪传递规则</code>：如果 $X \rightarrow \rightarrow Y$，$WY \rightarrow \rightarrow Z$，则 $WX \rightarrow \rightarrow (Z-WY)$；<br>iv）<code>混合伪传递规则</code>：如果 $X \rightarrow \rightarrow Y$，$XY \rightarrow Z$，则 $X \rightarrow (Z-Y)$。</p></blockquote><p>   （5）在$R(U)$上，如果有 $X \rightarrow \rightarrow Y$ 在 $W(W \subseteq U)$ 上成立，则 $X \rightarrow \rightarrow Y$ 称为$R(U)$的<code>嵌入型多值依赖</code>。</p><p>2）<strong>第四范式</strong></p><p><strong>【<code>定义4-5</code>】</strong>  设关系模式 $R(U,F) \in 1NF$，$F$是$R$上的多值依赖集，如果$R$的每个非平凡多值依赖 $X \rightarrow \rightarrow Y$（$Y-X \ne \varnothing$，$XY$未包含$R$的全部属性），$X$都含有$R$的候选键，则称$R$是<code>第四范式</code>，记为<code>4NF</code>。</p><p>6，<strong>各范式之间的关系</strong></p><p>1）<strong>各范式之间的关系</strong></p><script type="math/tex; mode=display">4NF \subset BCNF \subset 3NF \subset 2NF \subset 1NF</script><p>2）<strong>各范式小结</strong><br><img src="/images/db_query_opt_normal_form_20190413.png" alt="各范式小结"></p><blockquote><p>i）$4NF$：限制关系模式的属性之间<code>不允许</code>有非平凡且非函数依赖的多值依赖；<br>ii）$3NF \rightarrow BCNF$：消除主属性对候选关键字的<code>部分和传递</code>函数依赖；<br>iii）$2NF \rightarrow 3NF$：消除非主属性对候选关键字的<code>传递</code>函数依赖；<br>iv）$1NF \rightarrow 2NF$：消除非主属性对候选关键字的<code>部分</code>函数依赖。</p></blockquote><h2 id="四，关系模式的分解特性"><a href="#四，关系模式的分解特性" class="headerlink" title="四，关系模式的分解特性"></a>四，关系模式的分解特性</h2><p>1，<strong>关系模式的分解</strong></p><p>1）<code>关系模式的分解</code>定义：把一个关系模式分解成若干个关系模式的过程，称为<code>关系模式的分解</code>。</p><p><strong>【<code>定义4-6</code>】</strong> 关系模式$R(U, F)$ 的分解是指$R$为它的一组子集 $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 所代替的过程。其中，$U=U_1 \cup U_2 \dots \cup U_k$，并且设 $U_i \subseteq U_j(1 \le i,j \le k)$，$F_i$是$F$在$U$上的投影，即 $F_i = \{X \rightarrow Y \in F^+ \wedge XY \subseteq U_i \}$。</p><p>   分解后表的连接丢失或者多余元组的分解称为<code>有损分解</code>，或称<code>有损连接分解</code>。</p><p>2）<code>关系模式的分解</code>遵守原则： </p><blockquote><p>i）<code>无损连接性</code>：信息不失真（不增减信息）；<br>ii）<code>函数依赖保持性</code>：不破坏属性间存在的依赖关系。</p></blockquote><p>2，<strong>分解的无损连接性</strong></p><p>1）<strong>无损连接的概念</strong></p><p><strong>【<code>定义4-7</code>】</strong> 设$F$是关系模式$R$的函数依赖集，$\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 是$R$ 的一个分解，$r$是$R$的一个关系，定义</p><script type="math/tex; mode=display">m_{\rho}(r)=\pi_{U_{1}}(r) \infty \pi_{U_{2}}(r) \infty \cdots \infty_{\pi_{U_{k}}}(r)</script><p>如果$R$满足$F$的任意关系$r$均有则$r=m_\rho(r)$，则称分解 $\rho$ <code>具有无损连接性</code>。</p><p><strong>【<code>引理4-2</code>】</strong> 设 $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 为关系模式$R$的一个分解， $r$是$R$的任一个关系，有</p><blockquote><p>(1) $r \subseteq m_\rho(r)$；<br>(2) 如果 $s = m_\rho(r)$， 则 $\pi_{U_{i}}(r) = \pi_{U_{i}}(s)$；<br>(3) $m_\rho(m_\rho(r)) = m_\rho(r)$。</p></blockquote><p>2）<strong>进行关系分解的必要性</strong></p><p>一个关系模式分解后，可以存放原来所不能存放的信息，通常称为“<code>悬挂</code>”的元组，这是实际所需要的，也是分解的优点。</p><p>3）<strong>无损连接判定方法</strong></p><p><strong>【<code>算法4-2</code>】</strong> (<code>矩阵法</code>)判别一个分解的无损连接性的算法。</p><blockquote><p>(1) 构造初始表：构造一个$k$行$n$列的初始表，其中，每列对应于$R$的一个属性，每行用于表示分解后的一个模式组成。如果属性$A_j$属于关系模式$R_i$，则表示在表的第$i$行第$j$列置符号$a_j$，否则置符号$b_{ij}$。<br>(2) 根据$F$中的函数依赖修改表的内容：考察$F$中的每个函数依赖 $X \rightarrow Y$，在属性组$X$所在的那些列上寻找具有相同符号的行，如果找到这样的两行或者更多行，则修改这些行，使这些行上属性组$Y$所在的列上元素相同。<code>修改规则</code>是：如果$Y$所在的要修改的行有一个为$a_j$，则这些元素均变成$a_j$；否则改为$b_{mj}$（其中$m$为这些行的最小行号）。<br>(3) 判断分解是否为无损连接：如果通过修改，发现表中有一行变为 $a_1,a_2,\dots,a_n$，则<code>分解是无损连接的</code>，否则<code>分解不具有无损连接性</code>。</p></blockquote><p><strong>【<code>定理4-1</code>】</strong> （<code>定理法</code>）设 $\rho = \{ R_1,R_2 \}$ 是关系模式$R$的一个分解，$F$是$R$的函数依赖集，$U_1$，$U_2$和$U$分别是$R_1$，$R_2$和$R$的属性集合，那么$\rho$是$R$(关于$F$)的无损分解的充分必要条件为</p><script type="math/tex; mode=display">(U_1\cap U_2) \rightarrow U_1 - U_2 \in F^+</script><p><code>或者</code>  </p><script type="math/tex; mode=display">(U_1\cap U_2) \rightarrow U_2 - U_1 \in F^+</script><p><strong>【<code>定理4-2</code>】</strong> （<code>逐步分解定理</code>）设$F$是关系模式$R$的函数依赖集，$\rho = \{ R_1,R_2,\dots,R_k \}$ 是$R$关于$F$的一个无损连接。</p><blockquote><p>（1）如果 $\sigma = \{ S_1,S_2,\dots,S_m \}$ 是 $R_i$ 关于 $F_i$ 的一个无损连接分解，则 $\varepsilon = \{ R_1,R_2,\dots,R_{i-1},S_1,S_2,\dots,S_m,R_{i+1},\dots,R_k \}$ 是$R$关于$F$的无损连接分解，其中，$F_i = \pi_{R_i}(F)$。<br>（2）设 $\tau = \{ R_1,\dots,R_{k},R_{k+1},\dots,R_n \}$ 是 $R$ 的一个分解，其中，$\tau \supseteq \rho$，$\tau$ 也是$R$关于$F$的无损连接分解。</p></blockquote><p>3）<strong>分解的函数依赖保持性</strong></p><p><strong>【<code>定义4-8</code>】</strong> 设$F$是关系模式$R$的函数依赖集， $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 为$R$的一个分解，如果 $F_i = \pi_{R_i}(F)(i=1,2,\dots,k)$ 的并集 $(F_1 \cup F_2 \cup \dots \cup F_k)^+ \equiv F^+$，则称分解 $\rho$ 具有<code>函数依赖保持性</code>。</p><p>3，<strong>关系模式分解算法</strong></p><p>1）<strong>分解的基本要求</strong>：分解后的关系模式与分解前的关系模式等价，即分解必须具有<code>无损连接</code>和<code>函数依赖保持性</code>。</p><p>2）<strong>分解算法的结论</strong></p><blockquote><p> i）如果要求分解具有<code>无损连接性</code>，则分解一定可以达到<code>BCNF</code>；<br> ii）如果要求分解保持<code>函数依赖</code>，则分解可以达到<code>3NF</code>，但不一定能够达到<code>BCNF</code>；<br> iii）如果要求分解既具有<code>无损连接性</code>，又保持<code>函数依赖</code>，则分解可以达到<code>3NF</code>，但不一定能够达到<code>BCNF</code>。</p></blockquote><h2 id="五，关系模式的优化"><a href="#五，关系模式的优化" class="headerlink" title="五，关系模式的优化"></a>五，关系模式的优化</h2><p>1，<strong>水平分解</strong></p><p>1）<code>水平分解</code>的<strong>定义</strong>：<code>水平分解</code>是把关系元组分为若干个子集合，每个子集合定义为一个子关系，以提高系统效率的过程。</p><p>2）<code>水平分解</code>的<strong>规则</strong>：</p><blockquote><p>（1）根据“<code>80%与20%原则</code>”，在一个大型关系中，经常使用的数据只是很有限的一部分，可以把经常使用的数据分解出来形成一个子关系。<br>（2）如果关系$R$上具有$n$个事务，而且多数事务存取的数据不相交，则$R$可分解为不大于$n$个子关系，使每个事务存取的数据形成一个关系。</p></blockquote><p>2，<strong>垂直分解</strong></p><p>1）<code>垂直分解</code>的<strong>定义</strong>设 $R(A_1,A_2,\dots,A_k)$ 是关系模式，$R$的一个垂直分解是$n$个关系的集合$\{ R_1(B_1,B_2,\dots,B_v),\dots,R_n(D_1,D_2,\dots,D_m) \}$，其中，$\{B_1,B_2,\dots,B_v \},\dots,\{ D_1,D_2,\dots,D_m \}$ 是 $\{ A_1,A_2,\dots,A_k  \}$ 的子集合。</p><p>2）<code>垂直分解</code>的<strong>基本原则</strong>：经常在一起使用的属性从$R$中分解出来形成一个独立的关系。</p><h2 id="六，关系查询优化"><a href="#六，关系查询优化" class="headerlink" title="六，关系查询优化"></a>六，关系查询优化</h2><p>1，<strong>关系系统及其查询优化</strong></p><p>1）<strong>查询优化工作</strong>：</p><blockquote><p>i）关系数据库内部提供的优化机制；<br>ii）用户通过改变查询的运算次序和建立索引等机制进行优化。</p></blockquote><p>2）<strong>关系数据库查询优化的<code>总目标</code></strong>：选择有效的策略，快速求得给定关系表达式的值，以减少查询执行的总开销。</p><p>3）<strong>查询执行的开销计算</strong></p><blockquote><p>i）在集中式数据库中，<code>总代价=I/O代价+CPU代价</code><br>ii）在多用户环境下，<code>总代价=I/O代价+CPU代价+内存代价</code></p></blockquote><p>2，<strong>查询优化的一般策略</strong></p><blockquote><p>1）尽量先执行选择运算<br>2）在执行连接前对关系适当地预处理：</p><blockquote><p>i）索引连接；<br>ii）排序合并连接</p></blockquote></blockquote><p>3，<strong>关系代数等价变换规则</strong></p><p>1）<code>连接，笛卡尔积交换律</code></p><script type="math/tex; mode=display">E_1 \times E_2 \equiv E_2 \times E_1</script><script type="math/tex; mode=display">E_{1} \infty E_{2} \equiv E_{2} \infty E_{1}</script><script type="math/tex; mode=display">\begin{array}{c}{E_{1} \infty E_{2}} \\ {F}\end{array} \equiv \begin{array}{c}{E_{2} \infty E_{1}} \\ {F}\end{array}</script><p>2）<code>连接，笛卡尔积结合律</code></p><script type="math/tex; mode=display">(E_1 \times E_2) \times E_3 \equiv E_1 \times (E_2 \times E_3)</script><script type="math/tex; mode=display">(E_{1} \infty E_{2}) \infty E_{3} \equiv E_{1} \infty (E_{2} \infty E_{3})</script><script type="math/tex; mode=display">\begin{array}{c}{(E_{1} \infty E_{2}) \infty E_{3}} \\ {F_1} \quad \quad {F_2} \end{array} \equiv \begin{array}{c}{E_{1} \infty (E_{2} \infty E_{3})} \\ {F_1} \quad \quad {F_2} \end{array}</script><p>3）<code>投影的串接定律</code></p><script type="math/tex; mode=display">\pi A_1,A_2,\dots,A_n(\pi B_1,B_2,\dots.B_m(E)) = \pi A_1,A_2,\dots,A_n(E)</script><p>4）<code>选择的串接定律</code></p><script type="math/tex; mode=display">\sigma_{F_1}(\sigma_{F_2}(E)) \equiv \sigma_{F_1 \wedge F_2}(E)</script><p>5）<code>选择与投影的交换律</code></p><script type="math/tex; mode=display">F(\pi A_1,A_2,\dots,A_n(E)) \equiv \pi A_1,A_2,\dots,A_n(\sigma_F(E))</script><p>6）<code>选择与笛卡尔积的交换律</code></p><script type="math/tex; mode=display">\sigma_F(E_1 \times E_2) \equiv \sigma_F(E_1) \times E_2</script><script type="math/tex; mode=display">\sigma_F(E_1 \times E_2) \equiv \sigma_{F_1}(E_1) \times \sigma_{F_2}(E_2) （其中F = F_1 \wedge F_2）</script><script type="math/tex; mode=display">\sigma_F(E_1 \times E_2) \equiv \sigma_{F_2}(\sigma_{F_1} (E_1) \times E_2)</script><p>7）<code>选择与并运算的交换</code><br>设$E = E_1 \cup E_2$，$E_1$、$E_2$有相同的属性名，则</p><script type="math/tex; mode=display">\sigma_F(E_1 \cup E_2) \equiv \sigma_F(E_1) \cup \sigma_F(E_2)</script><p>8）<code>选择与差运算的交换</code></p><script type="math/tex; mode=display">\sigma_F(E_1 - E_2) \equiv \sigma_F(E_1) - \sigma_F(E_2)</script><p>9）<code>投影与笛卡尔积的交换</code></p><script type="math/tex; mode=display">\pi A_1,A_2,\dots,A_n,B_1,B_2,\dots,B_m(E_1 \times E_2) \equiv \pi A_1,A_2,\dots,A_n(E_1) \cup \pi B_1,B_2,\dots,B_m(E_2)</script><p>10）<code>投影与并运算的交换</code></p><script type="math/tex; mode=display">\pi A_1,A_2,\dots,A_n(E_1 \cup E_2) \equiv \pi A_1,A_2,\dots,A_n(E_1) \cup \pi A_1,A_2,\dots,A_m(E_2)</script><p>4，<strong>关系代数表达式的优化算法</strong></p><ul><li>关系系统的查询优化步骤：<blockquote><p>（1）把查询转换成某种内部表示<br>（2）把语法树转换成标准（优化）形式<br>（3）选择底层的存取路径<br>（4）生成查询计划，选择代价最小的查询计划</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，问题的提出&quot;&gt;&lt;a href=&quot;#一，问题的提出&quot; class=&quot;headerlink&quot; title=&quot;一，问题的提出&quot;&gt;&lt;/a&gt;一
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java基础100实例</title>
    <link href="https://zhangbc.github.io/2019/04/12/java_code_100/"/>
    <id>https://zhangbc.github.io/2019/04/12/java_code_100/</id>
    <published>2019-04-12T14:52:13.000Z</published>
    <updated>2019-04-12T15:03:08.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><ul><li><em>通过<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a>的初步学习，现将其教程训练代码汇聚成篇。</em></li></ul><h1 id="菜鸟教程-Java-Coding学习笔记"><a href="#菜鸟教程-Java-Coding学习笔记" class="headerlink" title="菜鸟教程-Java Coding学习笔记"></a>菜鸟教程-Java Coding学习笔记</h1><blockquote><ol><li>Applet应用程序实例</li><li>文档注释演示实例</li><li>序列化和反序列化</li><li>Socket编程—服务端实例</li><li>Socket编程—客户端实例</li><li>Java进阶知识<blockquote><ul><li>遍历演示</li><li>Map遍历实例</li><li>泛型方法实例 </li><li>泛型的有界类型参数实例</li><li>泛型类实例</li><li>类型通配符实例</li></ul></blockquote></li><li>发邮件(纯文本，HTML文本，附件)</li><li>图片二进制转换</li><li>JAVA8新特性实例</li><li>JAVA操作MYSQL实例</li></ol></blockquote><h1 id="菜鸟教程-Java实例"><a href="#菜鸟教程-Java实例" class="headerlink" title="菜鸟教程-Java实例"></a>菜鸟教程-Java实例</h1><h2 id="Java-环境设置实例"><a href="#Java-环境设置实例" class="headerlink" title="Java 环境设置实例"></a>Java 环境设置实例</h2><blockquote><blockquote><ol><li>Java实例 – 如何编译一个Java文件？</li><li>Java实例 – Java如何运行一个编译过的类文件？</li><li>Java实例 – 如何执行指定class文件目录（classpath）？</li><li>Java实例 – 如何查看当前Java运行的版本？</li></ol></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -d . HelloWorld.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.runoob.HelloWorld</span></span><br></pre></td></tr></table></figure><h2 id="Java-字符串"><a href="#Java-字符串" class="headerlink" title="Java 字符串"></a>Java 字符串</h2><blockquote><blockquote><ol><li>Java 实例 – 字符串比较</li><li>Java 实例 - 查找字符串最后一次出现的位置</li><li>Java 实例 - 删除字符串中的一个字符</li><li>Java 实例 - 字符串替换</li><li>Java 实例 - 字符串反转</li><li>Java 实例 - 字符串查找</li><li>Java 实例 - 字符串分割</li><li>Java 实例 - 字符串分割(StringTokenizer)</li><li>Java 实例 - 字符串大小写转换</li><li>Java 实例 - 测试两个字符串区域是否相等</li><li>Java 实例 - 字符串性能比较测试</li><li>Java 实例 - 字符串优化</li><li>Java 实例 - 字符串格式化</li><li>Java 实例 - 连接字符串</li></ol></blockquote></blockquote><h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h2><blockquote><blockquote><ol><li>Java 实例 – 数组排序及元素查找</li><li>Java 实例 – 数组添加元素</li><li>Java 实例 – 获取数组长度</li><li>Java 实例 – 数组反转</li><li>Java 实例 – 数组输出</li><li>Java 实例 – 数组获取最大和最小值</li><li>Java 实例 – 数组合并</li><li>Java 实例 – 数组填充</li><li>Java 实例 – 数组扩容</li><li>Java 实例 – 查找数组中的重复元素</li><li>Java 实例 – 删除数组元素</li><li>Java 实例 – 数组差集</li><li>Java 实例 – 数组交集</li><li>Java 实例 – 在数组中查找指定元素</li><li>Java 实例 – 判断数组是否相等</li><li>Java 实例 - 数组并集</li></ol></blockquote></blockquote><h2 id="Java-时间处理"><a href="#Java-时间处理" class="headerlink" title="Java 时间处理"></a>Java 时间处理</h2><blockquote><blockquote><ol><li>Java 实例 - 格式化时间（SimpleDateFormat）</li><li>Java 实例 - 获取当前时间</li><li>Java 实例 - 获取年份、月份等</li><li>Java 实例 - 时间戳转换成时间</li></ol></blockquote></blockquote><h2 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h2><blockquote><blockquote><ol><li>Java 实例 – 方法重载</li><li>Java 实例 – 输出数组元素</li><li>Java 实例 – 汉诺塔算法</li><li>Java 实例 – 斐波那契数列</li><li>Java 实例 – 阶乘</li><li>Java 实例 – 方法覆盖</li><li>Java 实例 – instanceOf 关键字用法</li><li>Java 实例 – break 关键字用法</li><li>Java 实例 – continue 关键字用法</li><li>Java 实例 – 标签(Label)</li><li>Java 实例 – enum 和 switch 语句使用</li><li>Java 实例 – Enum（枚举）构造函数及方法的使用</li><li>Java 实例 – for 和 foreach循环使用</li><li>Java 实例 – Varargs 可变参数使用</li><li>Java 实例 – 重载(overloading)方法中使用 Varargs</li></ol></blockquote></blockquote><h2 id="打印图形"><a href="#打印图形" class="headerlink" title="打印图形"></a>打印图形</h2><blockquote><blockquote><ol><li>Java 实例 – 打印菱形</li><li>Java 实例 – 九九乘法表</li><li>Java 实例 – 打印三角形</li><li>Java 实例 – 打印倒立的三角形</li><li>Java 实例 – 打印平行四边形</li><li>Java 实例 – 打印矩形</li></ol></blockquote></blockquote><h2 id="Java-文件操作"><a href="#Java-文件操作" class="headerlink" title="Java 文件操作"></a>Java 文件操作</h2><blockquote><blockquote><ol><li>Java 实例 - 文件写入</li><li>Java 实例 - 读取文件内容</li><li>Java 实例 - 删除文件</li><li>Java 实例 - 将文件内容复制到另一个文件</li><li>Java 实例 - 向文件中追加数据</li><li>Java 实例 - 创建临时文件</li><li>Java 实例 - 修改文件最后的修改日期</li><li>Java 实例 - 获取文件大小</li><li>Java 实例 - 文件重命名</li><li>Java 实例 - 设置文件只读</li><li>Java 实例 - 检测文件是否存在</li><li>Java 实例 - 在指定目录中创建文件</li><li>Java 实例 - 获取文件修改时间</li><li>Java 实例 - 创建文件</li><li>Java 实例 - 文件路径比较</li></ol></blockquote></blockquote><h2 id="Java-目录操作"><a href="#Java-目录操作" class="headerlink" title="Java 目录操作"></a>Java 目录操作</h2><blockquote><blockquote><ol><li>Java 实例 - 递归创建目录</li><li>Java 实例 - 删除目录</li><li>Java 实例 - 判断目录是否为空</li><li>Java 实例 - 判断文件是否隐藏</li><li>Java 实例 - 获取目录大小</li><li>Java 实例 - 在指定目录中查找文件</li><li>Java 实例 - 获取文件的上级目录</li><li>Java 实例 - 获取目录最后修改时间</li><li>Java 实例 - 打印目录结构</li><li>Java 实例 - 遍历指定目录下的所有目录</li><li>Java 实例 - 遍历指定目录下的所有文件</li><li>Java 实例 - 在指定目录中查找文件</li><li>Java 实例 - 遍历系统根目录</li><li>Java 实例 - 查看当前工作目录</li><li>Java 实例 - 遍历目录</li></ol></blockquote></blockquote><h2 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h2><blockquote><blockquote><ol><li>Java 实例 - 异常处理方法</li><li>Java 实例 - 多个异常处理（多个catch）</li><li>Java 实例 - Finally的用法</li><li>Java 实例 - 使用 catch 处理异常</li><li>Java 实例 - 多线程异常处理</li><li>Java 实例 - 获取异常的堆栈信息</li><li>Java 实例 - 重载方法异常处理</li><li>Java 实例 - 链试异常</li><li>Java 实例 - 自定义异常</li></ol></blockquote></blockquote><h2 id="Java-数据结构"><a href="#Java-数据结构" class="headerlink" title="Java 数据结构"></a>Java 数据结构</h2><blockquote><blockquote><ol><li>Java 实例 – 数字求和运算</li><li>Java 实例 – 利用堆栈将中缀表达式转换成后缀</li><li>Java 实例 – 在链表（LinkedList）的开头和结</li><li>Java 实例 – 获取链表（LinkedList）的第一个</li><li>Java 实例 – 删除链表中的元素</li><li>Java 实例 – 获取链表的元素</li><li>Java 实例 – 获取向量元素的索引值</li><li>Java 实例 – 栈的实现</li><li>Java 实例 – 链表元素查找</li><li>Java 实例 – 压栈出栈的方法实现字符串反转</li><li>Java 实例 – 队列（Queue）用法</li><li>Java 实例 – 获取向量的最大元素</li><li>Java 实例 – 链表修改</li><li>Java 实例 – 旋转向量</li></ol></blockquote></blockquote><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><blockquote><blockquote><ol><li>Java 实例 – 数组转集合</li><li>Java 实例 – 集合比较</li><li>Java 实例 – HashMap遍历</li><li>Java 实例 – 集合长度</li><li>Java 实例 – 集合打乱顺序</li><li>Java 实例 – 集合遍历</li><li>Java 实例 – 集合反转</li><li>Java 实例 – 删除集合中指定元素</li><li>Java 实例 – 只读集合</li><li>Java 实例 – 集合输出</li><li>Java 实例 – 集合转数组</li><li>Java 实例 – List 循环移动元素</li><li>Java 实例 – 查找 List 中的最大最小值</li><li>Java 实例 – 遍历 HashTable 的键值</li><li>Java 实例 – 使用 Enumeration 遍历 HashTable</li><li>Java 实例 – 集合中添加不同类型元素</li><li>Java 实例 – List 元素替换</li><li>Java 实例 – List 截取</li></ol></blockquote></blockquote><h2 id="Java-网络实例"><a href="#Java-网络实例" class="headerlink" title="Java 网络实例"></a>Java 网络实例</h2><blockquote><blockquote><ol><li>Java 实例 – 获取指定主机的IP地址</li><li>Java 实例 – 查看端口是否已使用</li><li>Java 实例 – 获取本机ip地址及主机名</li><li>Java 实例 – 获取远程文件大小</li><li>Java 实例 – Socket 实现多线程服务器程序</li><li>Java 实例 – 查看主机指定文件的最后修改时间</li><li>Java 实例 – 使用 Socket 连接到指定主机</li><li>Java 实例 – 网页抓取</li><li>Java 实例 – 获取 URL响应头的日期信息</li><li>Java 实例 – 获取 URL 响应头信息</li><li>Java 实例 – 解析 URL</li><li>Java 实例 – ServerSocket 和 Socket 通信实例</li></ol></blockquote></blockquote><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><blockquote><blockquote><ol><li>Java 实例 – 查看线程是否存活</li><li>Java 实例 – 获取当前线程名称</li><li>Java 实例 – 状态监测</li><li>Java 实例 – 线程优先级设置</li><li>Java 实例 – 死锁及解决方法</li><li>Java 实例 – 获取线程id</li><li>Java 实例 – 线程挂起</li><li>Java 实例 – 终止线程</li><li>Java 实例 – 生产者/消费者问题</li><li>Java 实例 – 获取线程状态</li><li>Java 实例 – 获取所有线程</li><li>Java 实例 – 查看线程优先级</li><li>Java 实例 – 中断线程</li></ol></blockquote></blockquote><ul><li><a href="https://github.com" target="_blank" rel="noopener"><strong>github</strong></a>代码送门: <a href="https://github.com/zhangbc/java_projects/tree/runoob" target="_blank" rel="noopener">java_projects/runoob</a>  </li><li><a href="https://dev.tencent.com/user" target="_blank" rel="noopener"><strong>腾讯云coding</strong></a>代码送门: <a href="https://git.dev.tencent.com/zhangbocheng/java_project.git/tree/dev" target="_blank" rel="noopener">java_project/dev</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java扩展知识</title>
    <link href="https://zhangbc.github.io/2019/04/12/java_extend_knowledge/"/>
    <id>https://zhangbc.github.io/2019/04/12/java_extend_knowledge/</id>
    <published>2019-04-12T14:19:34.000Z</published>
    <updated>2019-04-12T14:24:20.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java文档注释"><a href="#1，Java文档注释" class="headerlink" title="1，Java文档注释"></a>1，Java文档注释</h2><p>1）<strong><code>Java</code>支持三种注释方式</strong>，分别是<code>//</code>、<code>/*  */</code>、<code>/**  */</code>(说明注释)。</p><p>2）<strong><code>javadoc</code>标签</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">@author</td><td style="text-align:left">标识一个类的作者</td><td style="text-align:left">@author description</td></tr><tr><td style="text-align:left">@deprecated</td><td style="text-align:left">指名一个过期的类或成员</td><td style="text-align:left">@deprecated description</td></tr><tr><td style="text-align:left">{@docRoot}</td><td style="text-align:left">指明当前文档根目录的路径</td><td style="text-align:left">Directory Path</td></tr><tr><td style="text-align:left">@exception</td><td style="text-align:left">标志一个类抛出的异常</td><td style="text-align:left">@exception exception-name explanation</td></tr><tr><td style="text-align:left">{@inheritDoc}</td><td style="text-align:left">从直接父类继承的注释</td><td style="text-align:left">Inherits a comment from the immediate surperclass.</td></tr><tr><td style="text-align:left">{@link}</td><td style="text-align:left">插入一个到另一个主题的链接</td><td style="text-align:left">{@link name text}</td></tr><tr><td style="text-align:left">{@linkplain}</td><td style="text-align:left">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td style="text-align:left">Inserts an in-line link to another topic.</td></tr><tr><td style="text-align:left">@param</td><td style="text-align:left">说明一个方法的参数</td><td style="text-align:left">@param parameter-name explanation</td></tr><tr><td style="text-align:left">@return</td><td style="text-align:left">说明返回值类型</td><td style="text-align:left">@return explanation</td></tr><tr><td style="text-align:left">@see</td><td style="text-align:left">指定一个到另一个主题的链接</td><td style="text-align:left">@see anchor</td></tr><tr><td style="text-align:left">@serial</td><td style="text-align:left">说明一个序列化属性</td><td style="text-align:left">@serial description</td></tr><tr><td style="text-align:left">@serialData</td><td style="text-align:left">明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td style="text-align:left">@serialData description</td></tr><tr><td style="text-align:left">@serialField</td><td style="text-align:left">说明一个ObjectStreamField组件</td><td style="text-align:left">@serialField name type description</td></tr><tr><td style="text-align:left">@since</td><td style="text-align:left">标记当引入一个特定的变化时</td><td style="text-align:left">@since release</td></tr><tr><td style="text-align:left">@throws</td><td style="text-align:left">和 @exception标签一样.</td><td style="text-align:left">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td style="text-align:left">{@value}</td><td style="text-align:left">显示常量的值，该常量必须是static属性。</td><td style="text-align:left">Displays the value of a constant, which must be a static field.</td></tr><tr><td style="text-align:left">@version</td><td style="text-align:left">指定类的版本</td><td style="text-align:left">@version info</td></tr></tbody></table></div><ul><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档注释演示实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareNumber</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the square of number.</span></span><br><span class="line"><span class="comment">     * This is a multiline description. You can use as many lines as you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number The value to be squared.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> number squared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number * number;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method input a number from the user.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The value input as a double.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException in input error</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNumber</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader inData = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        String str;</span><br><span class="line">        str = inData.readLine();</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(str);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method demonstrates square().</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args args unused.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException on input error.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SquareNumber sn = <span class="keyword">new</span> SquareNumber();</span><br><span class="line">        <span class="keyword">double</span> val;</span><br><span class="line">        System.out.print(<span class="string">"Enter value to be squared:"</span>);</span><br><span class="line">        val = sn.getNumber();</span><br><span class="line">        val = sn.square(val);</span><br><span class="line">        System.out.println(<span class="string">"Squared value is : "</span> + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，Java-8-新特性"><a href="#2，Java-8-新特性" class="headerlink" title="2，Java 8 新特性"></a>2，Java 8 新特性</h2><p>1）<strong><code>Java8</code>(即<code>jdk1.8</code>)新特性</strong></p><blockquote><p>（1）<code>Lambda</code> 表达式：<code>Lambda</code>允许把函数作为一个方法的参数（函数作为参数传递进方法中。<br>（2）方法引用：可以直接引用已有<code>Java</code>类或对象（实例）的方法或构造器。与<code>lambda</code>联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>（3）默认方法：默认方法就是一个在接口里面有了一个实现的方法。<br>（4）新工具：新的编译工具，如：<code>Nashorn</code>引擎<code>jjs</code>、 类依赖分析器<code>jdeps</code>。<br>（5）<code>Stream API</code>：把真正的函数式编程风格引入到<code>Java</code>中。<br>（6）<code>Date Time API</code>：加强对日期与时间的处理。<br>（7）<code>Optional</code> 类：<code>Optional</code> 类已经成为 <code>Java 8</code> 类库的一部分，用来解决空指针异常。<br>（8）<code>Nashorn</code>, <code>JavaScript</code> 引擎：允许我们在<code>JVM</code>上运行特定的<code>javascript</code>应用。</p></blockquote><h2 id="3，Java-MySQL连接"><a href="#3，Java-MySQL连接" class="headerlink" title="3，Java MySQL连接"></a>3，Java MySQL连接</h2><ul><li>MysqlDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/28 22:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlDemo</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDBC驱动名及其数据库URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://127.0.0.1:3306/pyspider_db"</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库的用户与密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"xxxxxx"</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            System.out.println(<span class="string">"连接数据库..."</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line">​</span><br><span class="line">            System.out.println(<span class="string">"实例化Statement对象..."</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">"select id, name, url from websites;"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                String url = rs.getString(<span class="string">"url"</span>);</span><br><span class="line">​</span><br><span class="line">                System.out.printf(<span class="string">"ID: %d\t站点名称：%s\t站点URL：%s\n"</span>, id, name, url);</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4，Java-9-新特性"><a href="#4，Java-9-新特性" class="headerlink" title="4，Java 9 新特性"></a>4，Java 9 新特性</h2><p>详情参见：<a href="http://www.runoob.com/java/java9-new-features.html" target="_blank" rel="noopener">Java 9 新特性</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java网络编程</title>
    <link href="https://zhangbc.github.io/2019/04/12/java_net_program/"/>
    <id>https://zhangbc.github.io/2019/04/12/java_net_program/</id>
    <published>2019-04-12T14:13:28.000Z</published>
    <updated>2019-04-12T14:21:49.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java网络编程"><a href="#1，Java网络编程" class="headerlink" title="1，Java网络编程"></a>1，Java网络编程</h2><p>1）<strong>概述</strong></p><p><code>网络编程</code>：编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br><code>java.net</code>包中<code>J2EE</code>的<code>API</code>包含有类和接口，他们提供低层次的通信细节。主要有：</p><blockquote><ul><li><code>TCP</code>：传输控制协议，保障了两个应用程序之间的可靠通信，通常用于互联网协议，称为<code>TCP/IP</code>；</li><li><code>UDP</code>：用户数据报协议，一个无连接的协议，提供了应用程序之间要发送的数据的数据包。</li></ul></blockquote><p>2）Socket编程</p><p><code>套接字</code>使用<code>TCP</code>提供了两台计算机之间的通信机制。 客户端程序创建一个<code>套接字</code>，并尝试连接服务器的<code>套接字</code>。</p><p>当连接建立时，服务器会创建一个 <code>Socket</code> 对象。客户端和服务器现在可以通过对 <code>Socket</code> 对象的写入和读取来进行通信。</p><p> <code>java.net.Socket</code> 类代表一个套接字，并且 <code>java.net.ServerSocket</code> 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p><p>以下步骤在两台计算机之间使用<code>套接字</code>建立<code>TCP</code>连接时会出现：</p><blockquote><ul><li>服务器实例化一个 <code>ServerSocket</code> 对象，表示通过服务器上的端口通信。</li><li>服务器调用 <code>ServerSocket</code> 类的 <code>accept()</code> 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li><li>服务器正在等待时，一个客户端实例化一个 <code>Socket</code> 对象，指定服务器名称和端口号来请求连接。</li><li><code>Socket</code> 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 <code>Socket</code> 对象能够与服务器进行通信。</li><li>在服务器端，<code>accept()</code> 方法返回服务器上一个新的 <code>socket</code> 引用，该 <code>socket</code> 连接到客户端的 <code>socket</code>。</li></ul></blockquote><p>3）<strong><code>ServerSocket</code>类的方法</strong>：服务器应用程序通过使用 <code>java.net.ServerSocket</code> 类以获取一个端口,并且侦听客户端请求。</p><p>4）<strong><code>Socket</code>类的方法</strong>：<code>java.net.Socket</code> 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 <code>Socket</code> 对象通过实例化 ，而 服务器获得一个 <code>Socket</code> 对象则通过 <code>accept()</code> 方法的返回值。</p><p>5）<strong><code>InetAddress</code>类的方法</strong>：表示互联网协议（<code>IP</code>）地址。</p><p>6）<strong><code>demo</code>实例</strong></p><ul><li><p><em>GreetingClient.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Socket编程--客户端实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String serverName = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"连接到主机："</span> + serverName + <span class="string">", 端口号："</span> + port);</span><br><span class="line">            Socket client = <span class="keyword">new</span> Socket(serverName, port);</span><br><span class="line">            System.out.println(<span class="string">"远程主机地址："</span> + client.getRemoteSocketAddress());</span><br><span class="line">            OutputStream outServer = client.getOutputStream();</span><br><span class="line">            DataOutputStream outData = <span class="keyword">new</span> DataOutputStream(outServer);</span><br><span class="line"></span><br><span class="line">            outData.writeUTF(<span class="string">"Hello from "</span> + client.getLocalSocketAddress());</span><br><span class="line">            InputStream inFromServer = client.getInputStream();</span><br><span class="line">            DataInputStream inData = <span class="keyword">new</span> DataInputStream(inFromServer);</span><br><span class="line">            System.out.println(<span class="string">"服务器响应："</span> + inData.readUTF());</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>GreetingServer.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketTimeoutException;</span><br><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> GreetingServer(port);</span><br><span class="line">            thread.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetingServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        serverSocket.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"等待远程连接，端口号为："</span></span><br><span class="line">                        + serverSocket.getLocalPort() + <span class="string">"..."</span>);</span><br><span class="line">                Socket server = serverSocket.accept();</span><br><span class="line">                DataInputStream inData = <span class="keyword">new</span> DataInputStream(server.getInputStream());</span><br><span class="line">                System.out.println(inData.readUTF());</span><br><span class="line"></span><br><span class="line">                DataOutputStream outData = <span class="keyword">new</span> DataOutputStream(server.getOutputStream());</span><br><span class="line">                outData.writeUTF(<span class="string">"谢谢连接我："</span> + server.getLocalSocketAddress()</span><br><span class="line">                        + <span class="string">"\nGoodbye!"</span>);</span><br><span class="line">                server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException es) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Socket timed out!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，Java发送邮件"><a href="#2，Java发送邮件" class="headerlink" title="2，Java发送邮件"></a>2，Java发送邮件</h2><ul><li><em>SendEmail.java</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.DataHandler;</span><br><span class="line"><span class="keyword">import</span> javax.activation.DataSource;</span><br><span class="line"><span class="keyword">import</span> javax.activation.FileDataSource;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.Message.RecipientType;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发邮件(纯文本，HTML文本，附件)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbocheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 20:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmail</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="comment">// 收件人邮箱</span></span><br><span class="line">        String to = <span class="string">"xxxxxxxxxxxxxxxxx@qq.com"</span>;</span><br><span class="line">        <span class="comment">// 发件人邮箱</span></span><br><span class="line">        <span class="keyword">final</span> String from = <span class="string">"xxxxxxxxxxxxxxxxx@163.com"</span>;</span><br><span class="line">        <span class="keyword">final</span> String pwd = <span class="string">"xxxxxxxx"</span>;</span><br><span class="line">        <span class="comment">// 指定发邮件的主机</span></span><br><span class="line">        String host = <span class="string">"smtp.163.com"</span>;</span><br><span class="line">        <span class="comment">// 获取系统属性</span></span><br><span class="line">        Properties properties = System.getProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置邮件服务器</span></span><br><span class="line">        properties.setProperty(<span class="string">"mail.host"</span>, host);</span><br><span class="line">        properties.put(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取默认Session对象</span></span><br><span class="line">        Session session = Session.getDefaultInstance(properties, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(from, pwd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建默认的MimeMessage对象</span></span><br><span class="line">            MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">            <span class="comment">// Set From：头部头字段</span></span><br><span class="line">            message.setFrom(<span class="keyword">new</span> InternetAddress(from));</span><br><span class="line">            <span class="comment">// Set To：头部头字段</span></span><br><span class="line">            message.addRecipient(RecipientType.TO,</span><br><span class="line">                    <span class="keyword">new</span> InternetAddress(to));</span><br><span class="line">            <span class="comment">// Set Subject：头部头字段</span></span><br><span class="line">            message.setSubject(<span class="string">"This is the Subject Line!"</span>);</span><br><span class="line">            <span class="comment">// 设置消息体</span></span><br><span class="line">            message.setText(<span class="string">"This is test text."</span>);</span><br><span class="line">            <span class="comment">// 发送HTML消息，可以插入html标签</span></span><br><span class="line">            message.setContent(<span class="string">"&lt;h1&gt;This is actual message&lt;/h1&gt;"</span>,</span><br><span class="line">                    <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            <span class="comment">// 创建消息部分</span></span><br><span class="line">            BodyPart messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">            <span class="comment">// 消息</span></span><br><span class="line">            messageBodyPart.setText(<span class="string">"This is message body."</span>);</span><br><span class="line">            <span class="comment">// 创建多重消息</span></span><br><span class="line">            Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">            <span class="comment">// 设置文本消息</span></span><br><span class="line">            multipart.addBodyPart(messageBodyPart);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 附件部分</span></span><br><span class="line">            messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">            String fileName = <span class="string">"/home/projects/java_pro/java_instances_demo/src/main/java/com/runoob/SendEmail.java"</span>;</span><br><span class="line">            DataSource source = <span class="keyword">new</span> FileDataSource(fileName);</span><br><span class="line">            messageBodyPart.setDataHandler(<span class="keyword">new</span> DataHandler(source));</span><br><span class="line">            messageBodyPart.setFileName(fileName);</span><br><span class="line">            multipart.addBodyPart(messageBodyPart);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送完整部分</span></span><br><span class="line">            message.setContent(multipart);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            Transport.send(message);</span><br><span class="line">            System.out.println(<span class="string">"Sent message successfully."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException mex) &#123;</span><br><span class="line">            mex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3，Java-Applet基础"><a href="#3，Java-Applet基础" class="headerlink" title="3，Java Applet基础"></a>3，Java Applet基础</h2><p>1）<strong><code>Applet</code>基础</strong></p><p><code>Applet</code>是一种<code>Java</code>程序，一般运行在支持<code>Java</code>的<code>Web</code>浏览器内，是一个全功能的Java应用程序。</p><blockquote><ul><li><code>Java</code> 中 <code>Applet</code> 类继承了 <code>java.applet.Applet</code> 类。</li><li><code>Applet</code> 类没有定义 <code>main()</code>，所以一个 <code>Applet</code> 程序不会调用 <code>main()</code> 方法。</li><li><code>Applet</code> 被设计为嵌入在一个 <code>HTML</code> 页面。</li><li>当用户浏览包含 <code>Applet</code> 的 <code>HTML</code> 页面，<code>Applet</code> 的代码就被下载到用户的机器上。</li><li>要查看一个 <code>Applet</code> 需要 <code>JVM</code>。 <code>JVM</code> 可以是 <code>Web</code> 浏览器的一个插件，或一个独立的运行时环境。</li><li>用户机器上的 <code>JVM</code> 创建一个 <code>Applet</code> 类的实例，并调用 <code>Applet</code> 生命周期过程中的各种方法。</li><li><code>Applet</code> 有 <code>Web</code> 浏览器强制执行的严格的安全规则，<code>Applet</code> 的安全机制被称为沙箱安全。</li><li><code>Applet</code> 需要的其他类可以用 <code>Java</code> 归档（<code>JAR</code>）文件的形式下载下来。</li></ul></blockquote><p>2）<strong><code>Applet</code>的生命周期</strong></p><p><code>Applet</code> 类中的四个方法给我们提供了一个框架：</p><blockquote><ul><li><code>init</code>:  提供所需的任何初始化。在 <code>Applet</code> 标记内的 <code>param</code> 标签被处理后调用该方法。</li><li><code>start</code>: 浏览器调用 <code>init</code> 方法后，该方法被自动调用。每当用户从其他页面返回到包含 <code>Applet</code> 的页面时，则调用该方法。</li><li><code>stop</code>: 当用户从包含 <code>Applet</code> 的页面移除的时候，该方法自动被调用。</li><li><code>destroy</code>: 此方法仅当浏览器正常关闭时调用。</li><li><code>paint</code>: 该方法在 <code>start()</code> 方法之后立即被调用，或者在 <code>Applet</code> 需要重绘在浏览器的时候调用。<code>paint()</code> 方法实际上继承于 <code>java.awt</code>。</li></ul></blockquote><p>3）<strong><code>Applet</code>类</strong></p><p>每一个 <code>Applet</code> 都是 <code>java.applet.Applet</code> 类的子类，基础的 <code>Applet</code> 类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。</p><p>4）<strong><code>Applet</code>的调用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World, Applet<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">applet</span> <span class="attr">code</span>=<span class="string">"HelloWorldApplet.class"</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">applet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java进阶编程</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_advance_program/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_advance_program/</id>
    <published>2019-04-11T14:05:07.000Z</published>
    <updated>2019-04-11T16:14:43.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java数据结构"><a href="#1，Java数据结构" class="headerlink" title="1，Java数据结构"></a>1，Java数据结构</h2><p><code>Java</code>工具包提供了强大的数据结构，在<code>Java</code>中的数据结构主要包括以下接口和类：<code>枚举（Enumeration）</code>，<code>位集合（BitSet）</code>，<code>向量（Vector）</code>，<code>栈（Stack）</code>，<code>字典（Dictionary）</code>，<code>哈希表（Hashtable）</code>，<code>属性（Properties）</code>。</p><p>1）<strong>枚举（<code>Enumeration</code>）</strong>：该接口定义了一种从数据结构中取回连续元素的方式。</p><p>2）<strong>位集合（<code>BitSet</code>）</strong>：该类实现了一组可以单独设置和清除的位或标志。</p><p>3）<strong>向量（<code>Vector</code>）</strong>：对象的元素通过索引访问，在创建时不必给对象指定大小，其大小会根据需要动态的变化。</p><p>4）<strong>栈（<code>Stack</code>）</strong>：实现了一个后进先出的数据结构，是<code>Vector</code>的一个子类。</p><p>5）<strong>字典（<code>Dictionary</code>）</strong>：是一个抽象类，定义了键映射到值的数据结构。当想要通过特定的键而不是整数索引来访问数据时，应使用<code>Dictionary</code>。<br><strong><code>注意</code></strong>：<code>Dictionary</code>类已经过时了，在实际开发中，你可以实现<code>Map</code>接口来获取键/值的存储功能。</p><p>6）<strong>哈希表（<code>Hashtable</code>）</strong>：提供了一种在用户定义键结构的基础上来组织数据的手段。<code>Hashtable</code>是原始的<code>java.util</code>的一部分， 是一个<code>Dictionary</code>具体的实现 。</p><p>7）<strong>属性（<code>Properties</code>）</strong>：继承于 Hashtable.Properties 类表示了一个持久的属性集；属性列表中每个键及其对应值都是一个字符串。</p><h2 id="2，Java集合框架"><a href="#2，Java集合框架" class="headerlink" title="2，Java集合框架"></a>2，Java集合框架</h2><p>1）<strong>集合框架设计目标</strong></p><blockquote><p>（1）必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的；<br>（2）允许不同类型的集合，以类似的方式工作，具有高度的互操作性；<br>（3）对一个集合的扩展和适应必须是简单的。</p></blockquote><p>2）<strong>Java集合框架图</strong></p><p><img src="/images/java_advance_program_collection_20190411.png" alt="Java集合框架图"></p><p>3）<strong>集合框架是一个用来代表和操纵集合的统一架构</strong>，包含如下内容：</p><blockquote><p>（1）<code>接口</code>：是代表集合的抽象数据类型。例：<code>Collection</code>，<code>List</code>，<code>Set</code>，<code>Map</code>等。<br>（2）<code>实现（类）</code>：是集合接口的具体实现。从本质上，他们是可重复使用的数据结构，例：<code>ArrayList</code>，<code>LinkedList</code>，<code>HashSet</code>，<code>HashMap</code>。<br>（3）<code>算法</code>：是实现集合接口的对象里的方法执行的一些有用的计算，例：搜索和排序，这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。</p></blockquote><p><img src="/images/java_advance_program_collection_members_20190411.png" alt="Java 集合框架构成"></p><p>集合框架的类和接口均在<code>java.util</code>包中。<br>任何对象加入集合类后，自动转变为<code>Object</code>类型，所以在取出的时候，需要进行强制类型转换。</p><p>4）<strong>集合接口</strong></p><ul><li><p><code>Set</code>和<code>List</code>的区别</p><blockquote><ul><li><code>Set</code> 接口实例存储的是无序的，不重复的数据。<code>List</code> 接口实例存储的是有序的，可以重复的元素。</li><li><code>Set</code> 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有<code>HashSet</code>,<code>TreeSet</code>&gt;。</li><li><code>List</code>和数组类似，可以动态增长，根据实际存储的数据的长度自动增长<code>List</code>的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有<code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code>&gt; 。</li></ul></blockquote><p>5）<strong>集合实现类（集合类）</strong>：<code>Java</code>提供了一套实现了<code>Collection</code>接口的标准集合类。</p><p>6）<strong>集合算法</strong>：集合定义了三个不可改变的静态变量：<code>EMPTY_SET</code>，<code>EMPTY_LIST</code>，<code>EMPTY_MAP</code>。<code>Collection Algorithms</code>是一个列表中的所有算法实现。</p><p>7）<strong>迭代</strong>：使用<code>Java Iterator</code>，通过实例列出<code>Iterator</code>和<code>listIterator</code>接口提供的所有方法。</p></li><li><p>ArrayListDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"Hello"</span>);</span><br><span class="line">        list.add(<span class="string">"World"</span>);</span><br><span class="line">        list.add(<span class="string">"Maven"</span>);</span><br><span class="line">        list.add(<span class="string">"Demo"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历1：使用foreach遍历List</span></span><br><span class="line">        System.out.println(<span class="string">"使用foreach遍历List:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str: list) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历2：把链表变为数组相关的内容进行遍历List</span></span><br><span class="line">        String[] strArray = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        list.toArray(strArray);</span><br><span class="line">        System.out.println(<span class="string">"\n把链表变为数组相关的内容进行遍历List:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">            System.out.print(strArray[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历3：使用迭代器进行相关遍历List</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        System.out.println(<span class="string">"\n使用迭代器进行相关遍历List:"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MapDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        map.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        map.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历1：通过Map.KeySet遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.KeySet遍历key与value："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key: map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + key + <span class="string">", value="</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历2：通过Map.entrySet使用iterator遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + entry.getKey() + <span class="string">", value="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历3：推荐，通过Map.entrySet遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet遍历key和value:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry:</span><br><span class="line">             map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + entry.getKey() + <span class="string">", value="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历4：通过Map.values()遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String val: map.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"value="</span> + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>8）<strong>比较器</strong>：使用 <code>Java Comparator</code>，通过实例列出<code>Comparator</code>接口提供的所有方法。</p><h2 id="3，Java泛型"><a href="#3，Java泛型" class="headerlink" title="3，Java泛型"></a>3，Java泛型</h2><p>1）<strong>Java泛型（<code>generics</code>）</strong> 是<code>JDK5</code>中引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<code>泛型的本质</code>是参数化类型，即：所操作的数据类型被指定为一个参数。</p><p>2）<strong>定义泛型方法的规则</strong></p><blockquote><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<code>&lt;E&gt;</code>）。</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个<code>类型变量</code>，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（如<code>int</code>,<code>double</code>,<code>char</code>的等）。 </li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建不同类型的数组：Integer，Double和Character</span></span><br><span class="line">        Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubleArray = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">        Character[] charArray = &#123;<span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'0'</span>&#125;;</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"整型数组元素为："</span>);</span><br><span class="line">        printArray(intArray);</span><br><span class="line">        System.out.println(<span class="string">"双精度小数数组元素为："</span>);</span><br><span class="line">        printArray(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">"字符型数组元素为："</span>);</span><br><span class="line">        printArray(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法printArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E element: inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）<strong>有界的类型参数</strong>：限制那些被允许传递到一个类型参数的类型种类范围。声明首先要列出类型参数的名称，后跟 <code>extends</code> 关键字，最后紧跟它的上界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型的有界类型参数实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxGenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%d,%d和%d中最大的数为%d.\n\n"</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, maximum(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"%.2f,%.2f和%.2f中最大的数为%.2f.\n\n"</span>,</span><br><span class="line">                <span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span>, maximum(<span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span>));</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"%s,%s和%s中最大的数为%s.\n\n"</span>,</span><br><span class="line">                <span class="string">"pear"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>,</span><br><span class="line">                maximum(<span class="string">"pear"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">maximum</span><span class="params">(T x, T y, T z)</span> </span>&#123;</span><br><span class="line">        T max = x;</span><br><span class="line">        <span class="keyword">if</span> (y.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）<strong>泛型类</strong>：在类名后面添加类型参数声明部分。泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个<code>类型变量</code>，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为<code>参数化的类</code>或<code>参数化的类型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        integerBox.add(<span class="number">10</span>);</span><br><span class="line">        stringBox.add(<span class="string">"菜鸟教程"</span>);</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"整型值为：%d\n"</span>, integerBox.get());</span><br><span class="line">        System.out.printf(<span class="string">"字符串为：%s\n"</span>, stringBox.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）<strong>类型通配符</strong>：一般使用<code>?</code>代替具体的类型参数。</p><blockquote><p>（1）类型通配符上限通过形如<code>List</code>来定义，如此定义就是通配符泛型值接受<code>Number</code>及其下层子类类型；<br>（2）类型通配符下限通过形如<code>List&lt;? super Number&gt;</code>来定义，表示类型只能接受<code>Number</code>及其三层父类类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型通配符实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wildcard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">​</span><br><span class="line">        name.add(<span class="string">"icon"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line">​</span><br><span class="line">        getData(name);</span><br><span class="line">        getUpperNumber(age);</span><br><span class="line">        getUpperNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"data: %s\n"</span>, data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUpperNumber</span><span class="params">(List&lt;? extends Number&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"data: "</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4，Java序列化"><a href="#4，Java序列化" class="headerlink" title="4，Java序列化"></a>4，Java序列化</h2><p>1）<strong>Java序列化</strong>：<code>Java</code>提供了一种对象序列化的机制，该机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据，有关对象的类型的信息和存储在对象中数据的类型。</p><blockquote><p>（1）序列化一个对象，并将它发送到输出流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p><p>（2）从流中取出下一个对象，并将对象反序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException, ClassNotFundException</span></span><br></pre></td></tr></table></figure></p></blockquote><p>2）<strong>完整<code>demo</code>实例</strong>：</p><ul><li><p>Employee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> runoob;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Employee类实现Serializable接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 12:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mailing a check to "</span> + name + <span class="string">" "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SerializeDemo.java </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SerializeDemo类，序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.name = <span class="string">"Reyan Ali"</span>;</span><br><span class="line">        employee.address = <span class="string">"Phonkka kuan, Ambehta Peer."</span>;</span><br><span class="line">        employee.SSN = <span class="number">11122333</span>;</span><br><span class="line">        employee.number = <span class="number">101</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fileOut = <span class="keyword">new</span></span><br><span class="line">                    FileOutputStream(<span class="string">"employee.ser"</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">            out.writeObject(employee);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.println(<span class="string">"Serialized data is saved in employee.ser."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ul><li>DeserializeDemo.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DeserializeDemo类，反序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.ser"</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            employee = (Employee) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Employee class not found."</span>);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Deserialize Employee..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Name: "</span> + employee.name);</span><br><span class="line">        System.out.println(<span class="string">"Address: "</span> + employee.address);</span><br><span class="line">        System.out.println(<span class="string">"SSN: "</span> + employee.SSN);</span><br><span class="line">        System.out.println(<span class="string">"Number: "</span> + employee.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java面向对象</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_object_oriented/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_object_oriented/</id>
    <published>2019-04-11T11:57:07.000Z</published>
    <updated>2019-04-11T12:07:56.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java-继承"><a href="#1，Java-继承" class="headerlink" title="1，Java 继承"></a>1，Java 继承</h2><p>1）<strong><code>Java</code>继承的概念</strong>：<code>继承</code>就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>2）<strong><code>Java</code>继承类型</strong>：Java不支持多继承，但是支持多重继承。<br><img src="/images/java_obj_oriented_extends_20190411.png" alt="Java继承"><br>3）<strong><code>Java</code>继承的特性</strong></p><blockquote><ul><li>子类拥有父类非 <code>private</code> 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li><code>Java</code> 的继承是<code>单继承</code>，但是可以<code>多重继承</code>，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的<code>耦合性</code>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul></blockquote><p>4）<strong><code>Java</code>继承关键字</strong></p><p><code>继承</code>可以使用<code>extends</code>和<code>implements</code>这两个关键字来实现继承，都继承于<code>java.lang.Object</code>，默认继承<code>object</code>祖先类。</p><blockquote><p>（1）<code>extends</code>：只能继承一个类。<br>（2）<code>implements</code>：可以变相地使<code>java</code>具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口。<br>（3）<code>super</code>：通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。<br>（4）<code>this</code>：指向自己的引用。<br>（5）<code>finally</code>：声明类可以把类定义为不能继承的，即<code>最终类</code>；或用于修饰方法，该方法不能被子类重写。</p></blockquote><p> 5）<strong><code>Java</code>构造器</strong><br> 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <code>super</code> 关键字调用父类的构造器并配以适当的参数列表。</p><ul><li>ExtendsDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/3/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========SubClassOne 类继承==========="</span>);</span><br><span class="line">        SubClassOne sc1 = <span class="keyword">new</span> SubClassOne();</span><br><span class="line">        SubClassOne sc2 = <span class="keyword">new</span> SubClassOne(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"==========SubClassTwo 类继承==========="</span>);</span><br><span class="line">        SubClassTwo sc3 = <span class="keyword">new</span> SubClassTwo();</span><br><span class="line">        SubClassTwo sc4 = <span class="keyword">new</span> SubClassTwo(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SuperClass 祖先类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SuperClass() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SuperClass(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass(int number)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SubClassOne 类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassOne</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SubClassOne() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClassOne()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SubClassOne(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SubClassOne(int number): "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SubClassTwo 类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassTwo</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SubClassTwo() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"SubClassTwo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SubClassTwo(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SubClassTwo(int number): "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，Java-Override-Overload"><a href="#2，Java-Override-Overload" class="headerlink" title="2，Java Override/Overload"></a>2，Java Override/Overload</h2><p>1）<strong>重写（<code>Override</code>）</strong><br><code>重写</code>是子类对父类对允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即<code>外壳不变，核心重写</code>。重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animal类，祖先类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物可以移动..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnimalDog类，继承Animal，并重写父类的move()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalDog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">"狗可以跑和走."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal dog = <span class="keyword">new</span> AnimalDog();</span><br><span class="line">        animal.move();</span><br><span class="line">        dog.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）<strong>方法的重写规则</strong></p><blockquote><ul><li>参数列表必须完全与被重写方法的相同。</li><li>返回类型必须完全与被重写方法的返回类型相同。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为<code>final</code>的方法不能被重写。</li><li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote><p>3）<strong><code>super</code></strong>：当需要在子类中调用父类的被重写方法时，要使用<code>super</code>关键字。</p><p>4）<strong>重载（<code>Overload</code>）</strong>：在一个类里面，方法名字相同，而参数不同，返回类型可同可不同。</p><p>5）<strong>重载规则</strong></p><blockquote><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载；</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul></blockquote><ul><li>OverLoading.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(int)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> number, String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(int, String)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test(int, String)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(String,int)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test(String,int)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverLoading overLoad = <span class="keyword">new</span> OverLoading();</span><br><span class="line">        System.out.println(overLoad.test());</span><br><span class="line">        overLoad.test(<span class="number">100</span>);</span><br><span class="line">        System.out.println(overLoad.test(<span class="number">100</span>, <span class="string">"test3"</span>));</span><br><span class="line">        System.out.println(overLoad.test(<span class="string">"test"</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>6）<strong><code>重写</code>和<code>重载</code>的区别</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">区别点</th><th style="text-align:left">重载方法</th><th style="text-align:left">重写方法</th></tr></thead><tbody><tr><td style="text-align:left">参数列表</td><td style="text-align:left">必须修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">返回类型</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">异常</td><td style="text-align:left">可以修改</td><td style="text-align:left">可以减少或删除，一定不能抛出新的或更广的异常</td></tr><tr><td style="text-align:left">访问</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table></div><p>方法的重写(<code>Overriding</code>)和重载(<code>Overloading</code>)是<code>java</code>多态性的不同表现，<code>重写</code>是父类与子类之间多态性的一种表现，<code>重载</code>可以理解成多态的具体表现形式。</p><blockquote><ul><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为<code>方法的重载(Overloading)</code>。</li><li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为<code>重写(Overriding)</code>。</li><li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul></blockquote><h2 id="3，Java-多态"><a href="#3，Java-多态" class="headerlink" title="3，Java 多态"></a>3，Java 多态</h2><p><code>多态</code>是同一个行为具有多个不同表现形式或形态的能力。<strong>多态的好处</strong>：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><p>1）<strong>多态的优点</strong>：消除类型之间的耦合关系；可替换性；可扩充性；接口性；灵活性；简化性。</p><p>2）<strong>多态存在的三个必要条件</strong>：<code>继承</code>；<code>重写</code>；<code>父类引用指向子类对象</code>。</p><ul><li>PolymorphicDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/3/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show(<span class="keyword">new</span> Cat());</span><br><span class="line">        show(<span class="keyword">new</span> Dog());</span><br><span class="line">​</span><br><span class="line">        Animals animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        animal.eat();</span><br><span class="line">​</span><br><span class="line">        Cat cat = (Cat) animal;</span><br><span class="line">        cat.work();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animals animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            Cat cat = (Cat) animal;</span><br><span class="line">            cat.work();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            Dog dog = (Dog) animal;</span><br><span class="line">            dog.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抓老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"看家"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3）<strong>虚函数</strong>：虚函数的存在是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。</p><p>4）<strong>多态的实现方式</strong>：<code>重写</code>；<code>接口</code>；<code>抽象类</code>和<code>抽象方法</code>。</p><h2 id="4，Java-抽象类"><a href="#4，Java-抽象类" class="headerlink" title="4，Java 抽象类"></a>4，Java 抽象类</h2><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>1）<strong>抽象类</strong>：在Java语言中使用<code>abstract class</code>定义抽象类。</p><p>2）<strong>继承抽象类</strong></p><p>3）<strong>抽象方法</strong>：<code>abstract</code> 关键字可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体；抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><p>4）<strong>抽象类总结规定</strong></p><blockquote><p>（1）抽象类不能被实例化；只有抽象类的非抽象子类可以创建对象；<br>（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；<br>（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能；<br>（4）构造方法，类方法（用 <code>static</code> 修饰的方法）不能声明为抽象方法；<br>（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></blockquote><h2 id="5，Java-封装"><a href="#5，Java-封装" class="headerlink" title="5，Java 封装"></a>5，Java 封装</h2><p>1）在面向对象程式设计方法中，<code>封装（Encapsulation）</code>是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的<code>接口</code>控制。</p><p><code>封装</code> <strong>最主要的功能</strong>在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>2）<strong>封装的优点</strong></p><blockquote><p>（1）两个的封装能够减少耦合；<br>（2）类内部的结构可以自由修改；<br>（3）可以对成员变量进行更精确的控制；<br>（4）隐藏信息，实现细节。</p></blockquote><h2 id="6，Java-接口"><a href="#6，Java-接口" class="headerlink" title="6，Java 接口"></a>6，Java 接口</h2><p>1）<strong>接口概念</strong><br>     <code>接口（Interface）</code>，在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p> 类描述对象的属性和方法。接口则包含类要实现的方法。</p><p> 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p> 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 <code>Java</code> 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p>2）<strong>接口与类相似点</strong></p><blockquote><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在<code>.java</code> 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 <code>.class</code> 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul></blockquote><p>3）<strong>接口与类的区别</strong></p><blockquote><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 <code>static</code> 和 <code>final</code> 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul></blockquote><p>4）<strong>接口特性</strong></p><blockquote><ul><li>接口是隐式的，接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 <code>public abstract</code>。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <code>public static final</code> 变量。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li><li>接口的方法都是公有的。</li></ul></blockquote><p>5）<strong>抽象类和接口的区别</strong></p><blockquote><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <code>public static final</code> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 <code>static</code> 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul></blockquote><p>6）<strong>接口的声明</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7）<strong>接口的实现</strong>：当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类；类使用<code>implements</code>关键字实现接口，在类声明中，<code>implements</code>关键字放在<code>class</code>声明后面。</p><p>（1）重写接口中声明的方法时，需要注意以下规则：</p><blockquote><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul></blockquote><p>（2）在实现接口的时候，需要注意以下规则：</p><blockquote><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul></blockquote><p>8）<strong>接口的继承</strong></p><p>9）<strong>接口的多继承</strong>：在<code>Java</code>中，类的多继承是不合法，但接口允许多继承；在接口的多继承中<code>extenfs</code>关键字只需要用一次，在其后跟着继承接口。</p><p>10）<strong>标记接口</strong><br>    <code>标记接口</code>是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。</p><p><code>标记接口</code>的<strong>作用</strong>：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p><code>标记接口</code>的<strong>主要目的</strong>：建立一个公共的父接口；向一个类添加数据类型。</p><h2 id="7，Java-包（Package）"><a href="#7，Java-包（Package）" class="headerlink" title="7，Java 包（Package）"></a>7，Java 包（Package）</h2><p> 1）<strong>包的作用</strong></p><blockquote><p>（1）把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。<br>（2）如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。<br>（3）包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p></blockquote><p> 总之，<code>Java</code> 使用包（<code>package</code>）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（<code>class</code>）、接口、枚举（<code>enumerations</code>）和注释（<code>annotation</code>）等。</p><p> 2）<strong>创建包</strong></p><p> 3）<strong><code>impor</code>t语句</strong>：为了能够使用某一个包的成员，需要在<code>Java</code>程序中明确导入该包。</p><p> 4）<strong><code>package</code>的目录结构</strong><br> 类目录的绝对路径叫做 <code>class path</code>。设置在系统变量 <code>CLASSPATH</code> 中。编译器和 <code>java</code> 虚拟机通过将 <code>package</code> 名字加到 <code>class path</code> 后来构造 <code>.class</code> 文件的路径。</p><p>5）<strong>设置<code>CLASSPATH</code>系统变量</strong></p><ul><li><p>用下面的命令显示当前的<code>CLASSPATH</code>变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows 平台（DOS 命令行下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C:\&gt; <span class="built_in">set</span> CLASSPATH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX 平台（Bourne shell 下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CLASSPATH</span></span></span><br></pre></td></tr></table></figure></li><li><p>删除当前<code>CLASSPATH</code>变量内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows 平台（DOS 命令行下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C:\&gt; <span class="built_in">set</span> CLASSPATH=</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX 平台（Bourne shell 下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> CLASSPATH; <span class="built_in">export</span> CLASSPATH</span></span><br></pre></td></tr></table></figure></li><li><p>设置<code>CLASSPATH</code>变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows 平台（DOS 命令行下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C:\&gt; <span class="built_in">set</span> CLASSPATH=C:\users\jack\java\classes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX 平台（Bourne shell 下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> CLASSPATH=/home/jack/java/classes; <span class="built_in">export</span> CLASSPATH</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
</feed>
