<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天堂的鸽子</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangbc.github.io/"/>
  <updated>2019-10-07T15:13:36.222Z</updated>
  <id>https://zhangbc.github.io/</id>
  
  <author>
    <name>Bocheng Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【机器学习基础】贝叶斯线性模型</title>
    <link href="https://zhangbc.github.io/2019/10/07/prml_03_02/"/>
    <id>https://zhangbc.github.io/2019/10/07/prml_03_02/</id>
    <published>2019-10-07T08:42:29.000Z</published>
    <updated>2019-10-07T15:13:36.222Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《模式识别与机器学习》的读书笔记。</p></blockquote><h1 id="一，贝叶斯线性回归"><a href="#一，贝叶斯线性回归" class="headerlink" title="一，贝叶斯线性回归"></a>一，贝叶斯线性回归</h1><h2 id="1，参数分布"><a href="#1，参数分布" class="headerlink" title="1，参数分布"></a>1，参数分布</h2><p>关于线性拟合的贝叶斯⽅法的讨论，⾸先引⼊模型参数 $\boldsymbol{w}$ 的先验概率分布。现在这个阶段，把噪声精度参数 $\beta$ 当做已知常数。⾸先，由公式(3.8)定义的似然函 数 $p(t|\boldsymbol{w})$ 是 $\boldsymbol{w}$ 的⼆次函数的指数形式，于是对应的共轭先验是⾼斯分布，形式为：</p><script type="math/tex; mode=display">p(\boldsymbol{w})=\mathcal{N}(\boldsymbol{w}|\boldsymbol{m}_{0},\boldsymbol{S}_{0})\tag{3.30}</script><p>均值为 $\boldsymbol{m}_{0}$ ，协⽅差为 $\boldsymbol{S}_{0}$ 。</p><p>由于共轭⾼斯先验分布的选择，后验分布也将是⾼斯分布。 我们可以对指数项进⾏配平⽅， 然后使⽤归⼀化的⾼斯分布的标准结果找到归⼀化系数，这样就计算出了后验分布的形式：</p><script type="math/tex; mode=display">p(\boldsymbol{w}|\boldsymbol{t})=\mathcal{N}(\boldsymbol{w}|\boldsymbol{m}_{N},\boldsymbol{S}_{N})\tag{3.31}</script><p>其中，</p><script type="math/tex; mode=display">\boldsymbol{m}_{N}=\boldsymbol{S}_{N}(\boldsymbol{S}_{0}^{-1}\boldsymbol{m}_{0}+\beta \boldsymbol{\Phi}^{T}\boldsymbol{t}) \\\boldsymbol{S}_{N}^{-1}=\boldsymbol{S}_{0}^{-1}+\beta \boldsymbol{\Phi}^{T}\boldsymbol{\Phi}</script><p>为了简化起见，考虑⾼斯先验的⼀个特定的形式，即考虑零均值各向同性⾼斯分布，这个分布由⼀个精度参数 $\alpha$ 控制，即：</p><script type="math/tex; mode=display">p(\boldsymbol{w}|\alpha)=\mathcal{N}(\boldsymbol{w}|\boldsymbol{0},\alpha^{-1}\boldsymbol{I})\tag{3.32}</script><p>对应的 $\boldsymbol{w}$ 后验概率分布由公式(3.31)给出，其中，</p><script type="math/tex; mode=display">\boldsymbol{m}_{N}=\beta \boldsymbol{S}_{N}\boldsymbol{\Phi}^{T}\boldsymbol{t}\\\boldsymbol{S}_{N}^{-1}=\alpha \boldsymbol{I}+\beta \boldsymbol{\Phi}^{T}\boldsymbol{\Phi}</script><p>后验概率分布的对数由对数似然函数与先验的对数求和的⽅式得到。它是 $\boldsymbol{w}$ 的函数，形式为：</p><script type="math/tex; mode=display">\ln p(\boldsymbol{w}|\boldsymbol{t})=-\frac{\beta}{2}\sum_{n=1}^{N}\{t_n-\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}-\frac{\alpha}{2}\boldsymbol{w}^{T}\boldsymbol{w}+常数\tag{3.33}</script><h2 id="2，预测分布"><a href="#2，预测分布" class="headerlink" title="2，预测分布"></a>2，预测分布</h2><p>在实际应⽤中，我们通常感兴趣的不是 $\boldsymbol{w}$ 本⾝的值，⽽是对于新的 $\boldsymbol{x}$ 值预测出 $t$ 的值。这需要我们计算出<strong>预测分布</strong>（<code>predictive distribution</code>），定义为：</p><script type="math/tex; mode=display">p(t|\mathbf{t},\alpha,\beta)=\int p(t|\boldsymbol{w},\beta)p(\boldsymbol{w}|\mathbf{t},\alpha,\beta)\mathrm{d}\boldsymbol{w}\tag{3.34}</script><p>其中 $\mathbf{t}$ 是训练数据⽬标变量的值组成的向量。经综合分析，预测分布的形式可以进一步具体化为：</p><script type="math/tex; mode=display">p(t|\boldsymbol{x},\mathbf{t},\alpha,\beta)=\mathcal{N}(t|\boldsymbol{m}_{N}^{T}\boldsymbol{\phi}(\boldsymbol{x}),\sigma_{N}^{2}(\boldsymbol{x}))\tag{3.35}</script><p>其中，</p><script type="math/tex; mode=display">\sigma_{N}^{2}(\boldsymbol{x})=\frac{1}{\beta}+\boldsymbol{\phi}(\boldsymbol{x})^{T}\boldsymbol{S}_{N}\boldsymbol{\phi}(\boldsymbol{x})</script><p>其中，式中第⼀项表⽰数据中的噪声，第⼆项反映了与参数 $\boldsymbol{w}$ 关联的不确定性。当额外的数据点被观测到的时候，后验概率分布会变窄。从⽽可以证明出 $\sigma_{N+1}^{2}(\boldsymbol{x})\le \sigma_{N}^{2}(\boldsymbol{x})$（<code>Qazaz et al.</code>, 1997）。 在极限 $N \to \infty$ 的情况下， 式中第⼆项趋于零， 从⽽预测分布的⽅差只与参数 $\beta$ 控制的具有可加性的噪声有关。</p><p>在下图3.15～3.18中，我们调整⼀个由⾼斯基函数线性组合的模型，使其适应于不同规模的数据集，然后观察对应的后验概率分布。其中，绿⾊曲线对应着产⽣数据点的函数 $\sin(2\pi x)$（带有附加的⾼斯噪声），⼤⼩为 $N = 1, N = 2, N = 4$ 和 $N = 25$ 的数据集在四幅图中⽤蓝⾊圆圈表⽰。对于每幅图，红⾊曲线是对应的⾼斯预测分布的均值，红⾊阴影区域是均值两侧的⼀个标准差范围的区域。注意，预测的不确定性依赖于 $x$，并且在数据点的邻域内最⼩。</p><p><img src="/images/prml_20191005233709.png" alt="N=1"></p><p><img src="/images/prml_20191005233718.png" alt="N=2"></p><p><img src="/images/prml_20191005233730.png" alt="N=4"></p><p><img src="/images/prml_20191005233748.png" alt="N=25"></p><p>为了更加深刻地认识对于不同的 $x$ 值的预测之间的协⽅差，我们可以从 $\boldsymbol{w}$ 的后验概率分布中抽取样本，然后画出对应的函数 $y(x, \boldsymbol{w})$ ，如图3.19～3.22所⽰。</p><p><img src="/images/prml_20191005233947.png" alt="N=1"></p><p><img src="/images/prml_20191005233957.png" alt="N=2"></p><p><img src="/images/prml_20191005234011.png" alt="N=4"></p><p><img src="/images/prml_20191005234022.png" alt="N=25"></p><h2 id="3，等价核"><a href="#3，等价核" class="headerlink" title="3，等价核"></a>3，等价核</h2><p>考虑以下<strong>预测均值</strong>形式：</p><script type="math/tex; mode=display">y(\boldsymbol{x},\boldsymbol{m}_{N})=\boldsymbol{m}_{N}^{T}\boldsymbol{\phi}(\boldsymbol{x})=\beta \boldsymbol{\phi}(\boldsymbol{x})^{T}\boldsymbol{S}_{N}\boldsymbol{\Phi}^{T}\mathbf{t}=\sum_{n=1}^{N}\beta \boldsymbol{\phi}(\boldsymbol{x})^{T}\boldsymbol{S}_{N}\boldsymbol{\phi}(\boldsymbol{x}_{n})t_{n}\tag{3.36}</script><p>其中，</p><script type="math/tex; mode=display">\boldsymbol{S}_{N}^{-1}=\boldsymbol{S}_{0}^{-1}+\beta \boldsymbol{\Phi}^{T}\boldsymbol{\Phi}</script><p>因此在点 $\boldsymbol{x}$ 处的预测均值由训练集⽬标变量 $t_n$ 的线性组合给出，即：</p><script type="math/tex; mode=display">y(\boldsymbol{x},\boldsymbol{m}_{N})=\sum_{n=1}^{N}k(\boldsymbol{x},\boldsymbol{x}_{n})t_{n}\tag{3.37}</script><p>其中，    </p><script type="math/tex; mode=display">k(\boldsymbol{x},\boldsymbol{x}^{\prime})=\beta \boldsymbol{\phi}(\boldsymbol{x})^{T}\boldsymbol{S}_{N}\boldsymbol{\phi}(\boldsymbol{x}^{\prime})\tag{3.38}</script><p>被称为<strong>平滑矩阵</strong>（<code>smoother matrix</code>）或者<strong>等价核</strong>（<code>equivalent kernel</code>）。像这样的回归函数，通过对训练集⾥⽬标值进⾏线性组合做预测，被称为<strong>线性平滑</strong>（<code>linear smoother</code>）。</p><p>如图3.23，⾼斯基函数的等价核 $k(x, x^{\prime})$ ， 图中给出了 $x$ 关于 $x^{\prime}$ 的图像， 以及通过这个矩阵的三个切⽚， 对应于三个不同的 $x$ 值，⽤来⽣成这个核的数据集由 $x$ 的200个值组成，$x$ 均匀地分布在区 间 $(−1, 1)$ 中。</p><p><img src="/images/prml_20191006132738.png" alt="⾼斯基函数的等价核"></p><p>如图3.24，多项式基函数在 $x=0$ 的等价核 $k(x, x^{\prime})$ 。 </p><p><img src="/images/prml_20191006132829.png" alt="多项式基函数的等价核"></p><p>如图3.25，<code>Sigmoid</code>基函数在 $x=0$ 的等价核 $k(x, x^{\prime})$ 。 </p><p><img src="/images/prml_20191006132838.png" alt="Sigmoid基函数的等价核"></p><p>考虑 $y(\boldsymbol{x})$ 和 $y(\boldsymbol{x}^{\prime})$ 的协⽅差</p><script type="math/tex; mode=display">\begin{aligned}\text{cov}[y(\boldsymbol{x}),\boldsymbol{x}^{\prime}]&=\text{cov}[\boldsymbol{\phi}(\boldsymbol{x})^{T}\boldsymbol{w},\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}^{\prime})]\\&=\boldsymbol{\phi}(\boldsymbol{x})^{T}\boldsymbol{S}_{N}\boldsymbol{\phi}(\boldsymbol{x}^{\prime})\\&=\beta^{-1}k(\boldsymbol{x},\boldsymbol{x}^{\prime})\end{aligned}\tag{3.39}</script><p>⽤核函数表⽰线性回归给出了解决回归问题的另⼀种⽅法。通过不引⼊⼀组基函数（它隐式地定义了⼀个等价的核），⽽是直接定义⼀个局部的核函数，然后在给定观测数据集的条件下， 使⽤这个核函数对新的输⼊变量  $\boldsymbol{x}$ 做预测。 这就引出了⽤于回归问题（以及分类问题）的⼀个很实⽤的框架，被称为<strong>⾼斯过程</strong>（<code>Gaussian process</code>）。</p><p>⼀个等价核定义了模型的权值，通过这个权值，训练数据集⾥的⽬标值被组合，然后对新的 $\boldsymbol{x}$ 值做预测，可以证明这些权值的和等于1，即</p><script type="math/tex; mode=display">\sum_{n=1}^{N}k(\boldsymbol{x},\boldsymbol{x}_{n})=1\tag{3.40}</script><p>对于所有的 $\boldsymbol{x}$ 值都成⽴。</p><p>公式(3.38)给出的等价核满⾜⼀般的核函数共有的⼀个<strong>重要性质</strong>：可以表⽰为⾮线性函数的向量 $\boldsymbol{\psi}(\boldsymbol{x})$ 的内积的形式，即</p><script type="math/tex; mode=display">k(\boldsymbol{x},\boldsymbol{z})=\boldsymbol{\psi}(\boldsymbol{x})^{T}\boldsymbol{\psi}(\boldsymbol{z})\tag{3.41}</script><p>其中，$\boldsymbol{\psi}(\boldsymbol{x})=\beta^{\frac{1}{2}}\boldsymbol{S}_{N}^{\frac{1}{2}}\boldsymbol{\phi}(\boldsymbol{x})$ 。</p><h1 id="二，贝叶斯模型比较"><a href="#二，贝叶斯模型比较" class="headerlink" title="二，贝叶斯模型比较"></a>二，贝叶斯模型比较</h1><p>假设我们想⽐较 $L$ 个模型 ${\mathcal{M}_i}$ ，其中 $i=1, \dots,L$ ，这⾥，⼀个模型指的是观测数据 $\mathcal{D}$ 上的概率分布。在多项式曲线拟合的问题中，概率分布被定义在⽬标值 $\mathbf{t}$ 上， ⽽输⼊值 $\mathbf{X}$ 被假定为已知的。其他类型的模型定义了 $\mathbf{X}$ 和 $\mathbf{t}$ 上的联合分布。我们会假设数据是由这些模型中的⼀个⽣成的， 但是我们不知道究竟是哪⼀个，其不确定性通过先验概率分布 $p(\mathcal{M}_i)$ 表⽰。给定⼀个训练数据集 $\mathcal{D}$ ，估计后验分布</p><script type="math/tex; mode=display">p(\mathcal{M}_{i}|\mathcal{D})\propto p(\mathcal{M}_{i})p(\mathcal{D}|\mathcal{M}_{i})</script><p>其中，<strong>模型证据</strong>（<code>model evidence</code>） $p(\mathcal{D}|\mathcal{M}_{i})$ ，也叫<strong>边缘似然</strong>（<code>marginal likelihood</code>），它表达了数据展现出的不同模型的优先级，也可以被看做在模型空间中的似然函数，在这个空间中参数已经被求和或者积分。两个模型的模型证据的⽐值 $\frac{p(\mathcal{D}|\mathcal{M}_{i})}{p(\mathcal{D}|\mathcal{M}_{j})}$ 被称为<strong>贝叶斯因⼦</strong>（<code>Bayes factor</code>）（<code>Kass and Raftery</code>, 1995）。</p><p>⼀旦知道了模型上的后验概率分布，那么根据概率的加和规则与乘积规则，预测分布为</p><script type="math/tex; mode=display">p(t|\boldsymbol{x},\mathcal{D})=\sum_{i=1}^{L}p(t|\boldsymbol{x},\mathcal{M}_{i},\mathcal{D})p(\mathcal{M}_{i}|\mathcal{D})\tag{3.42}</script><p>对于模型求平均的⼀个简单的近似是使⽤最可能的⼀个模型⾃⼰做预测，这被称为<strong>模型选择</strong> （<code>model selection</code>）。</p><p>对于⼀个由参数 $\boldsymbol{w}$ 控制的模型，根据概率的加和规则和乘积规则，模型证据为</p><script type="math/tex; mode=display">p(\mathcal{D}|\mathcal{M}_{i})=\int p(\mathcal{D}|\boldsymbol{w},\mathcal{M}_{i})p(\boldsymbol{w}|\mathcal{M}_{i})\mathrm{d}\boldsymbol {w}\tag{3.43}</script><p>⾸先考虑模型有⼀个参数 $w$ 的情形。这个参数的后验概率正⽐于 $p(\mathcal{D}|w)p(w)$ ，其中为了简化记号，我们省略 了它对于模型  ${\mathcal{M}_i}$ 的依赖。 假设后验分布在最⼤似然值 $w_{MAP}$ 附近是⼀个尖峰，宽度为 $\Delta w_{后验}$ ，那么可以⽤被积函数的值乘以尖峰的宽度来近似这个积分。进⼀步假设先验分布是平的，宽度为 $\Delta w_{先验}$ ，即 $p(w)=\frac{1}{\Delta w_{先验}}$ ，那么有</p><script type="math/tex; mode=display">\begin{aligned}p(\mathcal{D})&=\int p(\mathcal{D}|w)p(w)\mathrm{d}w \\ &\simeq p(\mathcal{D}|w_{MAP})\frac{\Delta w_{后验}}{\Delta w_{先验}}\end{aligned}\tag{3.44}</script><p>取对数，可得</p><script type="math/tex; mode=display">\ln p(\mathcal{D})\simeq \ln p(\mathcal{D}|w_{MAP}) + \ln\left(\frac{\Delta w_{后验}}{\Delta w_{先验}}\right)\tag{3.45}</script><p>其中，式中第⼀项表⽰拟合由最可能参数给出的数据，对于平的先验分布来说，这对应于对数似然；第⼆项⽤于根据模型的复杂度来惩罚模型。</p><p>如图3.26，近似模型证据，如果我们假设参数上的后验概率分布在众数 $w_{MAP}$ 附近有⼀个尖峰。</p><p><img src="/images/prml_20191006201043.png" alt="近似模型证据"></p><p>对于⼀个有 $M$ 个参数的模型，可以对每个参数进⾏类似的近似。假设所有的参数 $\frac{\Delta w_{后验}}{\Delta w_{先验}}$ 都相同，则有</p><script type="math/tex; mode=display">\ln p(\mathcal{D})\simeq \ln p(\mathcal{D}|w_{MAP}) + M\ln\left(\frac{\Delta w_{后验}}{\Delta w_{先验}}\right)\tag{3.46}</script><p>如图3.27，对于三个具有不同复杂度的模型，数据集的概率分布的图形表⽰，其中 $\mathcal{M}_{1}$ 是最简单的，$\mathcal{M}_{3}$ 是 最复杂的。</p><p><img src="/images/prml_20191006201647.png" alt="M个参数的模型"></p><p><strong>贝叶斯模型⽐较框架</strong>中隐含的⼀个假设是，⽣成数据的真实的概率分布包含在考虑的模型集合当中。如果这个假设确实成⽴，那么可以证明，平均来看，贝叶斯模型⽐较会倾向于选择出正确的模型。</p><p>考虑两个模型 $\mathcal{M}_{1}$ 和 $\mathcal{M}_{2}$ ，其中真实的概率分布对应于模型 $\mathcal{M}_{1}$ 。对于给定的有限数据集，确实有可能出现错误的模型反⽽使贝叶斯因⼦较⼤的事情。 但是，如果把贝叶斯因⼦在数据集分布上进⾏平均，那么可以得到期望贝叶斯因⼦，即关于数据的真实分布求的平均值：</p><script type="math/tex; mode=display">\int p(\mathcal{D}|\mathcal{M}_{1})\ln \frac{p(\mathcal{D}|\mathcal{M}_{1})}{p(\mathcal{D}|\mathcal{M}_{2})}\mathrm{d}\mathcal{D}</script><h1 id="三，证据近似"><a href="#三，证据近似" class="headerlink" title="三，证据近似"></a>三，证据近似</h1><p>⾸先对参数 $\boldsymbol{w}$ 求积分， 得到边缘似然函数（<code>marginal likelihood function</code>），然后通过最⼤化边缘似然函数，确定超参数的值。 这个框架在统计学的⽂献中被称为<strong>经验贝叶斯</strong>（<code>empirical Bayes</code>）（<code>Bernardo and Smith</code>, 1994; <code>Gelman et al.</code>, 2004），或者被称为<strong>第⼆类最⼤似然</strong>（<code>type 2 maximum likelihood</code>）（<code>Berger</code>, 1985），或者被称为<strong>推⼴的最⼤似然</strong>（<code>generalized maximum likelihood</code>）。在机器学习的⽂献中， 这种⽅法也被称为<strong>证据近似</strong>（<code>evidence approximation</code>）（<code>Gull</code>, 1989; <code>MacKay</code>, 1992<code>a</code>）。</p><p>引⼊ $\alpha$ 和 $\beta$ 上的超先验分布，那么预测分布可以通过对 $\boldsymbol{w}$ ,  $\alpha$ 和 $\beta$ 求积分的⽅法得到， 即</p><script type="math/tex; mode=display">p(t|\mathbf{t})=\iiint p(t|\boldsymbol{w},\beta)p(\boldsymbol{w}|\mathbf{t},\alpha,\beta)p(\alpha,\beta|\mathbf{t})\mathrm{d}\boldsymbol{w} \mathrm{d}\alpha \mathrm{d}\beta\tag{3.47}</script><p>如果后验分布 $p(\alpha,\beta|\mathbf{t})$ 在 $\hat{\alpha}$ 和 $\hat{\beta}$ 附近有尖峰，那么预测分布可以通过对 $\boldsymbol{w}$ 积分的⽅式简单地得到，其中 $\alpha$ 和 $\beta$ 被固定为 $\hat{\alpha}$ 和 $\hat{\beta}$  ，即</p><script type="math/tex; mode=display">\begin{aligned}p(t|\mathbf{t}) &\simeq p(t|\mathbf{t},\hat{\alpha},\hat{\beta})\\&=\int p(t|\boldsymbol{w},\hat{\beta})p(\boldsymbol{w}|\mathbf{t},\hat{\alpha},\hat{\beta})\mathrm{d}\boldsymbol{w}\end{aligned}\tag{3.48}</script><h2 id="1，计算证据函数"><a href="#1，计算证据函数" class="headerlink" title="1，计算证据函数"></a>1，计算证据函数</h2><p>边缘似然函数 $p(\mathbf{t}|\alpha,\beta)$ 是通过对权值参数 $\boldsymbol{w}$ 进⾏积分得到的，即</p><script type="math/tex; mode=display">p(\mathbf{t}|\alpha,\beta)=\int p(\mathbf{t}|\boldsymbol{w},\beta)p(\boldsymbol{w}|\alpha)\mathrm{d}\boldsymbol{w}\tag{3.49}</script><p>根据以前的相关公式，也可以写成</p><script type="math/tex; mode=display">p(\mathbf{t}|\alpha,\beta)=\left(\frac{\beta}{2\pi}\right)^{\frac{N}{2}}\left(\frac{\alpha}{2\pi}\right)^{\frac{M}{2}}\int \exp\{-E(\boldsymbol{w})\}\mathrm{d}\boldsymbol{w}\tag{3.50}</script><p>其中 $M$ 是 $\boldsymbol{w}$ 的维数，并且，</p><script type="math/tex; mode=display">\begin{aligned}E(\boldsymbol{w})&=\beta E_{D}(\boldsymbol{w})+\alpha E_{W}(\boldsymbol{w})\\&=\frac{\beta}{2}||\mathbf{t}-\boldsymbol{\Phi}\boldsymbol{w}||^{2}+\frac{\alpha}{2}\boldsymbol{w}^{T}\boldsymbol{w}\end{aligned}\tag{3.51}</script><p>现在对 $\boldsymbol{w}$ 配平⽅，可得</p><script type="math/tex; mode=display">E(\boldsymbol{w})=E(\boldsymbol{m}_{N})+\frac{1}{2}(\boldsymbol{w}-\boldsymbol{m}_{N})^{T}\boldsymbol{A}(\boldsymbol{w}-\boldsymbol{m}_{N})\tag{3.52}</script><p>令</p><script type="math/tex; mode=display">\boldsymbol{A}=\alpha\boldsymbol{I}+\beta\boldsymbol{\Phi}^{T}\boldsymbol{\Phi}\\\boldsymbol{m}_{N}=\beta \boldsymbol{A}^{-1}\boldsymbol{\Phi}\mathbf{t}\\E(\boldsymbol{m}_{N})=\frac{\beta}{2}||\mathbf{t}-\boldsymbol{\Phi}\boldsymbol{m}_{N}||^{2}+\frac{\alpha}{2}\boldsymbol{m}_{N}^{T}\boldsymbol{m}_{N}</script><p><strong>注意</strong> $\boldsymbol{A}$ 对应于误差函数的⼆阶导数 $\boldsymbol{A} = \nabla\nabla E(\boldsymbol{w})$ 被称为 <strong><code>Hessian</code>矩阵</strong>。</p><p>经计算，可得边缘似然函数的对数，即证据函数的表达式：</p><script type="math/tex; mode=display">\ln p(\mathbf{t}|\alpha,\beta)=\frac{M}{2}\ln\alpha+\frac{N}{2}\ln\beta-E(\boldsymbol{m}_{N})-\frac{1}{2}\ln |\boldsymbol{A}|-\frac{N}{2}\ln(2\pi)\tag{3.53}</script><p>如图3.28，模型证据与多项式阶数之间的关系。</p><p><img src="/images/prml_20191007134944.png" alt="模型证据与多项式阶数之间的关系"></p><h2 id="2，最⼤化证据函数"><a href="#2，最⼤化证据函数" class="headerlink" title="2，最⼤化证据函数"></a>2，最⼤化证据函数</h2><p>⾸先考虑 $p(\mathbf{t}|\alpha,\beta)$ 关于 $\alpha$ 的最⼤化，定义下⾯的特征向量⽅程</p><script type="math/tex; mode=display">(\beta\boldsymbol{\Phi}^{T}\boldsymbol{\Phi})\boldsymbol{\mu}_{i}=\lambda_{i}\boldsymbol{\mu}_{i}\tag{3.54}</script><p>根据公式，可知 $\boldsymbol{A}$ 的特征值为 $\alpha + \lambda_{i}$ 。 现在考虑公式(3.53)中涉及到 $\ln|\boldsymbol{A}|$ 的项关于 $\alpha$ 的导数</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} \alpha} \ln |\boldsymbol{A}|=\frac{\mathrm{d}}{\mathrm{d} \alpha} \ln \prod_{i}\left(\lambda_{i}+\alpha\right)=\frac{\mathrm{d}}{\mathrm{d} \alpha} \sum_{i} \ln \left(\lambda_{i}+\alpha\right)=\sum_{i} \frac{1}{\lambda_{i}+\alpha}\tag{3.55}</script><p>因此函数公式(3.53)关于 $\alpha$ 的驻点满⾜</p><script type="math/tex; mode=display">0=\frac{M}{2\alpha}-\frac{1}{2}\boldsymbol{m}_{N}^{T}\boldsymbol{m}_{N}-\frac{1}{2}\sum_{i}\frac{1}{\lambda_{i}+\alpha}</script><p>整理，有</p><script type="math/tex; mode=display">\alpha\boldsymbol{m}_{N}^{T}\boldsymbol{m}_{N}=M-\alpha\sum_{i}\frac{1}{\lambda_{i}+\alpha}=\gamma</script><p>由于 $i$ 的求和式中⼀共有 $M$ 项，因此 $\gamma$ 可以写成</p><script type="math/tex; mode=display">\gamma=\sum_{i}\frac{\lambda_{i}}{\alpha+\lambda_{i}}\tag{3.56}</script><p>因而，最⼤化边缘似然函数的 $\alpha$ 满⾜</p><script type="math/tex; mode=display">\alpha=\frac{\gamma}{\boldsymbol{m}_{N}^{T}\boldsymbol{m}_{N}}\tag{3.57}</script><p><strong>注意</strong>： $\alpha$ 的值是纯粹通过观察训练集确定的。</p><p>类似地，关于 $\beta$ 最⼤化对数边缘似然函数，注意到公式(3.54)定义的特征值 $\lambda_{i}$ 正⽐于 $\beta$ ，因此  $\frac{\mathrm{d}}{\mathrm{d}\beta}=\frac{\lambda}{\beta_{i}}$ 。于是</p><script type="math/tex; mode=display">\frac{\mathrm{d}}{\mathrm{d} \beta} \ln |\boldsymbol{A}|=\frac{\mathrm{d}}{\mathrm{d} \beta} \sum_{i} \ln \left(\lambda_{i}+\alpha\right)=\frac{1}{\beta}\sum_{i} \frac{\lambda_{i}}{\lambda_{i}+\alpha}=\frac{\gamma}{\beta}\tag{3.58}</script><p>边缘似然函数的驻点因此满⾜</p><script type="math/tex; mode=display">0=\frac{N}{2\beta}-\frac{1}{2}\sum_{n=1}^{N}\{t_{n}-\boldsymbol{m}_{N}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}-\frac{\gamma}{2\beta}</script><p>整理，可以得到最⼤化边缘似然函数的 $\beta$ 满⾜</p><script type="math/tex; mode=display">\frac{1}{\beta}=\frac{1}{N-\gamma}\sum_{n=1}^{N}\{t_{n}-\boldsymbol{m}_{N}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}\tag{3.59}</script><h2 id="3，参数的有效数量"><a href="#3，参数的有效数量" class="headerlink" title="3，参数的有效数量"></a>3，参数的有效数量</h2><p>如图3.29，似然函数的轮廓线（红⾊）和先验概率分布（绿⾊），其中参数空间中的坐标轴被旋转，与<code>Hessian</code>矩阵的特征向量 $\boldsymbol{\mu}_i$ 对齐。</p><p><img src="/images/prml_20191007143628.png" alt="似然函数的轮廓线"></p><p>考察单⼀变量 $x$ 的⾼斯分布的⽅差的最⼤似然估计为</p><script type="math/tex; mode=display">\sigma_{ML}^{2}=\frac{1}{N}\sum_{n=1}^{N}(x_{n}-\mu_{ML})^{2}\tag{3.60}</script><p>这个估计是有偏的，因为均值的最⼤似然解 $\mu_{ML}$ 拟合了数据中的⼀些噪声。从效果上来看，这占⽤了模型的⼀个⾃由度。对应的⽆偏的估计形式为</p><script type="math/tex; mode=display">\sigma_{MAP}^{2}=\frac{1}{N-1}\sum_{n=1}^{N}(x_{n}-\mu_{ML})^{2}\tag{3.61}</script><p>分母中的因⼦ $N−1$ 反映了模型中的⼀个⾃由度被⽤于拟合均值的事实，它抵消了最⼤似然解的偏差。</p><p>如图3.30，$\gamma$ 与 $\ln\alpha$ 的关系（红⾊曲线）以及 $2\alpha E_{W}(\boldsymbol{m}_{N})$ 与 $\ln\alpha$ 的关系（蓝⾊曲线）， 数据集为正弦数据集。这两条曲线的交点定义了 $\alpha$ 的最优解，由模型证据的步骤给出。</p><p><img src="/images/prml_20191007145425.png" alt="证据框架来确定α"></p><p>如图3.31，对应的对数证据 $\ln p(\mathbf{t}|\alpha,\beta)$ 关于 $\ln\alpha$ 的图像（红⾊曲线），说明了峰值与图3.30中曲线的交点恰好重合。同样给出的时测试集误差（蓝⾊曲线），说明模型证据最⼤值的位置接近于具有最好泛化能⼒的点。</p><p><img src="/images/prml_20191007145440.png" alt="对数证据"></p><p>如图3.32，独⽴的参数关于有效参数数量 $\gamma$ 的函数图像。⾼斯基函数模型中的10个参数 $w_i$ 与参数有效数量 $\gamma$ 的关系，其中超参数的变化范围为 $0\le\alpha\le\infty$，使得 $\gamma$ 的变化范围为 $0\le\gamma\le M$ 。</p><p><img src="/images/prml_20191007155836.png" alt="独⽴的参数关于有效参数数量"></p><p>如果考虑极限情况 $N\gg M$ ， 数据点的数量⼤于参数的数量，那么根据公式，所有的参数都可以根据数据良好确定。因为 $\boldsymbol{\Phi}^{T}\boldsymbol{\Phi}$ 涉及到数据点的隐式求和，因此特征值 $\lambda_{i}$ 随着数据集规模的增加⽽增⼤。在这种情况下，$\gamma = M$ ，并且 $\alpha$ 和 $\beta$ 的重新估计⽅程变为</p><script type="math/tex; mode=display">\alpha=\frac{M}{2E_{W}(\boldsymbol{m}_{N})}\\\beta=\frac{N}{2E_{D}(\boldsymbol{m}_{N})}</script><h1 id="四，固定基函数的局限性"><a href="#四，固定基函数的局限性" class="headerlink" title="四，固定基函数的局限性"></a>四，固定基函数的局限性</h1><p>基函数的数量随着输⼊空间的维度 $D$ 迅速增长，通常是指数⽅式的增长。</p><p>真实数据集有两个<strong>性质</strong>：第⼀， 数据向量 $\{\boldsymbol{x}_n\}$ 通常位于⼀个⾮线性流形内部。由于输⼊变量之间的相关性，这个流形本⾝的维度⼩于输⼊空间的维度。如果我们使⽤局部基函数，那么可以让基函数只分布在输⼊空间中包含数据的区域。这种⽅法被⽤在径向基函数⽹络中，也被⽤在⽀持向量机和相关向量机当中。神经⽹络模型使⽤可调节的基函数，这些基函数有着<code>sigmoid</code>⾮线性的性质。神经⽹络可以通过调节参数，使得在输⼊空间的区域中基函数会按照数据流形发⽣变化。第⼆，⽬标变量可能只依赖于数据流形中的少量可能的⽅向。利⽤这个性质，神经⽹络可以通过选择输⼊空间中基函数产⽣响应的⽅向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《模式识别与机器学习》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一，贝叶斯线性回归&quot;&gt;&lt;a href=&quot;#一，贝叶斯线性回归&quot; class=&quot;headerlink&quot; title=&quot;一，贝叶斯线性回归&quot;&gt;&lt;/a&gt;一，贝
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zhangbc.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习基础" scheme="https://zhangbc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习基础】线性基函数模型</title>
    <link href="https://zhangbc.github.io/2019/10/07/prml_03_01/"/>
    <id>https://zhangbc.github.io/2019/10/07/prml_03_01/</id>
    <published>2019-10-07T08:16:48.000Z</published>
    <updated>2019-10-07T15:22:18.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《模式识别与机器学习》的读书笔记。</p></blockquote><h1 id="一，线性基函数模型"><a href="#一，线性基函数模型" class="headerlink" title="一，线性基函数模型"></a>一，线性基函数模型</h1><h2 id="1，线性基函数"><a href="#1，线性基函数" class="headerlink" title="1，线性基函数"></a>1，线性基函数</h2><p>回归问题的<strong>⽬标</strong>是在给定 $D$ 维输⼊（<code>input</code>） 变量 $\boldsymbol{x}$ 的情况下， 预测⼀个或者多个连续⽬标（<code>target</code>）变量 $t$ 的值。</p><p>通过将⼀组输⼊变量的⾮线性函数进⾏线性组合， 我们可以获得⼀类更加有⽤的函数， 被称为<strong>基函数</strong>（<code>basis function</code>）。</p><p>回归问题的最简单模型是输⼊变量的<strong>线性组合</strong>：</p><script type="math/tex; mode=display">y(\boldsymbol{x},\boldsymbol{w}) = w_0+w_1x_1+\dots+w_Dx_D\tag{3.1}</script><p>其中，$\boldsymbol{x}=(x_1,x_2,\dots,x_D)^T$ ，通常称为<strong>线性回归</strong>（<code>linear regression</code>），这个模型的<strong>关键性质</strong>在于它是参数 $w_0 ,\dots ,w_D$ 的⼀个线性函数。 但是， 它也是输⼊变量 $x_i$ 的⼀个线性函数， 这给模型带来了极⼤的局限性。因此扩展模型的类别：将输⼊变量的固定的⾮线性函数进⾏线性组合：</p><script type="math/tex; mode=display">y(\boldsymbol{x},\boldsymbol{w}) = w_0+\sum_{j=1}^{M-1}w_{j}\phi_{j}(\boldsymbol{x})\tag{3.2}</script><p>其中， $\phi_{j}(\boldsymbol{x})$ 被称为<strong>基函数</strong>（<code>basis function</code>），参 数 $w_0$ 使得数据中可以存在任意固定的偏 置，这个值通常被称为<strong>偏置参数</strong>（<code>bias parameter</code>）。此模型称为<strong>线性模型</strong>。</p><p>通常，定义⼀个额外的<strong>虚“基函数”</strong> $\phi_{0}(\boldsymbol{x}) = 1$ 是很⽅便的，这时，</p><script type="math/tex; mode=display">y(\boldsymbol{x},\boldsymbol{w}) = \sum_{j=0}^{M-1}w_{j}\phi_{j}(\boldsymbol{x}) = \boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x})\tag{3.3}</script><p>其中，$\boldsymbol{w}=(w_0,x_1,\dots,w_{M-1})^T$ ，$\boldsymbol{\phi}=(\phi_0,\phi_2,\dots,\phi_{M-1})^T$  。</p><p>在许多模式识别的实际应⽤中， 我们会对 原始的数据变量进⾏某种固定形式的预处理或者特征抽取。如果原始变量由向量 $\boldsymbol{x}$ 组成，那么特征可以⽤基函数 $\{\phi_{j}(\boldsymbol{x})\}$ 来表⽰。</p><p><strong>多项式基函数</strong>的⼀个<strong>局限性</strong>在于它们是输⼊变量的全局函数，因此对于输⼊空间⼀个区域的改变将会影响所有其他的区域。这个问题的解决方案：把输⼊空间切分成若⼲个区域，然后对于每个区域⽤不同的多项式函数拟合，这样的函数叫做<strong>样条函数</strong>（<code>spline function</code>）（<code>Hastie et al.</code>, 2001）。</p><p><strong>⾼斯基函数</strong>：</p><script type="math/tex; mode=display">\phi_{j}(x)=\exp\left\{-\frac{(x-\mu_{j})^2}{2s^{2}}\right\}\tag{3.4}</script><p>其中，$\mu_{j}$ 控制了基函数在输⼊空间中的位置，参数 $s$ 控制了基函数的空间⼤⼩。</p><p><strong><code>sigmoid</code>基函数</strong>：</p><script type="math/tex; mode=display">\phi_{j}(x)=\sigma\left(\frac{x-\mu_{j}}{s}\right)\tag{3.5}</script><p>其中 $\sigma(a)$ 是 <strong><code>logistic sigmoid</code>函数</strong>，定义为：</p><script type="math/tex; mode=display">\sigma_{a}=\frac{1}{1+\exp(-a)}\tag{3.6}</script><p>除此之外，基函数还可以选择<strong>傅⾥叶基函数</strong>，<strong><code>tanh</code>函数</strong>等等。其中，<strong><code>tanh</code>函数</strong> 和 <strong><code>logistic sigmoid</code>函数</strong> 的关系如下：$\tanh(a)=2\sigma(2a)-1$。</p><p>如图3.1～3.3，分别为是多项式基函数，⾼斯基函数，<code>sigmoid</code>基函数。</p><p><img src="/images/prml_20190929233008.png" alt="多项式基函数"></p><p><img src="/images/prml_20190929 233018.png" alt="⾼斯基函数"></p><p><img src="/images/prml_20190929233035.png" alt="sigmoid基函数"></p><h2 id="2，最⼤似然与最⼩平⽅"><a href="#2，最⼤似然与最⼩平⽅" class="headerlink" title="2，最⼤似然与最⼩平⽅"></a>2，最⼤似然与最⼩平⽅</h2><p>假设⽬标变量 $t$ 由确定的函数 $y(\boldsymbol{x},\boldsymbol{w})$ 给出，这个函数被附加了<strong>⾼斯噪声</strong>，即</p><script type="math/tex; mode=display">t=y(\boldsymbol{x},\boldsymbol{w})+\epsilon</script><p>其中，$\epsilon$ 是⼀个零均值的⾼斯随机变量，精度（⽅差的倒数）为 $\beta$，则有：</p><script type="math/tex; mode=display">p(t|\boldsymbol{x},\boldsymbol{w},\beta)=\mathcal{N}(t|y(\boldsymbol{x},\boldsymbol{w}),\beta^{-1})\tag{3.7}</script><p>均值为：</p><script type="math/tex; mode=display">\mathbb{E}[t|\boldsymbol{x}]=\int tp(t|\boldsymbol{x})\mathrm{d}t=y(\boldsymbol{x},\boldsymbol{w})</script><p>考虑⼀个输⼊数据集 $\mathbf{X}=\{\boldsymbol{x}_1,\dots, \boldsymbol{x}_N\}$， 对应的⽬标值为 $t_1,\dots , t_N$ 。 我们把⽬标向量 $\{t_n\}$ 组成⼀个列向量， 记作 $\mathbf{t}$。 假设这些数据点是独⽴地从分布公式(3.7)中抽取的，那么可以得到下⾯的似然函数的表达式， 它是可调节参数 $\boldsymbol{w}$ 和 $\beta$ 的函数，形式为：</p><script type="math/tex; mode=display">p(\mathbf{t}|\mathbf{X},\boldsymbol{w},\beta)=\prod_{n=1}^{N}\mathcal{N}(t_{n}|\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n}),\beta^{-1})\tag{3.8}</script><p>取似然函数的对数，使⽤⼀元⾼斯分布的标准形式，可得：</p><script type="math/tex; mode=display">\begin{aligned}\ln p(\mathbf{t}|\boldsymbol{w},\beta)&=\sum_{n=1}^{N}\ln \mathcal{N}(t_{n}|\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n}),\beta^{-1}) \\ &= \frac{N}{2}\ln\beta-\frac{N}{2}\ln(2\pi)-\beta E_{D}(\boldsymbol{w}) \end{aligned}\tag{3.9}</script><p>其中，<strong>平⽅和误差函数</strong>的定义为：</p><script type="math/tex; mode=display">E_{D}(\boldsymbol{w})=\frac{1}{2}\sum_{n=1}^{N}\{t_{n}-\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}\tag{3.10}</script><p>对数似然函数的梯度为：</p><script type="math/tex; mode=display">\nabla\ln p(\mathbf{t}|\boldsymbol{w},\beta)=\beta\sum_{n=1}^{N}\{t_{n}-\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}\boldsymbol{\phi}(\boldsymbol{x}_{n})^{T}\tag{3.11}</script><p>令梯度等于零，求解 $\boldsymbol{w}$ 可得：</p><script type="math/tex; mode=display">\boldsymbol{w}_{ML}=(\boldsymbol{\Phi}^{T}\boldsymbol{\Phi})^{-1}\boldsymbol{\Phi}^{T}\mathbf{t}\tag{3.12}</script><p>这被称为<strong>最⼩平⽅问题的规范⽅程</strong>（<code>normal equation</code>）。这⾥ $\boldsymbol{\Phi}$ 是⼀个 $N \times M$ 的矩阵，被称为<strong>设计矩阵</strong>（<code>design matrix</code>），它的元素为 $\Phi_{nj}=\phi_{j}(\boldsymbol{x}_{n})$ ，即</p><script type="math/tex; mode=display">\mathbf{\Phi}=\left(\begin{array}{cccc}{\phi_{0}\left(\boldsymbol{x}_{1}\right)} & {\phi_{1}\left(\boldsymbol{x}_{1}\right)} & {\cdots} & {\phi_{M-1}\left(\boldsymbol{x}_{1}\right)} \\ {\phi_{0}\left(\boldsymbol{x}_{2}\right)} & {\phi_{1}\left(\boldsymbol{x}_{2}\right)} & {\cdots} & {\phi_{M-1}\left(\boldsymbol{x}_{2}\right)} \\ {\vdots} & {\vdots} & {\ddots} & {\vdots} \\ {\phi_{0}\left(\boldsymbol{x}_{N}\right)} & {\phi_{1}\left(\boldsymbol{x}_{N}\right)} & {\cdots} & {\phi_{M-1}\left(\boldsymbol{x}_{N}\right)}\end{array}\right)</script><p>其中，量</p><script type="math/tex; mode=display">\mathbf{\Phi}^{\dagger} \equiv\left(\mathbf{\Phi}^{T} \mathbf{\Phi}\right)^{-1} \mathbf{\Phi}^{T}</script><p>被称为矩阵 $\mathbf{\Phi}$ 的 <strong><code>Moore-Penrose</code>伪逆矩阵</strong>（<code>pseudo-inverse matrix</code>）（<code>Rao and Mitra</code>, 1971; <code>Golub and Van Loan</code>, 1996）。</p><p>图3.4，最⼩平⽅解的⼏何表⽰，在⼀个 $N$ 维空间中，坐标轴是 $t_1,\dots , t_N$ 的值。<strong>最⼩平⽅回归函数</strong>可以通过下⾯的⽅式得到：寻找数据向量 $\mathbf{t}$ 在由基函数 $\phi_{j}(\boldsymbol{x})$ 张成的⼦空间上的正交投影，其中每个基函数都可以看成⼀个长度为 $N$ 的向量 $\varphi_j$ ，它的元素为 $\phi_{j}(\boldsymbol{x}_{n})$ 。注意， $\varphi_j$ 对应于 $\mathbf{\Phi}$ 的第 $j$ 列， ⽽ $\boldsymbol{\phi}(\boldsymbol{x}_{n})$ 对应于 $\mathbf{\Phi}$ 的第 $i$ ⾏。</p><p><img src="/images/prml_20190930113538.png" alt="最⼩平⽅解的⼏何表⽰"></p><p>如果显式地写出偏置参数，那么误差函数公式(3.10)变为：</p><script type="math/tex; mode=display">E_{D}(\boldsymbol{w})=\frac{1}{2}\sum_{n=1}^{N}\{t_{n}-w_{0}-\sum_{j=1}^{M-1}w_{j}\phi_{j}(\boldsymbol{x}_{n})\}^{2}\tag{3.13}</script><p>令关于 $w_0$ 的导数等于零，解出 $w_0$ ，可得</p><script type="math/tex; mode=display">w_0=\bar{t}-\sum_{j=1}^{M-1}w_{j}\bar\phi_{j}</script><p>其中，</p><script type="math/tex; mode=display">\bar{t}=\frac{1}{N}\sum_{n=1}^{N}t_{n} \\ \bar{\phi}_{j}=\frac{1}{N}\sum_{n=1}^{N}\phi_{j}(\boldsymbol{x}_n)</script><p>因此，偏置 $w_0$ 补偿了⽬标值的平均值（在训练集上的）与基函数的值的平均值的加权求和之间的差。 </p><p>关于噪声精度参数 $\beta$ 最⼤化似然函数公式(3.9)，结果为：</p><script type="math/tex; mode=display">\frac{1}{\beta_{ML}}=\frac{1}{N}\sum_{n=1}^{N}\{t_{n}-\boldsymbol{w}_{ML}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}\tag{3.14}</script><p>因此，噪声精度的倒数由⽬标值在回归函数周围的<strong>残留⽅差</strong>（<code>residual variance</code>）给出。</p><h2 id="3，顺序学习"><a href="#3，顺序学习" class="headerlink" title="3，顺序学习"></a>3，顺序学习</h2><p>顺序算法中，每次只考虑⼀个数据点，模型的参数在每观测到⼀个数据点之后进⾏更新。顺序学习也适⽤于实时的应⽤，在实时应⽤中，数据观测以⼀个连续的流的⽅式持续到达，我们必须在观测到所有数据之前就做出预测。</p><p>我们可以获得⼀个顺序学习的算法通过考虑随机梯度下降（<code>stochastic gradient descent</code>）也 被称为<strong>顺序梯度下降</strong>（<code>sequential gradient descent</code>）的⽅法。 如果误差函数由数据点的和组成 $E = \sum_{n} E_n$ ，那么在观测到模式 $n$ 之后，随机梯度下降算法使⽤下式更新参数向量 $\boldsymbol{w}$ ：</p><script type="math/tex; mode=display">\boldsymbol{w}^{(\tau+1)}=\boldsymbol{w}^{(\tau)}-\eta\nabla E_{n}\tag{3.15}</script><p>其中 $\tau$ 表⽰迭代次数，$\eta$  是学习率参数。 $\boldsymbol{w}$ 被初始化为某个起始向 量  $\boldsymbol{w}^{(0)}$ 。对于平⽅和误差函数公式(3.10)的情形，我们有：</p><script type="math/tex; mode=display">\boldsymbol{w}^{(\tau+1)}=\boldsymbol{w}^{(\tau)}+\eta(t_{n}-\boldsymbol{w}^{(\tau)T}\boldsymbol{\phi}_{n})\boldsymbol{\phi}_{n}\tag{3.16}</script><p>其中 $\boldsymbol{\phi}_{n}=\boldsymbol{\phi}(\boldsymbol{x}_{n})$。 这被称为<strong>最⼩均⽅</strong>（<code>least-mean-squares</code>）或者 <strong><code>LMS</code>算法</strong>。$\eta$ 的值需要仔细选择，确保<strong>算法收敛</strong>（<code>Bishop and Nabney</code>, 2008）。</p><h2 id="4，正则化最⼩平⽅"><a href="#4，正则化最⼩平⽅" class="headerlink" title="4，正则化最⼩平⽅"></a>4，正则化最⼩平⽅</h2><p>为误差函数添加正则化项的思想来控制过拟合，因此需要最⼩化的总的误差函数的形式为</p><script type="math/tex; mode=display">E_{D}(\boldsymbol{w})+\lambda E_{W}(\boldsymbol{w})</script><p>其中 $\lambda$ 是正则化系数，正则化项的⼀个最简单的形式为权向量的各个元素的平⽅和</p><script type="math/tex; mode=display">E_{W}(\boldsymbol{w})=\frac{1}{2}\boldsymbol{w}^{T}\boldsymbol{w}</script><p>考虑平⽅和误差函数</p><script type="math/tex; mode=display">E_{D}(\boldsymbol{w})=\frac{1}{2}\sum_{n=1}^{N}\{t_{n}-\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}\tag{3.17}</script><p>那么总误差函数就变成了</p><script type="math/tex; mode=display">\frac{1}{2}\sum_{n=1}^{N}\{t_{n}-\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}+\frac{\lambda}{2}\boldsymbol{w}^{T}\boldsymbol{w}</script><p>这种对于正则化项的选择⽅法在机器学习的⽂献中被称为<strong>权值衰减</strong>（<code>weight decay</code>）。</p><p>令总误差函数关于 $\boldsymbol{w}$ 的梯度等于零，解出 $\boldsymbol{w}$ ，有：</p><script type="math/tex; mode=display">\boldsymbol{w}=(\lambda \boldsymbol{I}+\boldsymbol{\Phi}^{T}\boldsymbol{\Phi})^{-1}\boldsymbol{\Phi}^{T}\boldsymbol{t}\tag{3.18}</script><p>有时使⽤⼀个更加⼀般的正则化项，这时正则化的误差函数的形式为：</p><script type="math/tex; mode=display">\frac{1}{2}\sum_{n=1}^{N}\{t_{n}-\boldsymbol{w}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})\}^{2}+\frac{\lambda}{2}\sum_{j=1}^{M}|w_{j}|^{q}\tag{3.19}</script><p>如图3.5～3.8，对于不同的参数 $q$，公式(3.19)中的正则化项的轮廓线。</p><p><img src="/images/prml_20191003214249.png" alt="q=0.5"></p><p><img src="/images/prml_20191003214301.png" alt="q=1"></p><p><img src="/images/prml_20191003214316.png" alt="q=2"></p><p><img src="/images/prml_20191003214325.png" alt="q=4"></p><p>在统计学的⽂献中，$q=1$ 的情形被称为<strong>套索</strong>（<code>lasso</code>）（<code>Tibshirani</code>, 1996）。它的<strong>性质</strong>为：如果 $\lambda$ 充分⼤，那么某些系数 $w_j$ 会变为零，从⽽产⽣了⼀个<strong>稀疏</strong>（<code>sparse</code>）<strong>模型</strong>，这个模型中对应的基函数不起作⽤。</p><p>如图3.9，$q=2$ 的⼆次正则化项的限制区域。</p><p><img src="/images/prml_20191004154353.png" alt="q=2"></p><p>如图3.10，$q=1$ 的套索正则化项的限制区域。</p><p><img src="/images/prml_20191004154407.png" alt="q=1"></p><h2 id="5，多个输出"><a href="#5，多个输出" class="headerlink" title="5，多个输出"></a>5，多个输出</h2><p>对于预测 $K&gt;1$ 个⽬标变量，我们把这些⽬标变量聚集起来，记作⽬标向量 $\boldsymbol{t}$ ，其解决方案是：对于 $\boldsymbol{t}$ 的每个分量，引⼊⼀个不同的基函数集合，从⽽变成了多个独⽴的回归问题。但是，⼀个更有趣的并且更常⽤的⽅法是对⽬标向量的所有分量使⽤⼀组相同的基函数来建模，即：</p><script type="math/tex; mode=display">\boldsymbol{y}(\boldsymbol{x}, \boldsymbol{w})=\boldsymbol{W}^{T}\phi(\boldsymbol{x})\tag{3.20}</script><p>其中 $\boldsymbol{y}$ 是⼀个 $K$ 维列向量，$\boldsymbol{W}$ 是⼀个 $M\times K$ 的参数矩阵，$\phi(\boldsymbol{x})$ 是⼀个 $M$ 为列向量， 每个元素 为 $\phi_{j}(\boldsymbol{x})$ ，$\phi_{0}(\boldsymbol{x}) = 1$ 。 假设令⽬标向量的条件概率分布是⼀个各向同性的⾼斯分布，形式为：</p><script type="math/tex; mode=display">p(\boldsymbol{t}|\boldsymbol{x},\boldsymbol{W},\beta)=\mathcal{N}(\boldsymbol{t}|\boldsymbol{W}^{T}\boldsymbol{\phi}(\boldsymbol{x}),\beta^{-1}\boldsymbol{I})\tag{3.21}</script><p>如果有⼀组观测 $\boldsymbol{t}_1,\dots,\boldsymbol{t}_N$ ，可以把这些观测组合为⼀个 $N \times K$ 的矩阵 $\boldsymbol{T}$ ，使得矩阵的第 $n$ ⾏为 $\boldsymbol{t}_{n}^{T}$ 。类似地，把输⼊向量 $\boldsymbol{x}_1,\dots,\boldsymbol{x}_N$ 组合为矩阵 $\boldsymbol{X}$ 。这样，对数似然函数：</p><script type="math/tex; mode=display">\begin{aligned}\ln p(\mathbf{T}|\boldsymbol{X},\boldsymbol{W},\beta)&=\sum_{n=1}^{N}\ln \mathcal{N}(\boldsymbol{t}_{n}|\boldsymbol{W}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n}),\beta^{-1}\boldsymbol{I}) \\ &= \frac{NK}{2}\ln\left(\frac{\beta}{2\pi}\right)-\frac{\beta}{2}\sum_{n=1}^{N}||\boldsymbol{t}_{n}-\boldsymbol{W}^{T}\boldsymbol{\phi}(\boldsymbol{x}_{n})||^{2} \end{aligned}\tag{3.22}</script><p>关于 $\boldsymbol{W}$ 最⼤化这个函数，可得：</p><script type="math/tex; mode=display">\boldsymbol{W}_{ML}=(\boldsymbol{\Phi}^{T}\boldsymbol{\Phi})^{-1}\boldsymbol{\Phi}^{T}\boldsymbol{T}\tag{3.23}</script><p>对于每个⽬标变量 $t_k$ 考察这个结果，那么有</p><script type="math/tex; mode=display">\boldsymbol{w}_{k}=(\boldsymbol{\Phi}^{T}\boldsymbol{\Phi})^{-1}\boldsymbol{\Phi}^{T}\boldsymbol{t}_{k}=\mathbf{\Phi}^{\dagger}\boldsymbol{t}_{k}\tag{3.24}</script><p>其中，$\boldsymbol{t}_{k}$ 是⼀个 $N$ 维列向量， 元素为 $t_{nk}$ 其中 $n=1,\dots,N$ 。 因此不同⽬标变量的回归问题在这⾥被分解开，并且我们只需要计算⼀个伪逆矩阵 $\mathbf{\Phi}^{\dagger}$ ，这个矩阵是被所有向量 $\boldsymbol{w}_k$ 所共享的。</p><h1 id="二，-偏置-方差分解"><a href="#二，-偏置-方差分解" class="headerlink" title="二， 偏置-方差分解"></a>二， 偏置-方差分解</h1><p> 假如已知条件概率分布 $p(t|\boldsymbol{x})$，每⼀种损失函数都能够给出对应的最优预测结果。使⽤最多的⼀个选择是平⽅损失函数，此时最优的预测由条件期望（记作 $h(\boldsymbol{x})$ ）给出，即</p><script type="math/tex; mode=display">h(\boldsymbol{x}) = \mathbb{E}[t|\boldsymbol{x}]=\int tp(t|\boldsymbol{x})\mathrm{d}t\tag{3.25}</script><p>考察平⽅损失函数的期望：</p><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{L}]=\int\{y(\boldsymbol{x})-h(\boldsymbol{x})\}^{2}p(\boldsymbol{x})\mathrm{d}\boldsymbol{x}+\int\int\{h(\boldsymbol{x})-t\}^{2}p(\boldsymbol{x},t)\mathrm{d}\boldsymbol{x}\mathrm{d}t\tag{3.26}</script><p>其中，与 $y(\boldsymbol{x})$ ⽆关的第⼆项，是由数据本⾝的噪声造成的，表⽰期望损失能够达到的最⼩值。第⼀项与对函数 $y(\boldsymbol{x})$ 的选择有关，我们要找⼀个 $y(\boldsymbol{x})$ 的解，使得这⼀项最⼩。由于它是⾮负的，因此我们希望能够让这⼀项的最⼩值等于零。</p><p>考察公式(3.26)的第⼀项被积函数，对于⼀个特定的数据集 $\mathcal{D}$，它的形式为</p><script type="math/tex; mode=display">\{y(\boldsymbol{x};\mathcal{D})-h(\boldsymbol{x})\}^{2}</script><p>由于这个量与特定的数据集 $\mathcal{D}$ 相关，因此对所有的数据集取平均。如果我们在括号内减去然后加上 $\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]$ ，然后展开，有</p><script type="math/tex; mode=display">\begin{aligned}\{y(\boldsymbol{x};\mathcal{D})-\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]+\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]-h(\boldsymbol{x})\}^{2} \\=\{y(\boldsymbol{x};\mathcal{D})-\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]\}^{2}+\{\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]-h(\boldsymbol{x })\}^{2}\\+2\{y(\boldsymbol{x};\mathcal{D})-\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]\}\{\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]-h(\boldsymbol{x})\}\end{aligned}</script><p>现在关于 $\mathcal{D}$ 求期望，然后注意到最后⼀项等于零，可得</p><script type="math/tex; mode=display">\begin{array}{l}{\mathbb{E}_{\mathcal{D}}\left[\{y(\boldsymbol{x} ; \mathcal{D})-h(\boldsymbol{x})\}^{2}\right]} \\ {\quad=\underbrace{\left\{\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x}; \mathcal{D})]-h(\boldsymbol{x})\right\}^{2}}_{(偏置)^{2}}+\underbrace{\mathbb{E}_{\mathcal{D}}\left[\left\{y(\boldsymbol{x} ; \mathcal{D})-\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x} ; \mathcal{D})]\right\}^{2}\right]}_{方差}}\end{array}\tag{3.27}</script><p>其中，$y(\boldsymbol{x};\mathcal{D})$ 与回归函数 $h(\boldsymbol{x})$ 的差的平⽅的期望可以表⽰为两项的和。第⼀项，被称为<strong>平⽅偏置</strong>（<code>bias</code>），表⽰所有数据集的平均预测与预期的回归函数之间的差异。第⼆项，被称为<strong>⽅差</strong>（<code>variance</code>），度量了对于单独的数据集，模型所给出的解在平均值附近波动的情况，因此也就度量了函数 $y(\boldsymbol{x};\mathcal{D})$ 对于特定的数据集的选择的敏感程度。</p><p>综上，对于期望平⽅损失的分解：</p><script type="math/tex; mode=display">期望损失=偏置^{2}+方差+噪声\tag{3.28}</script><p>其中，</p><script type="math/tex; mode=display">偏置^{2}=\int \{\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x};\mathcal{D})]-h(\boldsymbol{x})\}^{2}p(\boldsymbol{x})\mathrm{d}\boldsymbol{x} \\方差=\int \mathbb{E}_{\mathcal{D}}[\{y(\boldsymbol{x} ; \mathcal{D})-\mathbb{E}_{\mathcal{D}}[y(\boldsymbol{x} ; \mathcal{D})]\}^{2}p(\boldsymbol{x} )\mathrm{d}\boldsymbol{x}  \\噪声=\int\int\{h(\boldsymbol{x})-t\}^{2}p(\boldsymbol{x},t)\mathrm{d}\boldsymbol{x}\mathrm{d}t</script><p>对于⾮常灵活的模型来说，偏置较⼩， ⽅差较⼤；对于相对固定的模型来说，偏置较⼤，⽅差较⼩。</p><p>图3.11~3.13，模型复杂度对于偏置和⽅差的依赖的说明。左侧⼀列给出了对于不同的 $\ln \lambda$ 值，根据数据集拟合模型的结果。 为了清晰起见， 只给出了100个拟合模型中的20个。 右侧⼀列给出了对应的100个拟合的均值 （红⾊）以及⽤于⽣成数据集的正弦函数（绿⾊）。</p><p><img src="/images/prml_20191005141816.png" alt="lambda=2.6"></p><p><img src="/images/prml_20191005141838.png" alt="lambda=-0.31"></p><p><img src="/images/prml_20191005141852.png" alt="lambda=-2.4"></p><p><strong>举例</strong>：讨论正弦数据集，我们产⽣了100个数据集合， 每个集合都包含 $N = 25$ 个数据点，都是独⽴地从正弦曲线 $h(x)=\sin(2\pi x)$ 抽取的。数据集的编号为 $l = 1, \dots , L$ ， 其中 $L=100$，并且对于每个数据 集 $\mathcal{D}^{(l)}$ ，我们通过最⼩化正则化的误差函数拟合了⼀个带有24个⾼斯基函数的模型，然 后给出了预测函数 $y^{(l)}(x)$ ，如图3.11~13所⽰。如图3.11，对应着较⼤的正则化系数 $\lambda$，这样的模型的⽅差很⼩（因为左侧图中的红⾊曲线看起来很相似），但是偏置很⼤（因为右侧图中的两条曲线看起来相当不同）。相反，如图3.13，正则化系数 $\lambda$ 很⼩，这样模型的⽅差较⼤（因为左侧图中 的红⾊曲线变化性相当⼤）， 但是偏置很⼩（因为平均拟合的结果与原始正弦曲线⼗分吻合）。注意，把 $M = 25$ 这种复杂模型的多个解进⾏平均，会产⽣对于回归函数⾮常好的拟合， 这表明求平均是⼀个很好的步骤。事实上，将多个解加权平均是贝叶斯⽅法的核⼼，虽然这种求平均针对的是参数的后验分布，⽽不是针对多个数据集。</p><p>对于这个例⼦，我们也可以定量地考察<strong>偏置-⽅差折中</strong>。平均预测由下式求出：</p><script type="math/tex; mode=display">\bar{y}(x)=\frac{1}{L}\sum_{l=1}^{L}y^{(l)}(x)\tag{3.29}</script><p>有，</p><script type="math/tex; mode=display">偏置^{2}=\frac{1}{N}\sum_{n=1}^{N}\{\bar{y}(x_{n})-h(x)\}^{2}</script><script type="math/tex; mode=display">方差=\frac{1}{N}\sum_{n=1}^{N}\frac{1}{L}\sum_{l=1}^{L}\{y^{(l)}(x_{n})-\bar{y}(x_{n})\}^{2}</script><p>图3.14，平⽅偏置和⽅差的图像，以及它们的加和。</p><p><img src="/images/prml_20191005144308.png" alt="平⽅偏置和⽅差"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《模式识别与机器学习》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一，线性基函数模型&quot;&gt;&lt;a href=&quot;#一，线性基函数模型&quot; class=&quot;headerlink&quot; title=&quot;一，线性基函数模型&quot;&gt;&lt;/a&gt;一，线
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zhangbc.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习基础" scheme="https://zhangbc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习基础】概率分布之指数族分布</title>
    <link href="https://zhangbc.github.io/2019/09/29/prml_02_03/"/>
    <id>https://zhangbc.github.io/2019/09/29/prml_02_03/</id>
    <published>2019-09-29T11:34:14.000Z</published>
    <updated>2019-10-07T15:41:45.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《模式识别与机器学习》的读书笔记。</p></blockquote><h1 id="一，指数族分布"><a href="#一，指数族分布" class="headerlink" title="一，指数族分布"></a>一，指数族分布</h1><h2 id="1，指数族分布基本概念"><a href="#1，指数族分布基本概念" class="headerlink" title="1，指数族分布基本概念"></a>1，指数族分布基本概念</h2><p>参数为 $\boldsymbol{\eta}$ 的变量 $\boldsymbol{x}$ 的指数族分布定义为具有下⾯形式的概率分布的集合：</p><script type="math/tex; mode=display">p(\boldsymbol{x|\eta}) = h(\boldsymbol{x})g(\boldsymbol{\eta})\exp \{\boldsymbol{\eta}^{T}\boldsymbol{\mu}(\boldsymbol{x})\}\tag{2.106}</script><p>其中 $\boldsymbol{x}$ 可能是标量或者向量， 可能是离散的或者是连续的。 这⾥ $\boldsymbol{\eta}$ 被称为概率分布的 <strong>⾃然参数</strong> （<code>natural parameters</code>），$\boldsymbol{\mu}(\boldsymbol{x})$ 是 $\boldsymbol{x}$ 的某个函数。函数 $g(\boldsymbol{\eta})$ 可以被看成系数，它确保了概率分布是归⼀化的，因此满⾜：</p><script type="math/tex; mode=display">g(\boldsymbol{\eta})\int h(\boldsymbol{x})\exp \{\boldsymbol{\eta}^{T}\boldsymbol{\mu}(\boldsymbol{x})\}\mathrm{d}\boldsymbol{x}=1\tag{2.107}</script><p>如果 $\boldsymbol{x}$ 是离散变量，那么上式中的积分就要替换为求和。</p><p>考虑伯努利分布：</p><script type="math/tex; mode=display">p(x|\mu) = \text {Bern}(x|\mu) = \mu^{x}(1-\mu)^{1-x}\tag{2.108}</script><p>变形，有：</p><script type="math/tex; mode=display">\begin{aligned} p(x|\mu) &= \exp \{x\ln \mu +(1-x) \ln (1-\mu)\} \\ &= (1-\mu)\exp \left\{\ln \left(\frac{\mu}{1-\mu}\right)x\right\}\end{aligned}\tag{2.109}</script><p>对比公式(2.106)，可得：</p><script type="math/tex; mode=display">\eta = \ln \left(\frac{\mu}{1-\mu}\right)</script><p>从而，有：</p><script type="math/tex; mode=display">\begin{aligned}\mu &= \sigma(\eta) \\ &= \frac{1}{1+\exp(-\eta)}\end{aligned}\tag{2.110}</script><p>被称为 <strong><code>logistic sigmoid</code>函数</strong>。<br>因此，伯努利分布的指数族分布标准形式：</p><script type="math/tex; mode=display">p(x|\mu) = \sigma(-\eta)\exp(\eta x)\tag{2.111}</script><p>其中，</p><script type="math/tex; mode=display">\mu(x) = x \\ h(x) = 1 \\ g(\eta)=\sigma(-\eta)</script><p>考虑单⼀观测 $\boldsymbol{x}$ 的多项式分布，形式为：</p><script type="math/tex; mode=display">p(\boldsymbol{x|\mu}) = \prod_{k=1}^{K}\mu_{k}^{x_{k}} = \exp\left\{\sum_{k=1}^K x_{k}\ln \mu_{k}\right\}\tag{2.112}</script><p>其中 $\boldsymbol{x} = (\boldsymbol{x}_1,\dots ,\boldsymbol{x}_M)^T$ 。把它写成公式(2.106)的标准形式，即：</p><script type="math/tex; mode=display">p(\boldsymbol{x|\mu}) = \exp(\boldsymbol{\eta}^{T}\boldsymbol{x})\tag{2.113}</script><p>其中，$\eta_{k} = \ln \mu_{k}$ ，$\boldsymbol{\eta}=(\eta_1,\dots,\eta_{M})^T$，并且</p><script type="math/tex; mode=display">\boldsymbol{\mu}(\boldsymbol{x}) = \boldsymbol{x} \\ h(\boldsymbol{x}) = 1 \\ g(\boldsymbol{\eta}) = 1 \\ \sum_{k=1}^{K} \mu_{k}=1</script><p>考虑只⽤ $M−1$ 个参数来表⽰这个分布，把 $\mu_M$ ⽤剩余的 $\{\mu_k\}$ 表⽰，其中 $k = 1, \dots , M−1$，这样就只剩下了 $M−1$ 个参数，公式(2.112)变为：</p><script type="math/tex; mode=display">\begin{aligned}p(\boldsymbol{x|\mu}) &= \exp\left\{\sum_{k=1}^K x_{k}\ln \mu_{k}\right\} \\ &= \exp \left\{\sum_{k=1}^{M-1}x_{k}\ln\left(\frac{\mu_{k}}{1-\sum_{j=1}^{M-1}\mu_{j}}\right) + \ln \left(1-\sum_{k=1}^{M-1}\mu_{k}\right)\right\} \end{aligned}\tag{2.114}</script><p>令</p><script type="math/tex; mode=display">\eta_{k} = \ln\left(\frac{\mu_{k}}{1-\sum_{j=1}^{M-1}\mu_{j}}\right)</script><p>即得：</p><script type="math/tex; mode=display">\mu_{k} = \frac{\exp (\eta_{k})}{1+\sum_{j=1}^{M-1}\exp(\eta_{j})}\tag{2.115}</script><p>这被称为 <strong><code>softmax</code>函数</strong>，或者<strong>归⼀化指数</strong>（<code>normalized exponential</code>）。因此，单⼀观测 $\boldsymbol{x}$ 的多项式分布的指数族分布标准形式：</p><script type="math/tex; mode=display">p(\boldsymbol{x}|\boldsymbol{\eta}) = \left(1+\sum_{k=1}^{M-1}\exp(\eta_{k})\right)^{-1}\exp(\boldsymbol{\mu}^T\boldsymbol{x})\tag{2.116}</script><p>其中 $\boldsymbol{\eta}=(\eta_1,\dots,\eta_{M-1},0)^T$，并且</p><script type="math/tex; mode=display">\boldsymbol{\mu}(\boldsymbol{x}) = \boldsymbol{x} \\ h(\boldsymbol{x}) = 1 \\ g(\boldsymbol{\eta}) =\left(1+\sum_{k=1}^{M-1}\exp(\eta_{k})\right)^{-1}</script><p>对于⼀元⾼斯分布，有：</p><script type="math/tex; mode=display">\begin{aligned} p\left(x | \mu, \sigma^{2}\right) &=\frac{1}{\left(2 \pi \sigma^{2}\right)^{\frac{1}{2}}} \exp \left\{-\frac{1}{2 \sigma^{2}}(x-\mu)^{2}\right\} \\ &=\frac{1}{\left(2 \pi \sigma^{2}\right)^{\frac{1}{2}}} \exp \left\{-\frac{1}{2 \sigma^{2}}x^{2} + \frac{\mu}{\sigma^{2}}x -\frac{1}{2 \sigma^{2}}\mu^{2}\right\} \end{aligned}\tag{2.117}</script><p>其中，</p><script type="math/tex; mode=display">\boldsymbol{\eta}=\dbinom{\frac{\mu}{\sigma^{2}}}{\frac{-1}{2\sigma^2}} \\ \boldsymbol{\mu}({x})=\dbinom{x}{x^2} \\ h(x) = (2\pi)^{-\frac{1}{2}} \\ g(\boldsymbol{\eta}) = (-2\eta_2)^{\frac{1}{2}}\exp \left(\frac{\eta_{1}^{2}}{4\eta_{2}}\right)</script><h2 id="2，最⼤似然与充分统计量"><a href="#2，最⼤似然与充分统计量" class="headerlink" title="2，最⼤似然与充分统计量"></a>2，最⼤似然与充分统计量</h2><p>设二元函数 $z=f(x,y)$ 在平面区域 $D$上具有一阶连续偏导数，则对于每一个点 $P_0(x_0,y_0)\in D$ 都可定出一个向量 </p><script type="math/tex; mode=display">\left\{\frac{\partial f}{\partial x_0},\frac{\partial f}{\partial y_0} \right\} = f_x(x_0,y_0)\boldsymbol{i} + f_y(x_0,y_0)\boldsymbol{j}</script><p>，该向量称为函数 $z=f(x,y)$ 在点$P_0(x_0,y_0)$的<strong>梯度</strong>，记作 $\text{gradf}(x_0,y_0)$ 或 $\nabla f(x_0, y_0)$<br>即有：</p><script type="math/tex; mode=display">\text { gradf }(x_0, y_0)=\nabla f(x_0, y_0)=\left\{\frac{\partial f}{\partial x_0}, \frac{\partial f}{\partial y_0}\right\}=f_{x}(x_0, y_0) \boldsymbol{i}+f_{y}(x_0, y_0) \boldsymbol{j}\tag{2.118}</script><p>其中 $\nabla =\frac{\partial}{\partial x} \boldsymbol{i} + \frac{\partial}{\partial y}\boldsymbol{j}$ 称为（二维的）<strong>向量微分算子</strong>或 <strong><code>Nabla</code>算子</strong>，  $\nabla {f}=\frac{\partial {f}}{\partial x} \boldsymbol{i} + \frac{\partial{f}}{\partial y}\boldsymbol{j}$ 。</p><p>对公式(2.107)的两侧关于 $\boldsymbol{\mu}$ 取梯度，有：</p><script type="math/tex; mode=display">\begin{aligned} \nabla g(\boldsymbol{\eta})\int h(\boldsymbol{x})\exp \{\boldsymbol{\eta}^{T}\boldsymbol{\mu}(\boldsymbol{x})\}\mathrm{d}\boldsymbol{x} + g(\boldsymbol{\eta})\int h(\boldsymbol{x})\exp \{\boldsymbol{\eta}^{T}\boldsymbol{\mu}(\boldsymbol{x})\}\boldsymbol{\mu}(\boldsymbol{x})\mathrm{d}\boldsymbol{x} =0 \end{aligned}\tag{2.119}</script><p>从而可以推导出：</p><script type="math/tex; mode=display">-\nabla \ln g(\boldsymbol{\eta}) = \mathbb{E}[\boldsymbol{\mu}(\boldsymbol{x})]\tag{2.120}</script><p>现在考虑⼀组独⽴同分布的数据 $\boldsymbol{X} = \{\boldsymbol{x}_1, \dots, \boldsymbol{x}_N\}$。对于这个数据集，似然函数为：</p><script type="math/tex; mode=display">p(\boldsymbol{X|\eta}) = \left(\prod_{n=1}^{N}h(\boldsymbol{x}_{n})\right) g(\boldsymbol{\eta})^{N} \exp\left\{\sum_{n=1}^{N} \boldsymbol{\eta}^{T}\boldsymbol{\mu}(\boldsymbol{x}_n)\right\}\tag{2.121}</script><p>令 $\ln p(\boldsymbol{X|\eta})$ 关于 $\boldsymbol{\eta}$ 的导数等于零，我们可以得到最⼤似然估计 $\boldsymbol{\mu}_{ML}$ 满⾜的条件：</p><script type="math/tex; mode=display">-\nabla \ln g(\boldsymbol{\eta}_{ML})=\frac{1}{N}\sum_{n=1}^{N}\boldsymbol{\mu}(\boldsymbol{x}_n)\tag{2.122}</script><p>原则上可以通过解这个⽅程来得到 $\boldsymbol{\mu}_{ML}$ 。我们看到最⼤似然估计的解只通过 $\boldsymbol{\mu}(\boldsymbol{x}_n)$ 对数据产⽣依赖，因此这个量被称为指数族分布的<strong>充分统计量</strong>（<code>sufficient statistic</code>）。</p><h2 id="3，共轭先验"><a href="#3，共轭先验" class="headerlink" title="3，共轭先验"></a>3，共轭先验</h2><p>对于指数族分布的任何成员，都存在⼀个共轭先验，可以写成下⾯的公式：</p><script type="math/tex; mode=display">p(\boldsymbol{\eta} | \boldsymbol{\chi}, \nu)=f(\boldsymbol{\chi}, \nu) g(\boldsymbol{\eta})^{\nu} \exp \left\{\nu \boldsymbol{\eta}^{T} \boldsymbol{\chi}\right\}\tag{2.123}</script><h2 id="4，无信息先验"><a href="#4，无信息先验" class="headerlink" title="4，无信息先验"></a>4，无信息先验</h2><p>在许多情形下， 我们可能对分布应该具有的形式⼏乎完全不知道。 这时， 我们可以寻找⼀种形式的先验分布， 被称为<strong>⽆信息先验</strong>（<code>noninformative prior</code>）。 这种先验分布的⽬的是尽量对后验分布产⽣尽可能⼩的影响（<code>Jeffreys</code>, 1946; <code>Box and Tiao</code>, 1973; <code>Bernardo and Smith</code>, 1994）。这有时被称为“<strong>让数据⾃⼰说话</strong>”。</p><p>考虑⽆信息先验的两个简单的例⼦（<code>Berger</code>, 1985）。</p><p>例1，如果概率密度的形式为：</p><script type="math/tex; mode=display">p(x|\mu)=f(x-\mu)\tag{2.124}</script><p>那么参数 $\mu$ 被称为<strong>位置参数</strong>（<code>location parameter</code>）。这⼀类概率分布具有<strong>平移不变性</strong>（<code>translation invariance</code>），因为如果把 $x$ 平移⼀个常数，得到 $\hat{x}=x+c$，那么：</p><script type="math/tex; mode=display">p(\hat{x}|\hat{\mu})=f(\hat{x}-\hat{\mu})\tag{2.125}</script><p>其中，$\hat{\mu}=\mu+c$。新变量的概率密度的形式与原变量相同，因此概率密度与原点的选择⽆关。想要选择⼀个能够反映这种平移不变性的先验分布，因此我们选择的先验概率分布要对区间 $A \le \mu \le B$ 以及平移后的区间 $A−c \le \mu \le B−c$ 赋予相同的概率质量。这说明：</p><script type="math/tex; mode=display">\int_{A}^{B} p(\mu)\mathrm{d}\mu = \int_{A-c}^{B-c} p(\mu)\mathrm{d}\mu = \int_{A}^{B} p(\mu - c)\mathrm{d}\mu\tag{2.126}</script><p>并且由于这必须对于任意的 $A$ 和 $B$ 的选择都成⽴，因此有：</p><script type="math/tex; mode=display">p(\mu-c)=p(\mu)\tag{2.127}</script><p>这表明 $p(\mu)$ 是常数。</p><p>例2，考虑概率分布的形式为：</p><script type="math/tex; mode=display">p(x|\sigma)=\frac{1}{\sigma}f\left(\frac{x}{\sigma}\right)\tag{2.128}</script><p>其中，$\sigma \gt 0$。参数 $\sigma$ 被称为 <strong>缩放参数</strong>（<code>scale parameter</code>），概率密度具有<strong>缩放不变性</strong>（<code>scale invariance</code>）因为如果把 $x$ 缩放⼀个常数，得到 $\hat{x} = cx$，那么：</p><script type="math/tex; mode=display">p(\hat{x}|\hat{\sigma})=\frac{1}{\hat{\sigma}}f\left(\frac{\hat{x}}{\hat{\sigma}}\right)\tag{2.129}</script><p>其中，$\hat{\sigma}=c\sigma$。这个变换对应于单位的改变。想要选择⼀个能够反映这种缩放不变性的先验分布，因此我们选择的先验概率分布要对区间 $A \le \sigma \le B$ 以及平移后的区间 $\frac{A}{c} \le \sigma \le \frac{B}{c}$ 赋予相同的概率质量。这说明：</p><script type="math/tex; mode=display">\int_{A}^{B} p(\sigma)\mathrm{d}\sigma = \int_{\frac{A}{c}}^{\frac{B}{c}} p(\sigma)\mathrm{d}\sigma = \int_{A}^{B} p\left(\frac{1}{c}\sigma\right)\frac{1}{c}\mathrm{d}\sigma\tag{2.130}</script><p>并且由于这必须对于任意的 $A$ 和 $B$ 的选择都成⽴，因此有：</p><script type="math/tex; mode=display">p(\sigma) = p\left(\frac{1}{c}\sigma\right)\frac{1}{c}\tag{2.131}</script><h1 id="二，非参数化方法"><a href="#二，非参数化方法" class="headerlink" title="二，非参数化方法"></a>二，非参数化方法</h1><p>具有具体函数形式的概率分布，并且由少量的参数控制，这些参数的值可以由数据集确定。这被称为<strong>概率密度建模的参数化（<code>parametric</code>）⽅法</strong>。</p><h2 id="1，核密度估计"><a href="#1，核密度估计" class="headerlink" title="1，核密度估计"></a>1，核密度估计</h2><p>假设观测服从 $D$ 维空间的某个未知的概率密度分布 $p(\boldsymbol{x})$。把这个 $D$ 维空间选择成<strong>欧⼏⾥得空间</strong>， 并且我们想估计 $p(\boldsymbol{x})$ 的值。 根据之前对于局部性的讨论， 考虑包含 $\boldsymbol{x}$ 的某个⼩区域 $\mathcal{R}$。这个区域的概率质量为：</p><script type="math/tex; mode=display">P = \int_{\mathcal{R}} p(\boldsymbol{x}) \mathrm{d}\boldsymbol{x}\tag{2.132}</script><p>假设收集了服从 $p(\boldsymbol{x})$ 分布的 $N$ 次观测，由于每个数据点都有⼀个落在区域 $\mathcal{R}$ 中的概率 $P$ ，因此位于区域 $\mathcal{R}$ 内部的数据点的总数 $K$ 将服从<strong>⼆项分布</strong>：</p><script type="math/tex; mode=display">\text {Bin}(K|N, P) = \frac{N!}{K!(N-K)!} P^{K}(1-P)^{N-K}\tag{2.133}</script><p>对于⼤的 $N$ 值， 这 个分布将会在均值附近产⽣尖峰，并且 $K\simeq NP$。<br>假定区域 $\mathcal{R}$ ⾜够⼩，使得在这个区域内的概率密度 $p(\boldsymbol{x})$ ⼤致为常数，设 $V$ 是区域 $\mathcal{R}$ 的体积，那么 $P \simeq p(\boldsymbol{x})V$ 。</p><p>由以上分析，可以得到概率密度的估计：</p><script type="math/tex; mode=display">p(\boldsymbol{x}) = \frac{K}{NV}\tag{2.134}</script><p>我们有两种⽅式利⽤公式(2.232)的结果。 我们可以固定 $K$ 然后从数据中确定 $V$ 的值， 这就 是 $K$ <strong>近邻⽅法</strong>。我们还可以固定 $V$ 然后从数据中确定 $K$ ，这就是<strong>核⽅法</strong>。在极限 $N \to \infty$ 的情况下，如果 $V$ 随着 $N$ ⽽合适地收缩，并且 $K$ 随着 $N$ 增⼤，那么可以证明 $K$ <strong>近邻</strong>概率密度估计和<strong>核⽅法</strong>概率密度估计都会收敛到真实的概率密度（<code>Duda and Hart</code>, 1973）。</p><p>取区域 $\mathcal{R}$ 以 $\boldsymbol{x}$ 为中⼼的⼩超⽴⽅体，确定概率密度。为了统计落在这个区域内的数据点的数量 $K$ ，定义下⾯的函数：</p><script type="math/tex; mode=display">k(\boldsymbol{\mu})=\left\{\begin{array}{l}{1，|\mu_i| \le \frac{1}{2}, i=1,\dots,D} \\ {0，其他情况}\end{array}\right.\tag{2.135}</script><p>并且满足：</p><p>1）$k(\boldsymbol{\mu}) \ge 0$<br>2）$\int k(\boldsymbol{\mu}) \mathrm{d} \boldsymbol{\mu} = 1$</p><p>这表⽰⼀个以原点为中⼼的单位⽴⽅体。 函数 $k(\boldsymbol{\mu})$ 是 <strong>核函数</strong>（<code>kernel function</code>）的⼀个例⼦， 在这个问题中也被称为 <strong><code>Parzen</code>窗</strong>（<code>Parzen window</code>）。 不难发现，如果数据点 $\boldsymbol{x}_n$ 位于以 $\boldsymbol{x}$ 为中⼼的边长为 $h$ 的⽴⽅体中，则位于这个⽴⽅体内的数据点的总数为：</p><script type="math/tex; mode=display">K=\sum_{k=1}^{K}k\left(\frac{\boldsymbol{x}-\boldsymbol{x_n}}{h}\right)\tag{2.136}</script><p>由公式(2.134)可得点 $\boldsymbol{x}$ 处的概率密度估计，称为<strong>核密度估计</strong>，或者 <strong><code>Parzen</code>估计</strong>：</p><script type="math/tex; mode=display">p(\boldsymbol{x})=\frac{1}{N}\sum_{n=1}^{N}\frac{1}{h^{D}} k \left(\frac{\boldsymbol{x}-\boldsymbol{x_n}}{h}\right)\tag{2.137}</script><p>其中，记 $D$ 维边长为 $h$ 的⽴⽅体的体积公式 $V = h^D$ 。</p><p>使⽤<strong>⾼斯核函数</strong>，可以得到下⾯的核概率密度模型：</p><script type="math/tex; mode=display">p(\boldsymbol{x})=\frac{1}{N}\sum_{n=1}^{N}\frac{1}{\left(2 \pi h^{2}\right)^{\frac{D}{2}}} \exp \left\{-\frac{||\boldsymbol{x}-\boldsymbol{x}_n||^{2}}{2 h^{2}}\right\}\tag{2.138}</script><p>其中 $h$ 表⽰⾼斯分布的<strong>标准差</strong>。因此概率密度模型可以通过以下⽅式获得：令每个数据点都服从<strong>⾼斯分布</strong>，然后把数据集⾥的每个数据点的贡献相加，之后除以 $N$ ，使得概率密度正确地被归⼀化。</p><p>如图2.33，核密度模型。</p><p><img src="/images/prml_20190929000243.png" alt="核密度模型"></p><h2 id="2，近邻⽅法"><a href="#2，近邻⽅法" class="headerlink" title="2，近邻⽅法"></a>2，近邻⽅法</h2><p><strong>核⽅法</strong>进⾏概率密度估计的⼀个难点是控制核宽度的参数 $h$ 对于所有的核都是固定的。 在⾼数据密度的区域，⼤的 $h$ 值可能会造成过度平滑，并且破坏了本应从数据中提取出的结构； 但是，减⼩ $h$ 的值可能导致数据空间中低密度区域估计的噪声。因此，$h$ 的最优选择可能依赖于数据空间的位置。这个问题可以通过概率密度的<strong>近邻⽅法</strong>解决。</p><p>假设球体的半径可以⾃由增长，直到它精确地包含 $K$ 个数据点。 这样，概率密度 $p(\boldsymbol{x})$ 的估计就由公式(2.134)给出， 其中 $V$ 等于最终球体的体积。这种⽅法被称为 <strong><code>K</code>近邻⽅法</strong>。</p><p>如图2.34，$K$ 近邻⽅法。</p><p><img src="/images/prml_20190929000307.png" alt="K近邻⽅法"></p><p>现在讨论明概率密度估计的 $K$ <strong>近邻⽅法</strong>如何推⼴到分类问题。</p><p>假设有⼀个数据集，其中 $N_k$ 个数据点属于类别 $\mathcal{C}_k$ ，数据点的总数为 $N$ ，因此 $\sum_{k} N_k = N$ 。如果想对⼀个新的数据点 $\boldsymbol{x}$ 进⾏分类，那么可以画⼀个以 $\boldsymbol{x}$ 为中⼼的球体，这个球体精确地包含 $K$ 个数据点（⽆论属于哪个类别）。假设球体的体积为 $V$ ，并且包含来⾃类别 $\mathcal{C}_k$ 的 $K_k$ 个数据点，这样与每个类别关联的⼀个概率密度的估计：</p><script type="math/tex; mode=display">p(\boldsymbol{x}|\mathcal{C}_k) = \frac{K_k}{N_kV}\tag{2.139}</script><p>⽆条件概率密度为：</p><script type="math/tex; mode=display">p(\boldsymbol{x}) = \frac{K}{NV}\tag{2.140}</script><p>类先验为：</p><script type="math/tex; mode=display">p(\mathcal{C}_k) = \frac{N_k}{N}\tag{2.141}</script><p>可以得到类别的后验概率公式：</p><script type="math/tex; mode=display">p(\mathcal{C}_k | \boldsymbol{x}) = \frac{p(\boldsymbol{x}|\mathcal{C}_k)p(\mathcal{C}_k)}{p(\boldsymbol{x})} = \frac{K_k}{K}\tag{2.142}</script><p><strong>最近邻</strong> ($K = 1$) <strong>分类器</strong>的⼀个重要的性质是：在极限 $N \to \infty$ 的情况下，错误率不会超过<strong>最优分类器</strong>（即使⽤真实概率分布的分类器）可以达到的最⼩错误率的⼆倍（<code>Cover and Hart</code>, 1967）。</p><p>如图2.35～2.36，$K$ 近邻分类器（$K=1$ 和 $K=3$）。</p><p><img src="/images/prml_20190929121905.png" alt="K=3"></p><p><img src="/images/prml_20190929121914.png" alt="K=1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《模式识别与机器学习》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一，指数族分布&quot;&gt;&lt;a href=&quot;#一，指数族分布&quot; class=&quot;headerlink&quot; title=&quot;一，指数族分布&quot;&gt;&lt;/a&gt;一，指数族分布&lt;/
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zhangbc.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习基础" scheme="https://zhangbc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习基础】概率分布之高斯分布</title>
    <link href="https://zhangbc.github.io/2019/09/29/prml_02_02/"/>
    <id>https://zhangbc.github.io/2019/09/29/prml_02_02/</id>
    <published>2019-09-29T08:11:56.000Z</published>
    <updated>2019-10-07T15:04:47.210Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《模式识别与机器学习》的读书笔记。</p></blockquote><h1 id="一，多元高斯分布"><a href="#一，多元高斯分布" class="headerlink" title="一，多元高斯分布"></a>一，多元高斯分布</h1><p>考虑<strong>⾼斯分布</strong>的⼏何形式，⾼斯对于 $\boldsymbol{x}$ 的依赖是通过下⾯形式的⼆次型：</p><script type="math/tex; mode=display">\Delta^{2} = (\boldsymbol{x} - \boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x} - \boldsymbol{\mu})\tag{2.30}</script><p>其中，$\Delta$ 被叫做 $\boldsymbol{\mu}$ 和 $\boldsymbol{x}$ 之间的<strong>马⽒距离</strong>（<code>Mahalanobis distance</code>）。 当 $\boldsymbol{\Sigma}$ 是单位矩阵时，就变成了<strong>欧式距离</strong>。对于 $\boldsymbol{x}$ 空间中这个⼆次型是常数的曲⾯，⾼斯分布也是常数。</p><p>现在考虑<strong>协⽅差矩阵</strong>的<strong>特征向量⽅程</strong>：</p><script type="math/tex; mode=display">\boldsymbol{\Sigma} \boldsymbol{\mu}_i = \lambda_{i} \boldsymbol{\mu}_{i}\tag{2.31}</script><p>其中 $i = 1,\dots , D$。由于 $\boldsymbol{\Sigma}$ 是<strong>实对称矩阵</strong>，因此它的特征值也是实数，并且特征向量可以被选成<strong>单位正交</strong>的，即：</p><script type="math/tex; mode=display">\boldsymbol{\mu}_{i}^{T} \boldsymbol{\mu}_{j} = I_{ij}\tag{2.32}</script><p>其中 $I_{ij}$ 是单位矩阵的第 $i, j$ 个元素，满⾜：</p><script type="math/tex; mode=display">I_{i j}=\left\{\begin{array}{l}{1，如果 i=j} \\ {0，其他情况}\end{array}\right. \tag{2.33}</script><p>协⽅差矩阵 $\boldsymbol{\Sigma}$ 可以表⽰成特征向量的展开的形式：</p><script type="math/tex; mode=display">\boldsymbol{\Sigma} = \sum_{i=1}^{D} \lambda_i \boldsymbol{\mu}_{i}\boldsymbol{\mu}_{i}^{T}\tag{2.34}</script><p>协⽅差矩阵的逆矩阵 $\boldsymbol{\Sigma}^{-1}$ 可以表⽰成特征向量的展开的形式：</p><script type="math/tex; mode=display">\boldsymbol{\Sigma}^{-1} = \sum_{i=1}^{D} \frac{1}{\lambda_i} \boldsymbol{\mu}_{i}\boldsymbol{\mu}_{i}^{T}\tag{2.35}</script><p>⼆次型公式(2.30)即可表示为：</p><script type="math/tex; mode=display">\Delta^{2} = \sum_{i=1}^{D} \frac{y_{i}^{2}}{\lambda_{i}}\tag{2.36}</script><p>其中，$y_{i}^{2} = \boldsymbol{u_i^T} (\boldsymbol{x} - \boldsymbol{\mu})$ 。</p><p>把 $\{y_i\}$ 表⽰成单位正交向量 $\boldsymbol{\mu_i}$ 关于原始的 $x_i$ 坐标经过平移和旋转后形成的新的坐标系。定义向量 $\boldsymbol{y} = (y_1,\dots, y_D)^T$ ，即有：</p><script type="math/tex; mode=display">\boldsymbol {y} = \boldsymbol{U} (\boldsymbol{x} - \boldsymbol{\mu})\tag{2.37}</script><p>其中 $\boldsymbol{U}$ 是⼀个矩阵，它的⾏是向量 $\boldsymbol{u}_{i}^{T}$ 。从公式(2.32)可以看出 $\boldsymbol{U}$ 是⼀个<strong>正交矩阵</strong>， 即它满⾜性质 $\boldsymbol{U}\boldsymbol{U}^T = \boldsymbol{I}$ ，因此也满⾜ $\boldsymbol{U}^T \boldsymbol{U} = \boldsymbol{I}$ ，其中 $\boldsymbol{I}$ 是单位矩阵。</p><p>⼀个特征值严格⼤于零的矩阵被称为<strong>正定（<code>positive definite</code>）矩阵</strong>。偶尔遇到⼀个或者多个特征值为零的⾼斯分布，那种情况下分布是奇异的，被限制在 了⼀个低维的⼦空间中。如果所有的特征值都是⾮负的，那么这个矩阵被称为<strong>半正定（<code>positive semidefine</code>）矩阵</strong>。</p><p>如图2.12，红⾊曲线表⽰⼆维空间 $\boldsymbol{x} = (x_1 , x_2)$ 的⾼斯分布的常数概率密度的椭圆⾯， 它表⽰的概率密度为 $\exp(−\frac{1}{2})$，值是在 $\boldsymbol{x} = \boldsymbol{\mu}$ 处计算的。椭圆的轴由协⽅差矩阵的特征向量 $\mu_i$ 定义，对应的特征值为 $\lambda_i$ 。</p><p><img src="/images/prml_20190920171000.png" alt="椭圆面"></p><p>现在考虑在由 $y_i$ 定义的新坐标系下⾼斯分布的形式。 从 $\boldsymbol{x}$ 坐标系到 $\boldsymbol{y}$ 坐标系， 我们有⼀个 <strong><code>Jacobian</code>矩阵</strong> $\boldsymbol{J}$ ，它的元素为：</p><script type="math/tex; mode=display">\boldsymbol{J}_{ij} = \frac{\partial {x_i}}{\partial {j_j}} = U_{ij}\tag{2.38}</script><p>其中 $U_{ji}$ 是矩阵 $\boldsymbol{U}^T$ 的元素。使⽤矩阵 $\boldsymbol{U}$ 的单位正交性质，我们看到 <strong><code>Jacobian</code>矩阵</strong> ⾏列式的平⽅为：</p><script type="math/tex; mode=display">| \boldsymbol{J}^{2} | = |\boldsymbol{U}^{T}|^{2} = |\boldsymbol{U}^{T}||\boldsymbol{U}| = |\boldsymbol{U}^{T}\boldsymbol{U}| = |\boldsymbol{I}| = 1\tag{2.39}</script><p>从而可知，$|\boldsymbol{J}|=1$ ，并且，⾏列式 $|\boldsymbol{\Sigma}|$ 的协⽅差矩阵可以写成特征值的乘积，因此：</p><script type="math/tex; mode=display">|\boldsymbol{\Sigma}|^{\frac{1}{2}} = \prod_{j=1}^{D} \lambda_{j}^{\frac{1}{2}}\tag{2.40}</script><p>因此在 $\boldsymbol{y}$ 坐标系中，⾼斯分布的形式为：</p><script type="math/tex; mode=display">p(\boldsymbol{y}) = p(\boldsymbol{x})|\boldsymbol{J}| = \prod_{j=1}^{D} \frac{1}{(2 \pi \lambda_{j})^{\frac{1}{2}}} \exp \left \{- \frac{y_{i}^2}{2\lambda_j} \right \}\tag{2.41}</script><p>这是 $D$ 个独⽴⼀元⾼斯分布的乘积。</p><p>在 $\boldsymbol{y}$ 坐标系中，概率分布的积分为：</p><script type="math/tex; mode=display">\int p(\boldsymbol{y}) \mathrm{d} \boldsymbol{y} = \prod_{j=1}^{D} \int_{-\infty}^{\infty} \frac{1}{(2 \pi \lambda_{j})^{\frac{1}{2}}} \exp \left \{- \frac{y_{i}^2}{2\lambda_j} \right \} \mathrm{d} y_j = 1\tag{2.42}</script><p><strong>⾼斯分布</strong>下 $\boldsymbol{x}$ 的期望为：</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{E}[\boldsymbol{x}] &= \frac{1}{(2 \pi)^{\frac{D}{2}}} \frac{1}{|\boldsymbol{\Sigma}|^{\frac{1}{2}}} \int \exp \left\{-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right\} \boldsymbol{x} \mathrm{d} \boldsymbol{x} \\ &= \frac{1}{(2 \pi)^{\frac{D}{2}}} \frac{1}{|\boldsymbol{\Sigma}|^{\frac{1}{2}}} \int \exp \left\{-\frac{1}{2}\boldsymbol{z}^{T} \boldsymbol{\Sigma}^{-1} \boldsymbol{z}\right\} (\boldsymbol{z+\mu}) \mathrm{d} \boldsymbol{z} \end{aligned}\tag{2.43}</script><p>其中，$\boldsymbol{z = x - \mu}$ 。注意到指数位置是 $\boldsymbol{z}$ 的偶函数，并且由于积分区间为 $(−\infty, \infty)$，因此在因⼦ $(\boldsymbol{z + \mu})$ 中的 $\boldsymbol{z}$ 中的项会由于对称性变为零。因此 $\mathbb{E}[\boldsymbol{x}] = \boldsymbol{\mu}$ 。称 $\boldsymbol{\mu}$ 为⾼斯分布的<strong>均值</strong>。</p><p>现在考虑⾼斯分布的⼆阶矩。对于多元⾼斯分布，有 $D^2$ 个由 $\mathbb{E}[x_i x_j]$ 给出的⼆阶矩，可以聚集在⼀起组成矩阵 $\mathbb{E}[\boldsymbol{x}\boldsymbol{x}^T ]$。</p><script type="math/tex; mode=display">\begin{aligned} \mathbb{E}[\boldsymbol{x}\boldsymbol{x}^{T}] &= \frac{1}{(2 \pi)^{\frac{D}{2}}} \frac{1}{|\boldsymbol{\Sigma}|^{\frac{1}{2}}} \int \exp \left\{-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right\} \boldsymbol{x} \boldsymbol{x}^{T}\mathrm{d} \boldsymbol{x} \\ &= \frac{1}{(2 \pi)^{\frac{D}{2}}} \frac{1}{|\boldsymbol{\Sigma}|^{\frac{1}{2}}} \int \exp \left\{-\frac{1}{2}\boldsymbol{z}^{T} \boldsymbol{\Sigma}^{-1} \boldsymbol{z}\right\} (\boldsymbol{z+\mu})(\boldsymbol{z+\mu})^{T} \mathrm{d} \boldsymbol{z} \end{aligned}\tag{2.44}</script><p>其中，$\boldsymbol{z = x - \mu}$ ，$\boldsymbol{z} = \sum_{j=1}^{D} y_i \boldsymbol{u_j}$ ，$y_i = \boldsymbol{u_j}^{T}\boldsymbol{z}$ 。</p><p>由此可以推导出：</p><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{x}\boldsymbol{x}^{T}] = \boldsymbol{\mu}\boldsymbol{u}^{T} + \boldsymbol{\Sigma}\tag{2.45}</script><p>随机变量 $\boldsymbol{x}$ 的<strong>协⽅差</strong>（<code>covariance</code>），定义为：</p><script type="math/tex; mode=display">\text{var}[\boldsymbol{x}] = \mathbb{E}[(\boldsymbol{x} - \mathbb{E}[\boldsymbol{x}])(\boldsymbol{x} - \mathbb{E}[\boldsymbol{x}])^{T}]\tag{2.46}</script><p>对于⾼斯分布这⼀特例，我们可以使⽤ $\mathbb{E}[\boldsymbol{x}] = \boldsymbol{\mu}$ 以及公式(2.45)的结果，得到：</p><script type="math/tex; mode=display">\text{var}[\boldsymbol{x}] = \boldsymbol{\Sigma}\tag{2.47}</script><p>由于参数 $\boldsymbol{\Sigma}$ 公式了⾼斯分布下 $\boldsymbol{x}$ 的协⽅差，因此它被称为<strong>协⽅差矩阵</strong>。</p><h1 id="二，条件⾼斯分布"><a href="#二，条件⾼斯分布" class="headerlink" title="二，条件⾼斯分布"></a>二，条件⾼斯分布</h1><p>多元⾼斯分布的⼀个<strong>重要性质</strong>：如果两组变量是联合⾼斯分布，那么以⼀组变量为条件， 另⼀组变量同样是⾼斯分布。</p><p>假设 $\boldsymbol{x}$ 是⼀个服从⾼斯分布 $\mathcal{N}(\boldsymbol{x} | \boldsymbol{\mu}, \mathbf{\Sigma})$ 的 $D$ 维向量。我们把 $\boldsymbol{x}$ 划分成两个不相交的⼦集 $\boldsymbol{x}_a$ 和 $\boldsymbol{x}_b$ 。 不失⼀般性， 令 $\boldsymbol{x}_a$ 为 $\boldsymbol{x}$ 的前 $M$ 个分量， 令 $\boldsymbol{x}_b$ 为剩余的 $D − M$ 个分量，因此</p><script type="math/tex; mode=display">\boldsymbol{x} = \dbinom{\boldsymbol{x}_a}{\boldsymbol{x}_b}</script><p>同理，对应的对均值向量 $\boldsymbol{\mu}$ 的划分，即</p><script type="math/tex; mode=display">\boldsymbol{\mu} = \dbinom{\boldsymbol{\mu}_a}{\boldsymbol{\mu}_b}</script><p>协⽅差矩阵 $\boldsymbol{\Sigma}$ 为：</p><script type="math/tex; mode=display">\boldsymbol{\Sigma} = \begin{pmatrix} \boldsymbol{\Sigma}_{aa} & \boldsymbol{\Sigma}_{ab} \\ \boldsymbol{\Sigma}_{ba} & \boldsymbol{\Sigma}_{bb}  \end{pmatrix}\tag{2.48}</script><p>注意，协⽅差矩阵的对称性 $\boldsymbol{\Sigma} ^T= \boldsymbol{\Sigma}$ 表明 $\boldsymbol{\Sigma}_{aa}$ 和 $\boldsymbol{\Sigma}_{bb}$ 也是对称的，⽽ $\boldsymbol{\Sigma}_{ba} = \boldsymbol{\Sigma}_{ab}^{T}$ 。</p><p>在许多情况下，使⽤<strong>协⽅差矩阵的逆矩阵</strong>⽐较⽅便，也叫<strong>精度矩阵（<code>precision matrix</code>）</strong>，即：</p><script type="math/tex; mode=display">\boldsymbol{\Lambda} \equiv \boldsymbol{\Sigma}^{-1}\tag{2.49}</script><p><strong>精度矩阵</strong>的划分形式</p><script type="math/tex; mode=display">\boldsymbol{\Lambda} = \begin{pmatrix} \boldsymbol{\Lambda}_{aa} & \boldsymbol{\Lambda}_{ab} \\ \boldsymbol{\Lambda}_{ba} & \boldsymbol{\Lambda}_{bb}  \end{pmatrix}</script><p>关于分块矩阵的逆矩阵的恒等式：</p><script type="math/tex; mode=display">\begin{pmatrix} \boldsymbol{A} & \boldsymbol{B} \\ \boldsymbol{C} & \boldsymbol{D}  \end{pmatrix}^{-1} = \begin{pmatrix} \boldsymbol{M} & \boldsymbol{-MBD^{-1}} \\ \boldsymbol{-D^{-1}CM} & \boldsymbol{D^{-1}+CMBD^{-1}}  \end{pmatrix}\tag{2.50}</script><p>其中， $\boldsymbol{M = (A-BD^{-1}C)^{-1}}$ ，$\boldsymbol{M}^{-1}$ 被称为公式(2.50)左侧矩阵关于⼦矩阵 $\boldsymbol{D}$ 的<strong>舒尔补</strong>（<code>Schur complement</code>）。</p><p>由以上公式和相关结论可以推导出条件概率分布 $p(\boldsymbol{x}_a | \boldsymbol{x}_b)$ 的<strong>均值</strong>和<strong>协⽅差</strong>的表达式：</p><script type="math/tex; mode=display">\boldsymbol{\mu}_{a|b} = \boldsymbol{\mu}_a + \boldsymbol{\Sigma}_{ab}\boldsymbol{\Sigma}_{bb}^{-1}(\boldsymbol{x}_b-\boldsymbol{\mu}_b)\tag{2.51}</script><script type="math/tex; mode=display">\boldsymbol{\Sigma}_{a|b} = \boldsymbol{\Sigma}_{aa} - \boldsymbol{\Sigma}_{ab}\boldsymbol{\Sigma}_{bb}^{-1}\boldsymbol{\Sigma}_{ba}\tag{2.52}</script><h1 id="三，边缘⾼斯分布"><a href="#三，边缘⾼斯分布" class="headerlink" title="三，边缘⾼斯分布"></a>三，边缘⾼斯分布</h1><p>对于<strong>边缘高斯分布</strong>：</p><script type="math/tex; mode=display">p(\boldsymbol{x}_a) = \int p(\boldsymbol{x}_a, \boldsymbol{x}_b) \mathrm{d} \boldsymbol{x}_b\tag{2.53}</script><p>同条件高斯分布一样，可以推导出边缘概率分布 $p(\boldsymbol{x}_a)$ 的<strong>均值</strong>和<strong>协⽅差</strong>的表达式：</p><script type="math/tex; mode=display">\boldsymbol{\Sigma}_{a} = (\boldsymbol{\Lambda}_{aa} - \boldsymbol{\Lambda}{ab}\boldsymbol{\Lambda}_{bb}^{-1}\boldsymbol{\Lambda}_{ba})^{-1}\tag{2.54}</script><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{x}_a] = \boldsymbol{\mu}_a\tag{2.55}</script><script type="math/tex; mode=display">\text{cov}[\boldsymbol{x}_a] = \boldsymbol{\Sigma}_{aa}\tag{2.56}</script><p>如图2.13，两个变量上的⾼斯概率分布 $p(x_a , x_b)$ 的轮廓线。</p><p><img src="/images/prml_20190920214738.png" alt="⾼斯概率分布轮廓线"></p><p>如图2.14，边缘概率分布 $p(x_a)$（蓝⾊曲线）和 $x_b = 0.7$ 的条件概率分布 $p(x_a|x_b)$（红⾊曲线）。</p><p><img src="/images/prml_20190920214747.png" alt="边缘概率分布和条件概率分布"></p><h1 id="四，⾼斯变量的贝叶斯定理"><a href="#四，⾼斯变量的贝叶斯定理" class="headerlink" title="四，⾼斯变量的贝叶斯定理"></a>四，⾼斯变量的贝叶斯定理</h1><p>令边缘概率分布和条件概率分布的形式：</p><script type="math/tex; mode=display">p(\boldsymbol{x}) = \mathcal{N}(\boldsymbol{x} |\boldsymbol{\mu}, \boldsymbol{\Lambda}^{-1})\tag{2.57}</script><script type="math/tex; mode=display">p(\boldsymbol{y} | \boldsymbol{x}) = \mathcal{N}(\boldsymbol{y} |\boldsymbol{Ax+b}, \boldsymbol{L}^{-1})\tag{2.58}</script><p>其中，$\boldsymbol{\mu}$ ， $\boldsymbol{A}$ 和 $\boldsymbol{b}$ 是控制均值的参数，$\boldsymbol{\Lambda}$ 和 $\boldsymbol{L}$ 是精度矩阵。如果 $\boldsymbol{x}$ 的维度为 $M$ ，$\boldsymbol{y}$ 的维度为 $D$，那么矩阵 $A$ 的⼤⼩为 $D \times M$ 。</p><p>⾸先，我们寻找 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 的联合分布的表达式。令</p><script type="math/tex; mode=display">\boldsymbol{z} = \dbinom{\boldsymbol{x}}{\boldsymbol{y}}</script><p>然后考虑联合概率分布的对数：</p><script type="math/tex; mode=display">\begin{aligned}\ln p(\boldsymbol{z}) &= \ln p(\boldsymbol{x}) + \ln p(\boldsymbol{y} | \boldsymbol{x}) \\ &= -\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \Lambda (\boldsymbol{x} - \boldsymbol{\mu}) \\  &-\frac{1}{2}(\boldsymbol{y} - \boldsymbol{Ax} - \boldsymbol{b})^{T} \boldsymbol{L} (\boldsymbol{y}-\boldsymbol{Ax}-\boldsymbol{b}) + 常数 \end{aligned} \tag{2.59}</script><p>可以推导出，$\boldsymbol{z}$ 上的⾼斯分布的<strong>精度矩阵</strong>（协⽅差的逆矩阵）为：</p><script type="math/tex; mode=display">\boldsymbol{R} = \begin{pmatrix} \boldsymbol{\Lambda + A^{T}LA} & \boldsymbol{-A^{T}L} \\ \boldsymbol{-LA} & \boldsymbol{L}  \end{pmatrix}</script><p>从而，$\boldsymbol{z}$ 上的⾼斯分布的<strong>均值</strong>和<strong>协⽅差</strong>的表达式：</p><script type="math/tex; mode=display">\text{cov}[\boldsymbol{z}] = \boldsymbol{R}^{-1} = \begin{pmatrix} \boldsymbol{\Lambda^{-1} } & \boldsymbol{\Lambda^{-1}A^{T}} \\ \boldsymbol{A\Lambda^{-1}} & \boldsymbol{L^{-1}+A\Lambda^{-1}A^{T}} \end{pmatrix}\tag{2.60}</script><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{z}] = \boldsymbol{R}^{-1} \dbinom{\boldsymbol{\Lambda \mu - A^{T}Lb}}{\boldsymbol{Lb}}\tag{2.61}</script><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{z}] = \dbinom{\boldsymbol{\mu}}{\boldsymbol{A\mu+b}}\tag{2.62}</script><p>边缘分布 $p(\boldsymbol{y})$ 的<strong>均值</strong>和<strong>协⽅差</strong>为：</p><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{y}] = \boldsymbol{A\mu+b}\tag{2.63}</script><script type="math/tex; mode=display">\text{cov}[\boldsymbol{y}] = \boldsymbol{L^{-1}+A\Lambda^{-1}A^{T}}\tag{2.64}</script><p>条件分布 $p(\boldsymbol{x}|\boldsymbol{y})$ 的<strong>均值</strong>和<strong>协⽅差</strong>为：</p><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{x} | \boldsymbol{y}] = (\boldsymbol{\Lambda + A^{T}LA})^{-1}\{ \boldsymbol{A^{T}L(y-b) + \Lambda \mu} \}\tag{2.65}</script><script type="math/tex; mode=display">\text{cov}[\boldsymbol{x|y}] = (\boldsymbol{\Lambda + A^{T}LA})^{-1}\tag{2.66}</script><h1 id="五，⾼斯分布的最⼤似然估计"><a href="#五，⾼斯分布的最⼤似然估计" class="headerlink" title="五，⾼斯分布的最⼤似然估计"></a>五，⾼斯分布的最⼤似然估计</h1><p>给定⼀个数据集 $\boldsymbol{X} = (\boldsymbol{x}_1, \dots, \boldsymbol{x}_N)^T$ ， 其中观测 $\{\boldsymbol{x}_n\}$ 假定是独⽴地从多元⾼斯分布中抽取的。我们可以使⽤最⼤似然法估计分布的参数。对数似然函数为：</p><script type="math/tex; mode=display">\ln p(\boldsymbol{X|\mu, \Sigma}) = -\frac{ND}{2} \ln (2\pi) - \frac{N}{2}\ln \boldsymbol{|\Sigma|} - \frac{1}{2}\sum_{n=1}^{N}\boldsymbol{(x_n -\mu)^{T}\Sigma^{-1}(x_n-\mu)}\tag{2.67}</script><p>令对数似然函数关于 $\mu$ 的导数为零，可以求得均值的最大似然估计：</p><script type="math/tex; mode=display">\boldsymbol{\mu}_{ML} = \frac{1}{N}\sum_{n=1}^{N}\boldsymbol{x}_n\tag{2.68}</script><p>方差的最大似然估计：</p><script type="math/tex; mode=display">\boldsymbol{\Sigma}_{ML} = \frac{1}{N}\sum_{n=1}^{N}(\boldsymbol{x}_n-\boldsymbol{\mu}_{ML})(\boldsymbol{x}_n-\boldsymbol{\mu}_{ML})^{T}\tag{2.69}</script><p>从而，</p><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{\mu}_{ML}] = \boldsymbol{\mu}\tag{2.70}</script><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{\Sigma}_{ML}] = \frac{N-1}{N}\boldsymbol{\Sigma}\tag{2.71}</script><script type="math/tex; mode=display">\tilde {\boldsymbol{\Sigma}}_{ML} = \frac{1}{N}\sum_{n=1}^{N-1}(\boldsymbol{x}_n-\boldsymbol{\mu}_{ML})(\boldsymbol{x}_n-\boldsymbol{\mu}_{ML})^{T}\tag{2.72}</script><h1 id="六，顺序估计"><a href="#六，顺序估计" class="headerlink" title="六，顺序估计"></a>六，顺序估计</h1><p>考虑公式(2.68)给出的均值的最⼤似然估计结果 $\boldsymbol{\mu}_{ML}$ 。 当它依赖于第 $N$ 次观察时， 将记作 $\boldsymbol{\mu}_{ML}^{(N)}$  。如果想分析最后⼀个数据点 $\boldsymbol{x}_N$ 的贡献，即有：</p><script type="math/tex; mode=display">\begin{aligned} \boldsymbol{\mu}_{ML}^{(N)} &= \frac{1}{N}\sum_{n=1}^{N}\boldsymbol{x}_n \\ &= \frac{1}{N}\boldsymbol{x}_{N} + \frac{1}{N}\sum_{n=1}^{N-1}\boldsymbol{x}_n \\ &= \frac{1}{N}\boldsymbol{x}_{N} + \frac{N-1}{N} \boldsymbol{\mu}_{ML}^{(N-1)} \\ &= \boldsymbol{\mu}_{ML}^{(N-1)} + \frac{1}{N}(\boldsymbol{x}_{n} -\boldsymbol{\mu}_{ML}^{(N-1)}) \end{aligned}\tag{2.73}</script><p>考虑⼀对随机变量 $\theta$ 和 $z$ ， 它们由⼀个联合概率分布 $p(z, \theta)$ 所控制。已知 $\theta$ 的条件下， $z$ 的条件期望定义了⼀个确定的函数 $f(\theta)$ ，叫<strong>回归函数</strong>，形式如下：</p><script type="math/tex; mode=display">f(\theta) \equiv \mathbb{E}[z|\theta] = \int zp(z|\theta)\mathrm{d}z\tag{2.74}</script><p>如图2.15，回归函数 $f(\theta)$ 。</p><p><img src="/images/prml_20190924081124.png" alt="z的条件期望"></p><p>⽬标是寻找根 $\theta^{∗}$ 使得 $f(\theta^{∗}) = 0$。 如果有观测 $z$ 和 $\theta$ 的⼀个⼤数据集， 那么可以直接对回归函数建模， 得到根的⼀个估计。 但是假设每次观测到⼀个 $z$ 的值， 我们想找到⼀个对应的<strong>顺序估计⽅法</strong>来找到 $\theta^{∗}$ 。 下⾯的解决这种问题的通⽤步骤由 <strong><code>Robbins and Monro</code></strong>（1951）给出。假定 $z$ 的条件⽅差是有穷的，即：</p><script type="math/tex; mode=display">\mathbb{E}[(z-f)^2|\theta] \lt \infty</script><p>并且不失⼀般性， 我们也假设当 $\theta \gt \theta^{∗}$ 时 $f(\theta) \gt 0$， 当 $\theta \lt \theta^{∗}$ 时 $f(\theta) \lt 0$，<strong><code>Robbins-Monro</code></strong> 的⽅法定义了⼀个根 $\theta^{∗}$ 的顺序估计的序列，由公式(2.75)给出。</p><script type="math/tex; mode=display">\theta^{(N)} = \theta^{(N-1)} + \alpha_{N-1}z(\theta^{(N-1)})\tag{2.75}</script><p>其中 $z(\theta^{(N)})$ 是当 $\theta$ 的取值为 $\theta (N)$ 时 $z$ 的观测值。系数 $\{\alpha_N\}$ 表⽰⼀个满⾜下列条件的正数序列：</p><script type="math/tex; mode=display">\lim_{N \to \infty}\alpha_{N}=0</script><script type="math/tex; mode=display">\sum_{N=1}^{\infty} \alpha_{N} = \infty</script><script type="math/tex; mode=display">\sum_{N=1}^{\infty} \alpha_{N}^{2} \lt \infty</script><p>根据定义，最⼤似然解 $\theta_{ML}$ 是负对数似然函数的⼀个驻点，因此满⾜：</p><script type="math/tex; mode=display">\left . \frac{\partial}{\partial \theta} \left\{\frac{1}{N}\sum_{n=1}^{N}- \ln p(x_N|\theta) \right\} \right|_{\theta_{ML}} = 0\tag{2.76}</script><p>交换导数与求和，取极限 $N \to \infty$ ，可以寻找最⼤似然解对应于寻找回归函数的根。 于是可以应⽤ <strong><code>Robbins-Monro</code>⽅法</strong>，此时它的形式为：</p><script type="math/tex; mode=display">\theta^{(N)} = \theta^{(N-1)} + \alpha_{N-1} \frac{\partial}{\partial\theta^{(N-1)}} \left [-\ln p(x_N |\theta^{(N-1)}) \right ]\tag{2.77}</script><h1 id="七，⾼斯分布的贝叶斯推断"><a href="#七，⾼斯分布的贝叶斯推断" class="headerlink" title="七，⾼斯分布的贝叶斯推断"></a>七，⾼斯分布的贝叶斯推断</h1><p>考虑⼀个⼀元⾼斯随机变量 $\mathbf{x}$，我们假设⽅差 $\sigma^2$ 是已知的，其任务是从⼀组 $N$ 次观测 $\mathbf{x}=(x_1,\dots, x_N)^T$ 中推断均值 $\mu$。 似然函数，即给定 $\mu$ 的情况下，观测数据集出现的概率。它可以看成 $\mu$ 的函数，由公式(2.78)给出。</p><script type="math/tex; mode=display">p(\mathbf{x}|\mu) = \prod_{n=1}^{N}p(x_n|\mu) = \frac{1}{\left(2 \pi \sigma^{2}\right)^{\frac{N}{2}}} \exp \left\{-\frac{1}{2 \sigma^{2}}\sum_{n=1}^{N}(x_n-\mu)^{2}\right\}\tag{2.78}</script><p>注意：似然函数 $p(\mathbf{x}|\mu)$ 不是 $\mu$ 的概率密度，没有被归⼀化。</p><p>如图2.16，在⾼斯分布的情形中，回归函数的形式。</p><p><img src="/images/prml_20190924103238.png" alt="回归函数的形式"></p><p>令先验概率分布为：</p><script type="math/tex; mode=display">p(\mu) = \mathcal{N}\left(\mu | \mu_0, \sigma_{0}^{2}\right)\tag{2.79}</script><p>从⽽后验概率为：</p><script type="math/tex; mode=display">p(\mu | \mathbf{x}) = \mathcal{N}\left(\mu | \mu_N, \sigma_{N}^{2}\right)\tag{2.80}</script><p>其中，</p><script type="math/tex; mode=display">\mu_N = \frac{\sigma^2}{N\sigma_{0}^2 + \sigma^2}\mu_0 + \frac{N\sigma_{0}^2}{N\sigma_{0}^2 + \sigma^2}\mu_{ML}</script><script type="math/tex; mode=display">\frac{1}{\sigma_{N}^{2}} = \frac{1}{\sigma_{0}^{2}} + \frac{N}{\sigma^{2}}</script><script type="math/tex; mode=display">\mu_{ML} = \frac{1}{N}\sum_{n=1}^{N}x_n</script><p>图2.17，⾼斯分布均值的贝叶斯推断。</p><p><img src="/images/prml_20190924105141.png" alt="⾼斯分布均值的贝叶斯推断"></p><p>现在假设均值是已知的，我们要推断⽅差。令 $\lambda \equiv \frac{1}{\sigma^{2}}$ ，$\lambda$ 的似然函数的形式为：</p><script type="math/tex; mode=display">p(\mathbf{x}|\lambda) = \prod_{n=1}^{N}\mathcal{N}(x_n|\mu, \lambda^{-1}) \propto \lambda^{\frac{N}{2}} \exp \left\{-\frac{\lambda}{2}\sum_{n=1}^{N}(x_n-\mu)^{2}\right\}\tag{2.81}</script><p>对应的<strong>共轭先验</strong>因此应该正⽐于 $\lambda$ 的幂指数，也正⽐于 $\lambda$ 的线性函数的指数。这对应于 <strong><code>Gamma</code>分布</strong>，定义为：</p><script type="math/tex; mode=display">\text{Gam}(\lambda|a,b) = \frac{1}{\Gamma(a)}b^{a}\lambda^{a-1}\exp (-b\lambda)\tag{2.82}</script><p><strong>均值</strong>和<strong>协⽅差</strong>分别为：</p><script type="math/tex; mode=display">\mathbb{E}[\lambda] = \frac{a}{b}\tag{2.83}</script><script type="math/tex; mode=display">\text{var}[\lambda] = \frac{a}{b^2}\tag{2.84}</script><p>如图2.18～2.20，不同的 $a$ 和 $b$ 的情况下 <code>Gamma</code>分布的图像。</p><p><img src="/images/prml_20190927194937.png" alt="a=b=0.1"></p><p><img src="/images/prml_20190927194947.png" alt="a=b=1"></p><p><img src="/images/prml_20190927195015.png" alt="a=4,b=6"></p><p>考虑⼀个先验分布 $\text{Gam}(\lambda|a_0,b_0)$。如果乘以公式(2.81)给出的似然函数，那么即可得到后验分布：</p><script type="math/tex; mode=display">p(\lambda | \mathbf{x}) \propto \lambda^{a_0-1} \lambda^{\frac{N}{2}} \exp \left\{-b_0 \lambda -\frac{\lambda}{2}\sum_{n=1}^{N}(x_n-\mu)^{2}\right\}\tag{2.85}</script><p>我们可以把它看成形式为 $\text{Gam}(\lambda|a_N,b_N)$ 的 <strong><code>Gamma</code>分布</strong>，其中</p><script type="math/tex; mode=display">a_N = a_0 + \frac{N}{2}</script><script type="math/tex; mode=display">b_N = b_0 \frac{1}{2}\sum_{n=1}^{N}(x_n-\mu)^2 = b_0 + \frac{N}{2}\sigma_{ML}^{2}</script><p>现在假设<strong>均值</strong>和<strong>精度</strong>都是未知的。为了找到<strong>共轭先验</strong>，考虑似然函数对于 $\mu$ 和 $\lambda$ 的依赖关系：</p><script type="math/tex; mode=display">\begin{aligned} p(\mathbf{x}|\mu,\lambda) &= \prod_{n=1}^{N} \left(\frac{\lambda}{2\pi} \right)^{\frac{1}{2}} \exp \left\{-\frac{\lambda}{2}(x_n-\mu)^{2}\right\} \\ &\propto \left[\lambda^{\frac{1}{2}} \exp\left(-\frac{\lambda \mu^{2}}{2}\right) \right]^{N} \exp \left\{\lambda \mu \sum_{n=1}^{N}x_n - \frac{\lambda}{2}\sum_{n=1}^{N}x_{n}^{2}\right\} \end{aligned}\tag{2.86}</script><p>假设先验分布的形式为：</p><script type="math/tex; mode=display">\begin{aligned} p(\mu,\lambda) &= \exp \left\{-\frac{\beta \lambda}{2}\left(\mu-\frac{c}{\beta}\right)^2 \right\} \lambda^{\frac{\beta}{2}} \exp \left\{-\left(d-\frac{c^2}{2\beta}\right)\lambda \right\} \\ &\propto \left[\lambda^{\frac{1}{2}} \exp\left(-\frac{\lambda \mu^{2}}{2}\right) \right]^{\beta} \exp \left\{c\lambda \mu - d\lambda\right\} \end{aligned}\tag{2.87}</script><p>其 中 $c, d$ 和 $\beta$ 都是常数。</p><p>归⼀化的先验概率的形式为：</p><script type="math/tex; mode=display">p(\mu,\lambda) = \mathcal{N}(\mu|\mu_0, (\beta \lambda)^{-1})\text{Gam}(\lambda|a,b)\tag{2.88}</script><p>这被称为<strong>正态-<code>Gamma</code>分布</strong>或者<strong>⾼斯-<code>Gamma</code>分布</strong>。如图2.21：</p><p><img src="/images/prml_20190927204821.png" alt="正态-Gamma分布"></p><p>对于 $D$ 维向量 $\boldsymbol{x}$ 的多元⾼斯分布 $\mathcal{N}(\boldsymbol{x|\mu, \Lambda}^{−1})$，假设精度已知，则均值 $\boldsymbol{\mu}$ 的共轭先验分布仍然是⾼斯分布。对于已知均值未知精度矩阵 $\boldsymbol{\Lambda}$ 的情形，共轭先验是<strong><code>Wishart</code>分布</strong>，定义为：</p><script type="math/tex; mode=display">\mathcal{W}(\mathbf{\Lambda} | \boldsymbol{W}, \nu)=B|\boldsymbol{\Lambda}|^{\frac{\nu-D-1}{2}} \exp \left(-\frac{1}{2} \operatorname{Tr}\left(\boldsymbol{W}^{-1} \boldsymbol{\Lambda}\right)\right)\tag{2.89}</script><p>其中 $\nu$ 被称为<strong>分布的⾃由度数量</strong>(<code>degrees of freedom</code>)，$\boldsymbol{W}$ 是⼀个 $D \times D$ 的标量矩阵，$\operatorname{Tr}(·)$ 表⽰矩阵的<strong>迹</strong>。归⼀化系数 $B$ 为：</p><script type="math/tex; mode=display">B(\boldsymbol{W}, \nu)=|\boldsymbol{W}|^{-\frac{\nu}{2}}\left(2^{\frac{\nu D}{2}} \pi^{\frac{D(D-1)}{4}} \prod_{i=1}^{D} \Gamma\left(\frac{\nu+1-i}{2}\right)\right)^{-1}\tag{2.90}</script><p>如果均值和精度都是未知的，那么类似于⼀元变量的推理⽅法，<strong>共轭先验</strong>为：</p><script type="math/tex; mode=display">p(\boldsymbol{\mu,\Lambda|\mu}_0,\beta,\boldsymbol{W}, \nu) = \mathcal{N}(\boldsymbol{\mu|\mu}_0, (\beta \boldsymbol{\Lambda})^{-1})\mathcal{W}(\mathbf{\Lambda} | \boldsymbol{W}, \nu)\tag{2.91}</script><p>这被称为<strong>正态-<code>Wishart</code>分布</strong>或者<strong>⾼斯-<code>Wishart</code>分布</strong>。</p><h1 id="八，学生-mathbf-t-分布"><a href="#八，学生-mathbf-t-分布" class="headerlink" title="八，学生 $\mathbf{t}$ 分布"></a>八，学生 $\mathbf{t}$ 分布</h1><p>如果有⼀个⼀元⾼斯分布 $\mathcal{N}\left(x | \mu, \tau^{-1}\right)$ 和⼀个 <code>Gamma</code>先验分布 $\text{Gam}(\tau|a, b)$，把精度积分出来，便可以得到 $x$ 的边缘分布，形式为：</p><script type="math/tex; mode=display">\begin{aligned} p(x | \mu, a, b) &=\int_{0}^{\infty} \mathcal{N}\left(x | \mu, \tau^{-1}\right) \operatorname{Gam}(\tau | a, b) \mathrm{d} \tau \\ &=\int_{0}^{\infty} \frac{b^{a} e^{(-b r)} \tau^{a-1}}{\Gamma(a)}\left(\frac{\tau}{2 \pi}\right)^{\frac{1}{2}} \exp \left\{-\frac{\tau}{2}(x-\mu)^{2}\right\} \mathrm{d} \tau \\ &=\frac{b^{a}}{\Gamma(a)}\left(\frac{1}{2 \pi}\right)^{\frac{1}{2}}\left[b+\frac{(x-\mu)^{2}}{2}\right]^{-a-\frac{1}{2}} \Gamma\left(a+\frac{1}{2}\right) \end{aligned}\tag{2.92}</script><p>形如 $p(x|\mu a,b)$ 如下：</p><script type="math/tex; mode=display">\text{St}(x|\mu,\lambda,\nu) = \frac{\Gamma(\frac{\nu}{2}+\frac{1}{2})}{\Gamma(\frac{\nu}{2})}\left(\frac{\lambda}{\pi \nu}\right)^{\frac{1}{2}}\left[1+\frac{\lambda(x-\mu)^2}{\nu}\right]^{-\frac{\nu}{2}-\frac{1}{2}}\tag{2.93}</script><p>称为<strong>学生 t 分布</strong>（<code>Student&#39;s t-distribution</code>）。 参数 $\lambda$ 有时被称为 $\mathbf{t}$ 分布的<strong>精度</strong>（<code>precision</code>）， 即使它通常不等于⽅差的倒数。参数 $\nu$ 被称为<strong>⾃由度</strong>（<code>degrees of freedom</code>）。如图2.22：</p><p><img src="/images/prml_20190927221621.png" alt="学生t分布"></p><p>学生 $\mathbf{t}$ 分布的⼀个<strong>重要性质</strong>：<strong>鲁棒性</strong>（robustness），即对于数据集⾥的⼏个离群点<code>outlier</code>的出现，分布不会像⾼斯分布那样敏感。</p><p>图 2.23，从⼀个<strong>⾼斯分布</strong>中抽取的30个数据点的直⽅图，以及得到的最⼤似然拟合。红⾊曲线表⽰使⽤ $\mathbf{t}$ 分布进⾏的拟合，绿⾊曲线（⼤部分隐藏在了红⾊曲 线后⾯）表⽰使⽤⾼斯分布进⾏的拟合。由于 $\mathbf{t}$  分布将⾼斯分布作为⼀种特例，因此它给出了与⾼斯分布⼏乎相同的解。</p><p><img src="/images/prml_20190927223450.png" alt="t分布与高斯分布a"></p><p>图 2.24，与图2.23同样的数据集，但是多了三个异常数据点。这幅图展⽰了⾼斯分布（绿⾊曲线）是如 何被异常点强烈地⼲扰的，⽽ $\mathbf{t}$ 分布（红⾊曲线）相对不受影响。</p><p><img src="/images/prml_20190927223502.png" alt="t分布与高斯分布b"></p><p>推⼴到多元⾼斯分布 $\mathcal{N}(\boldsymbol{x|\mu, \Lambda})$ 来得到对应的多元学生 $\mathbf{t}$ 分布，形式为：</p><script type="math/tex; mode=display">\operatorname{St}(\boldsymbol{x} | \boldsymbol{\mu}, \boldsymbol{\Lambda}, \nu)=\int_{0}^{\infty} \mathcal{N}\left(\boldsymbol{x} | \boldsymbol{\mu},(\eta \boldsymbol{\Lambda})^{-1}\right) \operatorname{Gam}\left(\eta | \frac{\nu}{2}, \frac{\nu}{2}\right) \mathrm{d} \nu \tag{2.94}</script><p>求积分，可得：</p><script type="math/tex; mode=display">\text{St}(\boldsymbol{x} | \boldsymbol{\mu}, \boldsymbol{\Lambda},,\nu) = \frac{\Gamma(\frac{\nu}{2}+\frac{D}{2})}{\Gamma(\frac{\nu}{2})}\left(\frac{|\boldsymbol{\Lambda}|}{(\pi \nu)^D}\right)^{\frac{1}{2}}\left[1+\frac{\Delta^{2}}{\nu}\right]^{-\frac{\nu}{2}-\frac{D}{2}}\tag{2.95}</script><p>其中 $D$ 是 $\boldsymbol{x}$ 的维度，$\Delta^2$ 是<strong>平⽅马⽒距离</strong>，定义为：</p><script type="math/tex; mode=display">\Delta^2 = (\boldsymbol{x-\mu})^T \boldsymbol{\Lambda} (\boldsymbol{x-\mu})\tag{2.96}</script><p>多元变量形式的学生 $\mathbf{t}$ 分布，满⾜下⾯的性质：</p><p>1）$\mathbb{E}[\boldsymbol{x}] = \boldsymbol{\mu}$   如果 $\nu \gt 1$</p><p>2）$\text{cov}[\boldsymbol{x}] = \frac{\nu}{\nu-2}\boldsymbol{\Lambda}^{-1}$   如果 $\nu \gt 2$</p><p>3）$\text{mode}[\boldsymbol{x}] = \boldsymbol{\mu}$   </p><h1 id="九，周期变量"><a href="#九，周期变量" class="headerlink" title="九，周期变量"></a>九，周期变量</h1><p>考察⼀个⼆维单位向量 $\boldsymbol{x}_1,\dots,\boldsymbol{x}_N$ ， 其中 $||\boldsymbol{x}_n|| = 1$ 且 $n = 1,\dots , N$ ， 如图2.25所⽰。</p><p><img src="/images/prml_20190927230755.png" alt="⼆维单位向量"></p><p>可以对向量 $\{\boldsymbol{x}_n\}$ 求平均，可得</p><script type="math/tex; mode=display">\bar{\boldsymbol{x}} = \frac{1}{N}\sum_{n=1}^{N}\boldsymbol{x}_n</script><p>注意，$\bar{\boldsymbol{x}}$ 通常位于单位圆的内部。</p><p>$\bar{\boldsymbol{x}}$ 对应的角度 $\bar{\theta}$ 为：</p><script type="math/tex; mode=display">\bar{\theta} = \tan^{-1} \left\{\frac{\sum_{n}\sin \theta_n}{\sum_{n}\cos \theta_n} \right\}\tag{2.97}</script><p>考虑的周期概率分布 $p(\theta)$ 的周期为 $2\pi$ 。$\theta$ 上的任何概率密度 $p(\theta)$ ⼀定⾮负， 积分等于1，并且⼀定是周期性的。因此， $p(\theta)$ ⼀定满⾜下⾯三个条件：</p><p>1） $p(\theta) \ge 0$ </p><p>2） $\int_{0}^{2\pi} p(\theta) \mathrm{d}\theta = 1$ </p><p>3） $p(\theta + 2\pi) = p(\theta)$ </p><p>考虑两个变量 $\boldsymbol{x} = (x_1 , x_2)$ 的⾼斯分布，均值为 $\boldsymbol{\mu} = (\mu_1, \mu_2)$，协⽅差矩阵为 $\boldsymbol{\Sigma} = \sigma^2 \boldsymbol{I}$ ，其中 $\boldsymbol{I}$ 是⼀个 $2\times2$ 的单位矩阵。因此有：</p><script type="math/tex; mode=display">p(x_1,x_2) = \frac{1}{2\pi \sigma^{2}} \exp \left\{-\frac{(x_1-\mu_1)^2+(x_2-\mu_2)^{2}}{2\sigma^{2}}\right\}\tag{2.98}</script><p><strong><code>von Mises</code>分布</strong>(<strong>环形正态分布</strong>（<code>circular normal</code>））：在单位圆 $r=1$上的概率分布 $p(\theta)$ 的最终表达式：</p><script type="math/tex; mode=display">p(\theta|\theta_0,m) = \frac{1}{2\pi I_0(m)} \exp \left\{m\cos(\theta-\theta_0)\right\}\tag{2.99}</script><p>其中，参数 $\theta_0$ 对应于分布的均值，$m$ 被称为 <strong><code>concentration</code>参数</strong>，类似于⾼斯分布的⽅差的倒数（<strong>精度</strong>）。归⼀化系数包含项 $I_0 (m)$，是<strong>零阶修正的第⼀类<code>Bessel</code>函数</strong>（<code>Abramowitz and Stegun</code>, 1965）， 定义为：</p><script type="math/tex; mode=display">I_0(m) = \frac{1}{2\pi} \int_{0}^{2\pi}\exp\{m\cos \theta\}\mathrm{d}\theta\tag{2.100}</script><p>如图2.26～2.27，<code>von Mises</code>分布的图像。</p><p><img src="/images/prml_20190927234905.png" alt="笛卡尔坐标系"></p><p><img src="/images/prml_20190927234914.png" alt="极坐标系"></p><p>如图2.28， <code>Bessel</code>函数 $I_0 (m)$ 的图像。</p><p><img src="/images/prml_20190928090610.png" alt="Bessel函数"></p><p>现在考虑 <strong><code>von Mises</code>分布</strong> 的参数 $\theta_0$ 和参数 $m$ 的最⼤似然估计。对数似然函数为：</p><script type="math/tex; mode=display">\ln p(\mathcal{D} | \theta_0,m)=-N\ln (2\pi)-\ln I_0(m)+m\sum_{n=1}^{N}\cos(\theta_n-\theta_0)\tag{2.101}</script><p>令其关于 $\theta_0$ 的导数等于零，从⽽可以得到：</p><script type="math/tex; mode=display">\theta_{0}^{ML} = \tan^{-1} \left\{\frac{\sum_{n}\sin \theta_n}{\sum_{n}\cos \theta_n} \right\}\tag{2.102}</script><p>关于 $m$ 最⼤化公式(2.101)，使⽤ $I_0^{\prime}(m)=I_1(m)$（<code>Abramowitz and Stegun</code>, 1965），从⽽可以得到：</p><script type="math/tex; mode=display">A(m_{NL})=\frac{1}{N}\sum_{n=1}^{N}\cos(\theta_{n}-\theta_{0}^{ML})\tag{2.103}</script><p>令</p><script type="math/tex; mode=display">A(m)=\frac{I_1(m)}{I_0(m)}</script><p>可以得到：</p><script type="math/tex; mode=display">A(m_{ML})=\left(\frac{1}{N}\sum_{n=1}^{N}\cos \theta_{n}\right)\cos \theta_{0}^{ML} + \left(\frac{1}{N}\sum_{n=1}^{N}\sin \theta_{n}\right)\sin \theta_{0}^{ML}\tag{2.104}</script><p>如图2.29， 函数 $A (m)$ 的图像。</p><p><img src="/images/prml_20190928090629.png" alt="Am函数"></p><h1 id="十，混合高斯模型"><a href="#十，混合高斯模型" class="headerlink" title="十，混合高斯模型"></a>十，混合高斯模型</h1><p>通过将更基本的概率分布（例如⾼斯分布）进⾏线性组合的这样的叠加⽅法，可以被形式化为概率模型，被称为<strong>混合模型</strong>（<code>mixture distributions</code>）（<code>McLachlan and Basford</code>, 1988; <code>McLachlan and Peel</code>, 2000）。</p><p>考虑 $K$ 个⾼斯概率密度的叠加，形式为：</p><script type="math/tex; mode=display">p(\boldsymbol{x}) = \sum_{k=1}^{K} \pi_{k} \mathcal{N}(\boldsymbol{x} |\boldsymbol{\mu_{k}}, \boldsymbol{\Sigma}_{k})\tag{2.105}</script><p>这被称为<strong>混合⾼斯</strong>（<code>mixture of Gaussians</code>）。 每⼀个⾼斯概率密度 $\mathcal{N}(\boldsymbol{x} |\boldsymbol{\mu_{k}}, \boldsymbol{\Sigma}_{k})$ 被称为混合分布的⼀个<strong>成分</strong>（<code>component</code>），并且有⾃⼰的均值 $\boldsymbol{\mu_{k}}$ 和协⽅差 $\boldsymbol{\Sigma}_{k}$。参数 $\pi_{k}$ 被称为<strong>混合系数</strong>（<code>mixing coefficients</code>），并且满足以下条件：</p><p>1）$\sum_{k=1}^{K} \pi_{k}=1$<br>2）$0\le \pi_{k} \le 1$</p><p>如图2.30，每个混合分量的常数概率密度轮廓线，其中三个分量分别被标记为红⾊、蓝⾊和绿⾊， 且混合系数的值在每个分量的下⽅给出。 </p><p><img src="/images/prml_ 20190928095829.png" alt="概率密度轮廓线"></p><p>如图2.31， 混合分布的边缘概率密度 $p(\boldsymbol{x})$ 的轮廓线。</p><p><img src="/images/prml_20190928095839.png" alt="边缘概率密度轮廓线"></p><p>如图2.32， 概率分布 $p(\boldsymbol{x})$ 的⼀个曲⾯图。</p><p><img src="/images/prml_20190928095852.png" alt="概率密度曲面图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《模式识别与机器学习》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一，多元高斯分布&quot;&gt;&lt;a href=&quot;#一，多元高斯分布&quot; class=&quot;headerlink&quot; title=&quot;一，多元高斯分布&quot;&gt;&lt;/a&gt;一，多元高斯
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zhangbc.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习基础" scheme="https://zhangbc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习基础】概率分布之变量</title>
    <link href="https://zhangbc.github.io/2019/09/29/prml_02_01/"/>
    <id>https://zhangbc.github.io/2019/09/29/prml_02_01/</id>
    <published>2019-09-29T06:26:42.000Z</published>
    <updated>2019-10-07T14:37:49.296Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《模式识别与机器学习》的读书笔记。</p></blockquote><h1 id="一，二元变量"><a href="#一，二元变量" class="headerlink" title="一，二元变量"></a>一，二元变量</h1><h2 id="1，二项分布"><a href="#1，二项分布" class="headerlink" title="1，二项分布"></a>1，二项分布</h2><p>考虑⼀个⼆元随机变量 $x \in \{0, 1\}$。 例如，$x$ 可能描述了扔硬币的结果，$x = 1$ 表⽰“正⾯”，$x = 0$ 表⽰反⾯。我们可以假设有⼀个损坏的硬币，这枚硬币正⾯朝上的概率未必等于反⾯朝上的概率。$x = 1$ 的概率被记作参数 $\mu$，因此有：</p><script type="math/tex; mode=display">p(x=1|\mu) = \mu\tag{2.1}</script><p>其中 $0\le \mu\le 1$ 。$x$ 的概率分布因此可以写成：</p><script type="math/tex; mode=display">\text {Bern}(x|\mu) = \mu^{x}(1-\mu)^{1-x}\tag{2.2}</script><p>这被叫做<strong>伯努利分布</strong>（<code>Bernoulli distribution</code>）。容易证明，这个分布是归⼀化的，并且均值和⽅差分别为：</p><script type="math/tex; mode=display">\mathbb{E}[x] = \mu\tag{2.3}</script><script type="math/tex; mode=display">\text{var}[x] = \mu(1-\mu)\tag{2.4}</script><p>如图 2.1，⼆项分布关于 $m$ 的函数的直⽅图，其中 $N = 10$ 且 $\mu = 0.25$。</p><p><img src="/images/prml_20190919231340.png" alt="⼆项分布"></p><p>假设我们有⼀个 $x$ 的观测值的数据集 $\mathcal{D} = \{x_1 ,\dots, x_N\}$。假设每次观测都是独⽴地从 $p(x | \mu)$ 中抽取的，因此可以构造关于 $\mu$ 的似然函数：</p><script type="math/tex; mode=display">p(\mathcal{D}|\mu) = \prod_{n=1}^{N}p(x_{n}|\mu) = \prod_{n=1}^{N}\mu^{x_{n}}(1-\mu)^{1-x_{n}}\tag{2.5}</script><p>其对数似然函数：</p><script type="math/tex; mode=display">\ln p(\mathcal{D}|\mu) = \sum_{n=1}^{N}\ln p(x_{n}|\mu) = \sum_{n=1}^{N}\{ x^n \ln \mu + (1-x^n) \ln (1-\mu)\}\tag{2.6}</script><p>在公式(2.6)中，令 $\ln p(\mathcal{D}|\mu)$ 关于 $\mu$ 的导数等于零，就得到了最⼤似然的估计值，也被称为<strong>样本均值</strong>（<code>sample mean</code>）：</p><script type="math/tex; mode=display">\mu_{ML} = \frac{1}{N} \sum_{n=1}^{N} x_{n}\tag{2.7}</script><p>求解给定数据集规模 $N$ 的条件下，$x = 1$ 的观测出现的数量 $m$ 的概率分布。 这被称为<strong>⼆项分布</strong> （<code>binomial distribution</code>）：</p><script type="math/tex; mode=display">\text {Bin}(m|N, \mu) = \dbinom{N}{m} \mu^{m}(1-\mu)^{N-m}\tag{2.8}</script><p>其中，</p><script type="math/tex; mode=display">\dbinom{N}{m} = \frac{N!}{(N-m)!m!}\tag{2.9}</script><p><strong>二项分布</strong> 的均值和⽅差分别为：</p><script type="math/tex; mode=display">\mathbb{E}[m] = \sum_{m=0}^{N} \text{Bin}(m|N, \mu) = N\mu\tag{2.10}</script><script type="math/tex; mode=display">\text{var}[m] = \sum_{m=0}^{N} (m-\mathbb{E}[m])^{2} \text{Bin}(m|N, \mu) = N\mu(1-\mu)\tag{2.11}</script><h2 id="2，Beta分布"><a href="#2，Beta分布" class="headerlink" title="2，Beta分布"></a>2，<code>Beta</code>分布</h2><p>首先，<strong><code>Gamma</code>函数</strong>的定义为：</p><script type="math/tex; mode=display">\Gamma(x) \equiv \int_{0}^{\infty} u^{x-1} e^{-u} \mathrm{d} u\tag{2.12}</script><p><strong><code>Gamma</code>函数</strong>具有如下性质：</p><p>1）$\Gamma(x+1) = x \Gamma(x)$<br>2）$\Gamma(1)=1$<br>3）当 $n$ 为整数时，$\Gamma(n+1) = n!$</p><p>如果我们选择⼀个正⽐于 $\mu$ 和 $(1 − \mu)$ 的幂指数的先验概率分布， 那么后验概率分布（正⽐于先验和似然函数的乘积）就会有着与先验分布相同的函数形式。这 个性质被叫做<strong>共轭性（<code>conjugacy</code>）</strong>。<br>先验分布选择<strong><code>Beta</code>分布</strong>定义为：</p><script type="math/tex; mode=display">\text {Beta}(\mu | a,b) = \frac{\Gamma{(a+b)}}{\Gamma{(a)}\Gamma{(b)}} \mu^{(a-1)}(1-\mu)^{(b-1)}\tag{2.13}</script><p>其中参数 $a$ 和 $b$ 经常被称为<strong>超参数</strong>（<code>hyperparameter</code>），均值和⽅差分别为：</p><script type="math/tex; mode=display">\mathbb{E}[\mu] = \frac{a}{a+b}\tag{2.14}</script><script type="math/tex; mode=display">\text{var}[\mu] = \frac{ab}{(a+b)^{2}(a+b+1)}\tag{2.15}</script><p>把<code>Beta</code>先验与⼆项似然函数相乘，然后归⼀化。只保留依赖于 $\mu$ 的因⼦，从而得到后验概率分布的形式为：</p><script type="math/tex; mode=display">p(\mu | m, l, a,b) = \frac{\Gamma{(m+a+l+b)}}{\Gamma{(m+a)}\Gamma{(l+b)}} \mu^{(m+a-1)}(1-\mu)^{(l+b-1)}\tag{2.16}</script><p>其中 $l = N − m$。</p><p>如图2.2～2.5： 对于不同的超参数 $a$ 和 $b$，公式(2.13)给出的<code>Beta</code>分布 $\text{Beta}(\mu | a, b)$ 关于 $\mu$ 的函数图像。</p><p><img src="/images/prml_20190920095614.png" alt="a=0.1,b=0.1"></p><p><img src="/images/prml_20190920095624.png" alt="a=1,b=1"></p><p><img src="/images/prml_20190920095635.png" alt="a=2,b=3"></p><p><img src="/images/prml_20190920095646.png" alt="a=8,b=4"></p><p><strong>贝叶斯学习过程</strong>存在⼀个共有的属性：随着我们观测到越来越多的数据，后验概率表⽰的不确定性将会持续下降。</p><p>为了说明这⼀点，我们可以⽤频率学家的观点考虑贝叶斯学习问题。考虑⼀个⼀般的贝叶斯推断问题，参数为 $\boldsymbol {\theta}$ ，并且我们观测到了⼀个数据集 $\mathcal{D}$，由联合概率分布 $p(\boldsymbol {\theta}, \mathcal{D})$ 描述，有：</p><script type="math/tex; mode=display">\mathbb{E}_{\boldsymbol {\theta}}[\boldsymbol {\theta}] = \mathbb{E}_{\mathcal{D}}[\mathbb{E}_{\boldsymbol {\theta}}[\boldsymbol {\theta}|\mathcal{D}]]\tag{2.17}</script><p>其中，</p><script type="math/tex; mode=display">\mathbb{E}_{\boldsymbol {\theta}}[\boldsymbol {\theta}] = \int p(\boldsymbol {\theta}) \boldsymbol {\theta} \mathrm{d} \boldsymbol {\theta}\tag{2.18}</script><script type="math/tex; mode=display">\mathbb{E}_{\mathcal{D}}[\mathbb{E}_{\boldsymbol {\theta}}[\boldsymbol {\theta}|\mathcal{D}]] = \int \left \{ \int \boldsymbol {\theta}p(\boldsymbol {\theta}|\mathcal{D}) \mathrm{d} \boldsymbol {\theta} \right \} p(\mathcal{D})\mathrm{d} \mathcal{D}\tag{2.19}</script><p>方差，</p><script type="math/tex; mode=display">\text{var}_{\boldsymbol {\theta}}[\boldsymbol {\theta}] = \mathbb{E}_{\mathcal{D}}[\text{var}[\boldsymbol {\theta}|\mathcal{D}]] + \text{var}_{\mathcal{D}} [\mathbb{E}_{\boldsymbol {\theta}}[\boldsymbol {\theta}|\mathcal{D}]]\tag{2.20}</script><h1 id="二，多项式变量"><a href="#二，多项式变量" class="headerlink" title="二，多项式变量"></a>二，多项式变量</h1><h2 id="1，多项式分布"><a href="#1，多项式分布" class="headerlink" title="1，多项式分布"></a>1，多项式分布</h2><p><strong>“1-of-K ”表⽰法</strong> ： 变量被表⽰成⼀个 $K$ 维向量 $\boldsymbol{x}$，向量中的⼀个元素 $x_k$ 等于1，剩余的元素等于0。注意，这样的向量 $\boldsymbol{x}$ 满足 $\sum_{k=1}^{K} x_k = 1$ ，如果我们⽤参数 $\mu_k$ 表⽰ $x_k = 1$ 的概率，那么 $\boldsymbol{x}$ 的分布：</p><script type="math/tex; mode=display">p(\boldsymbol{x}|\boldsymbol{\mu}) = \prod_{k=1}^{K} \mu_{k}^{x_k}\tag{2.21}</script><p>其中 $\boldsymbol{\mu} = (\mu_1 ,\dots, \mu_K)^T$ ， 参数 $\mu_k$ 要满⾜ $\mu_k \ge 0$ 和 $\sum_{k} \mu_k = 1$ 。</p><p>容易看出，这个分布是归⼀化的：</p><script type="math/tex; mode=display">\sum_{\boldsymbol {x}}p(\boldsymbol{x} | \boldsymbol{\mu}) = \sum_{k=1}^{K} \mu_k = 1\tag{2.22}</script><p>并且，</p><script type="math/tex; mode=display">\mathbb{E}[\boldsymbol{x}|\boldsymbol{\mu}] = \sum_{\boldsymbol {x}}p(\boldsymbol{x} | \boldsymbol{\mu}) \boldsymbol{x} = (\mu_1 ,\dots, \mu_K)^T = \boldsymbol {\mu}\tag{2.23}</script><p>现在考虑⼀个有 $N$ 个独⽴观测值 $\boldsymbol {x}_1 ,\dots, \boldsymbol {x}_N$ 的数据集 $\mathcal{D}$。对应的似然函数的形式为：</p><script type="math/tex; mode=display">p(\mathcal{D}|\boldsymbol{\mu}) = \prod_{n=1}^{N} \prod_{k=1}^{K} \mu_{k}^{x_{nk}} = \prod_{k=1}^{K} \mu_{k}^{(\sum_{n}x_{nk})} = \prod_{k=1}^{K} \mu_{k}^{m_k}\tag{2.24}</script><p>看到似然函数对于 $N$ 个数据点的依赖只是通过 $K$ 个下⾯形式的量：</p><script type="math/tex; mode=display">m_k = \sum_{n}x_{nk}\tag{2.25}</script><p>它表⽰观测到 $x_k = 1$ 的次数。这被称为这个分布的<strong>充分统计量</strong>（<code>sufficient statistics</code>）。</p><p>通过<strong>拉格朗⽇乘数法</strong>容易求得最大似然函数：</p><script type="math/tex; mode=display">\mu_k^{ML} = \frac{m_k}{N}\tag{2.26}</script><p>考虑 $m_1 ,\dots , m_K$ 在参数 $\boldsymbol{\mu}$ 和观测总数 $N$ 条件下的联合分布。根据公式(2.24)，这个分布的形式为：</p><script type="math/tex; mode=display">\text{Mult}(m_1 ,\dots , m_K | \boldsymbol{\mu}, N) = \dbinom{N}{m_1 \dots  m_K}\prod_{k=1}^{K} \mu_{k}^{m_k}\tag{2.27}</script><p>这被称为<strong>多项式分布</strong>（<code>multinomial distribution</code>）。 归⼀化系数是把 $N$ 个物体分成⼤⼩为 $m_1 ,\dots , m_K$ 的 $K$ 组的⽅案总数，定义为：</p><script type="math/tex; mode=display">\dbinom{N}{m_1 \dots  m_K} = \frac{N!}{m_1!m_2! \dots m_K!}\tag{2.28}</script><p>其中，$m_k$ 满足以下限制 $\sum_{k=1}^{K} m_k = N$ 。</p><h2 id="2，狄利克雷分布"><a href="#2，狄利克雷分布" class="headerlink" title="2，狄利克雷分布"></a>2，狄利克雷分布</h2><p><strong>狄利克雷分布</strong>（<code>Dirichlet distribution</code>）或<strong>多元<code>Beta</code>分布</strong>（<code>multivariate Beta distribution</code>）是一类在实数域以正单纯形（<code>standard simplex</code>）为支撑集（<code>support</code>）的高维连续概率分布，是 <strong><code>Beta</code>分布</strong>在高维情形的推广  。狄利克雷分布是<strong>指数族分布</strong>之一，也是<strong>刘维尔分布</strong>（<code>Liouville distribution</code>）的特殊形式，将狄利克雷分布的解析形式进行推广可以得到<strong>广义狄利克雷分布</strong>（<code>generalized Dirichlet distribution</code>）和<strong>组合狄利克雷分布</strong>（<code>Grouped Dirichlet distribution</code>）。</p><p><strong>狄利克雷分布</strong>概率的归⼀化形式为：</p><script type="math/tex; mode=display">\text{Dir}(\boldsymbol{\mu}|\boldsymbol{\alpha}) = \frac{\Gamma{(\alpha_{0})}}{\Gamma{(\alpha_{1})} \dots \Gamma{(\alpha_{K})}} \prod_{k=1}^{K}\mu_{k}^{\alpha_{k-1}}\tag{2.29}</script><p>其中，$\alpha_{0}=\sum_{k=1}^{K} \alpha_{k}$ 。</p><p>如图 2.6～2.8： 在不同的参数 $\alpha_{k}$ 的情况下，单纯形上的狄利克雷分布的图像。</p><p><img src="/images/prml_20190920160005.png" alt="ak=0.1"></p><p><img src="/images/prml_20190920160012.png" alt="ak=1"></p><p><img src="/images/prml_20190920160020.png" alt="ak=10"></p><p>如图2.9～2.11： 对于不同的 $N$ 值，$N$ 个均匀分布的均值的直⽅图。</p><p><img src="/images/prml_20190920160607.png" alt="N=1"></p><p><img src="/images/prml_20190920160615.png" alt="N=2"></p><p><img src="/images/prml_20190920160621.png" alt="N=10"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《模式识别与机器学习》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一，二元变量&quot;&gt;&lt;a href=&quot;#一，二元变量&quot; class=&quot;headerlink&quot; title=&quot;一，二元变量&quot;&gt;&lt;/a&gt;一，二元变量&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zhangbc.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习基础" scheme="https://zhangbc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习基础】总论</title>
    <link href="https://zhangbc.github.io/2019/09/19/prml_01_pandect/"/>
    <id>https://zhangbc.github.io/2019/09/19/prml_01_pandect/</id>
    <published>2019-09-19T00:49:10.000Z</published>
    <updated>2019-10-07T14:25:30.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《模式识别与机器学习》的读书笔记。</p></blockquote><h1 id="一，-概率论"><a href="#一，-概率论" class="headerlink" title="一， 概率论"></a>一， 概率论</h1><h2 id="1，离散型随机变量概率"><a href="#1，离散型随机变量概率" class="headerlink" title="1，离散型随机变量概率"></a>1，离散型随机变量概率</h2><p>假设随机变量 $X$ 可以取任意 的 $x_i$ ，其中 $i = 1, \dots. , M$ ，并且随机变量 $Y$ 可以取任意的 $y_j$ ，其中 $j = 1,\dots , L$。考虑 $N$ 次试验，其中我们对 $X$ 和 $Y$ 都进⾏取样， 把 $X = x_i$ 且 $Y = y_j$ 的试验的数量记作 $n_{ij}$ ，并且，把 $X$ 取值 $x_i$ （与 $Y$ 的取值⽆关）的试验的数量记作 $c_i$ ，类似地，把 $Y$ 取值 $y_j$ 的试验的数量记作 $r_j$ 。</p><p>$X$ 取值 $x_i$ 且 $Y$ 取值 $y_j$ 的概率被记作 $p(X = x_i , Y = y_j )$， 被称为 $X = x_i$ 和 $Y = y_j$ 的<strong>联合概率</strong> （<code>joint probability</code>）。它的计算⽅法为落在单元格 $i, j$ 的点的数量与点的总数的⽐值，即：</p><script type="math/tex; mode=display">p\left(X=x_{i}, Y=y_{i}\right)=\frac{n_{i j}}{N}\tag{1.5}</script><p>如图1.15所示，联合概率的计算方法。</p><p><img src="/images/prml_20190917233144.png" alt="联合概率计算"></p><p>类似地，$X$ 取值 $x_i$ （与 $Y$ 取值无关）的概率被记作 $p(X = x_i )$ ，也称为<strong>边缘概率</strong>（<code>marginal probability</code>），计算⽅法为落在列$i$上的点的数量与点的总数的⽐值，即：</p><script type="math/tex; mode=display">p\left(X=x_{i}\right)=\frac{c_{j}}{N}\tag{1.6}</script><p>由于图1.15中列 $i$ 上的实例总数就是这列的所有单元格中实例的数量之和，即$c_{i}=\sum_{j} n_{i j}$，因此根据公式(1.5)和公式(1.6)，我们可以得到概率的<strong>加和规则</strong>（<code>sun rule</code>），即：</p><script type="math/tex; mode=display">p\left(X=x_{j}\right)=\sum_{j=1}^{L} p\left(X=x_{i}, Y=y_{j}\right)\tag{1.7}</script><p>如果我们只考虑那些 $X = x_i$ 的实例， 那么这些实例中 $Y = y_j$ 的实例所占的⽐例被写成 $p(Y = y_j | X = x_i)$，被称为给定 $X = x_i$ 的 $Y = y_j$ 的<strong>条件概率</strong>（<code>conditional probability</code>），其计算⽅式为：计算落在单元格 $i, j$ 的点的数量列 $i$ 的点的数量的⽐值，即：</p><script type="math/tex; mode=display">p\left(Y=y_{j} | X=x_{i}\right)=\frac{n_{i j}}{c_{i}}\tag{1.8}</script><p>从公式(1.5)、公式(1.6)、公式(1.8)可以推导出概率的<strong>乘积规则</strong>（<code>product rule</code>），即：</p><script type="math/tex; mode=display">p\left(X=x_{i}, Y=y_{j}\right)=\frac{n_{i j}}{N}=\frac{n_{i j}}{c_{i}} \cdot \frac{c_{i}}{N}=p\left(Y=y_{j} | X=x_{i}\right) p\left(X=x_{i}\right)\tag{1.9}</script><p>根据<strong>乘积规则</strong>，以及对称性 $p(X, Y ) = p(Y, X)$，我们⽴即得到了下⾯的两个条件概率之间的关系，称为<strong>贝叶斯定理</strong>（<code>Bayes&#39; theorem</code>）即：</p><script type="math/tex; mode=display">p(Y | X)=\frac{p(X | Y) p(Y)}{p(X)}\tag{1.10}</script><p><strong>贝叶斯定理</strong>（<code>Bayes&#39; theorem</code>），在模式识别和机器学习领域扮演者中⼼⾓⾊。使⽤<strong>加和规则</strong>，贝叶斯定理中的<strong>分母</strong>可以⽤出现在分⼦中的项表⽰，这样就可以把分母看作归一常数，即：</p><script type="math/tex; mode=display">p(X)=\sum_{Y} p(X|Y) p(Y)\tag{1.11}</script><p>如果两个变量的联合分布可以分解成两个边缘分布的乘积，即 $p(X, Y) = p(X)p(Y)$， 那么我们说 $X$ 和 $Y$ <strong>相互独⽴</strong>（<code>independent</code>）。</p><h2 id="2，概率密度"><a href="#2，概率密度" class="headerlink" title="2，概率密度"></a>2，概率密度</h2><p>如果⼀个实值变量x的概率 落在区间 $(x, x + \delta x)$ 的概率由 $p(x)\delta x$ 给出（$\delta x \to 0$）， 那么 $p(x)$ 叫做 $x$ 的<strong>概率密度</strong>（<code>probability density</code>）。$x$ 位于区间 $(a, b)$ 的概率：</p><script type="math/tex; mode=display">p(x \in(a, b))=\int_{a}^{b} p(x) \mathrm{d}x\tag{1.12}</script><p>如图1.16，概率密度函数。</p><p><img src="/images/prml_20190918085229.png" alt="离散型变量的概率与概率密度函数"></p><p>由于概率是⾮负的，并且 $x$ 的值⼀定位于实数轴上得某个位置，因此概率密度⼀定满⾜下⾯两个<strong>条件</strong>：</p><p>1）$p(x) \geq 0$</p><p>2) $\int_{-\infty}^{\infty} p(x) \mathrm{d} x=1$</p><p>在变量以⾮线性的形式变化的情况下，概率密度函数通过<code>Jacobian</code>因⼦变换为与简单的函数不同的形式。</p><p>例如，假设我们考虑⼀个变量的变化 $x = g(y)$， 那么函数 $f(x)$ 就变成 了 $\tilde{f}(y)=f(g(y))$。现在让我们考虑⼀个概率密度函数 $p_x (x)$，它对应于⼀个关于新变量 $y$ 的密度函数 $p_y (y)$，对于很⼩的 $\delta x$ 的值，落在区间 $(x, x + \delta x)$ 内的观测会被变换到区间 $(y, y + \delta y)$ 中。其中 $p_{x}(x) \delta x \simeq p_{y}(y) \delta y$ ，因此有：</p><script type="math/tex; mode=display">p_{y}(y)=p_{x}(x)\left|\frac{\mathrm{d} x}{\mathrm{d} y}\right|=p_{x}(g(y))\left|g^{\prime}(y)\right|\tag{1.13}</script><p>位于区间 $(−\infty, z)$ 的 $x$ 的概率由<strong>累积分布函数</strong>（<code>cumulative distribution function</code>）给出。 定义为：</p><script type="math/tex; mode=display">P(z)=\int_{-\infty}^{z} p(x) \mathrm{d} x\tag{1.14}</script><p>如果我们有⼏个连续变量 $x_1 ,\dots , x_D$ ， 整体记作向量 $\boldsymbol{x}$， 那么我们可以定义联合概率密度 $p(\boldsymbol{x}) = p(x_1 ,\dots , x_D )$，使得 $\boldsymbol{x}$ 落在包含点 $\boldsymbol{x}$ 的⽆穷⼩体积 $\delta \boldsymbol{x}$ 的概率由 $p(\boldsymbol{x})\delta \boldsymbol{x}$ 给出。<strong>多变量概率密度</strong>必须满⾜以下<strong>条件</strong>：</p><p>1）$p(\boldsymbol{x}) \geq 0$</p><p>2) $\int p(\boldsymbol{x}) \mathrm{d} \boldsymbol{x}=1$</p><p>其中，积分必须在整个 $\boldsymbol{x}$ 空间上进⾏。</p><h2 id="3，期望和方差"><a href="#3，期望和方差" class="headerlink" title="3，期望和方差"></a>3，期望和方差</h2><p>在概率分布 $p(x)$ 下，函数 $f(x)$ 的平均值被称为 $f(x)$ 的<strong>期望</strong>（<code>expectation</code>），记作 $\mathbb{E}[f]$。对于⼀个离散变量，它的定义为：</p><script type="math/tex; mode=display">\mathbb{E}[f]=\sum_{x} p(x) f(x)\tag{1.15}</script><p>在连续变量的情形下，期望以对应的概率密度的积分的形式表⽰为：</p><script type="math/tex; mode=display">\mathbb{E}[f]=\int p(x) f(x) \mathrm{d}{x}\tag{1.16}</script><p>如果我们给定有限数量的 $N$ 个点，这些点满⾜某个概率分布或者概率密度函数， 那么期望可以通过<strong>求和</strong>的⽅式估计，因此有：</p><script type="math/tex; mode=display">\mathbb{E}[f] \simeq \frac{1}{N} \sum_{n=1}^{N} f\left(x_{n}\right)\tag{1.17}</script><p>$f(x)$ 的<strong>⽅差</strong>（<code>variance</code>）度量了 $f(x)$ 在均值 $\mathbb{E} [f(x)]$ 附近变化性的⼤⼩。被定义为：</p><script type="math/tex; mode=display">\operatorname{var}[f]=\mathbb{E}\left[(f(x)-\mathbb{E}[f(x)])^{2}\right]\tag{1.18}</script><p>将公式(1.18)中的平方项展开，即有公式(1.19)：</p><script type="math/tex; mode=display">\operatorname{var}[f]=\mathbb{E}\left[f(x)^{2}\right]-\mathbb{E}[f(x)]^{2}\tag{1.19}</script><p>特别地，我们可以考虑变量 $x$ ⾃⾝的⽅差，即有：</p><script type="math/tex; mode=display">\operatorname{var}[x]=\mathbb{E}\left[x^{2}\right]-\mathbb{E}[x]^{2}\tag{1.20}</script><p>对于两个随机变量 $x$ 和 $y$ ，<strong>协⽅差</strong>（<code>covariance</code>），表⽰在多⼤程度上 $x$ 和 $y$ 会共同变化。被定义为：</p><script type="math/tex; mode=display">\operatorname{cov}[x, y]=\mathbb{E}_{x, y}[\{x-\mathbb{E}[x]\}\{y-\mathbb{E}[y]\}]=\mathbb{E}_{x, y}[x y]-\mathbb{E}[x] \mathbb{E}[y]\tag{1.21}</script><p>显然，由公式(1.21)推知，如果 $x$ 和 $y$ <strong>相互独⽴</strong>，那么它们的<strong>协⽅差</strong>为0。</p><p>在两个随机向量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 的情形下，协⽅差是⼀个<strong>矩阵</strong>，即有：</p><script type="math/tex; mode=display">\operatorname{cov}[\boldsymbol{x}, \boldsymbol{y}]=\mathbb{E}_{\boldsymbol{x}, \boldsymbol{y}}\left[\{\boldsymbol{x}-\mathbb{E}[\boldsymbol{x}]\}\left\{\boldsymbol{y}^{T}-\mathbb{E}\left[\boldsymbol{y}^{T}\right]\right\}\right]=\mathbb{E}_{\boldsymbol{x}, \boldsymbol{y}}\left[\boldsymbol{x} \boldsymbol{y}^{T}\right]-\mathbb{E}[\boldsymbol{x}] \mathbb{E}\left[\boldsymbol{y}^{T}\right]\tag{1.22}</script><h2 id="4，贝叶斯概率"><a href="#4，贝叶斯概率" class="headerlink" title="4，贝叶斯概率"></a>4，贝叶斯概率</h2><p>在观察到数据之前，我们有⼀些关于参数 $\boldsymbol{w}$ 的假设，这以<strong>先验概率</strong> $p(\boldsymbol{w})$ 的形式给出。观测数据 $\mathcal{D} = {t_1,\dots, t_N}$ 的效果可以通过<strong>条件概率</strong> $p(\mathcal{D} | \boldsymbol{w})$ 表达，即贝叶斯定理的形式为：</p><script type="math/tex; mode=display">p(\boldsymbol{w} | \mathcal{D})=\frac{p(\mathcal{D} | \boldsymbol{w}) p(\boldsymbol{w})}{p(\mathcal{D})}\tag{1.23}</script><p>其中， 可以⽤后验概率分布和似然函数来表达贝叶斯定理的分母，即得：</p><script type="math/tex; mode=display">p(\mathcal{D})=\int p(\mathcal{D} | \boldsymbol{w}) p(\boldsymbol{w}) \mathrm{d} \boldsymbol{w}\tag{1.24}</script><p>让我们能够通过<strong>后验概率</strong> $p(\boldsymbol{w} | \mathcal{D})$，在观测到 $\mathcal{D}$ 之后估计 $\boldsymbol{w}$ 的不确定性。公式(1.23)中 $p(\mathcal{D} | \boldsymbol{w})$ 由观测数据集 $\mathcal{D}$ 来估计，可以被看成参数向量 $\boldsymbol{w}$ 的函数，被称为<strong>似然函数</strong>（<code>likelihood function</code>）。</p><h2 id="5，高斯分布"><a href="#5，高斯分布" class="headerlink" title="5，高斯分布"></a>5，高斯分布</h2><p><strong>正态分布</strong>（<code>Normal distribution</code>），也称<strong>常态分布</strong>，又名<strong>高斯分布</strong>（<code>Gaussian distribution</code>），最早由A.棣莫弗在求<strong>二项分布</strong>的渐近公式中得到。正态分布概念是由德国的数学家和天文学家<code>Moivre</code>于1733年首次提出的。</p><p><strong>正态曲线</strong>呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为<strong>钟形曲线</strong>。</p><p>对于⼀元实值变量 $x$，⾼斯分布被定义为：</p><script type="math/tex; mode=display">\mathcal{N}\left(x | \mu, \sigma^{2}\right)=\frac{1}{\left(2 \pi \sigma^{2}\right)^{\frac{1}{2}}} \exp \left\{-\frac{1}{2 \sigma^{2}}(x-\mu)^{2}\right\}\tag{1.25}</script><p>其中，$\mu$ 被叫做<strong>均值</strong>（<code>mean</code>）， $\sigma^{2}$ 被叫做<strong>⽅差</strong>（<code>variance</code>）或者<strong>方差参数</strong>。⽅差的平⽅根， 由 $\sigma$ 给定， 被叫做<strong>标准差</strong>（<code>standard deviation</code>）。 ⽅差的倒数， 记作 $\beta=\frac{1}{\sigma^{2}}$ ， 被叫做<strong>精度</strong> （<code>precision</code>）。</p><p>如图1.17，高斯分布曲线。</p><p><img src="/images/prml_20190918103504.png" alt="高斯分布曲线"></p><p>不难发现，<strong>高斯分布</strong>具有以下<strong>性质</strong>：</p><p>1）$\mathcal{N}\left(x | \mu, \sigma^{2}\right)&gt;0$</p><p>2）$\int_{-\infty}^{\infty} \mathcal{N}\left(x | \mu, \sigma^{2}\right) \mathrm{d} x=1$</p><p>3）$\mathbb{E}[x]=\int_{-\infty}^{\infty} \mathcal{N}\left(x | \mu, \sigma^{2}\right) x \mathrm{d} x=\mu$</p><p>4）$\mathbb{E}\left[x^{2}\right]=\int_{-\infty}^{\infty} \mathcal{N}\left(x | \mu, \sigma^{2}\right) x^{2} \mathrm{d} x=\mu^{2}+\sigma^{2}$</p><p>5）$\operatorname{var}[x]=\mathbb{E}\left[x^{2}\right]-\mathbb{E}[x]^{2}=\sigma^{2}$</p><p>分布的最⼤值被叫做<strong>众数</strong>。对于<strong>⾼斯分布</strong>，<strong>众数</strong>与<strong>均值</strong>恰好相等。</p><p>对 $D$ 维向量 $\boldsymbol{x}$ 的⾼斯分布，定义为：</p><script type="math/tex; mode=display">\mathcal{N}(\boldsymbol{x} | \boldsymbol{\mu}, \mathbf{\Sigma})=\frac{1}{(2 \pi)^{\frac{D}{2}}} \frac{1}{|\boldsymbol{\Sigma}|^{\frac{1}{2}}} \exp \left\{-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right\}\tag{1.26}</script><p>其中 $D$ 维向量 $\boldsymbol{\mu}$ 被称为<strong>均值</strong>，$D \times D$ 的矩阵 $\boldsymbol{\Sigma}$ 被称为<strong>协⽅差</strong>，$|\boldsymbol{\Sigma}|$ 表⽰ $\boldsymbol{\Sigma}$ 的⾏列式。</p><p>独⽴地从相同的数据点中抽取的数据点被称为<strong>独⽴同分布</strong>（<code>independent and identically distributed</code>），通常缩写成<code>i.i.d.</code>。</p><p>假设给定一个观测的数据集由标量变量 $x$ 的 $N$ 次观测组成，写作 $<br>\mathbf{x} = (x_1,\dots, x_N)^T $ ，记向量变量 $\boldsymbol{x} = (x_1,\dots, x_N)^T$ ，假定各次观测是独⽴地从⾼斯分布中抽取的， 分布的均值 $\mu$ 和⽅差 $\sigma^{2}$ 未知， 我们想根据数据集来确定这些参数。由于数据集 $\mathbf{x}$ 是<strong>独⽴同分布</strong>的，因此给定 $\mu$ 和 $\sigma^{2}$ ，我们可以给出数据集的概率即为高斯分布的似然函数：</p><script type="math/tex; mode=display">p\left(\mathbf{x} | \mu, \sigma^{2}\right)=\prod_{n=1}^{N} \mathcal{N}\left(x_{n} | \mu, \sigma^{2}\right)\tag{1.27}</script><p>对于似然函数公式(1.27)变形可得到：</p><script type="math/tex; mode=display">\ln p\left(\mathbf{x} | \mu, \sigma^{2}\right)=-\frac{1}{2 \sigma^{2}} \sum_{n=1}^{N}\left(x_{n}-\mu\right)^{2}-\frac{N}{2} \ln \sigma^{2}-\frac{N}{2} \ln (2 \pi)\tag{1.28}</script><p>关于 $\mu$ ，最⼤化函数公式(1.28)，我们可以得到<strong>均值最⼤似然解</strong>：</p><script type="math/tex; mode=display">\mu_{ML} = \frac{1}{N} \sum_{n=1}^{N}x_{n}\tag{1.29}</script><p>关于 $\sigma^{2}$  ，最⼤化函数公式(1.28)，我们可以得到<strong>方差最⼤似然解</strong>：</p><script type="math/tex; mode=display">\sigma^{2}_{ML} = \frac{1}{N} \sum_{n=1}^{N} (x_n - \mu_{ML})^{2}\tag{1.30}</script><h2 id="6，考察曲线拟合问题"><a href="#6，考察曲线拟合问题" class="headerlink" title="6，考察曲线拟合问题"></a>6，考察曲线拟合问题</h2><p><strong>曲线拟合问题</strong>的<strong>⽬标</strong>是能够根据 $N$ 个输⼊ $\mathbf{x}\equiv(x_1,\dots, x_N)^T$ 组成的数据集和它们对应的⽬标值 $\mathbf{t}\equiv  (t_1,\dots, t_N)^T$ ，在给出输⼊变量 $x$ 的新值的情况下，对⽬标变量 $t$ 进⾏预测。</p><p>现假定给定 $x$ 的值， 对应的 $t$ 值服从<strong>⾼斯分布</strong>，分布的均值为 $y(x, \boldsymbol{w})$ ，由公式(1.1)给出。则其概率为:</p><script type="math/tex; mode=display">p(t|x, \boldsymbol{w}, \beta ) = \mathcal{N}\left(t | y(x, \boldsymbol{w}),  \beta^{-1}\right)\tag{1.31}</script><p>如图1.18，⾼斯条件概率分布。</p><p><img src="/images/prml_20190918151706.png" alt="⾼斯条件概率分布"></p><p>似然函数为：</p><script type="math/tex; mode=display">p\left(\mathbf{t} | \mathbf{x}, \boldsymbol{w}, \beta \right)=\prod_{n=1}^{N} \mathcal{N}\left(t | y(x, \boldsymbol{w}),  \beta^{-1}\right)\tag{1.32}</script><p>似然函数变形为：</p><script type="math/tex; mode=display">\ln p\left(\mathbf{t} | \mathbf{x}, \boldsymbol{w}, \beta \right)=-\frac{\beta}{2} \sum_{n=1}^{N}\left\{y(x_{n},\boldsymbol{w})-t_n\right\}^{2}+\frac{N}{2} \ln \beta-\frac{N}{2} \ln (2 \pi)\tag{1.33}</script><p>考虑确定多项式系数的最⼤似然解（记作 $\boldsymbol{w}_{ML}$ ），这些由公式(1.33)来确定。可以使⽤最⼤似然⽅法来确定⾼斯条件分布的精度参数 $\beta$ ：</p><script type="math/tex; mode=display">\frac{1}{\beta_{ML}} = \frac{1}{N} \sum_{n=1}^{N}\left\{y(x_{n},\boldsymbol{w}_{ML})-t_n\right\}^{2}\tag{1.34}</script><p>简单起见，引⼊在多项式系数 $\boldsymbol{w}$ 上的先验分布，我们考虑下⾯形式的⾼斯分布：</p><script type="math/tex; mode=display">p(\boldsymbol{w} | \alpha)=\mathcal{N}\left(\boldsymbol{w} | \mathbf{0}, \alpha^{-1} \boldsymbol{I}\right)=\left(\frac{\alpha}{2 \pi}\right)^{\frac{M+1}{2}} \exp \left\{-\frac{\alpha}{2} \boldsymbol{w}^{T} \boldsymbol{w}\right\}\tag{1.35}</script><p>给定数据集，我们现在通过寻找最可能的 $\boldsymbol{w}$ 值（即<strong>最⼤化后验概率</strong>）来确定 $\boldsymbol{w}$ 。这种技术被称 为<strong>最⼤后验</strong>（<code>maximum posterior</code>），简称<strong><code>MAP</code></strong>。根据公式(1.35)和公式(1.33)可得最⼤化后验概率即最⼩化：</p><script type="math/tex; mode=display">\frac{\beta}{2} \sum_{n=1}^{N}\left\{y\left(x_{n}, \boldsymbol{w}\right)-t_{n}\right\}^{2}+\frac{\alpha}{2}\boldsymbol{w}^{T}\boldsymbol{w}\tag{1.36}</script><h2 id="7，贝叶斯曲线拟合"><a href="#7，贝叶斯曲线拟合" class="headerlink" title="7，贝叶斯曲线拟合"></a>7，贝叶斯曲线拟合</h2><p><strong>贝叶斯⽅法</strong>就是⾃始⾄终地使⽤概率的<strong>加和规则</strong>和<strong>乘积规则</strong>。因此预测概率可以写成：</p><script type="math/tex; mode=display">p\left(t | x, \mathbf{x}, \mathbf{t} \right)=\int p(t | x, \boldsymbol{w}) p(\boldsymbol{w} | \mathbf{x}, \mathbf{t}) \mathrm{d} \boldsymbol{w}\tag{1.37}</script><p>预测分布由⾼斯的形式：</p><script type="math/tex; mode=display">p\left(t | x, \mathbf{x}, \mathbf{t} \right) = \mathcal{N}\left(t | m(x), s^{2}(x)\right)\tag{1.38}</script><p>其中，均值，</p><script type="math/tex; mode=display">m(x) = \beta \phi(x)^{T} \boldsymbol{S} \sum_{n=1}^{N}\phi(x_n)t_n\tag{1.39}</script><p>⽅差，</p><script type="math/tex; mode=display">s^{2}(x) = \beta^{-1} + \phi(x)^{T}\boldsymbol{S}\phi(x)\tag{1.40}</script><p>矩阵，</p><script type="math/tex; mode=display">\boldsymbol{S}^{-1} = \alpha \boldsymbol{I} + \beta \sum_{n=1}^{N}\phi({x_n})\phi({x_n})^{T}\tag{1.41}</script><p>其中，$\boldsymbol{I}$  是单位矩阵，向量 $\phi(x)$ 被定义为 $\phi_i (x) = x^{i} (i = 0, \dots, M)$。</p><p>如图1.19，⽤贝叶斯⽅法处理多项式曲线拟合问题得到的预测分布的结果。使⽤的多项式为 $M$ = 9，超参数被固定为 $\alpha = 5 \times 10^{-3}$ 和 $\beta = 11.1$（对应于已知的噪声⽅差）。 其中， 红⾊曲线表⽰预测概率分布的均值，红⾊区域对应于均值周围 $±1$ 标准差的范围。</p><p><img src="/images/prml_20190918151304.png" alt="贝叶斯⽅法处理多项式曲线拟合问题"></p><p>如图1.20，参数为 $S$ 的交叉验证⽅法。</p><p><img src="/images/prml_20190918151313.png" alt="交叉验证⽅法"></p><h1 id="二，模型选择"><a href="#二，模型选择" class="headerlink" title="二，模型选择"></a>二，模型选择</h1><p>为了建⽴好的模型，我们想使⽤尽可能多的可得到的数据进⾏训练。然⽽，如果验证机很⼩，它对预测表现的估计就会有⼀定的噪声。解决这种困境的⼀种⽅法是使⽤<strong>交叉验证</strong>（<code>cross validation</code>）。这种⽅法能够让可得到数据的 $\frac{S−1}{S}$ ⽤于训练，同时使⽤所有的数据来评估表现。当数据相当稀疏的时候，考虑 $S = N$ 的情况很合适，其中 $N$ 是数据点的总数。这种技术叫做<strong>留⼀法</strong>（<code>leave-one-out</code>）。</p><p>如图1.21，交叉验证。</p><p><img src="/images/prml_20190918160236.png" alt="交叉验证"></p><p><strong>交叉验证</strong>的⼀个主要的<strong>缺点</strong>是需要进⾏的训练的次数随着 $S$ ⽽增加，这对于训练本⾝很耗时的问题来说是个⼤问题。对于像交叉验证这种使⽤分开的数据来评估模型表现的⽅法来说，还 有⼀个问题：对于⼀个单⼀的模型，我们可能有多个复杂度参数（例如可能有若⼲个正则化参数）。</p><h1 id="三，维度灾难"><a href="#三，维度灾难" class="headerlink" title="三，维度灾难"></a>三，维度灾难</h1><p>如果我们有 $D$ 个输⼊变量，那么 ⼀个三阶多项式就可以写成如下的形式：</p><script type="math/tex; mode=display">y(\boldsymbol{x}, \boldsymbol{w}) = w_{0} + \sum_{i=1}^{D}w_{i}x_{i} + \sum_{i=1}^{D}\sum_{j=1}^{D}w_{ij}x_{i}x_{j} + \sum_{i=1}^{D}\sum_{j=1}^{D}\sum_{k=1}^{D}w_{ijk}x_{i}x_{j}x_{k}\tag{1.42}</script><p>随着 $D$ 的增加，独⽴的系数的数量（并⾮所有的系数都独⽴，因为变量 $x$ 之间的互换对称性）的 增长速度正⽐于$D^3$ 。</p><p>注意到，$D$ 维空间的半径为 $r$ 的球体的体积⼀定是 $r^{D}$ 的倍数，因此有：</p><script type="math/tex; mode=display">V_{D}(r) = K_{D}r^{D}\tag{1.43}</script><p>其中常数 $K_{D}$ 值依赖于D。因此要求解的体积比，即：</p><script type="math/tex; mode=display">\frac{V_{D}(1)-V_{D}(1-\epsilon)}{V_{D}(1)} = 1 - (1-\epsilon)^{D}\tag{1.44}</script><p>如图1.22，对于不同的 $D$，位于 $r = 1 − \epsilon$ 和 $r = 1$ 之间的部分与球的体积⽐。</p><p><img src="/images/prml_20190918161735.png" alt="维度D"></p><p>如图1.23，不同的维度 $D$ 中的⾼斯分布的概率密度关于半径 $r$ 的关系。</p><p><img src="/images/prml_20190918163058.png" alt="D与r的关系"></p><p><strong>维度灾难</strong>(<code>Curse of Dimensionality</code>)：通常是指在涉及到向量的计算的问题中，随着维度的增加，计算量呈指数倍增长的一种现象。</p><h1 id="四，决策论"><a href="#四，决策论" class="headerlink" title="四，决策论"></a>四，决策论</h1><h2 id="1，最⼩化错误分类率"><a href="#1，最⼩化错误分类率" class="headerlink" title="1，最⼩化错误分类率"></a>1，最⼩化错误分类率</h2><p>假定我们的⽬标很简单，即尽可能少地作出错误分类。我们需要⼀个规则来把每个 $x$ 的值分到⼀个合适的类别。这种规则将会把输⼊空间切分成不同的区域 $\mathcal{R}_{k}$ ，这种区域被称为<strong>决策区域</strong> （<code>decision region</code>）。每个类别都有⼀个决策区域，区域 $\mathcal{R}_{k}$ 中的所有点都被分到 $\mathcal{C}_{k}$ 类。决策区域间的边界被叫做<strong>决策边界</strong>（<code>decision boundary</code>）或者<strong>决策⾯</strong>（<code>decision surface</code>）。注意， 每⼀个 决策区域未必是连续的，可以由若⼲个分离的区域组成。 如果我们把属于 $\mathcal{C}_{1}$ 类的输⼊向量分到了 $\mathcal{C}_{2}$ 类（或者相反）， 那么我们就犯了⼀个错误。这种事情发⽣的概率为：</p><script type="math/tex; mode=display">\begin{aligned} p(\text { mistake }) &=p\left(\boldsymbol{x} \in \mathcal{R}_{1}, \mathcal{C}_{2}\right)+p\left(\boldsymbol{x} \in \mathcal{R}_{2}, \mathcal{C}_{1}\right) \\ &=\int_{\mathcal{R}_{1}} p\left(\boldsymbol{x}, \mathcal{C}_{2}\right) \mathrm{d} \boldsymbol{x}+\int_{\mathcal{R}_{2}} p\left(\boldsymbol{x}, \mathcal{C}_{1}\right) \mathrm{d} \boldsymbol{x} \end{aligned}\tag{1.45}</script><p>如图1.24，两个类别的联合概率分布 $p(x, \mathcal{C}_k)$ 与 $x$ 的关系。</p><p><img src="/images/prml_20190918171908.png" alt="联合概率分布与x关系"></p><p>对于更⼀般的 $K$ 类的情形，最⼤化正确率会稍微简单⼀些，即最⼤化下式：</p><script type="math/tex; mode=display">p(\text {correct}) = \sum_{k=1}^{K}p\left(\boldsymbol{x} \in \mathcal{R}_{k}, \mathcal{C}_{k}\right) = \sum_{k=1}^{K} \int_{\mathcal{R}_{k}} p\left(\boldsymbol{x}, \mathcal{C}_{k}\right) \mathrm{d} \boldsymbol{x}\tag{1.46}</script><h2 id="2，最⼩化期望损失"><a href="#2，最⼩化期望损失" class="headerlink" title="2，最⼩化期望损失"></a>2，最⼩化期望损失</h2><p><strong>损失函数</strong>也被称为<strong>代价函数</strong>（<code>cost function</code>），是对于所有可能的决策或者动作可能产⽣的损失的⼀种整体的度量。</p><p>假设对于新的 $x$ 值，真实的类别为 $\mathcal{C}_{k}$ ，我们把 $x$ 分类为 $\mathcal{C}_{j}$ （其中 $j$ 可能与 $k$ 相等，也可能不相等）。这样做的结果是，我们会造成某种程度的损失，记作 $L_{kj}$ ，它可以看成<strong>损失矩阵</strong>（<code>loss matrix</code>）的第 $k, j$ 个元素。</p><p>对于⼀个给定的输⼊向量 $\boldsymbol{x}$，我们对于真实类别的不确定性通过联合概率分布 $p(\boldsymbol{x}, \mathcal{C}_{k})$ 表⽰。因此，我们转⽽去最⼩化平均损失。平均损失根据这个联合概率分布计算，定义为：</p><script type="math/tex; mode=display">\mathbb{E}[L] = \sum_{k}\sum_{j} \int_{\mathcal{R}_{k}} L_{kj}p(\boldsymbol{x}, \mathcal{C}_{k})\mathrm{d} \boldsymbol{x}\tag{1.47}</script><h2 id="3，拒绝选项"><a href="#3，拒绝选项" class="headerlink" title="3，拒绝选项"></a>3，拒绝选项</h2><p>在发⽣分类错误的输⼊空间中，后验概率 $p(\mathcal{C}_{k} | \boldsymbol{x})$ 通常远⼩于1，或者等价地，不同类别的联合分布 $p(\boldsymbol{x}, \mathcal{C}_{k})$ 有着可⽐的值。这些区域中，类别的归属相对不确定。在某些应⽤中， 对于这种困难的情况， 避免做出决策是更合适的选择。 这样会使得模型的分类错误率降低。 这被称为<strong>拒绝选项</strong>（<code>reject option</code>）。</p><p>如图1.25，拒绝选项。</p><p><img src="/images/prml_20190918180040.png" alt="拒绝选项"></p><h2 id="4，推断和决策"><a href="#4，推断和决策" class="headerlink" title="4，推断和决策"></a>4，推断和决策</h2><p>同时解决两个问题，即简单地学习⼀个函数，将输⼊ $\boldsymbol{x}$ 直接映射为决策。这样的函数被称为<strong>判别函数</strong>（<code>discriminant function</code>）。</p><p>给出三种不同的⽅法来解决决策问题，具体如下：</p><p>a）⾸先对于每个类别 $\mathcal{C}_{k}$ ， 独⽴地确定类条件密度  $p(\boldsymbol{x} | \mathcal{C}_{k})$ ，这是⼀个推断问题。 然后， 推断先验类概率 $p(\mathcal{C}_{k})$ 。之后，使⽤贝叶斯定理求出后验类概率  $p(\mathcal{C}_{k} | \boldsymbol{x})$ 。等价地，我们可以直接对联合概率分布 $p(\boldsymbol{x} , \mathcal{C}_{k})$ 建模，然后归⼀化，得到后验概率。得到后验概率之后， 我们可以使⽤决策论来确定每个新的输⼊ $\boldsymbol{x}$ 的类别。显式地或者隐式地对输⼊以及输出进⾏建模的⽅法被称为<strong>⽣成式模型</strong>（<code>generative model</code>），因为通过取样，可以⽤来⼈⼯⽣成出输⼊空间的数据点。</p><p>b）⾸先解决确定后验类密度  $p(\mathcal{C}_{k} | \boldsymbol{x})$ 这⼀推断问题，接下来使⽤决策论来对新的输⼊ $\boldsymbol{x}$ 进⾏分类。这种直接对后验概率建模的⽅法被称为<strong>判别式模型</strong>（<code>discriminative models</code>）。</p><p>c）找到⼀个函数 $f(\boldsymbol{x})$， 被称为<strong>判别函数</strong>。 这个函数把每个输⼊ $\boldsymbol{x}$ 直接映射为类别标签。</p><h2 id="5，回归问题的损失函数"><a href="#5，回归问题的损失函数" class="headerlink" title="5，回归问题的损失函数"></a>5，回归问题的损失函数</h2><p>讨论曲线拟合问题，决策阶段包括对于每个输⼊ $\boldsymbol{x}$，选择⼀个对于 $t$ 值的具体估计 $y(\boldsymbol{x})$。假设这样做之后，我们造成了⼀个损失 $L(t, y(\boldsymbol{x}))$。平均损失（或者说期望损失）就是：</p><script type="math/tex; mode=display">\mathbb{E}[L] = \int\int L(t, y(\boldsymbol{x}, x))p(\boldsymbol{x}, t)\mathrm{d} \boldsymbol{x}\mathrm{d}{t}\tag{1.48}</script><p>回归问题中，损失函数的⼀个通常的选择是<strong>平⽅损失</strong>，定义为 $L(t, y(\boldsymbol{x})) = \{y(\boldsymbol{x}) − t\}^{2}$ 。这种情况下，期望损失函数可以写成：</p><script type="math/tex; mode=display">\mathbb{E}[L] = \int\int \{y(\boldsymbol{x}) − t\}^{2}p(\boldsymbol{x}, t)\mathrm{d} \boldsymbol{x}\mathrm{d}{t}\tag{1.49}</script><p>假设⼀个完全任意的函数 $y(\boldsymbol{x})$，我们能够形式化地使⽤变分法：</p><script type="math/tex; mode=display">\frac{\delta \mathbb{E}[L]}{\delta y(\boldsymbol{x})} = 2 \int \{y(\boldsymbol{x}) − t\}p(\boldsymbol{x}, t)\mathrm{d}{t} = 0\tag{1.50}</script><p>求解 $y(\boldsymbol{x})$，使⽤概率的<strong>加和规则</strong>和<strong>乘积规则</strong>，得到：</p><script type="math/tex; mode=display">y(\boldsymbol{x})=\frac{\int \operatorname{tp}(\boldsymbol{x}, t) \mathrm{d} t}{p(\boldsymbol{x})}=\int t p(t | \boldsymbol{x}) \mathrm{d} t=\mathbb{E}_{t}[t | \boldsymbol{x}]\tag{1.51}</script><p>这是在 $\boldsymbol{x}$ 的条件下 $t$ 的条件均值， 被称为<strong>回归函数</strong>（<code>regression function</code>）。</p><p>如图1.26，回归函数。</p><p><img src="/images/prml_20190918195108.png" alt="回归函数"></p><p><strong>闵可夫斯基损失函数</strong>（<code>Minkowski loss</code>），它的期望为：</p><script type="math/tex; mode=display">\mathbb{E}[L_{q}] = \int\int |y(\boldsymbol{x}) − t|^{q}p(\boldsymbol{x}, t)\mathrm{d} \boldsymbol{x}\mathrm{d}{t}\tag{1.52}</script><p>如图1.27～1.30，对于不同的 $q$ 值，$L_{q} = |y − t|^{q}$ 的图像。</p><p><img src="/images/prml_20190918200648.png" alt="q=0.3"></p><p><img src="/images/prml_20190918200657.png" alt="q=1"></p><p><img src="/images/prml_20190918200706.png" alt="q=2"></p><p><img src="/images/prml_20190918200716.png" alt="q=10"></p><p>由公式(1.52)分析不难发现，当 $q = 2$ 时， 这个函数就变成了<strong>平⽅损失函数</strong>的期望。当 $q = 2$ 时，$\mathbb{E}[L_{q}]$ 的最⼩值是条件均值。当 $q = 1$ 时，$\mathbb{E}[L_{q}]$ 的最⼩值是条件中位数。当$q \to 0$ 时，$\mathbb{E}[L_{q}]$ 的最⼩值是条件众数。</p><h1 id="五，信息论"><a href="#五，信息论" class="headerlink" title="五，信息论"></a>五，信息论</h1><p>如果有两个不相关的事件 $x$ 和 $y$ ， 那么我们观察到两个事件同时发⽣时获得的信息应该等于观察到事件各⾃发⽣时获得的信息之和， 即 $h(x, y) = h(x) + h(y)$。 两个不相关事件是统计独⽴的， 因此 $p(x, y) = p(x)p(y)$。根据这两个关系，很容易看出 $h(x)$ ⼀定与 $p(x)$ 的对数有关。因此，我们有：</p><script type="math/tex; mode=display">h(x) = - \text{log}_{2}p(x)\tag{1.53}</script><p>概率分布  $p(x)$ 的期望，</p><script type="math/tex; mode=display">H[x] = - \sum_{x}p(x) \text {log}_{2}p(x)\tag{1.54}</script><p>这个重要的量被叫做随机变量 $\boldsymbol{x}$ 的<strong>熵</strong>（<code>entropy</code>）。</p><h2 id="1，关于理解熵的例子"><a href="#1，关于理解熵的例子" class="headerlink" title="1，关于理解熵的例子"></a>1，关于理解<strong>熵</strong>的例子</h2><p>考虑⼀个集合，包含 $N$ 个完全相同的物体，这些 物体要被分到若⼲个箱⼦中，使得第 $i$ 个箱⼦中有 $n_i$ 个物体。考虑把物体分配到箱⼦中的不同⽅案的数量。有 $N$ 种⽅式选择第⼀个物体，有 $(N − 1)$ 种⽅式选择第⼆个物体，以此类推。因此总 共有 $N!$ 种⽅式把 $N$ 个物体分配到箱⼦中，其中 $N!$ 表⽰乘积 $N\times(N − 1)\times \dots \times 2 \times 1$。然⽽，我们不想区分每个箱⼦内部物体的重新排列。在第 $i$ 个箱⼦中，有 $n_i !$ 种⽅式对物体重新排序，因此把 $N$ 个物体分配到箱⼦中的总⽅案数量为：</p><script type="math/tex; mode=display">W=\frac{N !}{\prod_{i} n_{i} !}\tag{1.55}</script><p>这被称为<strong>乘数</strong>（<code>multiplicity</code>）。<strong>熵</strong>被定义为通过适当的参数放缩后的对数乘数，即：</p><script type="math/tex; mode=display">H = \frac{1}{N} \ln W = \frac{1}{N} \ln N! - \frac{1}{N}\ln n_{i}!\tag{1.56}</script><p>考虑极限 $N \to \infty$ ，并且保持⽐值 $\frac{n_i}{N}$ 固定，使⽤<code>Stirling</code>的估计：</p><script type="math/tex; mode=display">\ln N! \simeq N \ln N - N\tag{1.57}</script><p>即可得：</p><script type="math/tex; mode=display">H = - \lim_{N \to \infty} \sum_{i} (\frac{n_{i}}{N}) \ln (\frac{n_{i}}{N}) = - \sum_{i} p_{i} \ln p_{i}\tag{1.58}</script><p>在概率归⼀化的限制下，使⽤<strong>拉格朗⽇乘数法</strong>可以找到<strong>熵</strong>的最⼤值。因此，我们要最⼤化：</p><script type="math/tex; mode=display">\tilde{H}=-\sum_{i} p\left(x_{i}\right) \ln p\left(x_{i}\right)+\lambda\left(\sum_{i} p\left(x_{i}\right)-1\right)\tag{1.59}</script><p>可以证明， 当所有的 $p(x_i)$ 都相等， 且值为 $p(x_i) = \frac{1}{M}$ 时， 熵取得最⼤值。 其中，$M$ 是状态 $x_i$ 的总数。此时对应的熵值为 $H = \ln M$ 。</p><h2 id="2，关于连续变量-boldsymbol-x-的概率分布-p-x-的熵"><a href="#2，关于连续变量-boldsymbol-x-的概率分布-p-x-的熵" class="headerlink" title="2，关于连续变量 $\boldsymbol{x}$ 的概率分布 $p(x)$ 的熵"></a>2，关于连续变量 $\boldsymbol{x}$ 的概率分布 $p(x)$ 的<strong>熵</strong></h2><p>⾸先把 $x$ 切分成宽度为 $\Delta$ 的箱⼦。然后假设 $p(x)$ 是连续的。<strong>均值定理</strong>（<code>mean value theorem</code>）（Weisstein, 1999）告诉我们，对于每个这样的箱⼦，⼀定存在⼀个值 $x_i$ 使得：</p><script type="math/tex; mode=display">\int_{i \Delta}^{(i+1) \Delta}p(x_i)\mathrm{d}x = p(x_i)\Delta\tag{1.60}</script><p>现在可以这样量化连续变量 $x$：只要 $x$ 落在第 $i$ 个箱⼦中，我们就把 $x$ 赋值为 $x_i$ 。因此观察到值 $x_i$ 的概率为 $p(x_i) \Delta$。这就变成了离散的分布，这种情形下<strong>熵</strong>的形式为：</p><script type="math/tex; mode=display">H \Delta = - \sum_{i}p(x_i) \Delta \ln(p(x_i) \Delta) - \ln \Delta\tag{1.61}</script><p>其中，</p><script type="math/tex; mode=display">\sum_{i}p(x_i) \Delta = 1 \tag{1.62}</script><p>考察 $\Delta \to 0$ ，由以上公式即可推得<strong>微分熵</strong>（<code>differential entropy</code>）：</p><script type="math/tex; mode=display">\lim_{\Delta \to 0}\left\{-\sum_{i} p\left(x_{i}\right) \Delta \ln p(x_i) \right\} = - \int p(x)\ln p(x) \mathrm{d}{x}\tag{1.63}</script><p>对于定义在多元连续变量（联合起来记作向量 $\boldsymbol{x}$ ）上的概率密度，<strong>微分熵</strong>为：</p><script type="math/tex; mode=display">H[\boldsymbol{x}] = - \int p(x) \ln p(x) \mathrm{d}{x}\tag{1.64}</script><p><strong>最⼤化微分熵</strong>的时候要遵循下⾯三个限制条件，即：</p><script type="math/tex; mode=display">\int_{-\infty}^{\infty}p(x) \mathrm{d}{x} = 1\tag{1.65}</script><script type="math/tex; mode=display">\int_{-\infty}^{\infty}x p(x) \mathrm{d}{x} = \mu\tag{1.66}</script><script type="math/tex; mode=display">\int_{-\infty}^{\infty}(x - \mu)^{2} p(x) \mathrm{d}{x} = \delta^{2}\tag{1.67}</script><p>在上述条件的限制下，使⽤<strong>拉格朗⽇乘数法</strong>可以找到<strong>熵</strong>的最⼤值。最终结果化：</p><script type="math/tex; mode=display">p(x) = \frac{1}{\left(2 \pi \sigma^{2}\right)^{\frac{1}{2}}} \exp \left\{-\frac{1}{2 \sigma^{2}}(x-\mu)^{2}\right\}\tag{1.68}</script><p>因此最⼤化微分熵的分布是<strong>⾼斯分布</strong>，其<strong>微分熵</strong>公式：</p><script type="math/tex; mode=display">H[x] = \frac{1}{2}\{ 1 + \ln(2\pi \delta^{2}) \}\tag{1.69}</script><h2 id="3，关于连续变量-boldsymbol-x-boldsymbol-y-的联合概率分布-p-boldsymbol-x-boldsymbol-y-的熵"><a href="#3，关于连续变量-boldsymbol-x-boldsymbol-y-的联合概率分布-p-boldsymbol-x-boldsymbol-y-的熵" class="headerlink" title="3，关于连续变量 $(\boldsymbol{x}, \boldsymbol{y})$ 的联合概率分布 $p(\boldsymbol{x}, \boldsymbol{y})$ 的熵"></a>3，关于连续变量 $(\boldsymbol{x}, \boldsymbol{y})$ 的联合概率分布 $p(\boldsymbol{x}, \boldsymbol{y})$ 的<strong>熵</strong></h2><p>假设有⼀个联合概率分布 $p(\boldsymbol{x}, \boldsymbol{y})$ ，我们从这个概率分布中抽取了⼀对 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 。如果 $\boldsymbol{x}$ 的值已知，那么需要确定对应的 $\boldsymbol{y}$ 值所需的附加的信息就是 $− \ln p(\boldsymbol{y} | \boldsymbol{x})$ 。因此，⽤来确定 $y$ 值的平均附加信息可以写成：</p><script type="math/tex; mode=display">H[\boldsymbol{x}|\boldsymbol{x}] = - \iint p(\boldsymbol{y}, \boldsymbol{x})\ln p(\boldsymbol{y}|\boldsymbol{x}) \mathrm{d}{\boldsymbol{y}} \mathrm{d}{\boldsymbol{x}}\tag{1.70}</script><p>这被称为给定 $\boldsymbol{x}$ 的情况下，$\boldsymbol{y}$ 的<strong>条件熵</strong>。使⽤乘积规则，很容易看出，条件熵满⾜下⾯的关系：</p><script type="math/tex; mode=display">H[\boldsymbol{x}, \boldsymbol{y}] = H[\boldsymbol{y}|\boldsymbol{x}] + H[\boldsymbol{x}]\tag{1.71}</script><h2 id="4，相对熵和互信息"><a href="#4，相对熵和互信息" class="headerlink" title="4，相对熵和互信息"></a>4，相对熵和互信息</h2><p>考虑某个未知的分布 $p(\boldsymbol{x})$，假定我们已经使⽤⼀个近似的分布 $q(\boldsymbol{x})$ 对它进⾏了建模。如果我们使⽤ $q(\boldsymbol{x})$ 来建⽴⼀个编码体系，⽤来把 $\boldsymbol{x}$ 的值传给接收者，那么，由于我们使⽤了 $q(\boldsymbol{x})$ ⽽不是真实分布 $p(\boldsymbol{x})$，因此在具体化 $\boldsymbol{x}$ 的值（假定我们选择了⼀个⾼效的编码系统）时，我们需要⼀些附加的信息。我们需要的平均的附加信息量（单位是<code>nat</code>）：</p><script type="math/tex; mode=display">\begin{aligned} \mathrm{KL}(p \| q) &=-\int p(\boldsymbol{x}) \ln q(\boldsymbol{x}) \mathrm{d} \boldsymbol{x}-\left(-\int p(\boldsymbol{x}) \ln p(\boldsymbol{x}) \mathrm{d} \boldsymbol{x}\right) \\ &=-\int p(\boldsymbol{x}) \ln \left\{\frac{q(\boldsymbol{x})}{p(\boldsymbol{x})}\right\} \mathrm{d} \boldsymbol{x} \end{aligned}\tag{1.72}</script><p>这被称为分布 $p(\boldsymbol{x})$ 和分布 $q(\boldsymbol{x})$ 之间的<strong>相对熵</strong>（<code>relative entropy</code>） 或者 <strong><code>Kullback-Leibler</code>散度</strong> （<code>Kullback-Leibler divergence</code>）， 或者 <strong><code>KL</code>散度</strong>（Kullback and Leibler, 1951）。</p><p>可以证明，<strong><code>Kullback-Leibler</code>散度</strong> 满⾜ $\mathrm{KL}(p | q) \ge 0$，并且当且仅当 $p(\boldsymbol{x}) = q(\boldsymbol{x})$ 时等号成⽴。</p><p>如果⼀个函数具有如下性质：每条弦都位于函数图像或其上⽅，那么我们说这个函数是<strong>凸函数</strong>。其性质为：</p><script type="math/tex; mode=display">f(\lambda a + (1-\lambda)b) \le \lambda f(a) + (1-\lambda)f(b)\tag{1.73}</script><p>由归纳法容易知，<strong>凸函数</strong> $f(x)$ 满足 <strong><code>Jensen</code>不等式</strong>（<code>Jensen&#39;s inequality</code>）：</p><script type="math/tex; mode=display">f \left(\sum_{i=1}^{M}\lambda_{i} x_i\right) \le \sum_{i=1}^{M}\lambda_i f(x_i)\tag{1.74}</script><p>对于连续变量，<strong><code>Jensen</code>不等式</strong>：</p><script type="math/tex; mode=display">f \left(\int \boldsymbol{x} p(\boldsymbol{x}) \mathrm{d} \boldsymbol{x}\right) \le \int f(\boldsymbol{x})p(\boldsymbol{x}) \mathrm{d} \boldsymbol{x}\tag{1.75}</script><p>现在考虑由 $p(\boldsymbol{x}, \boldsymbol{y})$ 给出的两个变量 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 组成的数据集。如果变量的集合是独⽴的，那么他们的联合分布可以分解为边缘分布的乘积 $p(\boldsymbol{x}, \boldsymbol{y}) = p(\boldsymbol{x})p(\boldsymbol{y})$ 。如果变量不是独⽴的，那么我们可以通过考察<strong>联合概率分布</strong>与<strong>边缘概率分布</strong>乘积之间的 <strong><code>Kullback-Leibler</code>散度</strong>来判断它们是否“接近”于相互独⽴。此时，<strong><code>Kullback-Leibler</code>散度</strong>：</p><script type="math/tex; mode=display">\begin{aligned} I[\boldsymbol{x}, \boldsymbol{y}] &\equiv \mathrm{KL}(p(\boldsymbol{x}, \boldsymbol{y}) \|p(\boldsymbol{x})q(\boldsymbol{y}))\\ &=-\iint p(\boldsymbol{x}, \boldsymbol{y}) \ln \left(\frac{p(\boldsymbol{x})q(\boldsymbol{y})}{p(\boldsymbol{x, y})}\right) \mathrm{d} \boldsymbol{x} \mathrm{d} \boldsymbol{y} \end{aligned}\tag{1.76}</script><p>这被称为变量 $\boldsymbol{x}$ 和变量 $\boldsymbol{y}$ 之间的<strong>互信息</strong>（<code>mutual information</code>）。 根据 <strong><code>Kullback-Leibler</code>散度</strong>的性质，我们看到 $I[\boldsymbol{x}, \boldsymbol{y}] \ge 0$ ，当且仅当 $\boldsymbol{x}$ 和 $\boldsymbol{y}$ 相互独⽴时等号成⽴。使⽤概率的<strong>加和规则</strong>和<strong>乘积规则</strong>，我们看到互信息和条件熵之间的关系：</p><script type="math/tex; mode=display">I[\boldsymbol{x,y}] = H[\boldsymbol{x}] - H[\boldsymbol{x|y}] = H[\boldsymbol{y}] - H[\boldsymbol{y|x}]\tag{1.77}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《模式识别与机器学习》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一，-概率论&quot;&gt;&lt;a href=&quot;#一，-概率论&quot; class=&quot;headerlink&quot; title=&quot;一， 概率论&quot;&gt;&lt;/a&gt;一， 概率论&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zhangbc.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习基础" scheme="https://zhangbc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习基础】从回归问题引基础：多项式曲线拟合</title>
    <link href="https://zhangbc.github.io/2019/09/17/prml_01_polynomial_curve_fitting/"/>
    <id>https://zhangbc.github.io/2019/09/17/prml_01_polynomial_curve_fitting/</id>
    <published>2019-09-17T13:52:56.000Z</published>
    <updated>2019-10-07T08:59:52.344Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《模式识别与机器学习》的读书笔记。</p></blockquote><h1 id="一，-举例：多项式曲线拟合"><a href="#一，-举例：多项式曲线拟合" class="headerlink" title="一， 举例：多项式曲线拟合"></a>一， 举例：多项式曲线拟合</h1><p>假设给定一个训练集。这个训练集由 $x$ 的 $N$ 次观测组成，写作 $\mathbf{x}\equiv(x_1,\dots, x_N)^T$ ，伴随这对应的 $t$ 的观测值，记作 $\mathbf{t}\equiv (t_1,\dots, t_N)^T$。其中，输入数据集合 $\mathbf{x}$ 通过选择$x_n(n=1,\dots,N)$ 的值来生成，这些 $x_n$ 均匀分布在区间[0, 1]，目标数据集 $\mathbf{t}$ 的获得方式是：首先计算函数 $sin(2\pi x)$ 的对应的值，然后给每个点增加一个小的符合高斯分布的随机噪声，从而得到对应的 $t_n$ 的值。 我们的<strong>目标</strong>是利用这个训练集预测对于输入变量的新值 $\hat{x}$ 得到的目标变量的值 $\hat{t}$。 </p><p>如下图1.1，由 $N$ =10个数据点组成的训练集的图像，用蓝色圆圈表示。</p><p><img src="/images/prml_20190917090037.png" alt="训练集"></p><p>如图1.2，误差函数对应于每个数据点与函数 $y(x, \boldsymbol{w})$ 之间位移（绿⾊垂直线）的平⽅和（的⼀半）。</p><p><img src="/images/prml_20190917090255.png" alt="误差分析"></p><p>但是现在，我们要⽤⼀种相当⾮正式的、相当简单的⽅式来进⾏曲线拟合。特别地，将使⽤下⾯形式的多项式函数来拟合数据：</p><script type="math/tex; mode=display">y(x, \boldsymbol{w})=w_{0}+w_{1} x+w_{2} x^{2}+\ldots+w_{M} x^{M}=\sum_{i=0}^{M} w_{j} x^{j}\tag{1.1}</script><p>其中 $M$ 是多项式的阶数（<code>order</code>），$x^j$ 表⽰ $x$ 的 $j$ 次幂。 多项式系数 $w_0 , \dots , w_M$ 整体记作向量 $\boldsymbol{w}$。 注意，虽然多项式函数 $y(x, \boldsymbol{w})$ 是 $x$ 的⼀个⾮线性函数，它是系数 $\boldsymbol{w}$ 的⼀个线性函数。类似多项式函数的这种关于未知参数满⾜线性关系的函数有着重要的性质，被叫做<strong>线性模型</strong>。</p><p>系数的值可以通过调整多项式函数拟合训练数据的⽅式确定。 这可以通过<strong>最⼩化误差函数</strong> （<code>error function</code>）的⽅法实现。</p><script type="math/tex; mode=display">E(\boldsymbol{w})=\frac{1}{2} \sum_{n=1}^{N}\left\{y\left(x_{n}, \boldsymbol{w}\right)-t_{n}\right\}^{2}\tag{1.2}</script><p>我们可以通过过选择使得 $E(\boldsymbol{w})$ 尽量⼩的 $\boldsymbol{w}$ 来解决曲线拟合问题。由于误差函数是系数 $\boldsymbol{w}$ 的⼆次函数， 因此它关于系数的导数是 $\boldsymbol{w}$ 的线性函数， 所以误差函数的最⼩值有⼀个唯⼀解， 记作 $\boldsymbol{w}^*$ ，可以⽤解析的⽅式求出。最终的多项式函数由函数 $y\left(x, \boldsymbol{w}^*\right)$ 给出。</p><p>如下图1.3～1.6，不同阶数的多项式曲线，⽤红⾊曲线表⽰，拟合了图1.1中的数据集。</p><p><img src="/images/prml_20190917092654.png" alt="M=0"></p><p><img src="/images/prml_20190917092714.png" alt="M=1"></p><p><img src="/images/prml_20190917092731.png" alt="M=3"></p><p><img src="/images/prml_20190917092742.png" alt="M=9"></p><p>当 $M=9$ 时，多项式函数精确地通过了每⼀个数据点，$E(\boldsymbol{w}^*) = 0$。 然⽽， 拟合的曲线剧烈震荡，就表达函数 $sin(2\pi x)$ ⽽⾔表现很差。这种⾏为叫做<strong>过拟合</strong>（<code>over-fitting</code>）。</p><p>通常用<strong>根均⽅</strong>（<code>RMS</code>）<strong>误差</strong>来计算：</p><script type="math/tex; mode=display">E_{R M S}=\sqrt{2 E\left(\boldsymbol{w}^{*}\right) / N}\tag{1.3}</script><p>如图1.7，当M 的取值为 $3 \leq M \leq 8$ 时， 测试误差较⼩， 对于⽣成函数 $sin(2\pi x)$ 也能给出合理的模拟。</p><p><img src="/images/prml_20190917101815.png" alt="根均方误差"></p><p>如图1.8，不同阶数的多项式的系数 $\boldsymbol{w}^{*}$ 的值。观察随着多项式阶数的增加，系数的⼤⼩是如何剧烈增⼤的。</p><p><img src="/images/prml_20190917105109.png" alt="系数变化"></p><p>如图1.9～1.10，使⽤ $M = 9$ 的多项式对 $N = 15$ 个数据点和 $N = 100$ 个数据点通过最⼩化平⽅和误差函数的⽅法得到的解。</p><p><img src="/images/prml_20190917105954.png" alt="N=15"></p><p><img src="/images/prml_20190917110004.png" alt="N=100"></p><p>常⽤来控制过拟合现象的⼀种技术是<strong>正则化</strong>（<code>regularization</code>）。 这种技术涉及到给误差函数增加⼀个<strong>惩罚项</strong>，使得系数不会达到很⼤的值。这种惩罚项最简单的形式采⽤所有系数的平⽅和的形式。这推导出了误差函数的修改后的形式：</p><script type="math/tex; mode=display">\tilde{E}(\boldsymbol{w})=\frac{1}{2} \sum_{n=1}^{N}\left\{y\left(x_{n}, \boldsymbol{w}\right)-t_{n}\right\}^{2}+\frac{\lambda}{2}\|\boldsymbol{w}\|^{2}\tag{1.4}</script><p>其中，系数 $\lambda$ 控制了正则化项相对于平⽅和误差项的重要性；</p><script type="math/tex; mode=display">\|\boldsymbol{w}\|^{2} \equiv \boldsymbol{w}^{T} \boldsymbol{w}=w_{0}^{2}+w_{1}^{2}+\ldots+w_{M}^{2}</script><p>通过把给定的数据中的⼀部分从测试集中分离出，来确定系数 $\boldsymbol{w}$。这个分离出来的验证集（<code>validation set</code>），也被称为<strong>拿出集</strong>（<code>hold-out set</code>），⽤来最优化模型的复杂度（$M$ 或者 $\lambda$）。</p><p>如图1.11～1.12，使⽤正则化的误差函数，⽤ $M = 9$ 的多项式拟合图中的数据集。其中正则化参数 $\lambda$ 选择了两个值，分别对应于 $\ln \lambda=-18$ 和 $\ln \lambda=0$。</p><p><img src="/images/prml_20190917152015.png" alt="ln lambda=-18"></p><p><img src="/images/prml_20190917152029.png" alt="ln lambda=0"><br>如图1.13，不同的正则化参数 $\lambda$ 下，$M$ = 9的多项式的系数 $\boldsymbol{w}^{*}$ 的值。观察随着 $\lambda$ 的增大，系数的⼤⼩是逐渐变小的。</p><p><img src="/images/prml_20190917152043.png" alt="正则参数"></p><p>如图1.14，对于 $M = 9$ 的多项式，均⽅根误差与 $\ln \lambda$ 的关系。</p><p><img src="/images/prml_20190917152101.png" alt="均⽅根误差与ln lambda的关系"></p><h1 id="二，-总结"><a href="#二，-总结" class="headerlink" title="二， 总结"></a>二， 总结</h1><p>  本小节为机器学习的入门篇，主要通过一个多项式拟合具体实例引出了线性模型相关概念，训练集的意义，误差函数，根均方差，修正误差函数等公式，正则化参数概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《模式识别与机器学习》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一，-举例：多项式曲线拟合&quot;&gt;&lt;a href=&quot;#一，-举例：多项式曲线拟合&quot; class=&quot;headerlink&quot; title=&quot;一， 举例：多项式曲
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zhangbc.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习基础" scheme="https://zhangbc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【资源共享】eBook分享大集合</title>
    <link href="https://zhangbc.github.io/2019/08/29/eBooks_share/"/>
    <id>https://zhangbc.github.io/2019/08/29/eBooks_share/</id>
    <published>2019-08-28T16:03:18.000Z</published>
    <updated>2019-09-29T06:16:03.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eBook分享大集合"><a href="#eBook分享大集合" class="headerlink" title="eBook分享大集合"></a>eBook分享大集合</h1><ul><li>主要以IT领域经典书籍收藏，以备不时之需。</li><li>福利传送门：<a href="https://github.com/zhangbc/eBooks" target="_blank" rel="noopener">【GitHub】</a> 欢迎各位指点，要是能补充更是感激不尽。</li></ul><h2 id="服务器系统类"><a href="#服务器系统类" class="headerlink" title="服务器系统类"></a>服务器系统类</h2><blockquote><ol><li>Linux高性能服务器编程</li><li>Shell脚本学习指南</li><li>高级Bash脚本编程指南.3.9.1 (杨春敏 黄毅 译)</li><li>鸟哥的Linux私房菜基础篇(第3版)</li><li>深入理解计算机系统</li></ol></blockquote><h2 id="机器学习类"><a href="#机器学习类" class="headerlink" title="机器学习类"></a>机器学习类</h2><blockquote><ol><li>吴恩达深度学习教程</li><li>deepLearning深度学习(开源版)</li><li>python自然语言处理实战：核心技术与算法</li><li>机器学习方法</li><li>社交网站的数据挖掘与分析</li><li>统计学习方法</li><li>用Python进行自然语言处理</li></ol></blockquote><h2 id="算法类"><a href="#算法类" class="headerlink" title="算法类"></a>算法类</h2><blockquote><ol><li>Java数据结构和算法(第2版)</li><li>编程之法面试和算法心得</li><li>编程珠玑(第2版)</li><li>编程珠玑2</li><li>大话数据结构</li><li>计算机程序设计艺术第1卷：基本算法（第3版）</li><li>计算机程序设计艺术第2卷：半数值算法（第3版）</li><li>计算机程序设计艺术第3卷：排序与查找（第2版）</li><li>剑指offer</li><li>数据结构(C语言版).严蔚敏_吴伟民.扫描版</li><li>数据结构与算法分析(C++描述)(第3版)</li><li>算法导论(第2版)</li></ol></blockquote><h2 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h2><blockquote><ol><li>HTTP权威指南</li><li>TCP-IP详解卷1：协议</li><li>TCP-IP详解卷2：实现</li><li>TCP-IP详解卷3：TCP事务协议，HTTP，NNTP和UNIX域协议</li><li>图解TCP IP(第5版)</li></ol></blockquote><h2 id="程序语言类"><a href="#程序语言类" class="headerlink" title="程序语言类"></a>程序语言类</h2><ul><li>C/C++语言</li></ul><blockquote><ol><li>C++ Primer(第5版)(中文版)</li><li>C和指针</li><li>C语言程序设计</li><li>C语言的科学和艺术</li><li>modern-cpp-tutorial</li><li>大规模C++程序设计</li><li>深入体验C语言项目开发</li><li>实用C语言编程（第3版）</li></ol></blockquote><ul><li>Python语言</li></ul><blockquote><ol><li>Django Web开发指南</li><li>Python.Cookbook(第2版)中文版</li><li>Python标准库中文版</li><li>Python高级编程（法莱德）</li><li>Python核心编程(第2版)</li><li>Python灰帽子</li><li>python基础教程(第2版)</li><li>Python源码剖析</li><li>think in Python</li><li>编写高质量代码 改善Python程序的91个建议</li><li>利用Python进行数据分析</li><li>流畅的Python</li><li>深入浅出Python</li></ol></blockquote><ul><li>Java语言</li></ul><blockquote><ol><li>Head First Java 中文高清版</li><li>Java编程思想(第4版)</li><li>Java核心技术(第8版)卷I_基础知识</li><li>Java核心技术</li><li>Java入门经典</li><li>阿里巴巴Java开发手册终极版v1.3.0</li><li>设计模式之禅 秦晓波</li></ol></blockquote><ul><li>PHP语言</li></ul><blockquote><ol><li>Ajax与PHPWeb开发.pdf</li><li>PHP高级程序设计_模式、框架与测试</li><li>PHP项目开发案例全程实录</li><li>PHP与MYSQL权威指南</li></ol></blockquote><ul><li>C#/.NET语言</li></ul><blockquote><ol><li>.NET本质论</li><li>.NET应用程序架构设计 原则 模式与实践</li><li>ASP.NET MVC4 WEB编程</li><li>ASP.NET MVC4高级编程</li><li>ASP.NET MVC4框架揭秘</li><li>ASP.NET.4.0 揭秘(卷1)</li><li>ASP.NET.4.0 揭秘(卷2)</li><li>ASP.NET本质论</li><li>ASP.NET设计模式</li><li>C#本质论</li><li>C#程序开发范例宝典</li><li>C#高级编程（第7版）</li><li>C#入门经典(第3版)</li><li>C#入门经典(第5版)</li><li>C#与.NET程序员面试宝典</li><li>CLR.via.C#（第3版）</li><li>IT企业必读的200个.NET面试题</li><li>WCF服务编程</li><li>WCF全面解析（上册）</li><li>WCF全面解析（下册）</li><li>编写高质量代码改善C#程序的157个建议</li><li>大话设计模式</li></ol></blockquote><ul><li>Web技术</li></ul><blockquote><ol><li>CSS权威指南(第3版)</li><li>HTML5程序设计(第2版)</li><li>HTML5权威指南</li><li>JavaScript高级应用与实践</li><li>JavaScript权威指南(第4版)</li><li>JavaScript权威指南(第6版)</li><li>JavaScript入门经典(第4版)</li><li>jQuery权威指南</li><li>WebKit技术内幕</li><li>高性能网站建设进阶指南</li><li>论道HTML5</li><li>认识与设计：理解UI设计准则</li></ol></blockquote><h2 id="数据库类"><a href="#数据库类" class="headerlink" title="数据库类"></a>数据库类</h2><ul><li>Oracle</li></ul><blockquote><ol><li>Oracle高性能SQL引擎剖析-SQL优化与调优机制详解</li><li>PLSQL操作手册</li><li>编程艺术深入数据库体系结构</li><li>剑破冰山  Oracle开发艺术</li><li>收获，不止Oracle</li></ol></blockquote><ul><li>MySQL</li></ul><blockquote><ol><li>MySQL 5权威指南(第3版)</li><li>MYSQL必知必会</li><li>MySQL技术内幕(第4版) </li><li>MySQL技术内幕：SQL编程</li><li>MySQL技术内幕InnoDB存储引擎</li><li>MySQL性能调优与架构设计</li><li>高性能MySQL(第2版)</li><li>高性能MySQL(第3版)</li></ol></blockquote><ul><li>SQL Server</li></ul><blockquote><ol><li>SQL2005技术内幕： T-SQ程序设计</li><li>SQL2005技术内幕：存储引擎</li><li>SQL2008技术内幕：T-SQL查询</li><li>SQL2008技术内幕：T-SQL语言基础</li><li>SQLServer2008查询性能优化</li><li>SQLSERVER2008学习笔记：日常维护、深入管理、性能优化</li><li>SQL反模式</li><li>Transact-SQL权威指南</li><li>数据库索引设计与优化</li><li>数据库性能调优.原理与技术</li></ol></blockquote><ul><li>大数据类</li></ul><blockquote><ol><li>Hadoop权威指南(第2版)</li><li>MongoDB权威指南</li><li>MongoDB实战</li><li>R与Hadoop大数据分析实战</li><li>Spark大数据处理：技术、应用与性能优化</li><li>Spark快速数据处理</li></ol></blockquote><h2 id="其他系列"><a href="#其他系列" class="headerlink" title="其他系列"></a>其他系列</h2><ul><li>IT思维类</li></ul><blockquote><ol><li>编码的奥秘</li><li>编码—隐匿在计算机软硬件背后的语言上</li><li>程序员的自我修养—链接、装载与库</li><li>程序员修炼之道</li><li>代码整洁之道</li><li>高效能人士的七个习惯</li><li>计算机程序的构造和解释</li><li>浪潮之巅</li><li>全栈增长工程师指南</li><li>人月神话</li><li>数学之美(第2版)</li><li>修改代码的艺术</li><li>一万小时天才理论</li></ol></blockquote><ul><li>非书籍类</li></ul><blockquote><ol><li>C语言学习资料.exe</li></ol></blockquote><ul><li>架构设计类</li></ul><blockquote><ol><li>GOF设计模式</li><li>UML和模式应用(第3版)</li><li>分布式JAVA应用 基础与实践</li><li>精通.NET企业项目开发：最新的模式、工具与方法</li><li>领域驱动设计C#2008实现 - 问题.设计.解决方案</li><li>领域驱动设计—软件核心复杂性应对之道</li><li>领域驱动设计与模式实战</li><li>企业应用架构模式</li><li>探索CQRS和事件源</li><li>微软应用技术架构(第2版)</li><li>重构_改善既有代码的设计</li><li>重构与模式</li></ol></blockquote><ul><li>敏捷开发类</li></ul><blockquote><ol><li>Scrum敏捷软件开发</li><li>Web开发敏捷之道</li><li>Web开发敏捷之道：应用Rails进行敏捷Web开发（第4版）</li><li>测试驱动开发的3项修炼：走出TDD丛林</li><li>大规模定制模式下的敏捷产品开发</li><li>高效程序员的45个习惯：敏捷开发修炼之道</li><li>敏捷估计与规划</li><li>敏捷技能修炼-敏捷软件开发与设计的最佳实践</li><li>敏捷开发：原则、模式与实践</li><li>敏捷开发的必要技巧</li><li>敏捷开发的艺术</li><li>敏捷开发回顾：使团队更强大</li><li>敏捷开发知识体系</li><li>敏捷软件开发：原则、模式与实践(C#版)</li><li>敏捷软件开发：原则、模式与实践</li><li>敏捷无敌</li><li>敏捷武士：看敏捷高手交付卓越软件</li><li>敏捷整合开发：更快改进性能的案例与实用技术</li><li>硝烟中的Scrum和XP</li><li>应用Rails进行敏捷Web开发(第3版)</li><li>用户故事与敏捷方法</li></ol></blockquote><h2 id="LFS-100M"><a href="#LFS-100M" class="headerlink" title="LFS(100M+)"></a>LFS(100M+)</h2><ul><li>由于 <code>GitHub</code> 是gitLFS属于付费产品，免费空间有限，不作上传处理。</li><li><strong>百度云</strong>传送门：<a href="https://pan.baidu.com/s/19mBtD55fTnyYskyjJs3k4w" target="_blank" rel="noopener">【LFS_EBOOKS】</a> <strong>提取码</strong>：hpgp </li></ul><blockquote><ol><li>C#范例开发大全</li><li>C#核心开发技术从入门到精通</li><li>C语言程序设计_现代方法(第2版)</li><li>C语言入门经典(第4版)</li><li>Java核心技术(第10版)卷II_高级特性</li><li>Oracle+Database+11g数据库管理艺术</li><li>PHP 核心技术与最佳实践</li><li>SQL Server 2012编程入门经典(第4版)</li><li>SQL Server企业级平台管理实践</li><li>大话设计模式</li><li>大话数据库</li><li>大数据Spark企业级实战版</li><li>代码大全(第2版)</li><li>代码重构(C# &amp; ASP.NET版)</li><li>锋利的jquery</li><li>软件设计精要与模式</li><li>实现领域驱动设计</li><li>数据结构与算法分析Java语言描述(第3版)</li><li>算法导论(第3版)</li></ol></blockquote><h1 id="GitHub上传100M以上文件解决方案"><a href="#GitHub上传100M以上文件解决方案" class="headerlink" title="GitHub上传100M以上文件解决方案"></a>GitHub上传100M以上文件解决方案</h1><ul><li>工具下载，详见<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">【官网】</a></li></ul><blockquote><p><a href="https://github.com/git-lfs/git-lfs/releases/download/v2.8.0/git-lfs-windows-v2.8.0.exe" target="_blank" rel="noopener">git-lfs-windows</a><br><a href="https://github.com/git-lfs/git-lfs/releases/download/v2.8.0/git-lfs-darwin-amd64-v2.8.0.tar.gz" target="_blank" rel="noopener">git-lfs-mac</a></p></blockquote><ul><li>基本步骤及其命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在项目中安装lfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要push的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs track <span class="string">"程序语言类\C&amp;C++语言\C语言入门经典(第四版).（美）霍顿.pdf"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .gitattributes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git lfs track <span class="string">"程序语言类\C&amp;C++语言\C语言入门经典(第四版).（美）霍顿.pdf"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add <span class="string">"程序语言类\C&amp;C++语言\C语言入门经典(第四版).（美）霍顿.pdf"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"[add] add lfs ebook for C."</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;eBook分享大集合&quot;&gt;&lt;a href=&quot;#eBook分享大集合&quot; class=&quot;headerlink&quot; title=&quot;eBook分享大集合&quot;&gt;&lt;/a&gt;eBook分享大集合&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;主要以IT领域经典书籍收藏，以备不时之需。&lt;/li&gt;
&lt;li&gt;福
      
    
    </summary>
    
      <category term="杂七杂八" scheme="https://zhangbc.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
      <category term="其他" scheme="https://zhangbc.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【经典算法】字符串转换成整数</title>
    <link href="https://zhangbc.github.io/2019/08/28/algorithm_strings_02/"/>
    <id>https://zhangbc.github.io/2019/08/28/algorithm_strings_02/</id>
    <published>2019-08-28T15:59:47.000Z</published>
    <updated>2019-08-28T16:12:53.702Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编程之法：面试和算法心得》的读书笔记。</p></blockquote><h4 id="算法1-3：字符串转换成整数"><a href="#算法1-3：字符串转换成整数" class="headerlink" title="算法1.3：字符串转换成整数"></a>算法1.3：字符串转换成整数</h4><ul><li><p>题目描述</p><p>  输入一个由数字组成的字符串，把它转换成整数并输出。例如:输入字符串”123”，输出整数为123。给定函数原型 <code>int StrToInt(const char *str)</code>，实现字符串转换成整数的功能，不能使用库函数<code>atoi</code>。</p></li><li><p>分析与解法</p></li></ul><blockquote><blockquote><p>思路分析：当扫描字符串的第一个字符“1”时，由于是第一位，故得到数字1；继续向后扫描到第二个字符”2“，之前已经得到数字1，在其后添加一个数字2，得到数字12，相当于前面的数字扩大了10倍然后加上刚扫描到的数字2，即：1×10+2=12。同理，扫描到第三个字符”3“，即可得到最终整数123为所求。故而，其<strong>基本思路</strong>就是：从左至右扫描字符串，把之前得到的数字乘以10，再加上当前字符表示的数字。 但是，在处理过程中，需要考虑以下问题：</p><blockquote><p>1）空指针的输入：输入的是指针，在访问空指针时程序会崩溃，需要提前判空；<br>2）正负符号：整数不仅包括数字，还有可能包括以“+”或“-”开头表示正负整数，遇到负号“-”需要做转换；<br>3）非法字符：输入的字符串中可能有不是数字的字符（如误操作其他字符），需要预先判断，碰到非法字符程序应停止转换；<br>4）整型溢出：输入的数字是以字符串的形式输入，若输入一个很长的字符串可能导致溢出。</p></blockquote></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1.3：字符串转成整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_INT = (<span class="keyword">int</span>)((<span class="keyword">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MIN_INT = -(<span class="keyword">int</span>)((<span class="keyword">unsigned</span>)~<span class="number">0</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="keyword">if</span>(str == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理空格</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isspace</span>(*str))</span><br><span class="line">&#123;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理正负</span></span><br><span class="line"><span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(*str == <span class="string">'+'</span> || *str == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*str == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sign = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(*str))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c = *str - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(sign &gt; <span class="number">0</span> &amp;&amp; (n &gt; MAX_INT/<span class="number">10</span> || (n == MAX_INT/<span class="number">10</span> &amp;&amp; c &gt; MAX_INT%<span class="number">10</span>)))</span><br><span class="line">&#123;</span><br><span class="line">n = MAX_INT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sign &lt; <span class="number">0</span> &amp;&amp; (n &gt; (<span class="keyword">unsigned</span>)MIN_INT/<span class="number">10</span> || (n == (<span class="keyword">unsigned</span>)MIN_INT/<span class="number">10</span> &amp;&amp; c &gt; (<span class="keyword">unsigned</span>)MIN_INT%<span class="number">10</span>)))</span><br><span class="line">&#123;</span><br><span class="line">n = MIN_INT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = n *<span class="number">10</span> + c;</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sign &gt; <span class="number">0</span> ? n:-n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>算法分析：此算法难点在于处理数据溢出，其时间复杂度为 $O(n)$。</p></blockquote></blockquote><ul><li>练习题</li></ul><blockquote><blockquote><p>实现 <code>string</code> 到 <code>double</code> 的转换。</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编程之法：面试和算法心得》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;算法1-3：字符串转换成整数&quot;&gt;&lt;a href=&quot;#算法1-3：字符串转换成整数&quot; class=&quot;headerlink&quot; title=&quot;算法1.3
      
    
    </summary>
    
      <category term="C++" scheme="https://zhangbc.github.io/categories/C/"/>
    
    
      <category term="数据结构与算法" scheme="https://zhangbc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【经典算法】字符串旋转和包含算法</title>
    <link href="https://zhangbc.github.io/2019/08/08/algorithm_strings_01/"/>
    <id>https://zhangbc.github.io/2019/08/08/algorithm_strings_01/</id>
    <published>2019-08-08T15:40:40.000Z</published>
    <updated>2019-08-08T15:48:32.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编程之法：面试和算法心得》的读书笔记。</p></blockquote><p>作为一名大龄青年，为了即将踏入研究生之路，特此需要做一些计算机相关基础知识的积累，以弥补算法知识，谨以此开始自己的算法学习之路。</p><h4 id="算法1-1：旋转字符串"><a href="#算法1-1：旋转字符串" class="headerlink" title="算法1.1：旋转字符串"></a>算法1.1：旋转字符串</h4><ul><li><p>题目描述</p><p>  给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。</p></li><li><p>分析与解法</p></li></ul><blockquote><p>解法一：暴力移位法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1.1：旋转字符串，暴力移位法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftShiftOne</span><span class="params">(<span class="keyword">char</span>* strs, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch = strs[i];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; number; i++)</span><br><span class="line">&#123;</span><br><span class="line">strs[i<span class="number">-1</span>] = strs[i];</span><br><span class="line">&#125;</span><br><span class="line">strs[i<span class="number">-1</span>] = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftRoatateString</span><span class="params">(<span class="keyword">char</span>* strs, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">LeftShiftOne(strs, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> strs[] = <span class="string">"ABCDEFGH"</span>;</span><br><span class="line">LeftRoatateString(strs, <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; strs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>算法分析：针对长度为n的字符串而言，假设需要移动m个字符到字符串的尾部，总共需要移动 <code>m*n</code> 次操作，同时设立一个变量存储第一个字符，故时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$，不合题意。</p></blockquote><p>解法二：三步反转法</p><blockquote><p>思路分析：将一个字符串分成X和Y两部分，在每个部分字符串上定义反转操作，如$X^T$，即把X的所有字符反转（例如X=”abc”，则 $X^T$=”cba”），于是得到：$(X^T Y^T)^T$=$YX$。</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1.1：旋转字符串，三步反转法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseString</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(from &lt; to)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> ch = str[from];</span><br><span class="line">str[from++] = str[to];</span><br><span class="line">str[to--] = ch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LeftReverseString</span><span class="params">(<span class="keyword">char</span>* strs, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m %= n;</span><br><span class="line">ReverseString(strs, <span class="number">0</span>, m<span class="number">-1</span>);</span><br><span class="line">ReverseString(strs, m, n<span class="number">-1</span>);</span><br><span class="line">ReverseString(strs, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> strs[] = <span class="string">"ABCDEFGH"</span>;</span><br><span class="line">LeftReverseString(strs, <span class="number">8</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; strs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>算法分析：针对长度为n的字符串而言，假设需要移动m个字符到字符串的尾部，总共需要移动 <code>2*n</code> 次操作，同时设立一个变量存储第一个字符，故时间复杂度为 $O(n)$，空间复杂度为 $O(1)$，符合题意。</p></blockquote></blockquote><ul><li>练习题（自己动手）</li></ul><blockquote><blockquote><ol><li>链表翻转。例如给出一个链表和一个数k，链表为1—&gt;2—&gt;3—&gt;4—&gt;5—&gt;6，k=2，则翻转后为2—&gt;1—&gt;6—&gt;5—&gt;4—&gt;3；若k=3，翻转后3—&gt;2—&gt;1—&gt;6—&gt;5—&gt;4。</li><li>编写程序在原来字符串中把字符串尾部的m个字符移动到字符串的头部，要求：长度为n的字符串操作时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。例如，源字符串为 “Ilovebaofeng”，m=7时输出为：“baofengIlove”。</li><li>单词翻转。输入一个英文句子，翻转句子中单词的顺序，但是单词内字符的顺序不变，句子中单词以空格符号隔开。为简单起见，标点符号和普通字符一样处理。例如，输入”I am a student.”，输出为 “student. a am I”。</li></ol></blockquote></blockquote><h4 id="算法1-2：字符串包含"><a href="#算法1-2：字符串包含" class="headerlink" title="算法1.2：字符串包含"></a>算法1.2：字符串包含</h4><ul><li><p>题目描述</p><p>  给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何快速地判断字符串B中的所有字符是否都在字符串A里面？<br>为简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数 bool StringContain(string &amp;A, string &amp;B)。<br>示例一：string 1：ABCD，string 2： BAD，答案为true；<br>示例二：string 1：ABCD，string 2： BCE，答案为false；<br>示例三：string 1：ABCD，string 2： AA，答案为true。</p></li><li><p>分析与解法</p></li></ul><blockquote><p>解法一：常规解法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1.2：字符串包含，常规方法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StringContain</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; b.length(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; (j &lt; a.length()) &amp;&amp; (a[j] != b[i]); j++);</span><br><span class="line"><span class="keyword">if</span>(j &gt;= a.length())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> a = <span class="string">"ABCD"</span>;</span><br><span class="line"><span class="built_in">string</span> b = <span class="string">"AA"</span>;</span><br><span class="line"><span class="keyword">bool</span> result = StringContain(a, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>算法分析：这是一种最直观也是最简单的方法思路。此算法需要 $O（n*m）$ 次操作，时间开销较大。</p></blockquote><p>解法二：排序方法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1.2：字符串包含，排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StringContainSort</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sort(a.begin(), a.end());   <span class="comment">// 包含于&lt;algorithm&gt;模块内</span></span><br><span class="line">sort(b.begin(), b.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pa = <span class="number">0</span>, pb = <span class="number">0</span>; pb &lt; b.length(); pb++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((pa &lt; a.length()) &amp;&amp; (a[pa] &lt; b[pb]))</span><br><span class="line">&#123;</span><br><span class="line">pa++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pa &gt;= a.length() || (a[pa] &gt; b[pb]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>算法分析：两个字符串的排序需要（常规情况）$O(m log m)+O(n log n)$ 次操作（快排算法），然后需要线性扫描 $O(m+n)$ 次操作。</p></blockquote><p>解法三： 转换成素数</p><blockquote><p>思路分析：</p><blockquote><p>1）假定有一个仅由字母组成的字符串，按照从小到大的顺序，让每个字母与一个素数唯一对应，即用26个<strong>素数</strong>分别对应于<code>A</code>~<code>Z</code>；<br>2）遍历长字符串。求得每个字符对应素数的乘积；<br>3）遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除；<br>4）输出结果。</p></blockquote></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1.2：字符串包含，转换成素数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StringContainPrime</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">26</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, </span><br><span class="line"><span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">array</span>[a[i] - <span class="string">'A'</span>];</span><br><span class="line"><span class="keyword">if</span>(f % x)</span><br><span class="line">&#123;</span><br><span class="line">f *= x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">array</span>[b[j] - <span class="string">'A'</span>];</span><br><span class="line"><span class="keyword">if</span>(f % x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>算法分析：算法的时间复杂度为 $O(n)$ ，最好的情况为 $O(1)$（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回 <code>false</code>）， <code>n</code> 为长字串的长度，空间复杂度为 $O(1)$。<br><strong>注意</strong>：此方法只有理论意义，因为整数乘积很大会造成溢出风险。</p></blockquote><p>解法四：<code>Hashtable</code>方法</p><blockquote><p>思路分析：先把长字符串 <code>A</code>中的所有字符都放入一个 <code>Hashtable</code> 里，然后轮询短字符串 <code>B</code>，看短字符串 <code>B</code> 的每个字符是否都在 <code>Hashtable</code> 里，如果都存在，说明长字符串 <code>A</code> 包含短字符串 <code>B</code>， 否则，说明不包含。</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法1.2：字符串包含，Hashtable方法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StringContainHash</span><span class="params">(<span class="built_in">string</span> &amp;a, <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i++)</span><br><span class="line">&#123;</span><br><span class="line">hash |= (<span class="number">1</span> &lt;&lt; (a[i] - <span class="string">'A'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.length(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(hash &amp; (<span class="number">1</span> &lt;&lt; (b[j] - <span class="string">'A'</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>算法分析：此方法实质是用一个整数代替了<code>Hashtable</code>，空间复杂度为 $O(1)$，时间复杂度为 $O(n)$。</p></blockquote></blockquote><ul><li>练习题（自己动手）</li></ul><blockquote><blockquote><p>变位词：如果两个字符串的字符一样，但是顺序不一样，被认为是兄弟字符串，比如 <code>bad</code> 和 <code>adb</code> 即为兄弟字符串，现提供一个字符串，如何在字典中迅速找到它的兄弟字符串，请描述数据结构和查询过程。</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编程之法：面试和算法心得》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一名大龄青年，为了即将踏入研究生之路，特此需要做一些计算机相关基础知识的积累，以弥补算法知识，谨以此开始自己的算法学习之路。&lt;/p&gt;
&lt;h4 id=&quot;算
      
    
    </summary>
    
      <category term="C++" scheme="https://zhangbc.github.io/categories/C/"/>
    
    
      <category term="数据结构与算法" scheme="https://zhangbc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Python编码规范】设计模式</title>
    <link href="https://zhangbc.github.io/2019/06/13/python_code91_05/"/>
    <id>https://zhangbc.github.io/2019/06/13/python_code91_05/</id>
    <published>2019-06-13T14:55:38.000Z</published>
    <updated>2019-08-08T15:33:23.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。</p></blockquote><p><strong>温馨提醒</strong>：在阅读本书之前，强烈建议先仔细阅读：<a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener"><strong>PEP</strong>规范</a>，增强代码的可阅读性，配合优雅的<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">pycharm</a>编辑器(开启<code>pep8</code>检查)写出规范代码，是<code>Python</code>入门的第一步。</p><h2 id="建议50：利用模块实现单例模式"><a href="#建议50：利用模块实现单例模式" class="headerlink" title="建议50：利用模块实现单例模式"></a>建议50：利用模块实现单例模式</h2><p>1）所有的变量都会绑定到模块；<br>2）模块只初始化一次；<br>3）<code>import</code>机制是线程安全的。</p><h2 id="建议51-用mixin模式让程序更加灵活"><a href="#建议51-用mixin模式让程序更加灵活" class="headerlink" title="建议51: 用mixin模式让程序更加灵活"></a>建议51: 用mixin模式让程序更加灵活</h2><p><code>模板方法模式</code>：在一个方法中定义一个算法的骨架，并将一些实现步骤延迟到子类中。</p><p><code>Python</code> 中每一个类都有一个<code>__base__</code>属性，是一个元组，用来存放所有的基类，基类在运行中可以动态改变。</p><h2 id="建议52：用发布订阅模式实现松耦合"><a href="#建议52：用发布订阅模式实现松耦合" class="headerlink" title="建议52：用发布订阅模式实现松耦合"></a>建议52：用发布订阅模式实现松耦合</h2><p> 发布订阅模式（publish/subscribe或pub/sub）是一种编程模式，消息的发送者（发布者）不会发送其消息给特定的接收者（订阅者），而是将发布的消息分为不同的类别直接发布，并不关注订阅者是谁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">发布订阅模式实现</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> message</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">route_table = defaultdict(list)</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(topic, callback)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">    :param topic:</span></span><br><span class="line"><span class="string">    :param callback:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">if</span> callback <span class="keyword">in</span> route_table[topic]:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">​</span><br><span class="line">    route_table[topic].append(callback)</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pub</span><span class="params">(topic, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">    :param topic:</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :param kwargs:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> route_table[topic]:</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">    :param name:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Hello, &#123;0&#125;.'</span>.format(name)</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">​</span><br><span class="line">    sub(<span class="string">'greet'</span>, greeting)</span><br><span class="line">    pub(<span class="string">'greet'</span>, <span class="string">'LaiYonghao'</span>)</span><br><span class="line">​</span><br><span class="line">    message.sub(<span class="string">'greet'</span>, greeting)</span><br><span class="line">    message.pub(<span class="string">'greet'</span>, <span class="string">'Welcome to Python'</span>)</span><br></pre></td></tr></table></figure><h2 id="建议53：用状态模式美化代码"><a href="#建议53：用状态模式美化代码" class="headerlink" title="建议53：用状态模式美化代码"></a>建议53：用状态模式美化代码</h2><p><code>状态模式</code>：当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。主要用于控制一个对象状态的条件表达式过于复杂的情况，其可把状态的判断逻辑转移到表示不同状态的一系列类中，进而把复杂的判断逻辑简化。<br>@stateful修饰函数，重载了被修饰类的<strong>getattr</strong>()方法从而使得类的实例方法能调用当前状态类的方法。被@stateful修饰后的类的实例是带有状态的，能够使用curr()查询当前状态，也可以使用switch()进行状态切换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">状态模式实现</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">from</span> state <span class="keyword">import</span> switch, stateful, State, behavior</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="meta">@stateful</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Workday</span><span class="params">(State)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">​</span><br><span class="line">        default = <span class="literal">True</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">        @behavior</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'work hard.'</span></span><br><span class="line">​</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Weekend</span><span class="params">(State)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">​</span><br><span class="line"><span class="meta">        @behavior</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">day</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'play harder.'</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    people = People()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">6</span>:</span><br><span class="line">            switch(people, People.Weekend)</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">            switch(people, People.Workday)</span><br><span class="line">        people.day()</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">​</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在阅读本书之前，强烈建议先仔细阅读：&lt;a href=&quot;https://legacy.py
      
    
    </summary>
    
      <category term="Python" scheme="https://zhangbc.github.io/categories/python/"/>
    
    
      <category term="Python编码规范" scheme="https://zhangbc.github.io/tags/python-coding-convention/"/>
    
  </entry>
  
  <entry>
    <title>【Python编码规范】库</title>
    <link href="https://zhangbc.github.io/2019/05/12/python_code91_04/"/>
    <id>https://zhangbc.github.io/2019/05/12/python_code91_04/</id>
    <published>2019-05-12T15:01:16.000Z</published>
    <updated>2019-05-12T15:21:55.643Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。</p></blockquote><p><strong>温馨提醒</strong>：在阅读本书之前，强烈建议先仔细阅读：<a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener"><strong>PEP</strong>规范</a>，增强代码的可阅读性，配合优雅的<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">pycharm</a>编辑器(开启<code>pep8</code>检查)写出规范代码，是<code>Python</code>入门的第一步。</p><h2 id="建议36：掌握字符串的基本用法"><a href="#建议36：掌握字符串的基本用法" class="headerlink" title="建议36：掌握字符串的基本用法"></a>建议36：掌握字符串的基本用法</h2><p><strong><code>Python</code>小技巧</strong>：<code>Python</code>遇到未闭合的小括号会自动将多行代码拼接为一行和把相邻的两个字符串字面量拼接在一起的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = (<span class="string">'select * '</span></span><br><span class="line"><span class="meta">... </span>      <span class="string">'from table '</span></span><br><span class="line"><span class="meta">... </span>      <span class="string">'whre field="value";'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st</span><br><span class="line"><span class="string">'select * from table whre field="value";'</span></span><br></pre></td></tr></table></figure><ul><li>字符串用法举例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(<span class="string">'hello world'</span>, basestring)  <span class="comment"># basestring是str与unicode的基类</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(<span class="string">'hello world'</span>, unicode)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(<span class="string">'hello world'</span>, str)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(<span class="string">u'hello world'</span>, unicode)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><code>split()</code>的陷阱示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' Hello World'</span>.split(<span class="string">' '</span>)</span><br><span class="line">[<span class="string">''</span>, <span class="string">'Hello'</span>, <span class="string">'World'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' Hello   World'</span>.split()</span><br><span class="line">[<span class="string">'Hello'</span>, <span class="string">'World'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' Hello   World'</span>.split(<span class="string">' '</span>)</span><br><span class="line">[<span class="string">''</span>, <span class="string">'Hello'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'World'</span>]</span><br></pre></td></tr></table></figure><ul><li><code>title()</code>应用示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.capwords(<span class="string">'hello  wOrld'</span>)</span><br><span class="line"><span class="string">'Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.capwords(<span class="string">' hello  wOrld '</span>)</span><br><span class="line"><span class="string">'Hello World'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">' hello  wOrld '</span>.title()</span><br><span class="line"><span class="string">' Hello  World '</span></span><br></pre></td></tr></table></figure><h2 id="建议37：按需选择sort-或者sorted"><a href="#建议37：按需选择sort-或者sorted" class="headerlink" title="建议37：按需选择sort()或者sorted()"></a>建议37：按需选择sort()或者sorted()</h2><p><code>sorted(iterable[, cmp[, key[, reverse]]])</code>：作用于任何可迭代对象，返回一个排序后的列表；</p><p><code>sort(cmp[, key[, reverse]]])</code>：一般作用于列表，直接修改原有列表，返回为<code>None</code>。</p><p>1）<strong>对字典进行排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>phone_book = &#123;<span class="string">'Linda'</span>: <span class="string">'775'</span>, <span class="string">'Bob'</span>: <span class="string">'9349'</span>, <span class="string">'Carol'</span>: <span class="string">'5834'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_pb = sorted(phone_book.iteritems(), key=itemgetter(<span class="number">1</span>))  ​<span class="comment"># 按照字典的value进行排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> phone_book</span><br><span class="line">&#123;<span class="string">'Linda'</span>: <span class="string">'775'</span>, <span class="string">'Bob'</span>: <span class="string">'9349'</span>, <span class="string">'Carol'</span>: <span class="string">'5834'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sorted_pb</span><br><span class="line">[(<span class="string">'Carol'</span>, <span class="string">'5834'</span>), (<span class="string">'Linda'</span>, <span class="string">'775'</span>), (<span class="string">'Bob'</span>, <span class="string">'9349'</span>)]</span><br></pre></td></tr></table></figure><p> 2）<strong>多维<code>list</code>排序</strong><br>​<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>game_result = [[<span class="string">'Linda'</span>, <span class="number">95</span>, <span class="string">'B'</span>], [<span class="string">'Bob'</span>, <span class="number">93</span>, <span class="string">'A'</span>], [<span class="string">'Carol'</span>, <span class="number">69</span>, <span class="string">'D'</span>], [<span class="string">'zhangs'</span>, <span class="number">95</span>, <span class="string">'A'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_res = sorted(game_result, key=itemgetter(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 按照学生成绩排序，成绩相同的按照等级排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> game_result</span><br><span class="line">[[<span class="string">'Linda'</span>, <span class="number">95</span>, <span class="string">'B'</span>], [<span class="string">'Bob'</span>, <span class="number">93</span>, <span class="string">'A'</span>], [<span class="string">'Carol'</span>, <span class="number">69</span>, <span class="string">'D'</span>], [<span class="string">'zhangs'</span>, <span class="number">95</span>, <span class="string">'A'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sorted_res</span><br><span class="line">[[<span class="string">'Carol'</span>, <span class="number">69</span>, <span class="string">'D'</span>], [<span class="string">'Bob'</span>, <span class="number">93</span>, <span class="string">'A'</span>], [<span class="string">'zhangs'</span>, <span class="number">95</span>, <span class="string">'A'</span>], [<span class="string">'Linda'</span>, <span class="number">95</span>, <span class="string">'B'</span>]]</span><br></pre></td></tr></table></figure></p><p>3）<strong>字典中混合<code>list</code>排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list_dict = &#123;</span><br><span class="line"><span class="meta">... </span>    <span class="string">'Li'</span>: [<span class="string">'M'</span>, <span class="number">7</span>],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'Zhang'</span>: [<span class="string">'E'</span>, <span class="number">2</span>],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'Du'</span>: [<span class="string">'P'</span>, <span class="number">3</span>],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'Ma'</span>: [<span class="string">'C'</span>, <span class="number">9</span>],</span><br><span class="line"><span class="meta">... </span>    <span class="string">'Zhe'</span>: [<span class="string">'H'</span>, <span class="number">7</span>]</span><br><span class="line"><span class="meta">... </span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_ld = sorted(list_dict.iteritems(), key=<span class="keyword">lambda</span> (k, v): itemgetter(<span class="number">1</span>)(v))  <span class="comment"># 按照字典的value[m,n]中的n值排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> list_dict</span><br><span class="line">&#123;<span class="string">'Zhe'</span>: [<span class="string">'H'</span>, <span class="number">7</span>], <span class="string">'Zhang'</span>: [<span class="string">'E'</span>, <span class="number">2</span>], <span class="string">'Ma'</span>: [<span class="string">'C'</span>, <span class="number">9</span>], <span class="string">'Du'</span>: [<span class="string">'P'</span>, <span class="number">3</span>], <span class="string">'Li'</span>: [<span class="string">'M'</span>, <span class="number">7</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sorted_ld</span><br><span class="line">[(<span class="string">'Zhang'</span>, [<span class="string">'E'</span>, <span class="number">2</span>]), (<span class="string">'Du'</span>, [<span class="string">'P'</span>, <span class="number">3</span>]), (<span class="string">'Zhe'</span>, [<span class="string">'H'</span>, <span class="number">7</span>]), (<span class="string">'Li'</span>, [<span class="string">'M'</span>, <span class="number">7</span>]), (<span class="string">'Ma'</span>, [<span class="string">'C'</span>, <span class="number">9</span>])]</span><br></pre></td></tr></table></figure><p>4）<strong><code>list</code>中混合字典排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>game_result = [</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'Bob'</span>, <span class="string">'wins'</span>: <span class="number">10</span>, <span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'rating'</span>: <span class="number">75</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'David'</span>, <span class="string">'wins'</span>: <span class="number">3</span>, <span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'rating'</span>: <span class="number">57</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'Carol'</span>, <span class="string">'wins'</span>: <span class="number">4</span>, <span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'rating'</span>: <span class="number">57</span>&#125;,</span><br><span class="line"><span class="meta">... </span>    &#123;<span class="string">'name'</span>: <span class="string">'Patty'</span>, <span class="string">'wins'</span>: <span class="number">9</span>, <span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'rating'</span>: <span class="number">71.48</span>&#125;</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted_res = sorted(game_result, key=itemgetter(<span class="string">'rating'</span>, <span class="string">'name'</span>))   <span class="comment"># 按照name和rating排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> game_result</span><br><span class="line">[&#123;<span class="string">'wins'</span>: <span class="number">10</span>, <span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>, <span class="string">'rating'</span>: <span class="number">75</span>&#125;, &#123;<span class="string">'wins'</span>: <span class="number">3</span>, <span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'David'</span>, <span class="string">'rating'</span>: <span class="number">57</span>&#125;, &#123;<span class="string">'wins'</span>: <span class="number">4</span>, <span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'Carol'</span>, <span class="string">'rating'</span>: <span class="number">57</span>&#125;, &#123;<span class="string">'wins'</span>: <span class="number">9</span>, <span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Patty'</span>, <span class="string">'rating'</span>: <span class="number">71.48</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sorted_res</span><br><span class="line">[&#123;<span class="string">'wins'</span>: <span class="number">4</span>, <span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'Carol'</span>, <span class="string">'rating'</span>: <span class="number">57</span>&#125;, &#123;<span class="string">'wins'</span>: <span class="number">3</span>, <span class="string">'losses'</span>: <span class="number">5</span>, <span class="string">'name'</span>: <span class="string">'David'</span>, <span class="string">'rating'</span>: <span class="number">57</span>&#125;, &#123;<span class="string">'wins'</span>: <span class="number">9</span>, <span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Patty'</span>, <span class="string">'rating'</span>: <span class="number">71.48</span>&#125;, &#123;<span class="string">'wins'</span>: <span class="number">10</span>, <span class="string">'losses'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>, <span class="string">'rating'</span>: <span class="number">75</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="建议38：使用copy模块深拷贝对象"><a href="#建议38：使用copy模块深拷贝对象" class="headerlink" title="建议38：使用copy模块深拷贝对象"></a>建议38：使用copy模块深拷贝对象</h2><ul><li><code>浅拷贝(shallow copy)</code>：构造一个新的复合对象并将从原对象中发现的引用插入该对象中。实现方式有：工厂函数，切片操作，<code>copy</code>模块中<code>copy</code>操作等；</li><li><p><code>深拷贝(deep copy)</code>：构造一个新的复合对象，但是遇到引用会继续递归拷贝其所指向的具体内容，也就是说它会针对引用所指向的对象继续进行拷贝，因此产生的对象不受其他引用对象操作的影响。实现方式有<code>copy</code>模块中的<code>deepcopy()</code>操作。</p></li><li><p>实例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, size, price)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.size = size</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pizza_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name, self.size, self.price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_pizza_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Pizza name: &#123;0&#125;, size: &#123;1&#125;, price: &#123;2&#125;"</span>.format(self.name, self.size, self.price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_size</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param size:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_price</span><span class="params">(self, price)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param price:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.customer_name = name</span><br><span class="line">        self.pizza_list = list()</span><br><span class="line">        self.pizza_list.append(Pizza(<span class="string">"Mushroom"</span>, <span class="number">12</span>, <span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order_more</span><span class="params">(self, pizza)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param pizza:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        self.pizza_list.append(pizza)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        self.customer_name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_oder_detail</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Customer name: &#123;0&#125;"</span>.format(self.customer_name)</span><br><span class="line">        <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(self.pizza_list):</span><br><span class="line">            item.show_pizza_info()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pizza</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param number:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.pizza_list[number]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">customer_one</span><span class="params">()</span>:</span></span><br><span class="line">    c1 = Order(<span class="string">"zhang San"</span>)</span><br><span class="line">    c1.order_more(Pizza(<span class="string">"seafood"</span>, <span class="number">9</span>, <span class="number">40</span>))</span><br><span class="line">    c1.order_more(Pizza(<span class="string">"fruit"</span>, <span class="number">12</span>, <span class="number">35</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"==============Customer one order info================="</span></span><br><span class="line">    c1.get_oder_detail()</span><br><span class="line"></span><br><span class="line">    c2 = copy(c1)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"==============Customer two order info(copy)================="</span></span><br><span class="line">    c2.change_name(<span class="string">"Li Si"</span>)</span><br><span class="line">    c2.get_pizza(<span class="number">2</span>).change_size(<span class="number">9</span>)</span><br><span class="line">    c2.get_pizza(<span class="number">2</span>).change_price(<span class="number">30</span>)</span><br><span class="line">    c2.get_oder_detail()</span><br><span class="line"></span><br><span class="line">    c3 = deepcopy(c1)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"==============Customer three order info(deepcopy)================="</span></span><br><span class="line">    c3.change_name(<span class="string">"Li Si"</span>)</span><br><span class="line">    c3.get_pizza(<span class="number">1</span>).change_size(<span class="number">10</span>)</span><br><span class="line">    c3.get_pizza(<span class="number">1</span>).change_price(<span class="number">50</span>)</span><br><span class="line">    c3.get_oder_detail()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"==============Customer one order info================="</span></span><br><span class="line">    c1.get_oder_detail()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    customer_one()</span><br></pre></td></tr></table></figure><ul><li>运行结果如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">==============Customer one order info=================</span><br><span class="line">Customer name: zhang San</span><br><span class="line">Pizza name: Mushroom, size: <span class="number">12</span>, price: <span class="number">30</span></span><br><span class="line">Pizza name: seafood, size: <span class="number">9</span>, price: <span class="number">40</span></span><br><span class="line">Pizza name: fruit, size: <span class="number">12</span>, price: <span class="number">35</span></span><br><span class="line">==============Customer two order info(copy)=================</span><br><span class="line">Customer name: Li Si</span><br><span class="line">Pizza name: Mushroom, size: <span class="number">12</span>, price: <span class="number">30</span></span><br><span class="line">Pizza name: seafood, size: <span class="number">9</span>, price: <span class="number">40</span></span><br><span class="line">Pizza name: fruit, size: <span class="number">9</span>, price: <span class="number">30</span></span><br><span class="line">==============Customer three order info(deepcopy)=================</span><br><span class="line">Customer name: Li Si</span><br><span class="line">Pizza name: Mushroom, size: <span class="number">12</span>, price: <span class="number">30</span></span><br><span class="line">Pizza name: seafood, size: <span class="number">10</span>, price: <span class="number">50</span></span><br><span class="line">Pizza name: fruit, size: <span class="number">9</span>, price: <span class="number">30</span></span><br><span class="line">==============Customer one order info=================</span><br><span class="line">Customer name: zhang San</span><br><span class="line">Pizza name: Mushroom, size: <span class="number">12</span>, price: <span class="number">30</span></span><br><span class="line">Pizza name: seafood, size: <span class="number">9</span>, price: <span class="number">40</span></span><br><span class="line">Pizza name: fruit, size: <span class="number">9</span>, price: <span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="建议39：使用Counter进行计数统计"><a href="#建议39：使用Counter进行计数统计" class="headerlink" title="建议39：使用Counter进行计数统计"></a>建议39：使用Counter进行计数统计</h2><ul><li>使用<code>dict</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_data = [<span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'2'</span>, <span class="string">'b'</span>, <span class="number">7</span>, <span class="string">'a'</span>, <span class="number">5</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_frq = dict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(some_data):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> item <span class="keyword">in</span> count_frq:</span><br><span class="line"><span class="meta">... </span>        count_frq[item] += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        count_frq[item] = <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> count_frq</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">5</span>: <span class="number">2</span>, <span class="number">7</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>defaultdict</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_data = [<span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'2'</span>, <span class="string">'b'</span>, <span class="number">7</span>, <span class="string">'a'</span>, <span class="number">5</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_frq = defaultdict(int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(some_data):</span><br><span class="line"><span class="meta">... </span>    count_frq[item] += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> count_frq</span><br><span class="line">defaultdict(&lt;type <span class="string">'int'</span>&gt;, &#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">5</span>: <span class="number">2</span>, <span class="number">7</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用<code>set</code>与<code>list</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_data = [<span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'2'</span>, <span class="string">'b'</span>, <span class="number">7</span>, <span class="string">'a'</span>, <span class="number">5</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_set = set(some_data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>count_list = list()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(some_data):</span><br><span class="line"><span class="meta">... </span>    count_list.append((item, some_data.count(item)))</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> count_list</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="string">'2'</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">2</span>), (<span class="string">'2'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">1</span>), (<span class="number">7</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">3</span>), (<span class="number">5</span>, <span class="number">2</span>), (<span class="string">'d'</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">3</span>), (<span class="string">'z'</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><ul><li>使用更为优雅的<code>Pythonic</code>方法—<code>collections.Counter</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_data = [<span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'2'</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">'2'</span>, <span class="string">'b'</span>, <span class="number">7</span>, <span class="string">'a'</span>, <span class="number">5</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Counter(some_data)</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="number">5</span>: <span class="number">2</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">7</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Counter(<span class="string">'success'</span>)</span><br><span class="line">Counter(&#123;<span class="string">'s'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">2</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'u'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Counter(s=<span class="number">3</span>, c=<span class="number">2</span>, e=<span class="number">1</span>, u=<span class="number">1</span>)</span><br><span class="line">Counter(&#123;<span class="string">'s'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">2</span>, <span class="string">'u'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Counter(&#123;<span class="string">'s'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">2</span>, <span class="string">'u'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">Counter(&#123;<span class="string">'s'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">2</span>, <span class="string">'u'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> list(Counter(some_data).elements())</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="number">2</span>, <span class="string">'b'</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="string">'2'</span>, <span class="string">'2'</span>, <span class="string">'z'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Counter(some_data).most_common(<span class="number">3</span>) <span class="comment"># 出现频次最高的前三个字符</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">3</span>), (<span class="number">5</span>, <span class="number">2</span>), (<span class="string">'2'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h2 id="建议40：深入理解ConfigParser"><a href="#建议40：深入理解ConfigParser" class="headerlink" title="建议40：深入理解ConfigParser"></a>建议40：深入理解ConfigParser</h2><ul><li>实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ConfigParser</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conf = ConfigParser.ConfigParser()</span><br><span class="line">conf.read(<span class="string">'config.ini'</span>)</span><br><span class="line"><span class="keyword">print</span> conf.get(<span class="string">'default'</span>, <span class="string">'host'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conf = ConfigParser.ConfigParser()</span><br><span class="line">conf.read(<span class="string">'config.ini'</span>)</span><br><span class="line"><span class="keyword">print</span> conf.get(<span class="string">'online'</span>, <span class="string">'conn_str'</span>)   <span class="comment"># 仅在default下</span></span><br><span class="line"></span><br><span class="line">​</span><br><span class="line">====================config.ini=========================</span><br><span class="line"></span><br><span class="line">[default]</span><br><span class="line">conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)s</span><br><span class="line">dbn = msyql</span><br><span class="line">host = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">user = root</span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line">pw = xxxxxx</span><br><span class="line">db = test</span><br><span class="line"></span><br><span class="line">[online]</span><br><span class="line">conn_str = %(dbn)s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)s</span><br><span class="line">dbn = msyql</span><br><span class="line">host = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">user = root</span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line">pw = xxxxxx</span><br><span class="line">db = test</span><br></pre></td></tr></table></figure><h2 id="建议41：使用argparese处理命令行参数"><a href="#建议41：使用argparese处理命令行参数" class="headerlink" title="建议41：使用argparese处理命令行参数"></a>建议41：使用argparese处理命令行参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'-v'</span>, dest=<span class="string">'verbose'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> args</span><br></pre></td></tr></table></figure><h2 id="建议42：使用pandas处理大型csv文件"><a href="#建议42：使用pandas处理大型csv文件" class="headerlink" title="建议42：使用pandas处理大型csv文件"></a>建议42：使用pandas处理大型csv文件</h2><p><code>csv</code>作为一种逗号分隔型值的纯文本格式文件，常见于数据库数据的导入导出、数据分析中记录的存储等。</p><p>以下列举几个与<code>csv</code>处理相关的<code>API</code>：</p><ul><li><code>csv.reader(csvfile[, dialect=&#39;excel&#39;][, fmtparam])</code>：用于<code>CSV</code>文件的读取，返回一个<code>reader</code>对象用于在<code>CSV</code>文件中进行行迭代；</li><li><code>csv.writer(csvfile, dialect=&#39;excel&#39;, **fmtparams)</code>：用于写入<code>CSV</code>文件；</li><li><code>csv.DictReader(csvfile, fieldnames=None, restKey=&#39;&#39;, restval=&#39;&#39;, dialect=&#39;excel&#39;, *args, **kwds)</code>：用于支持字典的读取；</li><li><p><code>csv.DictReader(csvfile, fieldnames=None, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, *args, **kwds)</code>：用于支持字典的写入。</p></li><li><p>实例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入csv</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'csv_test.csv'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    fields = [<span class="string">'Tran_date'</span>, <span class="string">'Product'</span>, <span class="string">'Price'</span>, <span class="string">'PaymentType'</span>]</span><br><span class="line">    writer = csv.DictWriter(fp, fieldnames=fields)</span><br><span class="line">    writer.writerow(dict(zip(fields, fields)))</span><br><span class="line">    data = &#123;<span class="string">'Tran_date'</span>: <span class="string">'1/2/09 6:17'</span>,</span><br><span class="line">            <span class="string">'Product'</span>: <span class="string">'Nick'</span>,</span><br><span class="line">            <span class="string">'Price'</span>: <span class="string">'1200'</span>,</span><br><span class="line">            <span class="string">'PaymentType'</span>: <span class="string">'Mastercard'</span>&#125;</span><br><span class="line">    writer.writerow(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取csv</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'csv_test.csv'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> csv.DictReader(fp):</span><br><span class="line">        <span class="keyword">print</span> item</span><br></pre></td></tr></table></figure><p><code>csv</code>使用非常简单，基本可以满足大部分需求，但是对于上百<code>MB</code>或<code>G</code>级别以上的文件处理无能为力。这种情况下，可以考虑使用<code>pandas</code>模块，它支持以下两种数据结构。</p><ul><li><code>Series</code>：是一种类似数组的带索引的一维数据结构，支持的类型与<code>NumPy</code>兼容。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Series([<span class="number">1</span>, <span class="string">'a'</span>, (<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj</span><br><span class="line">a         <span class="number">1</span></span><br><span class="line">b         a</span><br><span class="line">c    (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">d         <span class="number">3</span></span><br><span class="line">dtype: object</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj_dic = Series(&#123;<span class="string">'Book'</span>: <span class="string">'Python'</span>, <span class="string">'Author'</span>: <span class="string">'Dan'</span>, <span class="string">'ISBN'</span>: <span class="string">'011334'</span>, <span class="string">'Price'</span>: <span class="number">25</span>&#125;, index=[<span class="string">'book'</span>, <span class="string">'Author'</span>, <span class="string">'ISBN'</span>, <span class="string">'Price'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj_dic</span><br><span class="line">book         NaN  <span class="comment"># 匹配失败，导致数据丢失</span></span><br><span class="line">Author       Dan</span><br><span class="line">ISBN      <span class="number">011334</span></span><br><span class="line">Price         <span class="number">25</span></span><br><span class="line">dtype: object</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj_dic.isnull()</span><br><span class="line">book       <span class="literal">True</span></span><br><span class="line">Author    <span class="literal">False</span></span><br><span class="line">ISBN      <span class="literal">False</span></span><br><span class="line">Price     <span class="literal">False</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure><ul><li><code>DataFrame</code>：类似于电子表格，其数据为排好序的数据列的集合，每一列都可以是不同的数据类型，类似一个二维数组，支持行和列的索引。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;<span class="string">'OrderDate'</span>: [<span class="string">'1-6-10'</span>, <span class="string">'1-23-10'</span>, <span class="string">'2-9-10'</span>, <span class="string">'2-26-10'</span>, <span class="string">'3-15-10'</span>],</span><br><span class="line"><span class="meta">... </span>        <span class="string">'Region'</span>: [<span class="string">'East'</span>, <span class="string">'Central'</span>, <span class="string">'Central'</span>, <span class="string">'West'</span>, <span class="string">'East'</span>],</span><br><span class="line"><span class="meta">... </span>        <span class="string">'Rep'</span>: [<span class="string">'Jones'</span>, <span class="string">'Kivell'</span>, <span class="string">'Jardine'</span>, <span class="string">'Gill'</span>, <span class="string">'Sorvino'</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DataFrame(data, columns=[<span class="string">'OrderDate'</span>, <span class="string">'Region'</span>, <span class="string">'Rep'</span>])</span><br><span class="line">  OrderDate   Region      Rep</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span><span class="number">-6</span><span class="number">-10</span>     East    Jones</span><br><span class="line"><span class="number">1</span>   <span class="number">1</span><span class="number">-23</span><span class="number">-10</span>  Central   Kivell</span><br><span class="line"><span class="number">2</span>    <span class="number">2</span><span class="number">-9</span><span class="number">-10</span>  Central  Jardine</span><br><span class="line"><span class="number">3</span>   <span class="number">2</span><span class="number">-26</span><span class="number">-10</span>     West     Gill</span><br><span class="line"><span class="number">4</span>   <span class="number">3</span><span class="number">-15</span><span class="number">-10</span>     East  Sorvino</span><br></pre></td></tr></table></figure><p><code>pandas</code>中处理<code>CSV</code>文件的函数主要为<code>read_csv()</code>和<code>to_csv()</code>。</p><ul><li>指定读取部分列和文件的行数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.read_csv(<span class="string">'/home/projects/pythoner/quality_code/csv_test.csv'</span>, nrows=<span class="number">5</span>, usecols=[<span class="string">'Tran_date'</span>, <span class="string">'Product'</span>, <span class="string">'Price'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">     Tran_date Product  Price</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span></span><br></pre></td></tr></table></figure><ul><li>设置<code>CSV</code>文件与<code>excel</code>兼容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> csv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dia = csv.excel()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dia.delimiter = <span class="string">","</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pd.read_csv(<span class="string">'/home/projects/pythoner/quality_code/csv_test.csv'</span>, dialect=dia, error_bad_lines=<span class="literal">False</span>)</span><br><span class="line">      Tran_date Product  Price PaymentType</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">5</span>   <span class="number">6</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">6</span>   <span class="number">7</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">7</span>   <span class="number">8</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">8</span>   <span class="number">9</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">9</span>  <span class="number">10</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br></pre></td></tr></table></figure><ul><li>对文件进行分块处理并返回一个可迭代的对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader = pd.read_table(<span class="string">'/home/projects/pythoner/quality_code/csv_test.csv'</span>, chunksize=<span class="number">5</span>, iterator=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(reader).next()</span><br><span class="line">  Tran_date,Product,Price,PaymentType</span><br><span class="line"><span class="number">0</span>    <span class="number">1</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">1</span>    <span class="number">2</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">2</span>    <span class="number">3</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">3</span>    <span class="number">4</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">4</span>    <span class="number">5</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(reader).next()</span><br><span class="line">  Tran_date,Product,Price,PaymentType</span><br><span class="line"><span class="number">5</span>    <span class="number">6</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">6</span>    <span class="number">7</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">7</span>    <span class="number">8</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">8</span>    <span class="number">9</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br><span class="line"><span class="number">9</span>   <span class="number">10</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>,Nick,<span class="number">1200</span>,Mastercard</span><br></pre></td></tr></table></figure><ul><li>当文件格式相似时，支持多个文件合并处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_list = [<span class="string">'/home/projects/pythoner/quality_code/csv_test1.csv'</span>, <span class="string">'/home/projects/pythoner/quality_code/csv_test2.csv'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dfs = [pd.read_csv(f) <span class="keyword">for</span> f <span class="keyword">in</span> file_list]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>total_df = pd.concat(dfs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>total_df</span><br><span class="line">      Tran_date Product  Price PaymentType</span><br><span class="line"><span class="number">0</span>   <span class="number">1</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">0</span>   <span class="number">6</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">1</span>   <span class="number">7</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">3</span>   <span class="number">9</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br><span class="line"><span class="number">4</span>  <span class="number">10</span>/<span class="number">2</span>/<span class="number">09</span> <span class="number">6</span>:<span class="number">17</span>    Nick   <span class="number">1200</span>  Mastercard</span><br></pre></td></tr></table></figure><h2 id="建议43：一般情况使用ElementTree解析XML"><a href="#建议43：一般情况使用ElementTree解析XML" class="headerlink" title="建议43：一般情况使用ElementTree解析XML"></a>建议43：一般情况使用ElementTree解析XML</h2><p><code>ElementTree</code>解析<code>XML</code>具有以下特性：</p><ul><li>使用简单，将整个<code>XML</code>文件以树的形式展示，每一个元素的属性以字典的形式表示，非常方便处理；</li><li>内存上消耗明显低于<code>DOM</code>解析；</li><li>支持<code>XPath</code>查询，非常方便获取任意结点的值。</li></ul><h2 id="建议44：理解模块pickle优劣"><a href="#建议44：理解模块pickle优劣" class="headerlink" title="建议44：理解模块pickle优劣"></a>建议44：理解模块pickle优劣</h2><p>1）<code>pickle.dump(obj,file[,protocol])</code>：序列化数据到一个文件描述符。 其中：<code>protocol</code>为序列化使用的协议版本，0表示<code>ASCII</code>协议，为默认值；1表示老式的二进制协议；2表示2.3版本引入的新二进制协议。</p><p>2）<code>pickle.load()</code>：表示把文件中的对象恢复为原来的对象，这个过程也被称为<code>反序列化</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">my_data = &#123;<span class="string">"name"</span>: <span class="string">"Python"</span>, <span class="string">"type"</span>: <span class="string">"language"</span>, <span class="string">"version"</span>: <span class="string">"2.7.6"</span>&#125;</span><br><span class="line">fp = open(<span class="string">'pickle.dat'</span>, <span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(my_data, fp)</span><br><span class="line">fp.close()</span><br><span class="line">​</span><br><span class="line">fp = open(<span class="string">'pickle.dat'</span>, <span class="string">'rb'</span>)</span><br><span class="line">out = pickle.load(fp)</span><br><span class="line"><span class="keyword">print</span> out</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure><ul><li><code>pickle</code>的优点：</li></ul><blockquote><p>1）接口简单，容易使用；<br>2）<code>pickle</code>的存储格式具有通用性，能够被不同平台的<code>Python</code>解析器共享；<br>3）支持的数据类型广泛；<br>4）<code>pickle</code>模块是可扩展的；<br>5）能够自动维护对象间的引用。</p></blockquote><ul><li><code>pickle</code>的缺点：</li></ul><blockquote><p>1）<code>pickle</code>不能保证操作的原子性；<br>2）<code>pickle</code>存在安全性问题；<br>3）<code>pickle</code>协议是<code>Python</code>特定的，不同语言之间的兼容性难以保证。</p></blockquote><h2 id="建议45：序列化的另一个不错的选择—JSON"><a href="#建议45：序列化的另一个不错的选择—JSON" class="headerlink" title="建议45：序列化的另一个不错的选择—JSON"></a>建议45：序列化的另一个不错的选择—JSON</h2><p><code>JSON</code>具有以下优势：</p><ul><li>使用简单，支持多种数据类型；仅存在两大数据结构：名称/值对的集合（对象，记录，结构，字典，散列表，键列表，关联数组等）；值的有序列表（数组，向量，列表，序列等）。</li><li>存储格式可读性好，容易修改；</li><li><code>json</code>支持跨平台跨语言操作，能够轻易被其他语言解析，存储格式较紧凑，所占空间较小；</li><li>具有较强的扩展性；</li><li><code>json</code>在序列化<code>datetime</code>时会抛出<code>TypeError</code>异常，需要对<code>json</code>本身的<code>JSONEncoder</code>进行扩展。</li></ul><h2 id="建议46：使用traceback获取栈信息"><a href="#建议46：使用traceback获取栈信息" class="headerlink" title="建议46：使用traceback获取栈信息"></a>建议46：使用traceback获取栈信息</h2><ul><li>实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> trackback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    g_list[<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">return</span> g()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> h()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">del</span> g_list[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> i()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">i</span><span class="params">()</span>:</span></span><br><span class="line">    g_list.append(<span class="string">'i'</span>)</span><br><span class="line">    <span class="keyword">print</span> g_list[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f()</span><br><span class="line">    <span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Error: &#123;0&#125;'</span>.format(e)</span><br><span class="line">        traceback.print_exc()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Error: list index out of range</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/configure_parser.py"</span>, line <span class="number">33</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    f()</span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/configure_parser.py"</span>, line <span class="number">13</span>, <span class="keyword">in</span> f</span><br><span class="line">    <span class="keyword">return</span> g()</span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/configure_parser.py"</span>, line <span class="number">17</span>, <span class="keyword">in</span> g</span><br><span class="line">    <span class="keyword">return</span> h()</span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/configure_parser.py"</span>, line <span class="number">22</span>, <span class="keyword">in</span> h</span><br><span class="line">    <span class="keyword">return</span> i()</span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/configure_parser.py"</span>, line <span class="number">27</span>, <span class="keyword">in</span> i</span><br><span class="line">    <span class="keyword">print</span> g_list[<span class="number">7</span>]</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure><h2 id="建议47：使用logging记录日志信息"><a href="#建议47：使用logging记录日志信息" class="headerlink" title="建议47：使用logging记录日志信息"></a>建议47：使用logging记录日志信息</h2><p>1，<strong>日志级别</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">Level</th><th style="text-align:left">使用情形</th></tr></thead><tbody><tr><td style="text-align:left">DEBUG</td><td style="text-align:left">详细的信息，在追踪问题时使用</td></tr><tr><td style="text-align:left">INFO</td><td style="text-align:left">正常的信息</td></tr><tr><td style="text-align:left">WARNING</td><td style="text-align:left">一些不可预见的问题发生，或者将要发生，如磁盘空间低等，但不影响程序的运行</td></tr><tr><td style="text-align:left">ERROR</td><td style="text-align:left">由于某些严重的问题，程序中的一些功能受到影响</td></tr><tr><td style="text-align:left">CRITICAL</td><td style="text-align:left">严重的错误，或者程序本身不能继续运行</td></tr></tbody></table></div><p>2， <strong><code>logging lib</code>的四个主要对象</strong></p><ul><li><strong><code>logger</code></strong>：程序信息输出的接口，分散在不同的代码中，使得程序可以在运行时记录相应的信息，并根据设置的日志级别或者<code>filter</code>来决定哪些信息需要输出，并将这些信息分发到其关联的<code>handler</code>。</li><li><strong><code>Handler</code></strong>：用来处理信息的输出，可以将信息输出到控制台、文件或者网络。</li><li><strong><code>Formatter</code></strong>：决定<code>log</code>信息的格式。</li><li><strong><code>Filter</code></strong>：决定哪些信息需要输出，可以被<code>handler</code>和<code>logger</code>使用，支持层次关系。</li></ul><p><code>logging.basicConfig([**kwargs])</code> 提供对日志系统的基本配置，默认使用<code>StreamHandler</code>和<code>Formatter</code>并添加到<code>root logger</code>。字典参数列表如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">格式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">filename</td><td style="text-align:left">指定FileHandler的文件名，而不是默认的StreamHandler</td></tr><tr><td style="text-align:left">filemode</td><td style="text-align:left">打开文件的模式，默认为‘a’</td></tr><tr><td style="text-align:left">format</td><td style="text-align:left">输出格式字符串</td></tr><tr><td style="text-align:left">datefmt</td><td style="text-align:left">日期格式</td></tr><tr><td style="text-align:left">level</td><td style="text-align:left">设置root logger的日志级别</td></tr><tr><td style="text-align:left">stream</td><td style="text-align:left">指定StreamHandler，若与filename冲突，忽略stream</td></tr></tbody></table></div><ul><li>实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_logger</span><span class="params">(file_name, level=logging.INFO)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    设置日志文件输出</span></span><br><span class="line"><span class="string">    :param file_name: 文件名称</span></span><br><span class="line"><span class="string">    :param level: 日志严重级别 ==&gt; CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(level)</span><br><span class="line">    file_handler = logging.FileHandler(file_name, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">    file_handler.setLevel(level)</span><br><span class="line">    formatter = logging.Formatter(<span class="string">"%(asctime)s %(name)s %(levelname)s [line %(lineno)s]: %(message)s"</span>)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(file_handler)</span><br></pre></td></tr></table></figure><p>3，<strong>使用建议</strong></p><blockquote><p>1）尽量为<code>logging</code>取一个名字而不是采用默认，<code>eg</code>：<code>logger=logging.getLogger(__name__)；</code><br>2）为了方便找出问题，<code>logging</code>的名字建议以模块或者<code>class</code>命名；<br>3）<code>logging</code>只是线程安全的，不支持多进程写入同一个日志文件。</p></blockquote><h2 id="建议48：使用threading模块编写多线程程序"><a href="#建议48：使用threading模块编写多线程程序" class="headerlink" title="建议48：使用threading模块编写多线程程序"></a>建议48：使用threading模块编写多线程程序</h2><ul><li><code>Python</code>多线程支持两种方式创建：</li></ul><blockquote><p>1）通过继承<code>Thread</code>类，重写其<code>run()</code>方法(不是<code>start()</code>方法)；不支持守护线程；<br>2）创建<code>threading.Thread</code>对象,在它的初始化函数（<code>__init__()</code>）中将可调用对象作为参数传入。</p></blockquote><h2 id="建议49：使用Queue使多线程编程更加安全"><a href="#建议49：使用Queue使多线程编程更加安全" class="headerlink" title="建议49：使用Queue使多线程编程更加安全"></a>建议49：使用Queue使多线程编程更加安全</h2><p><code>Python</code>中的<code>Queue</code>模块提供了以下队列：</p><ul><li><strong><code>Queue.Queue(maxsize)</code></strong>：先进先出，<code>maxsize</code>为队列大小，其值为非正数时为无限循环队列；</li><li><strong><code>Queue.LifoQueue(maxsize)</code></strong>：后进先出，相当于栈；</li><li><p><strong><code>Queue.PriorityQueue(maxsize)</code></strong>：优先级队列。</p></li><li><p>生产-消费者模式实现<code>demo</code>：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">WRITE_LOCK = threading.Lock()</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生产-消费者模式（生产者）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue, condition, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        :param queue:</span></span><br><span class="line"><span class="string">        :param condition:</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">​</span><br><span class="line">        super(Producer, self).__init__()</span><br><span class="line">        self.queue = queue</span><br><span class="line">        self.name = name</span><br><span class="line">        self.condition = condition</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Producer &#123;0&#125; started."</span>.format(self.name)</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">global</span> WRITE_LOCK</span><br><span class="line">            self.condition.acquire()  <span class="comment"># 获取锁对象</span></span><br><span class="line">            <span class="keyword">if</span> self.queue.full():</span><br><span class="line">                <span class="keyword">with</span> WRITE_LOCK:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'Queue is full, producer wait!'</span></span><br><span class="line">                self.condition.wait()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                <span class="keyword">with</span> WRITE_LOCK:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"&#123;name&#125; put value: &#123;value&#125; into queue."</span>\</span><br><span class="line">                        .format(name=self.name, value=value)</span><br><span class="line">                    self.queue.put(<span class="string">"&#123;0&#125;: &#123;1&#125;"</span>.format(self.name, value))</span><br><span class="line">                    self.condition.notify()</span><br><span class="line">            self.condition.release()</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生产-消费者模式（消费者）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue, condition, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        :param queue:</span></span><br><span class="line"><span class="string">        :param condition:</span></span><br><span class="line"><span class="string">        :param name:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">​</span><br><span class="line">        super(Consumer, self).__init__()</span><br><span class="line">        self.queue = queue</span><br><span class="line">        self.name = name</span><br><span class="line">        self.condition = condition</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Consumer &#123;0&#125; started."</span>.format(self.name)</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">​</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">global</span> WRITE_LOCK</span><br><span class="line">            self.condition.acquire()  <span class="comment"># 获取锁对象</span></span><br><span class="line">            <span class="keyword">if</span> self.queue.empty():</span><br><span class="line">                <span class="keyword">with</span> WRITE_LOCK:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">'Queue is empty, consumer wait!'</span></span><br><span class="line">                self.condition.wait()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                value = self.queue.get()</span><br><span class="line">                <span class="keyword">with</span> WRITE_LOCK:</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"&#123;name&#125; get value: &#123;value&#125; from queue."</span>\</span><br><span class="line">                        .format(name=self.name, value=value)</span><br><span class="line">                    self.condition.notify()</span><br><span class="line">            self.condition.release()</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">​</span><br><span class="line">    qe = Queue.Queue(<span class="number">10</span>)</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    producer_1 = Producer(qe, con, <span class="string">"P1"</span>)</span><br><span class="line">    producer_1.start()</span><br><span class="line">    <span class="comment"># producer_2 = Producer(qe, con, "P2")</span></span><br><span class="line">    <span class="comment"># producer_2.start()</span></span><br><span class="line">​</span><br><span class="line">    consumer_1 = Consumer(qe, con, <span class="string">"C1"</span>)</span><br><span class="line">    consumer_1.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在阅读本书之前，强烈建议先仔细阅读：&lt;a href=&quot;https://legacy.py
      
    
    </summary>
    
      <category term="Python" scheme="https://zhangbc.github.io/categories/python/"/>
    
    
      <category term="Python编码规范" scheme="https://zhangbc.github.io/tags/python-coding-convention/"/>
    
  </entry>
  
  <entry>
    <title>【Python爬虫实例】Python解决521反爬方案</title>
    <link href="https://zhangbc.github.io/2019/05/05/python_anti_spider_521/"/>
    <id>https://zhangbc.github.io/2019/05/05/python_anti_spider_521/</id>
    <published>2019-05-05T15:49:14.000Z</published>
    <updated>2019-05-05T16:09:48.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考文献：<a href="https://github.com/xiantang/Spider/blob/master/Anti_Anti_Spider_521/pass_521.py" target="_blank" rel="noopener">https://github.com/xiantang/Spider/blob/master/Anti_Anti_Spider_521/pass_521.py</a></p></blockquote><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p><code>Python</code>在爬虫方面的优势，想必业界无人不知，随着互联网信息时代的的发展，<code>Python</code>爬虫日益突出的地位越来越明显，爬虫与反爬虫愈演愈烈。下面分析一例关于返回<code>HTTP</code>状态码为<code>521</code>的案例。</p><h2 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h2><ul><li>案例网站：<a href="https://www.yidaiyilu.gov.cn" target="_blank" rel="noopener">【中国一带一路官网】</a>， 以抓取文章<a href="https://www.yidaiyilu.gov.cn/xwzx/gnxw/87373.htm" target="_blank" rel="noopener">【“一带一路”建设成果图鉴丨陆海内外联动，湖北推动产能合作纵深推进】</a>为例，进行深度剖析。</li></ul><h2 id="案例剖析"><a href="#案例剖析" class="headerlink" title="案例剖析"></a>案例剖析</h2><p>1） 浏览器访问<a href="https://www.yidaiyilu.gov.cn/xwzx/gnxw/87373.htm" target="_blank" rel="noopener">【“一带一路”建设成果图鉴丨陆海内外联动，湖北推动产能合作纵深推进】</a>：<br><img src="/images/python_anti_spider_521_url_yidaiyilu_20190505.png" alt="URL访问"></p><p>2）写<code>ython</code>代码访问，查看<code>http(s)</code>返回状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USER_AGENT = UserAgent()</span><br><span class="line">ua = USER_AGENT.random</span><br><span class="line">url = <span class="string">r'https://www.yidaiyilu.gov.cn/xwzx/gnxw/87373.htm'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"www.yidaiyilu.gov.cn"</span>,</span><br><span class="line">    <span class="string">"User-Agent"</span>: ua</span><br><span class="line">&#125;</span><br><span class="line">rs = requests.session()</span><br><span class="line">resp = rs.get(url)</span><br><span class="line">print(resp.status_code)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure><p>不幸的是，返回的<code>http</code>的状态码却是<code>501</code>，<code>text</code>为一段混淆的<code>js</code>代码。</p><p><img src="/images/python_anti_spider_521_requests_20190505.png" alt="request_501"></p><p>3）百度查资料，推荐为文首的<a href="https://github.com/xiantang/Spider/blob/master/Anti_Anti_Spider_521/pass_521.py" target="_blank" rel="noopener">【参考文献】</a></p><p>继续参照资料修改代码，<code>Python</code>执行<code>JS</code>首选<code>execjs</code>，<code>pip</code>安装如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install PyExecJS</span><br></pre></td></tr></table></figure></p><p>将请求到的<code>js</code>执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text_521 = <span class="string">''</span>.join(re.findall(<span class="string">'&lt;script&gt;(.*?)&lt;/script&gt;'</span>, resp.text))</span><br><span class="line">func_return = text_521.replace(<span class="string">'eval'</span>, <span class="string">'return'</span>)</span><br><span class="line">content = execjs.compile(func_return)</span><br><span class="line">print(content.call(<span class="string">'f'</span>))</span><br></pre></td></tr></table></figure><p>将返回的结果<code>print</code>发现还是一段<code>JS</code>，标准格式化（<a href="https://www.html.cn/tool/js_beautify/" target="_blank" rel="noopener">【格式化<code>Javascript</code>工具】</a>），结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _2i = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="string">'location.href=location.pathname+location.search.replace(/[\?|&amp;]captcha-challenge/,\'\')'</span>, <span class="number">1500</span>);</span><br><span class="line">        <span class="built_in">document</span>.cookie = <span class="string">'__jsl_clearance=1557019601.296|0|'</span> + (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> _2i = [([(-~[] &lt;&lt; -~[])] * (((+!+&#123;&#125;) + [(-~[] &lt;&lt; -~[])] &gt;&gt; (-~[] &lt;&lt; -~[]))) + []), (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + [<span class="number">3</span> - ~(+!+&#123;&#125;) - ~(+!+&#123;&#125;)], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + [<span class="number">5</span>], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + [~~<span class="string">''</span>], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]), [-~~~!&#123;&#125; + [~~</span><br><span class="line">                                []</span><br><span class="line">                            ] - (-~~~!&#123;&#125;)], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + [-~&#123;&#125; - ~[-~&#123;&#125; - ~&#123;&#125;]], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]), [-~(+!+&#123;&#125;)], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + ([(-~[] &lt;&lt; -~[])] * (((+!+&#123;&#125;) + [(-~[] &lt;&lt; -~[])] &gt;&gt; (-~[] &lt;&lt; -~[]))) + []), (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + (-~[-~&#123;&#125; - ~&#123;&#125;] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]), (((-~[] &lt;&lt; -~[]) &lt;&lt; (-~[] &lt;&lt; -~[])) + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]), [<span class="number">3</span> - ~(+!+&#123;&#125;) - ~(+!+&#123;&#125;)], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + (((-~[] &lt;&lt; -~[]) &lt;&lt; (-~[] &lt;&lt; -~[])) + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]), [<span class="number">5</span>],</span><br><span class="line">                            [-~&#123;&#125; - ~[-~&#123;&#125; - ~&#123;&#125;]], (-~&#123;&#125; + [] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]) + [-~(+!+&#123;&#125;)], (-~[-~&#123;&#125; - ~&#123;&#125;] + [</span><br><span class="line">                                []</span><br><span class="line">                            ][<span class="number">0</span>]), [~~<span class="string">''</span>]</span><br><span class="line">                        ],</span><br><span class="line">                        _1d = <span class="built_in">Array</span>(_2i.length);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> _5 = <span class="number">0</span>; _5 &lt; _2i.length; _5++) &#123;</span><br><span class="line">                        _1d[_2i[_5]] = [<span class="string">'Bz'</span>, (-~[-~&#123;&#125; - ~&#123;&#125;] + [</span><br><span class="line">                                    []</span><br><span class="line">                                ][<span class="number">0</span>]), [&#123;&#125; + [] + [</span><br><span class="line">                                    []</span><br><span class="line">                                ][<span class="number">0</span>]][<span class="number">0</span>].charAt(-~~~!&#123;&#125;), <span class="string">'DR'</span>, ([(-~[] &lt;&lt; -~[])] / (+!<span class="regexp">/!/</span>) + [] + [</span><br><span class="line">                                    []</span><br><span class="line">                                ][<span class="number">0</span>]).charAt(-~[-~~~!&#123;&#125; - ~(-~[] - ~&#123;&#125; - ~&#123;&#125;)]) + (+[(+!+&#123;&#125;), (+!+&#123;&#125;)] + []).charAt((+!+&#123;&#125;)), [</span><br><span class="line">                                    [][</span><br><span class="line">                                        []</span><br><span class="line">                                    ] + [] + [</span><br><span class="line">                                        []</span><br><span class="line">                                    ][<span class="number">0</span>]</span><br><span class="line">                                ][<span class="number">0</span>].charAt(-~&#123;&#125; - ~[-~&#123;&#125; - ~&#123;&#125;]), <span class="string">'qM'</span>, (((-~[] &lt;&lt; -~[]) &lt;&lt; (-~[] &lt;&lt; -~[])) + [</span><br><span class="line">                                    []</span><br><span class="line">                                ][<span class="number">0</span>]) + (+[(+!+&#123;&#125;), (+!+&#123;&#125;)] + []).charAt((+!+&#123;&#125;)) + (-~&#123;&#125;</span><br><span class="line">                                    /~~<span class="string">''</span>+[]+[[]][<span class="number">0</span>]).charAt((+!<span class="regexp">/!/</span>)),<span class="string">'S'</span>,<span class="string">'g%'</span>,(((-~[]&lt;&lt;-~[])&lt;&lt;(-~[]&lt;&lt;-~[]))+[[]][<span class="number">0</span>]),<span class="string">'HxXL'</span>,[[][[]]+[]+[[]][<span class="number">0</span>]][<span class="number">0</span>].charAt(-~&#123;&#125;-~[-~&#123;&#125;-~&#123;&#125;]),<span class="string">'D'</span>,[-~(+!+&#123;&#125;)],<span class="string">'T%'</span>,<span class="string">'YW'</span>,[&#123;&#125;+[]+[[]][<span class="number">0</span>]][<span class="number">0</span>].charAt(-~~~!&#123;&#125;),<span class="string">'vw'</span>][_5]&#125;;<span class="keyword">return</span> _1d.join(<span class="string">''</span>)&#125;)()+<span class="string">';Expires=Sun, 05-May-19 02:26:41 GMT;Path=/;</span></span><br><span class="line"><span class="string">                                    '</span>&#125;;<span class="keyword">if</span>((<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">try</span>&#123;<span class="keyword">return</span> !!<span class="built_in">window</span>.addEventListener;&#125;<span class="keyword">catch</span>(e)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;&#125;)())&#123;<span class="built_in">document</span>.addEventListener(<span class="string">'</span></span><br><span class="line"><span class="string">                                    DOMContentLoaded '</span>,_2i,<span class="literal">false</span>)&#125;<span class="keyword">else</span>&#123;<span class="built_in">document</span>.attachEvent(<span class="string">'</span></span><br><span class="line"><span class="string">                                    onreadystatechange '</span>,_2i)&#125;</span><br></pre></td></tr></table></figure><p>4）修改与浏览器相关的代码，然后放入浏览器的<code>console</code>进行调试。</p><p><img src="/images/python_anti_spider_521_js_debug_20190505.png" alt="JS执行结果"></p><p><strong>注意</strong>，在调试过程中，不难发现，<code>js</code>变量是动态生成的。最初还嵌套有<code>document.createElement(&#39;div&#39;)</code>，<code>Python</code>的<code>execjs</code>包不支持处理这类代码，需要做相应处理。</p><p>5）综上分析，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YiDaiYiLuSpider</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    中国一带一路网（521反爬）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    USER_AGENT = UserAgent()</span><br><span class="line">    ua = USER_AGENT.random</span><br><span class="line">    url = <span class="string">r'https://www.yidaiyilu.gov.cn/xwzx/gnxw/87373.htm'</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"Host"</span>: <span class="string">"www.yidaiyilu.gov.cn"</span>,</span><br><span class="line">        <span class="string">"User-Agent"</span>: ua</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_text521</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        rs = requests.session()</span><br><span class="line">        resp = rs.get(url=cls.url, headers=cls.headers)</span><br><span class="line">        text_521 = <span class="string">''</span>.join(re.findall(<span class="string">'&lt;script&gt;(.*?)&lt;/script&gt;'</span>, resp.text))</span><br><span class="line">        cookie_id = <span class="string">'; '</span>.join([<span class="string">'='</span>.join(item) <span class="keyword">for</span> item <span class="keyword">in</span> resp.cookies.items()])</span><br><span class="line">        <span class="keyword">return</span> cookie_id, text_521</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_cookies</span><span class="params">(cls, func)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param func:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        func_return = func.replace(<span class="string">'eval'</span>, <span class="string">'return'</span>)</span><br><span class="line">        content = execjs.compile(func_return)</span><br><span class="line">        eval_func = content.call(<span class="string">'f'</span>)</span><br><span class="line">        var = str(eval_func.split(<span class="string">'='</span>)[<span class="number">0</span>]).split(<span class="string">' '</span>)[<span class="number">1</span>]</span><br><span class="line">        rex = <span class="string">r"&gt;(.*?)&lt;/a&gt;"</span></span><br><span class="line">        rex_var = re.findall(rex, eval_func)[<span class="number">0</span>]</span><br><span class="line">        mode_func = eval_func.replace(<span class="string">'document.cookie='</span>, <span class="string">'return '</span>).replace(<span class="string">';if((function()&#123;try&#123;return !!window.addEventListener;&#125;'</span>, <span class="string">''</span>). \</span><br><span class="line">            replace(<span class="string">"catch(e)&#123;return false;&#125;&#125;)())&#123;document.addEventListener('DOMContentLoaded',"</span> + var + <span class="string">",false)&#125;"</span>, <span class="string">''</span>). \</span><br><span class="line">            replace(<span class="string">"else&#123;document.attachEvent('onreadystatechange',"</span> + var + <span class="string">")&#125;"</span>, <span class="string">''</span>).\</span><br><span class="line">            replace(<span class="string">r"setTimeout('location.href=location.pathname+location.search.replace(/[\?|&amp;]captcha-challenge/,\'\')',1500);"</span>, <span class="string">''</span>).\</span><br><span class="line">            replace(<span class="string">'return return'</span>, <span class="string">'return'</span>).\</span><br><span class="line">            replace(<span class="string">"document.createElement('div')"</span>, <span class="string">'"https://www.yidaiyilu.gov.cn/"'</span>).\</span><br><span class="line">            replace(<span class="string">r"&#123;0&#125;.innerHTML='&lt;a href=\'/\'&gt;&#123;1&#125;&lt;/a&gt;';&#123;0&#125;=&#123;0&#125;.firstChild.href;"</span>.format(var, rex_var), <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">        content = execjs.compile(mode_func)</span><br><span class="line">        cookies_js = content.call(var)</span><br><span class="line">        __jsl_clearance = cookies_js.split(<span class="string">';'</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> __jsl_clearance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawler</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        url = <span class="string">r'https://www.yidaiyilu.gov.cn/zchj/sbwj/87255.htm'</span></span><br><span class="line">        cookie_id, text_521 = cls.get_text521()</span><br><span class="line">        __jsl_clearance = cls.generate_cookies(text_521)</span><br><span class="line">        cookies = <span class="string">"&#123;0&#125;;&#123;1&#125;;"</span>.format(cookie_id, __jsl_clearance)</span><br><span class="line">        cls.headers[<span class="string">"Cookie"</span>] = cookies</span><br><span class="line">        print(cls.headers)</span><br><span class="line">        res = requests.get(url=url, headers=cls.headers)</span><br><span class="line">        res.encoding = <span class="string">'utf-8'</span></span><br><span class="line">        print(res.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    YiDaiYiLuSpider.crawler()</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/images/python_anti_spider_521_js_result_20190505.png" alt="运行结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考文献：&lt;a href=&quot;https://github.com/xiantang/Spider/blob/master/Anti_Anti_Spider_521/pass_521.py&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="Python" scheme="https://zhangbc.github.io/categories/python/"/>
    
    
      <category term="Python爬虫实例" scheme="https://zhangbc.github.io/tags/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Python编码规范】基础语法</title>
    <link href="https://zhangbc.github.io/2019/05/05/python_code91_03/"/>
    <id>https://zhangbc.github.io/2019/05/05/python_code91_03/</id>
    <published>2019-05-04T23:59:26.000Z</published>
    <updated>2019-05-04T17:29:21.855Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。</p></blockquote><p><strong>温馨提醒</strong>：在阅读本书之前，强烈建议先仔细阅读：<a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener"><strong>PEP</strong>规范</a>，增强代码的可阅读性，配合优雅的<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">pycharm</a>编辑器(开启<code>pep8</code>检查)写出规范代码，是<code>Python</code>入门的第一步。</p><p><code>Python</code> 基础语法，即<code>Python</code>程序的基本要素，分为：</p><blockquote><ul><li>基本数据类型：数字、字符串、列表、字典、集合、元组等；</li><li>常见的语法：条件、循环、函数、列表解析等。</li></ul></blockquote><h2 id="建议19：有节制地使用from…import语句"><a href="#建议19：有节制地使用from…import语句" class="headerlink" title="建议19：有节制地使用from…import语句"></a>建议19：有节制地使用from…import语句</h2><p><code>Python</code>提供了3种方式引入外部模块：<code>import</code>语句，<code>from...import...</code>及<code>__import__</code>函数。</p><p><code>__import__</code>函数可以显式地将模块名称作为字符串传递并赋值给命名空间的变量。</p><ul><li>在使用<code>import</code>时需要注意以下事项：</li></ul><blockquote><p>1）一般尽量优先使用<code>import a</code>形式，如果访问<code>B</code>时需要使用<code>a.B</code>的形式；<br>2）有节制地使用<code>from a import B</code>形式，可以直接访问<code>B</code>；<br>3）尽量避免使用<code>from a import *</code>，减少污染命名空间。</p></blockquote><p><code>Python</code>的<code>import</code>机制：<code>Python</code>在初始化运行环境的时候会预先加载一批内建模块到内存中，其相关信息被存放在<code>sys.modules</code>中。</p><ul><li><code>from a import ...</code>无节制的使用产生的问题：</li></ul><blockquote><p>1）命名空间的冲突；</p></blockquote><p>文件<code>a.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"add in module A."</span></span><br></pre></td></tr></table></figure><p>文件<code>b.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"add in module B."</span></span><br></pre></td></tr></table></figure><p>测试文件<code>importtest.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> add</span><br><span class="line"><span class="keyword">from</span> b <span class="keyword">import</span> add</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">add()</span><br></pre></td></tr></table></figure><blockquote><p>2）循环嵌套导入的问题。</p></blockquote><ul><li>可以考虑<code>from...import</code>的情况：</li></ul><blockquote><p>1）当只需要导入部分属性或方法时；<br>2）模块中的这些属性和方法访问频率较高导致使用“模块名.名称”的形式进行访问过于烦琐时；<br>3）模块的文档明确说明需要使用<code>from...import</code>形式，导入的是一个包下面的子模块，且使用<code>from...import</code>形式能够更为简单和便捷时。</p></blockquote><h2 id="建议20：优先使用absolute-import来导入模块"><a href="#建议20：优先使用absolute-import来导入模块" class="headerlink" title="建议20：优先使用absolute import来导入模块"></a>建议20：优先使用absolute import来导入模块</h2><p>在<code>Python2.4</code>以前默认为隐式的<code>relative import</code>，局部范围的模块将覆盖同名的全局范围的模块。<code>Python2.5</code>后虽然默认的仍是<code>relative import</code>，但它为<code>absolute import</code>提供了一种新的机制，在模块中使用<code>from __future__ import absolute_import</code>语句进行说明后再进行导入。同时还通过点号<strong><code>.</code></strong>提供了一种显式进行<code>relative import</code>的方法。</p><p>相比于<code>absolute import</code>，<code>relative import</code>在实际应用中反馈的问题较多(<code>Python3</code>中已移除)，<code>absolute import</code>的可读性和出现问题后的可跟踪性更好，因此，推荐优先使用<code>absolute import</code>。</p><h2 id="建议21：i-1不等于-i"><a href="#建议21：i-1不等于-i" class="headerlink" title="建议21：i+=1不等于++i"></a>建议21：i+=1不等于++i</h2><p><code>Python</code>解释器会将<code>++i</code>操作解释为<code>+(+i)</code>，其中<code>+</code>表示正数符号。对于<code>--i</code>也是类似。</p><ul><li>实例一</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>++i</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>实例二：无限循环</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">ls = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">while</span> i &lt; len(ls):</span><br><span class="line"><span class="keyword">print</span> ls[<span class="number">0</span>]</span><br><span class="line">++i</span><br></pre></td></tr></table></figure><h2 id="建议22：使用with自动关闭资源"><a href="#建议22：使用with自动关闭资源" class="headerlink" title="建议22：使用with自动关闭资源"></a>建议22：使用with自动关闭资源</h2><ul><li><code>with</code> 语句的语法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 表达式 [<span class="keyword">as</span> 目标]:</span><br><span class="line">代码块</span><br></pre></td></tr></table></figure><ul><li>包含<code>with</code>语句的代码块执行过程如下：</li></ul><blockquote><p>1）计算表达式的值，返回一个上下文管理器对象；<br>2）加载上下文管理器对象的<code>__exit__()</code>方法以备后用；<br>3）调用上下文管理器对象的<code>__enter__()</code>方法；<br>4）若<code>with</code>语句中设置了目标对象，则将<code>__enter__()</code>方法的返回值赋值给目标对象；<br>5）执行<code>with</code>中的代码块；<br>6）若步骤5)中的代码正常结束，调用上下文管理器对象的<code>__exit__()</code>方法，其返回值直接忽略；<br>7）若步骤5)中的代码执行过程中发生异常，调用上下文管理器对象的<code>__exit__()</code>方法，并将异常类型，值及<code>traceback</code>信息作为参数传递给<code>__exit__()</code>方法。若<code>__exit__()</code>的返回值为false，则异常会被重新抛出；若<code>__exit__()</code>的返回值为<code>true</code>，则异常会被挂起，程序继续执行。</p></blockquote><h2 id="建议23：使用else子句简化循环（异常处理）"><a href="#建议23：使用else子句简化循环（异常处理）" class="headerlink" title="建议23：使用else子句简化循环（异常处理）"></a>建议23：使用else子句简化循环（异常处理）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="string">    :param number:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">​</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, number):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">2</span>, i):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'&#123;0&#125; is a prime number.'</span>.format(i)</span><br></pre></td></tr></table></figure><p>当循环“自然”终结（循环条件为假）时<code>else</code>从句会被执行一次；当循环是由<code>break</code>语句得到中断时，<code>else</code>子句就不被执行。</p><h2 id="建议24：遵循异常处理的几点原则"><a href="#建议24：遵循异常处理的几点原则" class="headerlink" title="建议24：遵循异常处理的几点原则"></a>建议24：遵循异常处理的几点原则</h2><p><code>Python</code>中常用的异常处理语法是：<code>try</code>，<code>except</code>，<code>else</code>，<code>finally</code>，可以有多种组合。</p><ul><li>异常处理流程图如下：</li></ul><p><img src="/images/python_code91_03_try_20190505.png" alt="异常处理流程图"></p><ul><li>异常处理遵循的基本原则：</li></ul><blockquote><p>1）注意异常的粒度，不推荐在<code>try</code>中放入过多的代码；<br>2）谨慎使用单独的<code>except</code>语句处理所有异常，最好能定位具体的异常；<br>3）注意异常捕捉的顺序，在合适的层次处理异常；向上层传递的时候需要警惕异常被丢失的情况，可以使用不带参数的<code>raise</code>来传递；<br>4）使用更为友好的异常信息，遵循异常参数的规范。</p></blockquote><h2 id="建议25：避免finally中可能发生的陷阱"><a href="#建议25：避免finally中可能发生的陷阱" class="headerlink" title="建议25：避免finally中可能发生的陷阱"></a>建议25：避免finally中可能发生的陷阱</h2><p>无论<code>try</code>语句中是否有异常抛出，<code>finally</code>语句总会被执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:UTF-8 -*-</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> a &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"data can not be negative."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="keyword">print</span> ex</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The end!"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">print</span> test(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">print</span> test(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="建议26：深入理解None，正确判断对象是否为空"><a href="#建议26：深入理解None，正确判断对象是否为空" class="headerlink" title="建议26：深入理解None，正确判断对象是否为空"></a>建议26：深入理解None，正确判断对象是否为空</h2><p><code>Python</code>中以下数据会被当作空处理：</p><ul><li>常量<code>None</code>；</li><li>常量<code>False</code>；</li><li>任何形式的数值类型零，如<code>0</code>，<code>0L</code>，<code>0.0</code>，<code>0j</code>；</li><li>空的序列，如<code>‘’</code>，<code>()</code>，<code>[]</code>；</li><li>空字典，如<code>{}</code>；</li><li>当用户定义的类中定义了<code>nonzero()</code>方法和<code>len()</code>方法，并且该方法返回整数<code>0</code>或者布尔值<code>False</code>。</li></ul><p><strong>注意</strong>：<code>None</code>的特殊性体现在它既不是<code>0</code>，<code>False</code>，也不是空字符串，它就是一个空值对象；其数据类型为<code>NoneType</code>，遵循单例模式，是唯一的，因而不能创建<code>None</code>对象。所有赋值为<code>None</code>的变量都相等，并且<code>None</code>与任何其他非<code>None</code>的对象比较结果都是<code>False</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="literal">None</span>)</span><br><span class="line"><span class="number">140735411631784</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span> == <span class="number">0</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span> == <span class="string">""</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140735411631784</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b   <span class="comment"># 所有赋值为`None`的变量都相等</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>实例：列表判空</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = []</span><br><span class="line"><span class="keyword">if</span> ls <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"ls is: "</span>, ls</span><br><span class="line">esle:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"ls is None"</span></span><br></pre></td></tr></table></figure><ul><li>以上程序运行输出为：<code>ls is: []</code>，显然不是我们的预期结果。应修正为：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls = []</span><br><span class="line"><span class="keyword">if</span> ls:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"ls is: "</span>, ls</span><br><span class="line">esle:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"ls is None"</span></span><br></pre></td></tr></table></figure><h2 id="建议27：连接字符串优先使用join而不是"><a href="#建议27：连接字符串优先使用join而不是" class="headerlink" title="建议27：连接字符串优先使用join而不是+"></a>建议27：连接字符串优先使用join而不是+</h2><p>1）使用操作符<code>+</code>连接字符串的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1, str2, str3 = <span class="string">"testing "</span>, <span class="string">"string "</span>, <span class="string">"concatenation "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 + str2 + str3</span><br><span class="line"><span class="string">'testing string concatenation '</span></span><br></pre></td></tr></table></figure><p>2）使用<code>join</code>方法连接字符串的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">''</span>.join([str1, str2, str3])</span><br><span class="line"><span class="string">'testing string concatenation '</span></span><br></pre></td></tr></table></figure><ul><li>性能测试函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:UTF-8 -*-</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line">​</span><br><span class="line">str_list = [<span class="string">"It is a long value string will not keep in memory "</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> xrange(<span class="number">10000</span>)]</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join_test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(str_list)</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus_test</span><span class="params">()</span>:</span></span><br><span class="line">    res = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(str_list):</span><br><span class="line">        res += v</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">​</span><br><span class="line">    join_timer = timeit.Timer(<span class="string">"join_test()"</span>, <span class="string">"from __main__ import join_test"</span>)</span><br><span class="line">    <span class="keyword">print</span> join_timer.timeit(number=<span class="number">10</span>)    <span class="comment"># 0.00255298614502    </span></span><br><span class="line">    <span class="keyword">print</span> join_timer.timeit(number=<span class="number">100000</span>)    <span class="comment"># 13.4903669357</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    plus_timer = timeit.Timer(<span class="string">"plus_test()"</span>, <span class="string">"from __main__ import plus_test"</span>)</span><br><span class="line">    <span class="keyword">print</span> plus_timer.timeit(number=<span class="number">10</span>)    <span class="comment"># 0.0193991661072</span></span><br><span class="line">    <span class="keyword">print</span> plus_timer.timeit(number=<span class="number">100000</span>)    <span class="comment"># 400.628134012</span></span><br></pre></td></tr></table></figure><p>从以上测试效果看，<code>join()</code>方法的效率要高于<code>+</code>操作符，尤其是字符串规模较大时，两者的效率十分明显。</p><p>执行一次<code>+</code>，就会申请一块新的内存空间，并将上一次的操作结果和本次的右操作数复制到新申请的内存空间。时间复杂度为 $O(n^2)$;<br>对于<code>join()</code>，会首先计算需要申请的总的内存空间，然后一次性申请所需内存并将字符序列中的每一个元素复制到内存中去，时间复杂度为$O(n)$。</p><h2 id="建议28：格式化字符串时尽量使用-format方式而不是"><a href="#建议28：格式化字符串时尽量使用-format方式而不是" class="headerlink" title="建议28：格式化字符串时尽量使用.format方式而不是%"></a>建议28：格式化字符串时尽量使用.format方式而不是%</h2><p><code>Python</code>中内置<code>%</code>操作符和<code>.format</code>方式都可以用作格式化字符串。</p><ul><li><code>%</code>转换说明符的基本形式为：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[转标记][宽度[.精确度]] 转换类型</span><br></pre></td></tr></table></figure><p><img src="/images/python_code91_03_format_convert_flag_20190505.png" alt="格式化字符串转换标记"></p><p><img src="/images/python_code91_03_format_convert_type_20190505.png" alt="格式化字符串转换类型"></p><p><strong>常见用法</strong></p><p>1）直接格式化字符或者数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"your score is %06.1f"</span> % <span class="number">9.5</span></span><br><span class="line">your score <span class="keyword">is</span> <span class="number">0009.5</span></span><br></pre></td></tr></table></figure><p>2）以元组的形式格式化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item_name = <span class="string">'circumference'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>radius = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"The %s of a circle with radius %f is %0.3f"</span> % \</span><br><span class="line"><span class="meta">... </span>      (item_name, radius, math.pi*radius*<span class="number">2</span>)</span><br><span class="line">The circumference of a circle <span class="keyword">with</span> radius <span class="number">3.000000</span> <span class="keyword">is</span> <span class="number">18.850</span></span><br></pre></td></tr></table></figure><p>3）以字典的形式格式化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>item_dict = &#123;<span class="string">'item_name'</span>: <span class="string">'circumference'</span>, <span class="string">'radius'</span>: <span class="number">3</span>, <span class="string">'value'</span>: math.pi*radius*<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"The %(item_name)s of a circle with radius %(radius)f is %(value)0.3f"</span> % (item_dict)</span><br><span class="line">The circumference of a circle <span class="keyword">with</span> radius <span class="number">3.000000</span> <span class="keyword">is</span> <span class="number">18.850</span></span><br></pre></td></tr></table></figure><ul><li><code>.format</code>方式格式化字符串的基本语法为：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.format([[填充符]对齐方式][符号][<span class="comment">#][0][宽度][,][.精度][转换类型])</span></span><br></pre></td></tr></table></figure><p><img src="/images/python_code91_03_format_align_20190505.png" alt="format对齐方式"></p><p><img src="/images/python_code91_03_format_list_20190505.png" alt="format符号列表"></p><p><strong>常见用法</strong></p><p>1）使用位置符号<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"The number &#123;0:,&#125; in hex is: &#123;0:#x&#125;,"</span> \</span><br><span class="line"><span class="meta">... </span>      <span class="string">"The number &#123;1&#125; in oct is: &#123;1:#o&#125;"</span>.format(<span class="number">4746</span>, <span class="number">45</span>)</span><br><span class="line">The number <span class="number">4</span>,<span class="number">746</span> <span class="keyword">in</span> hex <span class="keyword">is</span>: <span class="number">0x128a</span>,The number <span class="number">45</span> <span class="keyword">in</span> oct <span class="keyword">is</span>: <span class="number">0o55</span></span><br></pre></td></tr></table></figure></p><p>2）使用名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"The max number is &#123;max&#125;, the min number is &#123;min&#125;, the average number is &#123;avg&#125;"</span>\</span><br><span class="line"><span class="meta">... </span>    .format(max=<span class="number">9</span>, min=<span class="number">3</span>, avg=<span class="number">6</span>)</span><br><span class="line">The max number <span class="keyword">is</span> <span class="number">9</span>, the min number <span class="keyword">is</span> <span class="number">3</span>, the average number <span class="keyword">is</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>3）通过属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, sex, phone)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>        self.sex = sex</span><br><span class="line"><span class="meta">... </span>        self.phone = phone</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Customer (&#123;self.name&#125;, &#123;self.sex&#125;, &#123;self.phone&#125;)'</span>.format(self=self) </span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Customer(<span class="string">"Lisa"</span>, <span class="string">"F"</span>, <span class="string">"13304634561"</span>)</span><br><span class="line">Customer (Lisa, F, <span class="number">13304634561</span>)</span><br></pre></td></tr></table></figure><p>4）格式化元组的具体项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>point = (<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'X:&#123;0[0]&#125;; Y:&#123;0[1]&#125;'</span>.format(point)</span><br><span class="line">X:<span class="number">1</span>; Y:<span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>为什么要尽量使用<code>format</code>方式而不是<code>%</code>操作符来格式化字符串？</li></ul><blockquote><p>1）<code>format</code>方式在使用上较<code>%</code>操作符更为灵活；使用<code>format</code>方式时，参数的顺序与格式化的顺序不必完全相同；<br>2）<code>format</code>方式可以方便地作为参数传递；<br>3）<code>%</code>最终会被<code>.format</code>方式替代；<br>4）<code>%</code>方法在某些特殊情况下使用需要特别小心。如下例，特别小心 <strong><code>,</code></strong> 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>items = (<span class="string">"mouse"</span>, <span class="string">"mobilephone"</span>, <span class="string">"cup"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"items list are %s"</span> % (items)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="keyword">not</span> all arguments converted during string formatting</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"items list are %s"</span> % (items,)</span><br><span class="line">items list are (<span class="string">'mouse'</span>, <span class="string">'mobilephone'</span>, <span class="string">'cup'</span>)</span><br></pre></td></tr></table></figure><h2 id="建议29：区别对待可变对象和不可变对象"><a href="#建议29：区别对待可变对象和不可变对象" class="headerlink" title="建议29：区别对待可变对象和不可变对象"></a>建议29：区别对待可变对象和不可变对象</h2><p><code>Python</code>中一切皆对象，每一个对象都有一个唯一的标识符(<code>id()</code>)，类型(<code>type()</code>)以及值。</p><ul><li><strong>可变对象</strong>：字典，字节数组，列表；</li><li><p><strong>不可变对象</strong>：数字，字符串，元组。</p></li><li><p>实例</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    区别可变对象与不可变对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, course=list<span class="params">()</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.course = course</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_course</span><span class="params">(self, course_name)</span>:</span></span><br><span class="line">        self.course.append(course_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_course</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(self.course):</span><br><span class="line">            <span class="keyword">print</span> item, <span class="string">' '</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    stu_a = Student(<span class="string">"Wang Yi"</span>)</span><br><span class="line">    stu_a.add_course(<span class="string">"English"</span>)</span><br><span class="line">    stu_a.add_course(<span class="string">"Math"</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&#123;0&#125;'s course: "</span>.format(stu_a.name)</span><br><span class="line">    stu_a.print_course()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"================================="</span></span><br><span class="line"></span><br><span class="line">    stu_b = Student(<span class="string">"Li san"</span>)</span><br><span class="line">    stu_b.add_course(<span class="string">"Chinese"</span>)</span><br><span class="line">    stu_b.add_course(<span class="string">"Physics"</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&#123;0&#125;'s course: "</span>.format(stu_b.name)</span><br><span class="line">    stu_b.print_course()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Wang Yi<span class="string">'s course: </span></span><br><span class="line"><span class="string">English  </span></span><br><span class="line"><span class="string">Math  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">=================================</span></span><br><span class="line"><span class="string">Li san'</span>s course: </span><br><span class="line">English  </span><br><span class="line">Math  </span><br><span class="line">Chinese  </span><br><span class="line">Physics</span><br></pre></td></tr></table></figure><ul><li>修正建议：传入<code>None</code>作为默认参数，在创建对象时动态生成列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, course=None)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    <span class="keyword">if</span> course <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        course = list()</span><br><span class="line">    self.course = course</span><br></pre></td></tr></table></figure><h2 id="建议30：-，-，-：一致的容器初始化形式-gt-列表解析"><a href="#建议30：-，-，-：一致的容器初始化形式-gt-列表解析" class="headerlink" title="建议30：[]，()，{}：一致的容器初始化形式==&gt;列表解析"></a>建议30：[]，()，{}：一致的容器初始化形式==&gt;列表解析</h2><ul><li>列表解析的语法为：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> iter_item <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr]</span><br></pre></td></tr></table></figure><ul><li>列表解析的使用</li></ul><p>1）支持多重嵌套</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nested_list = [[<span class="string">'Hello'</span>, <span class="string">'World'</span>], [<span class="string">'Goodbye'</span>, <span class="string">'World'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> [[s.upper() <span class="keyword">for</span> s <span class="keyword">in</span> xs] <span class="keyword">for</span> xs <span class="keyword">in</span> nested_list]</span><br><span class="line">[[<span class="string">'HELLO'</span>, <span class="string">'WORLD'</span>], [<span class="string">'GOODBYE'</span>, <span class="string">'WORLD'</span>]]</span><br></pre></td></tr></table></figure><p>2）支持多重迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(a, b) <span class="keyword">for</span> a <span class="keyword">in</span> [<span class="string">'a'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="keyword">for</span> b <span class="keyword">in</span> [<span class="string">'1'</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">'b'</span>] <span class="keyword">if</span> a != b]</span><br><span class="line">[(<span class="string">'a'</span>, <span class="string">'1'</span>), (<span class="string">'a'</span>, <span class="number">3</span>), (<span class="string">'a'</span>, <span class="number">4</span>), (<span class="string">'a'</span>, <span class="string">'b'</span>), (<span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'1'</span>, <span class="number">4</span>), (<span class="string">'1'</span>, <span class="string">'b'</span>), (<span class="number">1</span>, <span class="string">'1'</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="string">'b'</span>), (<span class="number">2</span>, <span class="string">'1'</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="string">'b'</span>)]</span><br></pre></td></tr></table></figure><p>3）列表解析语法中的表达式可以是简单表达式，也可以是复杂表达式，甚至函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(v)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        v = v ** <span class="number">2</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        v = v + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> v</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> [f(v) <span class="keyword">for</span> v <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>] <span class="keyword">if</span> v &gt; <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> [v ** <span class="number">2</span> <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> v + <span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">-1</span>] <span class="keyword">if</span> v &gt; <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">4</span>, <span class="number">16</span>]</span><br></pre></td></tr></table></figure><p>4）列表解析语法中的<code>iterable</code>可以是任意可迭代对象。</p><h2 id="建议31：记住函数传参既不是传值也不是传引用-gt-而是传对象（的引用）"><a href="#建议31：记住函数传参既不是传值也不是传引用-gt-而是传对象（的引用）" class="headerlink" title="建议31：记住函数传参既不是传值也不是传引用==&gt;而是传对象（的引用）"></a>建议31：记住函数传参既不是传值也不是传引用==&gt;而是传对象（的引用）</h2><p>1）<strong>传引用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(n)</span><br><span class="line"><span class="meta">... </span>    n = n + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(n)</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(n)</span><br><span class="line"><span class="number">140407485781272</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inc(n)</span><br><span class="line"><span class="number">140407485781272</span></span><br><span class="line"><span class="number">140407485781248</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> n</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>：按照传引用的观点，结果输出应为4，并且<code>inc()</code>函数里面执行操作<code>n=n+1</code>的前后<code>n</code>的<code>id</code>值应该是不变的。</p><p>2）<strong>传值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">change_list</span><span class="params">(org_list)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"orginator list is: "</span>, org_list</span><br><span class="line"><span class="meta">... </span>    new_list = org_list</span><br><span class="line"><span class="meta">... </span>    new_list.append(<span class="string">"I am new."</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"new list is: "</span>, new_list </span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> new_list</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>org_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_list = change_list(org_list)</span><br><span class="line">orginator list <span class="keyword">is</span>:  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">new list <span class="keyword">is</span>:  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'I am new.'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> new_list</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'I am new.'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> org_list</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'I am new.'</span>]</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：通过程序输出不难发现，在传值过程中，原来的列表对象随着新对象的变化随之发生变化。</p><p>3）<strong>可变对象传引用，不可变对象传值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(org_list)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(org_list)</span><br><span class="line"><span class="meta">... </span>    new_list = org_list</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(new_list)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(new_list) &gt; <span class="number">5</span>:</span><br><span class="line"><span class="meta">... </span>        new_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i, e <span class="keyword">in</span> enumerate(new_list):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> isinstance(e, list):</span><br><span class="line"><span class="meta">... </span>            new_list[i] = <span class="string">"***"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> new_list</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(new_list)</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test1 = [<span class="number">1</span>, [<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>], <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change(test1)</span><br><span class="line"><span class="number">4512473528</span></span><br><span class="line"><span class="number">4512473528</span></span><br><span class="line">[<span class="number">1</span>, <span class="string">'***'</span>, <span class="string">'***'</span>, <span class="number">6</span>]</span><br><span class="line"><span class="number">4512473528</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> test1</span><br><span class="line">[<span class="number">1</span>, <span class="string">'***'</span>, <span class="string">'***'</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">1</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change(test2)</span><br><span class="line"><span class="number">4511466704</span></span><br><span class="line"><span class="number">4511466704</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="number">4512476552</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> test2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, [<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：传入参数<code>org_list</code>为列表，属于可变对象，按照可变对象传引用的理解，<code>new_list</code>和<code>org_list</code>指向同一块内存，因此两者的<code>id</code>值输出一致，即修改<code>new_list</code>会导致<code>org_list</code>的直接修改；但是在<code>test2</code>中调用函数<code>change()</code>前后并没有发生改变。</p><p><strong><code>Python</code>中的赋值机制理解</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = a</span><br><span class="line">b = <span class="number">7</span></span><br></pre></td></tr></table></figure><p><img src="/images/python_code91_03_python_equals_201900505.png" alt="Python中的赋值机制理解"></p><ul><li>验证上述过程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140407485781224</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">140407485781224</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">140407485781176</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">140407485781224</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong>：对于<code>Python</code>函数参数传递的正确说法是：<strong><code>传对象</code>或者<code>传对象的引用</code></strong>。函数参数在传递的过程中将整个对象传入，对可变对象对修改在函数外部以及内部都可见，调用者和被调用者之间共享这个对象；而对于不可变对象，由于不能真正被修改，因而修改往往是通过生成一个新对象然后赋值来实现的。</p><h2 id="建议32：警惕默认参数潜在的问题"><a href="#建议32：警惕默认参数潜在的问题" class="headerlink" title="建议32：警惕默认参数潜在的问题"></a>建议32：警惕默认参数潜在的问题</h2><ul><li>实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(new_item, list_a=list<span class="params">()</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(list_a)</span><br><span class="line"><span class="meta">... </span>    list_a.append(new_item)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(list_a)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> list_a</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="number">2</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="number">4511467712</span></span><br><span class="line"><span class="number">4511467712</span></span><br><span class="line">[<span class="string">'b'</span>, <span class="number">2</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="number">1</span>)</span><br><span class="line"><span class="number">4512439760</span></span><br><span class="line"><span class="number">4512439760</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">4512439760</span></span><br><span class="line"><span class="number">4512439760</span></span><br><span class="line">[<span class="number">1</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：在连续调用<code>test(1)</code>和<code>test(‘a’)</code>，结果和预想的完全不一样。</p><ul><li>解决方案：在函数调用过程中动态生成，可以在定义时使用<code>None</code>对象作为占位符。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(new_item, list_a=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> list_a <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line"><span class="meta">... </span>        list_a = list()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(list_a)</span><br><span class="line"><span class="meta">... </span>    list_a.append(new_item)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> id(list_a)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> list_a</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">4511794024</span></span><br><span class="line"><span class="number">4511794024</span></span><br><span class="line">[<span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="number">1</span>)</span><br><span class="line"><span class="number">4512440192</span></span><br><span class="line"><span class="number">4512440192</span></span><br><span class="line">[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="建议33：慎用变长参数"><a href="#建议33：慎用变长参数" class="headerlink" title="建议33：慎用变长参数"></a>建议33：慎用变长参数</h2><p><code>Python</code>支持可变长度的参数列表，可以通过函数定义时使用<code>*args</code>和<code>**kwargs</code>这两个特殊语法实现。</p><ul><li><code>*args</code>：实现可变参数列表； <code>*args</code>用于接收一个包装为元组形式的参数列表来传递非关键字参数，参数个数任意。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">summary</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">... </span>    result = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> args[<span class="number">0</span>:]:</span><br><span class="line"><span class="meta">... </span>        result += x</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> summary(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> summary(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><ul><li><code>**kwargs</code>：实现字典形式的关键字参数列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">category_table</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">"&#123;0&#125; is a kind of &#123;1&#125;."</span>.format(name, value)</span><br><span class="line"><span class="meta">... </span>        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>category_table(apple=<span class="string">"fruit"</span>, carrot=<span class="string">"vegetable"</span>, python=<span class="string">"programming language"</span>)</span><br><span class="line">python <span class="keyword">is</span> a kind of programming language.</span><br><span class="line">carrot <span class="keyword">is</span> a kind of vegetable.</span><br><span class="line">apple <span class="keyword">is</span> a kind of fruit.</span><br></pre></td></tr></table></figure><h2 id="建议34：深入理解str-和repr-的区别"><a href="#建议34：深入理解str-和repr-的区别" class="headerlink" title="建议34：深入理解str()和repr()的区别"></a>建议34：深入理解str()和repr()的区别</h2><p><strong><code>str()</code>和<code>repr()</code>的区别</strong>：</p><blockquote><p>1）二者的目标不同：<code>str()</code>面向用户，其目的是可读性，返回字符串类型；<code>repr()</code>面向的<code>Python</code>解释器，或者说开发者，其目的是准确性，返回表示<code>Python</code>解释器内部的含义，常作为<code>debug</code>用途；<br>2）在解释器中直接输入<code>a</code>时默认调用<code>repr()</code>，而<code>print a</code>则调用<code>str()</code>；<br>3）<code>repr()</code>的返回值一般可用<code>eval()</code>函数还原对象，即：<code>obj == eval(repr(obj))</code>；<br>4）二者分别调用<code>__str__()</code>和<code>__repr__()</code>方法，一般而言，在类中都应该定义<code>__repr__()</code>方法（默认方法）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"' '"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(s)</span><br><span class="line"><span class="string">"' '"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(s)</span><br><span class="line"><span class="string">'"\' \'"'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(repr(s)) == s</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(str(s))</span><br><span class="line"><span class="string">' '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(str(s)) == s</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="建议35：分清staticmethod和classmethod的适用场景"><a href="#建议35：分清staticmethod和classmethod的适用场景" class="headerlink" title="建议35：分清staticmethod和classmethod的适用场景"></a>建议35：分清staticmethod和classmethod的适用场景</h2><p><code>Python</code>中的静态方法(<code>staticmethod</code>)和类方法(<code>classmethod</code>)都依赖于装饰器(<code>decorator</code>)来实现。</p><ul><li><strong>静态方法(<code>staticmethod</code>)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(args1, args2, ...)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><strong>类方法(<code>classmethod</code>)</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls,args1, args2, ...)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>静态方法所带来的问题</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Fruit类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, area=<span class="string">""</span>, category=<span class="string">""</span>, batch=<span class="string">""</span>)</span>:</span></span><br><span class="line">        self.area = area</span><br><span class="line">        self.category = category</span><br><span class="line">        self.batch = batch</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_product</span><span class="params">(product_info)</span>:</span></span><br><span class="line">        area, category, batch = map(str, product_info.split(<span class="string">'-'</span>))</span><br><span class="line">        fruit = Fruit(area, category, batch)</span><br><span class="line">        <span class="keyword">return</span> fruit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span><span class="params">(Fruit)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span><span class="params">(Fruit)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    apple = Apple(<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'10'</span>)</span><br><span class="line">    orange = Orange.init_product(<span class="string">"3-3-9"</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"apple is instance of Apple: "</span>, isinstance(apple, Apple)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"orange is instance of Orange: "</span>, isinstance(orange, Orange)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple <span class="keyword">is</span> instance of Apple:  <span class="literal">True</span></span><br><span class="line">orange <span class="keyword">is</span> instance of Orange:  <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>：静态方法实际上相当于一个定义在类中的函数，<code>init_product()</code>返回的实际是<code>Fruit</code>对象，所以不会是<code>Orange</code>对象。因而静态方法并不能获取期望的结果，类方法才是正确的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Fruit类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, area=<span class="string">""</span>, category=<span class="string">""</span>, batch=<span class="string">""</span>)</span>:</span></span><br><span class="line">        self.area = area</span><br><span class="line">        self.category = category</span><br><span class="line">        self.batch = batch</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_product</span><span class="params">(cls, product_info)</span>:</span></span><br><span class="line">        area, category, batch = map(str, product_info.split(<span class="string">'-'</span>))</span><br><span class="line">        fruit = cls(area, category, batch)</span><br><span class="line">        <span class="keyword">return</span> fruit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span><span class="params">(Fruit)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span><span class="params">(Fruit)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    apple = Apple(<span class="string">'2'</span>, <span class="string">'5'</span>, <span class="string">'10'</span>)</span><br><span class="line">    orange = Orange.init_product(<span class="string">"3-3-9"</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"apple is instance of Apple: "</span>, isinstance(apple, Apple)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"orange is instance of Orange: "</span>, isinstance(orange, Orange)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在阅读本书之前，强烈建议先仔细阅读：&lt;a href=&quot;https://legacy.py
      
    
    </summary>
    
      <category term="Python" scheme="https://zhangbc.github.io/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>【Python编码规范】编程惯用法</title>
    <link href="https://zhangbc.github.io/2019/04/28/python_code91_02/"/>
    <id>https://zhangbc.github.io/2019/04/28/python_code91_02/</id>
    <published>2019-04-27T16:09:25.000Z</published>
    <updated>2019-04-27T16:41:29.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。</p></blockquote><p><strong>温馨提醒</strong>：在阅读本书之前，强烈建议先仔细阅读：<a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener"><strong>PEP</strong>规范</a>，增强代码的可阅读性，配合优雅的<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">pycharm</a>编辑器(开启<code>pep8</code>检查)写出规范代码，是<code>Python</code>入门的第一步。</p><h2 id="建议8：利用assert语句来发现问题"><a href="#建议8：利用assert语句来发现问题" class="headerlink" title="建议8：利用assert语句来发现问题"></a>建议8：利用assert语句来发现问题</h2><ul><li>断言(<code>assert</code>)基本语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> expression1 [<span class="string">","</span> expression2]</span><br></pre></td></tr></table></figure><ul><li><code>assert</code>用法举例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> x == y , <span class="string">"not equals"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: <span class="keyword">not</span> equals</span><br></pre></td></tr></table></figure><ul><li>关于<code>assert</code>的几点说明事项</li></ul><blockquote><p>1）<code>__debug__</code>的值默认为<code>True</code>，且只读，无法修改(<code>Python2.7</code>)。<br>2）断言是有代价的，对性能产生一定影响。禁用断言的方法是在运行脚本的时候加上<code>-O</code>标记(不优化字节码，而是忽略与断言相关的语句)。</p></blockquote><ul><li>使用断言(<code>assert</code>)注意点：</li></ul><blockquote><p>1）不要滥用，这是使用断言<strong>最基本</strong>的原则；<br>2）如果<code>Python</code>本身的异常能够处理就不要再使用断言；<br>3）不要使用断言来检查用户的输入；<br>4）在函数调用后，当需要确认返回值是否合理时可以使用断言；<br>5）当条件时业务逻辑继续下去的先决条件时，可以使用断言。</p></blockquote><h2 id="建议9：数据交换值时不推荐使用中间交换变量"><a href="#建议9：数据交换值时不推荐使用中间交换变量" class="headerlink" title="建议9：数据交换值时不推荐使用中间交换变量"></a>建议9：数据交换值时不推荐使用中间交换变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">'temp=x;x=y;y=temp'</span>,<span class="string">'x=2;y=3'</span>).timeit()</span><br><span class="line"><span class="number">0.03472399711608887</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Timer(<span class="string">'x,y=y,x'</span>,<span class="string">'x=2;y=3'</span>).timeit()</span><br><span class="line"><span class="number">0.031581878662109375</span></span><br></pre></td></tr></table></figure><ul><li><strong>测试用例说明</strong>：不借助中间变量的方式耗费的时间更少，代码简洁，值得推荐。</li></ul><h2 id="建议10：充分利用Lazy-evaluation的特性"><a href="#建议10：充分利用Lazy-evaluation的特性" class="headerlink" title="建议10：充分利用Lazy evaluation的特性"></a>建议10：充分利用Lazy evaluation的特性</h2><p><code>Lazy evaluation</code>常被译作“<code>延时计算</code>”或“<code>惰性计算</code>”，指的是仅仅在真正需要执行的时候才计算表达式的值。<strong>典型例子</strong>：生成器表达式。</p><blockquote><p>1）避免不必要的计算，带来性能上的提升；<br>2）节省空间，使用无限循环的数据结构成为可能。</p></blockquote><ul><li>实例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line"></span><br><span class="line">        a, b = b, a+b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    print(list(islice(fib(), <span class="number">5</span>)))</span><br></pre></td></tr></table></figure><h2 id="建议11：理解枚举替代实现的缺陷"><a href="#建议11：理解枚举替代实现的缺陷" class="headerlink" title="建议11：理解枚举替代实现的缺陷"></a>建议11：理解枚举替代实现的缺陷</h2><p>1）<strong>替代方法</strong></p><ul><li>使用类属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Seasons</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    Spring, Summer, Autumn, Winter = xrange(<span class="number">4</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Seasons.Spring)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>借助函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">enum</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> type(<span class="string">"Enum"</span>, (object,), dict(zip(args, xrange(len(args))), **kwargs))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons = enum(<span class="string">"Spring"</span>, <span class="string">"Summer"</span>, <span class="string">"Autumn"</span>, Winter=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons.Summer</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons.Winter</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>collections.namedtuple</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons = namedtuple(<span class="string">'Seasons'</span>,<span class="string">'Spring Summer Autumn Winter'</span>)._make(xrange(<span class="number">4</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Seasons</span><br><span class="line">Seasons(Spring=<span class="number">0</span>, Summer=<span class="number">1</span>, Autumn=<span class="number">2</span>, Winter=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> Seasons.Autumn</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>2）<strong>替代缺陷</strong></p><ul><li>允许枚举值重复</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons = namedtuple(<span class="string">'Seasons'</span>,<span class="string">'Spring Summer Autumn Winter'</span>)._make(xrange(<span class="number">4</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons</span><br><span class="line">Seasons(Spring=<span class="number">0</span>, Summer=<span class="number">1</span>, Autumn=<span class="number">2</span>, Winter=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons._replace(Spring=<span class="number">2</span>)   <span class="comment"># 不合理</span></span><br><span class="line">Seasons(Spring=<span class="number">2</span>, Summer=<span class="number">1</span>, Autumn=<span class="number">2</span>, Winter=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li>支持无意义的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Seasons.Summer + Seasons.Autumn == Seasons.Winter    <span class="comment"># 无意义</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>3）<strong><code>Python2.7</code>的替代方案(<code>Python3.4</code>后引入<code>Enum</code>类型)</strong>：<strong><code>flufl.enum</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flufl.enum <span class="keyword">import</span> Enum</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seasons</span><span class="params">(Enum)</span>:</span></span><br><span class="line">​</span><br><span class="line">    Spring = <span class="string">"Spring"</span></span><br><span class="line">    Summer = <span class="number">2</span></span><br><span class="line">    Autumn = <span class="number">3</span></span><br><span class="line">    Winter = <span class="number">4</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">Seasons = Enum(<span class="string">'Seasons'</span>, <span class="string">'Spring Summer Autumn Winter'</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">print</span> Seasons</span><br><span class="line"><span class="keyword">print</span> Seasons.Summer.value</span><br></pre></td></tr></table></figure><h2 id="建议12：不推荐使用type来进行类型检查"><a href="#建议12：不推荐使用type来进行类型检查" class="headerlink" title="建议12：不推荐使用type来进行类型检查"></a>建议12：不推荐使用type来进行类型检查</h2><p>1）基于内建类型扩展的用户自定义类型，<code>type</code>函数并不能准确返回结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInt</span><span class="params">(int)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    用户类UserInt继承int类实现定制化，不支持操作符（+=）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self._value = int(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(other, UserInt):</span><br><span class="line">            <span class="keyword">return</span> UserInt(self._value + other._value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._value + other</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"not support operation."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Integer(&#123;0&#125;)"</span>.format(self._value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    n = UserInt()</span><br><span class="line">    print(n)           <span class="comment"># 输出 0</span></span><br><span class="line"></span><br><span class="line">    m = UserInt(<span class="number">2</span>)</span><br><span class="line">    print(m)           <span class="comment"># 输出 2</span></span><br><span class="line"></span><br><span class="line">    print(n+m)         <span class="comment"># 输出 2</span></span><br><span class="line">    print(type(n) <span class="keyword">is</span> types.IntType)  <span class="comment"># 使用type进行类型判断，输出 False</span></span><br><span class="line">    print(isinstance(n, int))  <span class="comment"># 输出 True</span></span><br></pre></td></tr></table></figure><p>2）在旧式类中，所有类的实例的<code>type</code>值都相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a) == type(b)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;type <span class="string">'instance'</span>&gt;</span><br></pre></td></tr></table></figure><p>3）可以用<code>isinstance()</code>函数检查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">2</span>, float)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">"a"</span>, (str, unicode))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">2</span>,<span class="number">3</span>), (str, list))</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">2</span>,<span class="number">3</span>), (str, list, tuple))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="建议13：尽量转换为浮点类型再做除法"><a href="#建议13：尽量转换为浮点类型再做除法" class="headerlink" title="建议13：尽量转换为浮点类型再做除法"></a>建议13：尽量转换为浮点类型再做除法</h2><p><strong>当涉及除法运算的时候尽量先将操作数转换成浮点类型再做运算。</strong></p><ul><li>浮点数不精确性导致的无限循环：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> i!=<span class="number">1.5</span>:</span><br><span class="line"><span class="meta">... </span>    i=i+<span class="number">0.1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><h2 id="建议14：警惕eval-的安全漏洞"><a href="#建议14：警惕eval-的安全漏洞" class="headerlink" title="建议14：警惕eval()的安全漏洞"></a>建议14：警惕eval()的安全漏洞</h2><ul><li>实例：根据用户的输入，计算<code>Python</code>表达式的值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:UTF-8 -*-</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExpCalcBot</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Your answer is"</span>, eval(string)</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The expression you enter is not valid."</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Please enter a number or operation. Enter e to complete. '</span></span><br><span class="line">    inputStr = raw_input()</span><br><span class="line">    <span class="keyword">if</span> inputStr == <span class="string">'e'</span>:</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">elif</span> repr(inputStr) != <span class="string">' '</span>:</span><br><span class="line">        ExpCalcBot(inputStr)</span><br></pre></td></tr></table></figure><p><strong>输入</strong>：<code>__import__(&quot;os&quot;).system(&quot;dir&quot;)</code>：显示当前目录下的所有文件；<br>                <code>__import__(&quot;os&quot;).system(&quot;del */Q&quot;)</code>：删除当前目录下的所有文件。</p><p>因此，在实际应用过程中，<strong>如果使用对象不是信任源，应该尽量避免使用<code>eval</code>，在需要使用<code>eval</code>的地方可以用安全性更好的<code>ast.literal_eval</code>替代</strong>。</p><h2 id="建议15：使用enumerate-获取序列迭代的索引和值"><a href="#建议15：使用enumerate-获取序列迭代的索引和值" class="headerlink" title="建议15：使用enumerate()获取序列迭代的索引和值"></a>建议15：使用enumerate()获取序列迭代的索引和值</h2><p>对序列进行迭代并获取序列中的元素进行处理的几种方法举例：</p><ul><li><strong>方法一</strong>  在每次循环中对索引变量进行自增</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    print(<span class="string">"index:"</span>, index, <span class="string">"element:"</span>, i)</span><br><span class="line">    index += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><strong>方法二</strong> 使用<code>range()</code>和<code>len()</code>方法结合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(li)):</span><br><span class="line">    print(<span class="string">"index:"</span>, i, <span class="string">"element:"</span>, li[i])</span><br></pre></td></tr></table></figure><ul><li><strong>方法三</strong> 使用<code>while</code>循环，用<code>len</code>获取循环次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; len(li):</span><br><span class="line">    print(<span class="string">"index:"</span>, i, <span class="string">"element:"</span>, li[i])</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><strong>方法四</strong> 使用<code>zip()</code>方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="keyword">for</span> i, e <span class="keyword">in</span> zip(range(len(li)), li):</span><br><span class="line">    print(<span class="string">"index:"</span>, i, <span class="string">"element:"</span>, e)</span><br></pre></td></tr></table></figure><ul><li><strong>方法五(推荐)</strong> 使用<code>enumerate()</code>获取序列迭代对索引和值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="keyword">for</span> i, e <span class="keyword">in</span> enumerate(li):</span><br><span class="line">    print(<span class="string">"index:"</span>, i, <span class="string">"element:"</span>, e)</span><br></pre></td></tr></table></figure><p><strong><code>注意</code></strong>：在获取迭代过程中字典的<code>key</code>和<code>value</code>，应该使用如下<code>iteritems()</code>方法(<code>Python3</code>不再适用)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person=&#123;<span class="string">'name'</span>: <span class="string">'Josn'</span>, <span class="string">'age'</span>: <span class="number">19</span>, <span class="string">'hobby'</span>: <span class="string">'football'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k,v <span class="keyword">in</span> person.iteritems():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> k, <span class="string">":"</span>, v</span><br></pre></td></tr></table></figure><h2 id="建议16：分清-与is的适用场景"><a href="#建议16：分清-与is的适用场景" class="headerlink" title="建议16：分清==与is的适用场景"></a>建议16：分清<code>==</code>与<code>is</code>的适用场景</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="string">"Hi"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="string">"Hi"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a==b          <span class="comment"># is 和 == 结果是一样的</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 =<span class="string">"I am using long string for testing"</span>         <span class="comment"># 注意区分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 =<span class="string">"I am using long string for testing"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 <span class="keyword">is</span> b1</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1==b1                <span class="comment"># is 和 == 结果是不一样的</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p><img src="/images/python_code91_02_idis_20190428.png" alt="is与==的区别"></p><p><strong><code>is</code></strong>：即<code>object identity</code>，表示的是对象标识符，检查对象的标识符是否一致，也就是比较两个对象在内存中是否拥有同一块内存空间；</p><p><strong><code>==</code></strong>：即<code>equal</code>，表示的是值相等，用来判断两个对象的值是否相等，可以被重载。</p><p><strong>字符串驻留(<code>string interning</code>)机制</strong>：对于较小的字符串，为了提高系统性能会保留其值的一个副本，当创建新的字符串时直接指向该副本即可。</p><p><strong>注意</strong>：判断两个对象相等应该使用 <code>==</code> 而不是 <code>is</code>。</p><h2 id="建议17：考虑兼容性，尽可能使用Unicode"><a href="#建议17：考虑兼容性，尽可能使用Unicode" class="headerlink" title="建议17：考虑兼容性，尽可能使用Unicode"></a>建议17：考虑兼容性，尽可能使用Unicode</h2><p><code>Python</code>内建的字符串有两种类型：<code>str</code>和<code>Unicode</code>，共同祖先为<code>basestring</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_uni = <span class="string">u'unicode字符串'</span>  <span class="comment"># 前面加u表示Unicode</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str_uni</span><br><span class="line"><span class="string">u'unicode\u5b57\u7b26\u4e32'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str_uni)</span><br><span class="line">unicode字符串</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(str_uni)</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(str_uni).__bases__</span><br><span class="line">(&lt;type <span class="string">'basestring'</span>&gt;,)</span><br></pre></td></tr></table></figure><ul><li><p><code>Unicode</code>：又称<code>万国码</code>，为每种语言设置了唯一的二进制编码表示方式，提供从数字代码到不同语言字符集之间的映射，从而满足跨平台、跨语言之间的文本处理要求。</p></li><li><p><code>Unicode</code>编码系统分为<strong>编码方式</strong>和<strong>实现方式</strong></p><blockquote><ul><li>在编码方式上，分为<code>UCS-2</code>和<code>UCS-4</code>，<code>UCS-2</code>用两个字节编码；<code>UCS-4</code>用四个字节编码。</li><li>实现方式又称为<code>Unicode</code>转换方式，简称<code>UTF</code>，包括<code>UTF-7</code>、<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>等。</li><li><code>UTF-8</code> 较为常见，其特点是对不同范围的字符使用不同长度的编码，其中<code>0x00～0x7F</code>的字符<code>UTF-8</code>编码与<code>ASCII</code>编码完全相同；其最大长度是4个字节。</li></ul></blockquote></li></ul><p><img src="/images/python_code91_02_methodcoding_20190428.png" alt="UTF-8编码方式"></p><ul><li><code>Windows</code>本地默认编码是<code>CP936</code>。</li></ul><blockquote><ul><li>解码：<code>str.decode([编码参数[，错误处理]])</code>  </li><li>编码：<code>str.encode([编码参数[，错误处理]])</code><br>错误处理参数有3种方式：<blockquote><p>（1）<code>strict</code>：默认值，抛出<code>UnicodeError</code>异常；<br>（2）<code>ignore</code>：忽略不可转换的字符；<br>（3）<code>replace</code>：将不可转换字符用<code>?</code>代替。</p></blockquote></li></ul></blockquote><ul><li>常见的编码参数</li></ul><p><img src="/images/python_code91_02_codingargs_20190428.png" alt="常见的编码参数"></p><ul><li>对于A、B两种编码系统之间的相互转换示意图如下：</li></ul><p><img src="/images/python_code91_02_utf8coding_20190428.png" alt="编码转换示意图"></p><ul><li>有些软件在保存<code>UTF-8</code>编码时，会在文件最开始地方插入不可见的<code>BOM</code>(<code>0xEF</code>，<code>0xBB</code>，<code>0xBF</code>，    即<code>BOM</code>)，可以利用<code>codecs</code>模块解决。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line">​</span><br><span class="line">content = open(<span class="string">'manage.py'</span>, <span class="string">'r'</span>).read()</span><br><span class="line"><span class="keyword">if</span> content[:<span class="number">3</span>] == codecs.BOM_UTF8:</span><br><span class="line">    content = content[:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> content.decode(<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><ul><li>编码声明的三种方式：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=&lt;encoding name&gt;           #方式一</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:&lt;encoding name&gt; -*-    #方式二</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># vim:set fileencoding=&lt;encoding name&gt;    #方式三</span></span><br></pre></td></tr></table></figure><h2 id="建议18：构建合理的包层次来管理module"><a href="#建议18：构建合理的包层次来管理module" class="headerlink" title="建议18：构建合理的包层次来管理module"></a>建议18：构建合理的包层次来管理module</h2><p>本质上，每一个<code>Python</code>文件都是一个模块，使用模块可以增强代码的可维护性和可重用性。</p><p><strong><code>包</code></strong>    即目录，包含一个<code>__init__.py</code>文件，允许嵌套。包中的模块通过“<strong><code>.</code></strong>”访问符进行访问，即“<strong>包名.模块名</strong>”。</p><ul><li>直接导入一个包</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package</span><br></pre></td></tr></table></figure><ul><li>导入子模块或者子包，包嵌套的情况下可以进行嵌套导入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> package <span class="keyword">import</span> module</span><br><span class="line"><span class="keyword">import</span> package.module</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> package <span class="keyword">import</span> subpackage</span><br><span class="line"><span class="keyword">import</span> package.subpackage</span><br><span class="line"><span class="keyword">from</span> package.subpackage <span class="keyword">import</span> module</span><br><span class="line"><span class="keyword">import</span> package.subpackage.module</span><br></pre></td></tr></table></figure><ul><li><p>包中<code>__init__.py</code>文件的作用</p><blockquote><p>1）使包和普通目录区分；<br>2）在该文件中声明模块级别的<code>import</code>语句，从而使其变成包级别可见；<br>3）通过该文件中定义<code>__all__</code>变量，控制需要导入的子包或者模块。</p></blockquote></li><li><p>使用包的好处</p><blockquote><p>1）合理组织代码，便于维护和使用；<br>2）能够有效地避免名称空间冲突。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在阅读本书之前，强烈建议先仔细阅读：&lt;a href=&quot;https://legacy.py
      
    
    </summary>
    
      <category term="Python" scheme="https://zhangbc.github.io/categories/python/"/>
    
    
      <category term="Python编码规范" scheme="https://zhangbc.github.io/tags/python-coding-convention/"/>
    
  </entry>
  
  <entry>
    <title>【Python编码规范】Python编码入门</title>
    <link href="https://zhangbc.github.io/2019/04/25/python_code91_01/"/>
    <id>https://zhangbc.github.io/2019/04/25/python_code91_01/</id>
    <published>2019-04-25T14:56:39.000Z</published>
    <updated>2019-04-26T16:09:59.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。</p></blockquote><p><strong>温馨提醒</strong>：在阅读本书之前，强烈建议先仔细阅读：<a href="https://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener"><strong>PEP</strong>规范</a>，增强代码的可阅读性，配合优雅的<a href="http://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">pycharm</a>编辑器(开启<code>pep8</code>检查)写出规范代码，是<code>Python</code>入门的第一步。</p><blockquote><p><em>本书主要内容</em></p><blockquote><p>1）容易被忽视的重要概念和常识，如代码的布局和编写函数的原则等；<br>2）编写<code>Python</code>程序管用的方法，如利用<code>assert</code>语句去发现问题，使用<code>enumerate()</code>获取序列迭代的索引和值等；<br>3）语法中的关键条款，如有节制地使用<code>from…import</code>语句，异常处理的几点基本原则等；<br>4）常见库的使用，如按需选择<code>sort()</code>或者<code>sorted()</code>，使用<code>Queue</code>使多线程更安全等；<br>5）<code>Python</code>设计模式的使用，如用发布订阅模式实现松耦合，用状态模式美化代码等；<br>6）<code>Python</code>内部机制，如名字查找机制，描述符机制等；<br>7）开发工具的使用，如<code>pip</code>等各种开发工具的使用，各种代码测试用具的使用等；<br>8）<code>Python</code>代码的性能分析，优化的原则，工具，技巧，以及常见性能问题的解决等。</p></blockquote></blockquote><h2 id="建议1：理解Pythonic概念"><a href="#建议1：理解Pythonic概念" class="headerlink" title="建议1：理解Pythonic概念"></a>建议1：理解Pythonic概念</h2><p>1）<strong><code>Pythonic</code>的定义</strong>：充分体现<code>Python</code>自身特色的代码风格。</p><ul><li><code>The Zen of Python</code>(<code>Python</code>之禅)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>快速排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_quick</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string">    :param array:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    less = list()</span><br><span class="line">    greater = list()</span><br><span class="line">    <span class="keyword">if</span> len(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    pivot = array.pop()</span><br><span class="line">    <span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(array):</span><br><span class="line">        <span class="keyword">if</span> item &lt;= pivot:</span><br><span class="line">            less.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            greater.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sort_quick(less) + [pivot] + sort_quick(greater)</span><br></pre></td></tr></table></figure><p>2）<strong>代码风格</strong></p><ul><li>交换两个变量的值，<code>packaging/unpackaging</code>机制</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2</span></span><br><span class="line">y = <span class="number">3</span></span><br><span class="line">x, y = y, x</span><br><span class="line"><span class="keyword">print</span> x, y</span><br></pre></td></tr></table></figure><ul><li>容器遍历</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(items):</span><br><span class="line">    do_sth_with(item)</span><br></pre></td></tr></table></figure><ul><li>列表逆序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">str_c = <span class="string">'abcdef'</span></span><br><span class="line">print(list(reversed(list_a)))</span><br><span class="line">print(list(reversed(str_c)))</span><br></pre></td></tr></table></figure><ul><li>标准库</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串格式化</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Hello %(name)s!'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Tom'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>注解</strong>：<code>%</code>是非常影响可读性的，因为数量多了之后，很难清除哪一个占位符对应哪一个实参。</p><ul><li><code>str.format()</code>：<code>Python</code>最为推荐达到字符串格式化方法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串格式化, 替代%</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Hello &#123;name&#125;!'</span>.format(name=<span class="string">'Tom'</span>)</span><br></pre></td></tr></table></figure><p>3）<strong><code>Python</code>的包和模块结构</strong></p><blockquote><p>(1) 包和模块的命名采用小写，单数形式且短小；<br>(2)包通常作为命名空间，如只包含空的<code>__init__.py</code>文件。</p></blockquote><h2 id="建议2：编写pythonic代码"><a href="#建议2：编写pythonic代码" class="headerlink" title="建议2：编写pythonic代码"></a>建议2：编写pythonic代码</h2><p>1）<strong>要避免劣化代码</strong></p><blockquote><p>(1)避免只用大小写来区分不同的对象；<br>(2)避免使用容易引起混淆的名称；<br>(3)不要害怕过长的变量名。</p></blockquote><ul><li>实例1（函数名称，变量名意义均不明）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span><span class="params">(list_items, num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param list_items: </span></span><br><span class="line"><span class="string">    :param num: </span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> list_items:</span><br><span class="line">        <span class="keyword">if</span> num == element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>实例2（<strong>推荐</strong>）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_num</span><span class="params">(list_search, num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param list_search:</span></span><br><span class="line"><span class="string">    :param num:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(list_search):</span><br><span class="line">        <span class="keyword">if</span> num == value:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>2）<strong><code>pep8</code>检测工具</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;pip install -U pep8</span><br><span class="line">C:\Users\Administrator\Desktop\zxt&gt;pep8 --first database.py</span><br><span class="line">database.py:83:1: E302 expected 2 blank lines, found 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">pep8 --show-source --show-pep8 waijiao.py</span></span><br></pre></td></tr></table></figure><p>3）<strong>深入认识<code>Python</code>有助于编写<code>Pythonic</code>代码</strong></p><blockquote><ul><li>掌握<code>Python</code>提供的所有特性，包括语言特性和库特性；</li><li>跟进学习<code>Python</code>的最新版本提供的新特性，掌握其变化趋势；</li><li>深入学习公认比较<code>Pythonic</code>的代码，例如<code>Flask</code>、<code>gevent</code>、<code>requests</code>等。</li></ul></blockquote><h2 id="建议3：理解python与C语言的不同之处"><a href="#建议3：理解python与C语言的不同之处" class="headerlink" title="建议3：理解python与C语言的不同之处"></a>建议3：理解python与C语言的不同之处</h2><p>1）<strong>“缩进” 与 “<code>{}</code>“</strong><br><code>Python</code>中使用严格的代码缩进方式分隔代码块，应养成良好的习惯，统一缩进风格，不要混用<code>Tab</code>键和空格。</p><p>2）<strong><code>&#39;</code> 与 <code>&quot;</code></strong><br>在<code>C</code>语言中，二者有严格的区分，但是在<code>Python</code>中，区别较小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.10</span> (default, Jul <span class="number">15</span> <span class="number">2017</span>, <span class="number">17</span>:<span class="number">16</span>:<span class="number">57</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">"He said, \"Hello!\""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2 = <span class="string">'He said, "Hello!"'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1</span><br><span class="line"><span class="string">'He said, "Hello!"'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str2</span><br><span class="line"><span class="string">'He said, "Hello!"'</span></span><br></pre></td></tr></table></figure><p>3）<strong>三元操作符 <code>?:</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span></span><br><span class="line">y = <span class="number">-2</span></span><br><span class="line">print(x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y)</span><br><span class="line"><span class="number">-2</span></span><br></pre></td></tr></table></figure><p>4）<strong><code>switch...case</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = raw_input(<span class="string">"please input a number:"</span>)</span><br><span class="line"><span class="keyword">if</span> n == <span class="string">"0"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"You typed zero."</span></span><br><span class="line"><span class="keyword">elif</span> n == <span class="string">"1"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"You are in top."</span></span><br><span class="line"><span class="keyword">elif</span> n == <span class="string">"2"</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"N is an even number."</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Error!"</span></span><br></pre></td></tr></table></figure><ul><li>用跳转也可以实现：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"0"</span>:  <span class="string">"You typed zero."</span>,</span><br><span class="line">        <span class="string">"1"</span>:  <span class="string">"You are in top."</span>,</span><br><span class="line">        <span class="string">"2"</span>:  <span class="string">"N is an even number."</span></span><br><span class="line">    &#125;.get(n, <span class="string">"Error!"</span>)</span><br></pre></td></tr></table></figure><h2 id="建议4：在代码中适当添加注释"><a href="#建议4：在代码中适当添加注释" class="headerlink" title="建议4：在代码中适当添加注释"></a>建议4：在代码中适当添加注释</h2><p><code>Python</code>有3种形式的代码注释：<code>块注释</code>，<code>行注释</code>，<code>文档注释(docstring)</code>。</p><blockquote><p>(1）使用块或者行注释的时候仅注释复杂的操作，算法，难以理解的技巧或者不够一目了然的代码；<br>(2）注释和代码隔开一定的距离；<br>(3）给外部可访问的函数和方法添加文档注释(<code>docstring</code>)（<code>&quot;&quot;&quot; &quot;&quot;&quot;</code>）；<br>(4）推荐文件头部包含<code>copyright</code>申明，模块描述等。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Requests HTTP library</span></span><br><span class="line"><span class="string">~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="string">Requests is an HTTP library, written in Python, for human beings. Basic GET</span></span><br><span class="line"><span class="string">usage:</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; import requests</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; r = requests.get('https://www.python.org')</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; r.status_code</span></span><br><span class="line"><span class="string">   200</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; 'Python is a programming language' in r.content</span></span><br><span class="line"><span class="string">   True</span></span><br><span class="line"><span class="string"><span class="meta">... </span>or POST:</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; payload = dict(key1='value1', key2='value2')</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; r = requests.post('http://httpbin.org/post', data=payload)</span></span><br><span class="line"><span class="string">   &gt;&gt;&gt; print(r.text)</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">     ...</span></span><br><span class="line"><span class="string">     "form": &#123;</span></span><br><span class="line"><span class="string">       "key2": "value2",</span></span><br><span class="line"><span class="string">       "key1": "value1"</span></span><br><span class="line"><span class="string">     &#125;,</span></span><br><span class="line"><span class="string">     ...</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">The other HTTP methods are supported - see `requests.api`. Full documentation</span></span><br><span class="line"><span class="string">is at &lt;http://python-requests.org&gt;.</span></span><br><span class="line"><span class="string">:copyright: (c) 2015 by Kenneth Reitz.</span></span><br><span class="line"><span class="string">:license: Apache 2.0, see LICENSE for more details.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="建议5：通过适当添加空行使代码布局更为优雅，合理"><a href="#建议5：通过适当添加空行使代码布局更为优雅，合理" class="headerlink" title="建议5：通过适当添加空行使代码布局更为优雅，合理"></a>建议5：通过适当添加空行使代码布局更为优雅，合理</h2><p><strong><code>Python</code>代码布局应当遵循以下基本规则</strong>：<br>1）在一组代码表达完一个完整的思路之后，应该用空白行进行间隔；</p><ul><li>反例（多余空行）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> guess == number:</span><br><span class="line">    print(<span class="string">"Good job!"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Nope"</span>)</span><br></pre></td></tr></table></figure><p>2）尽量保持上下文语义的易理解性(如调用函数写在被调用函数之上)；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    B()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>3）避免过长的代码行，每行最好不要超过80个字符，超过的部分可以用圆括号、方括号、花括号等进行连接，并保存行连接的元素垂直对齐；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="string">'This is a verey long string.'</span></span><br><span class="line">     <span class="string">'It is used for testing line limited characters'</span>)</span><br></pre></td></tr></table></figure><p>4）不要为了保持水平对齐而使用多余的空格，同时也不要在一行有多个命令；</p><ul><li>反例（多余的空格）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x =                    <span class="number">5</span></span><br><span class="line">Year =                 <span class="number">2013</span></span><br><span class="line">name =                 <span class="string">"Jam"</span></span><br><span class="line">d2 = &#123;<span class="string">'spam'</span>: <span class="number">2</span>, <span class="string">'eggs'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>反例（一行中多个命令）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = <span class="number">1</span>; Y = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>5）空格的使用要能在需要强调的时候警示读者：<br>（1）二元运算符、比较、布尔运算的左右两边应该有空格；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>（2）逗号和分号前不要使用空格；</p><ul><li>推荐</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="number">4</span>:</span><br><span class="line">    print(x, y)</span><br><span class="line"></span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><ul><li>反例（不推荐）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="number">4</span> :</span><br><span class="line">    print(x , y)</span><br><span class="line"></span><br><span class="line">x , y = y , x</span><br></pre></td></tr></table></figure><p>（3）函数名和左右括号之间，序列索引操作时序列名和<code>[ ]</code>之间不要空格，函数默认参数两侧不需要空格；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_quick</span><span class="params">(array, if_print=<span class="number">0</span>)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">arrays = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure><p>（4）强调前面的操作符的时候使用空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-2</span> - <span class="number">5</span></span><br><span class="line">b*b + a*a</span><br></pre></td></tr></table></figure><h2 id="建议6：编写函数的4个原则"><a href="#建议6：编写函数的4个原则" class="headerlink" title="建议6：编写函数的4个原则"></a>建议6：编写函数的4个原则</h2><p><strong><code>函数</code></strong> 能够带来最大化的代码重用和最小化的代码冗余，不仅可以提高程序的健壮性，还可以增强可读性，减少维护成本。</p><p>1）<strong>函数设计尽量短小，嵌套层次不宜过深(最好控制在3层以内)</strong>；</p><p>2）<strong>函数声明应该做到合理，简单，易于使用</strong>；</p><p>3）<strong>函数参数设计应该考虑向下兼容</strong>；</p><p>4）<strong>一个函数只做一件事，尽量保证函数语句粒度的一致性</strong>。</p><h2 id="建议7：将常量集中到一个文件"><a href="#建议7：将常量集中到一个文件" class="headerlink" title="建议7：将常量集中到一个文件"></a>建议7：将常量集中到一个文件</h2><p><code>Python</code>使用常量：</p><blockquote><p>通过命名风格来提醒使用者该变量代表的意义为常量，如常量名所有字母大写，用下画线连接各个单词；<br>通过自定义的类实现常量功能。</p></blockquote><ul><li>示例：<code>const.py</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_const</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConstError</span><span class="params">(TypeError)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConstCaseError</span><span class="params">(ConstError)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__dict__.has_key(name):</span><br><span class="line">            <span class="keyword">raise</span> self.ConstError, <span class="string">"Can't change const.&#123;name&#125;"</span>.format(name=name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.isupper():</span><br><span class="line">            <span class="keyword">raise</span> self.ConstCaseError, <span class="string">'const name "&#123;name&#125;" is not all uppercase'</span>.format(name=name)</span><br><span class="line">        self.__dict__[name] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys.modules[__name__] = _const()</span><br></pre></td></tr></table></figure><ul><li>调用实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> const</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const.COMPANY = <span class="string">"IBM"</span></span><br><span class="line">print(const.COMPANY)</span><br><span class="line"></span><br><span class="line">const.COMPANY = <span class="string">"IBM2"</span></span><br></pre></td></tr></table></figure><ul><li>上述调用会报错，因为代码中的常量一旦生成便不可更改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/algorithm_sort.py"</span>, line <span class="number">40</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    const.COMPANY = <span class="string">"IBM2"</span></span><br><span class="line">  File <span class="string">"/home/projects/pythoner/quality_code/const.py"</span>, line <span class="number">18</span>, <span class="keyword">in</span> __setattr__</span><br><span class="line">    <span class="keyword">raise</span> self.ConstError, <span class="string">"Can't change const.&#123;name&#125;"</span>.format(name=name)</span><br><span class="line">const.ConstError: Can<span class="string">'t change const.COMPANY</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《编写高质量代码-改善Python程序的91个建议》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提醒&lt;/strong&gt;：在阅读本书之前，强烈建议先仔细阅读：&lt;a href=&quot;https://legacy.py
      
    
    </summary>
    
      <category term="Python" scheme="https://zhangbc.github.io/categories/python/"/>
    
    
      <category term="Python编码规范" scheme="https://zhangbc.github.io/tags/python-coding-convention/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（七）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_08/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_08/</id>
    <published>2019-04-22T14:53:30.000Z</published>
    <updated>2019-04-22T15:00:36.255Z</updated>
    
    <content type="html"><![CDATA[<p>弹指一瞬，已是四年没有更新这个系列的东西，想说的太多却欲言又止，生活的磨练快让我认不得从前的自己了，今日此时此刻翻阅了一下以前的关于自己的想法与历程，觉得有必要继续这个系列的话题了，以记录自己最真实的生活状态，人生旅程漫漫，不能没有梦，不能忘了原有的动力，即使穷生活也得还原生活的本真，揭开虚伪的面纱，还自己一个最真实的人生。</p><p>大学毕业快五年，我一直没有忘记思考自己想要什么样的生活？其实我还是没有想太明白，从不怕被人抛弃，也不怕人笑话，其实我对金钱一直是比较抵触的，但当听说很多朋友已买房的时候，我开始慢慢怀疑自己是不是有点另类了，多少人为了一套房子煞费苦心，得到了之后却并没觉得开心？虽然他们负债累累，谨小慎微的过着余生可数的日子，但是他们实现了人生一个小小的目标，而且时间不算太长。再回头审视自己，从学校出来，拿着微薄的薪水，带着一颗自卑的心，一直就这么撑着，因为身体的原因，还有倔强的性格，一丝丝不甘心的愿望，顿时觉得自己被时代抛弃了美好的青春年华。殊不知是自己缺少一颗闯进的心，缺少一个真正的规划的人生目标，2014年错失了一次从头再来的机会，那些所谓贷款的还款计划，今日想起来，着实应证了那句话，贫困限制了你的视野。穷怕了，连一个利息钱都不想多付一分，如果时时刻刻算着自己的经济账，那如何超脱自己，达到不受金钱的束缚？</p><p>毕业就知道，三年一个小坎，五年一个大坎，跳过了就成功了，没有跳过注定平庸，至少一段相当长的时期会过着不是自己想要的生活。其实毕业这五年，我算是平庸得不能在平庸了，但是至始至终有一颗不甘平庸的心。2013年得力于同窗的举荐进了一家不大不小的医药物流企业做ERP技术支持，从零开始，从维护一个简易的电商平台再到一个分公司ERP业务系统再到整个公司ERP系统，不足一年就已完全掌控，对ERP流程优化，业务系统改造，与部门有效沟通均出了应有之力。尽管如此，对当时的生活状态还是不满意，工资低不说，主要感觉还是无法满足自己的学习欲望，于是乎，各种倒腾自己的业余生活尝试新技术的学习，还是想做一名合格的码农。2014年4月同事离职，两个人的工作推到了我一个人身上，经一个月的调整，也算平稳过渡，就这么撑到了2015年4月离开。其实对我来说得到了极大了锻炼价值，从中慢慢体会了许多东西，什么事情分轻重缓急，哪些任务需要主次分明，哪些工作项得有条不紊，只有亲身体验了方可知其中的奥妙。在这家公司，让我学会了做事，技术没有收获多少，做事的思维大有提升。2015年4月离职，去了上海，原本是拜师傅去的，仅仅半个月由于自己基础实在是太薄弱，最后夭折，开始寻下一份工作。这辈子一定要尝试自己想做的工作，想过的日子，哪怕没钱，哪怕遭无数人鄙视，一定要去做，必须去满足自己小小的虚荣心，哪怕只有一天，无论付出多大的代价。这是我拜师最大的收获，认识了一位开发大神（也是我同乡），后来离开也拒绝了他给我的半个月薪水，不为别的，就为一个承若：干不好，分文不取，拍屁股走人。他给了我很多建议，受益匪浅，时至今日，我们依然保持着联系，我依然能感受他对我无微不至的关怀。花了一个月的时间，拿到两个比较中意的offer，因不想重拾ERP技术，拒绝了业界许多好心人的推荐，当时的想法就是宁可无工作也不去走老路，一定要坚持自己的信念。经过两家工作性质对比思考，最终选择了薪资较低而且极为陌生的领域，开始决定摸爬滚打。技术用上了我业余的学习所得，当然也没有排除我之前掌握的核心技术栈。说是开发工程师，其实进来才发现也不是那么回事，各种杂活脏活还是由我一个人做，创业公司嘛，坑不少，想想能锻炼人，能感受一波创业的辛酸史，便留下了断了其他念头，老板在吃喝玩乐方面也比较阔气。在这家公司最大的感受就是，创业不易，且行且珍惜，要有危机意识，时时刻刻保持一颗清醒的头脑，一句话谨记，逆水行舟不进则退。其实生活工作亦如此。后来，感觉老板心态变了，不断画饼(平生最恶此举)，我就离开了。期间认识了不少人，见识了不少场合，逢场作戏太多，越来越觉得当初毕业拒绝考虑医院单位是明智之举。2015年5月至2017年4月，就这样结束了我的第二份工作，即将有幸迎来我的第三份工作—我在一家互联网金融的创业公司担任爬虫工程师，算是一个真正入门的coder，又一个全新的挑战。从上海转战武汉，回武汉也是我的一个想法—离家进了一小步，故人在，朋友常聚，情谊永存，工作之外，还需要倒腾一下生活，我是一个极度恋旧情的人，很难和新朋友结交为知己。很赞赏那句“人生得一知己足矣”，但是心里还是不乐意这么去想，我始终坚持人之初性本善的理念，只要敞开心扉，就能拥抱世界，拥抱未来。</p><p>面对一个真实的自己，细细回味着自己走过的路，顿时发现自己还是那么的倔强，尝试混迹于各种领域，生活却多了几分艰辛，坚决不留后路，至于生活到底过得如何，我还是靠着勇气战胜了自己，若能克服自卑的心理，或许我的各种尝试才会体现其应有的价值。浪费青春也罢，折腾生活也好，我无怨无悔，我会一如既往地带着人生最初的问题走下去。牛人，就是走到哪里都有可用武之地，都有金钱可挥霍，都有很多有意义的事情等着他去完成。我不是牛人，但我相信这样的人生理念，从一个小白做起，不怕丢失工作，唯恐没有勇气胜任工作。</p><p>by zhangbc<br>2018-04-24</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;弹指一瞬，已是四年没有更新这个系列的东西，想说的太多却欲言又止，生活的磨练快让我认不得从前的自己了，今日此时此刻翻阅了一下以前的关于自己的想法与历程，觉得有必要继续这个系列的话题了，以记录自己最真实的生活状态，人生旅程漫漫，不能没有梦，不能忘了原有的动力，即使穷生活也得还原
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（六）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_07/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_07/</id>
    <published>2019-04-22T14:39:55.000Z</published>
    <updated>2019-04-22T14:51:53.849Z</updated>
    
    <content type="html"><![CDATA[<p>晃晃悠悠又是一年时，该到了总结与反思的时候了。想想当初的豪情壮志，如今却被时间磨平了，淡化了，可笑？可恨？可惜？可怜？这一年，不知道用什么言语表达，用什么词汇来描绘，单单是工作那么简单，抑或生活的平淡无奇，或许吧，生性贪婪而又好懒的我，真的不知道怎么总结这一年的得失？该是静下来好好思索思索的时候了，人无远虑，必有近忧。我始终认为人之所以与一般动物有别，就在于思维，靠着自己的思考实现自己应有的价值，思维的宽度决定了人的高度，思维的深度决定了人的价值。活着，本身就体现了一种非凡的价值。基于这个信念，我觉得有必要坦诚地面对现实，做好自己，别人的永远不会是自己的，但是世界是属于每个人的，不要忘却拼搏，终有一天会得到应有的回报。</p><p>这一年，从生活上得到的，工作中学到的，自己充电了解到的，都或多或少懂得了一些东西，少了一些面对未来的恐惧，多了一些生活的切身感悟，不再感怀生活，隐隐约约感到了一种无形的压力，迫使我继续前进，管他前面什么玩意儿，只要知道自己在干什么就足够了。规划赶不上变化，这不叫规划，凡是有成就的人，无不例外的实现了自己的既定目标，按着规划一步一步地去实践了，最后得以收获。所以，像我这样的小罗罗，注定成就不了所谓的事业，至少目前的这种态度，因为现实生活告诉我，成功容不得半点借口，今天计划的事情拖到明天，请问时间会倒流吗？对照一下13年的计划（参见13年终总结《2013与2014之流水》），顿时感慨良多。</p><p>1，补2013的读书空白。</p><p>这个做了一些，但还是严重不足，零零散散涉足了七八本（PDF，包括在读的），接触了Python，MySQL，学习不够深入。</p><p>2，每天坚持听一下VOA，抽点时间学习一下英语；(这一点做得非常差，逢考必败的根源所在) </p><p>这个做的稀烂，死活坚持不下来，不是没有用，订阅的SQLServerCentral没有研读过，稍微看过几篇，东西确实不错，老外就是老外，干货多多。IT不学真不行，永远了解不了最新的东西，最实在的东西。</p><p>3， 计划一次旅行。</p><p>玩嘛，我想这个毫无疑问实现了，时间虽短，但也算是达到了预期的效果，开开眼界，找找年轻疯狂的感觉，我想应该知足了，有游记见证，但是还欠一篇拙作，关于看电影引发的个人思考。</p><p>4，深入SQL学习，做一个SQL学习系列，这也是14年部门分下的培训任务。 </p><p>这个系列没有做，多多少少学了一些，缺乏系统性，至于什么原因，我不想辩解，多说无益。部门人员异动，所谓的培训任务也就不了了之。</p><p>5，独立开发一到两个有价值的系统。 </p><p>初生牛犊不怕邪，尽管雄心勃勃的做了个小系统（博客为证），由于种种原因，还是没有最终使用。这也没干好，那也没有做成，我究竟干了些什么呢？ </p><p>1，同事四月辞职，当时对业务系统还是没有多少头绪，交接的时候很多事情还是模棱两可，两个人的事情突然让我一个新手来做，顿时感到惶惶不可终日，不能怠慢了各路”神仙“，否则吃不了兜着走。 经过一个月的挣扎，算是基本搞定，平稳过渡，工作从开始的畏手畏脚到现在有的放矢。这或许就是所谓的成长吧，要想彻底的深入掌握ERP，我想还远远不够格，技术需要的不多，其实真正高大上的东西未必能普及到企业中去，ERP关键在于对业务的梳理，流程的理解，随业务的变化而变化，认识—&gt;理解—&gt;掌握—&gt;优化，看起来极其容易，做起来却百般不易。在维护的过程中，我逐渐明白一个道理，呆呆地坐在电脑前是开发不了用户满意的软件的，只有现场勘查，调研，充分理解用户实在的需求，站在用户的角度去探究解决问题的模型，我想即使做不到优秀，至少可以让用户用得满意，用得舒心。切忌，空对空的进行需求交流，分析，这是达不到效果的，最终的结果只会陷入bug—&gt;modify—&gt;bug—&gt;modify的泥潭。</p><p>2，生活，其实这没什么好说的，平淡无奇，掀不起半点涟漪。中秋，看了下同学，顺道和亲人过个团圆节，国庆，游了下西湖，走访了一位对我非常有影响力的叔叔，可以这么说，从小学到初中，我从他身上学到了不少东西，跟我讲作业，陪我玩象棋，与我谈未来，每逢寒暑假，只要他在家，我几乎是没有离开过他，对我的生活起着潜移默化的作用。 有这样一位指引者，我是多么的幸运啊！成年了，我们再也不是小孩子了，正因为如此，我们开始忙碌起来，忘记与亲人联系，忘记与朋友聊天，老婆老公，房子车子等一系列话题开始渐入我们的生活，心随之浮躁起来，开始了一些功利化的行为，从此联系似乎带了一种色彩，不再单纯了。疏于亲人，远于儿时最好的玩伴，只要不要同一个城市，作为朋友遗忘的概率极大，新建一个圈子，开始一种新的生活。或许我是一个比较喜欢恋旧的人的缘故吧，总感觉这样不太好，但是又不知如何是好？歌词唱得好：结交了新朋友，别忘了老朋友。感情，是个神奇的东西，它能牵动一个人的每根神经，或远或近，总有一种思念，偶尔总会情不自禁地拿起手中的电话拨拨最熟悉的号码，如果有一天不再联系，我无法想象我的生活有多么凄凉，不会聊谈了，嘴笨了，也许号码就不知不觉地没了，生活与感情，随缘吧。整个年度中，基本保证每周跟外公一次通话，跟父母一次通话，其他亲朋好友随机打，每个月电话费不低于100元，有些人常年未通电话，并非代表我们之间缘分已尽。</p><p>3，关于学习，这点确实做得很糟糕，博客数数几篇，寥寥几语，没有含金量，怎么能这样么？Python学习了基本语法，MySQL写点增删改查，多多接触，多多益善，这是个大忌。贪多必失， 用不到，学得多，忘得快，这个经典教训，一定要要牢记。多做笔记，做做分享，向大牛看齐，选一个切入点深入进去，真正学会融会贯通，做好知识储备，经历了一年的摸索，该是清醒的时候了。</p><p>4，关于经济目标，14年的规划是一年搞定助学贷款，今年实际完成是50%，弥补了去年的负债，再者向家里还了一笔债务，回家过年备点，基本上一年微薄的薪水就OK了， 存钱是没戏了，毕业三年内，我没有希望能存多少，但愿没有虚度光阴，实际还是虚度了一年。</p><p>2014年就这么过去了，总之是离目标有很大差距，主要原因是自己自制力不够，计划过于完美，难以实现。展望2015，希望有一个不一样的收获，所以，规划还是要有的。基于自己贪婪的性格，有必要重新审视一下，计划规划不能是一纸空文。走过的路，见过的人，做过的事，尽量留留痕迹，免得回头追问时间又去哪儿了？延续大四后期的坏习惯，看了大量的战争片，2015年再也不能这样了，否则真的玩完了。</p><p>谨记于此，以警示自己，误入歧途不能自拔，2015年应该没有什么大风浪，没有什么大动作，平平静静，充实365天，多多努力才是王道。</p><p>by zhangbc<br>2014-12-30</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;晃晃悠悠又是一年时，该到了总结与反思的时候了。想想当初的豪情壮志，如今却被时间磨平了，淡化了，可笑？可恨？可惜？可怜？这一年，不知道用什么言语表达，用什么词汇来描绘，单单是工作那么简单，抑或生活的平淡无奇，或许吧，生性贪婪而又好懒的我，真的不知道怎么总结这一年的得失？该是静
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（五）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_06/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_06/</id>
    <published>2019-04-22T14:28:05.000Z</published>
    <updated>2019-04-22T14:35:43.822Z</updated>
    
    <content type="html"><![CDATA[<p>上班已有几天了，可是思绪似乎还是停留在十一之行，也许是没有长大的表现，也许是该为这次的所见所闻记下点什么，一种发自内心的声音不停告诉自己，利用有限的时间，拿起一支拙劣的笔，为那个时刻，为已流失的光阴做一些补救脚印吧。此次杭州之行，收获还是蛮大的，且不说杭州风景，杭州美女，我只想说说杭州给我烙下的一个又一个印象。美丽杭州，说得一点也不过，或许在杭州，让我真真切切地感受到了中国梦的一步步逼近。当然，遇到的某些奇葩，我也就不提了，权且当他们小市民无知吧。</p><p>十一，我们花了一整天的时间，沿着西湖的河堤走了很长很长的一段路，西湖如西子，杭州佳人多，风景确实很美，感受在心灵，风景的描述及其感受，恕难从笔，我不擅长优美的散文故事。此篇所探讨的是国庆遇到的一系列的故事。早上，八点出发，坐7路公交，人多拥挤，这是每个城市的最大亮点。提到公交，我不得不感叹下武汉的公交，车猛，两车之间几乎可以保持零距离，人更猛，即使夹在门缝也不愿意下车，真正是做到了“敢为人先”的大无畏精神。相对于武汉，杭州公交略显宽松一点，我们在来回西湖的路上还能找个座位坐坐，恐怕这个待遇在武汉难得，至少我的印象很少，尤其在火车站赶坐公交，或者校门口坐公交，基本都是一路站到底。这或许就是城市生活，几许烦恼几多喜吧。这次出行，让我彻底感到无语的公交是在湖州长兴县城，一下子让我回到了高中时代的县城公交，破就不多说了，可恨的是25分钟一趟，沿途不报站，招手即停，更让你意想不到的是终点站还是高铁站。高铁都有了，还没钱改善一下公交么？从高铁站下来，遇上这样的公交，让我产生无限联想，县城企业无数，高大上的政府大楼（据说30亿建成），我还能说些什么呢？遇到这样的县城，只能是为该城百姓哀其不幸了。想想我们那个穷乡僻壤的小县城，这点还算是好的，年年在改善中，变化中……总体来说，杭州的公交还算不是太拥挤，或许我们赶上最疯狂的那一路吧，暂且留个好印象。</p><p>十一晚上，由于一切临时决定，算是做到了随心所欲，疯到了极点，到处招手打的，各路的士哥都把我们给拒绝了，原因是我们离我们所去之处比较近，不愿意送我们，还好心跟我们顺便指了一下方向。我们靠着导航瞎摸也不是个事儿，最后还是让两辆超破的摩的小坑了一把，以每人10元送我们去电影院，也在这里遇到了奇葩，姑且让我作个怪吧，建议出行尽量少做摩的，每个地方的摩的都不是省油的灯。十一点打的，由于是第一次，怕踩大坑，问了是打表还是一口价，说是打表，那没得说了，毕竟我们三个人都是第一次来这里，随便吧，反正我是抱着被坑的心态上车的，再说时候也不早了，离订房处还有一段相当的路程。为什么我是这种心态？说实在的，我对这些司机的故事早有耳闻，打表绕着走，一口价近道飞奔。四年前，在深圳，就这么深深地被坑了一次。上车和司机寒暄了几句，感觉司机人还算靠谱，下车20元，不算坑，毕竟快凌晨了，在某些地方，我想司机肯定会狠狠宰我们一次，毕竟一看我们就是外来主儿。相比摩的，我心里舒坦多了。接下来的三次的士都是这个价，路程不算太近，想到回家过年问起的士价格，真的感觉自己就是一个外乡人，被宰的主儿。从与司机的寒暄中，感受到了杭州人的生存压力，浙江富有，温州老板遍布神州大地，“5~6万的房价楼盘一天被抢空”，这话不管是不是含水分，含多少水分，但是能让我真正感受到杭州的生活成本不会太低，建筑极具特色。城市公共设施建设比较好，电影院随处可见，第一天费劲地找了两三家，第二天顺眼目睹了两三家。有住的就有吃的，有吃的就有乐的，有乐的就有游的，这或许就是杭州给我的一个印象吧。还有一点收获，是在钱塘江边上无意的收获，那就是漂流书屋，公共书屋，城市中能看到长廊边有这样的书亭设施，恐怕不多见，可以默默地感受一下杭州的城市文化建设。很多时候，谈及文化建设都感觉是知识分子的事情，老百姓能温饱就不错了。其实生活离不开文化，与人交流，感受生活，文化无处不在，与大师交流，心里豁然开明，与同龄人畅谈生，人生向往无限，与父辈交心，真真实实感受生活的酸甜苦辣，作为新一代的穷屌丝，文化不应该成为高大上的东西，我觉得有必要丰富一下自己的文化美餐，应该让文化实实在在地融入我们的日常生活，生活有向往，有期待，才有源源不断的奋斗的动力。但是杭州书亭美中不足的是，有书屋，书很陈旧，很少有人去翻阅，我随手翻看了一本书叫《麻雀》，屠格列夫著，这是当年小学四年级的一篇课文，讲述了一篇关于母爱的故事，印象非常深。记得当时读不懂，老师从教案中跟我们朗读课文中省去的那一部分时，我们更是一股脑的傻了。母爱，是一个伟大的话题，我很庆幸，我有一位勤恳和善仁慈，任劳任怨的母亲，只是感觉亏欠她太多太多……再次，翻开这篇课文，想到昨日的电影，心情顿时沉重了不少。</p><p>本次国庆之行，算是毕业后比较满意的一次旅行，杭州，长兴，两个不同的城市，两种不同的心境，收获却不是二的。浮浮躁躁的心，不知道又丢失了多少瞬间的灵感，不巧赶上工作的繁忙季，又不想丢失这些美好的记忆，所以还是记下来吧。写着写着，不曾想成了一篇回忆之作。</p><p>by zhangbc<br>2014-10-09</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上班已有几天了，可是思绪似乎还是停留在十一之行，也许是没有长大的表现，也许是该为这次的所见所闻记下点什么，一种发自内心的声音不停告诉自己，利用有限的时间，拿起一支拙劣的笔，为那个时刻，为已流失的光阴做一些补救脚印吧。此次杭州之行，收获还是蛮大的，且不说杭州风景，杭州美女，我
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
  <entry>
    <title>【心路历程】做好自己，面对现实（四）</title>
    <link href="https://zhangbc.github.io/2019/04/22/myself_05/"/>
    <id>https://zhangbc.github.io/2019/04/22/myself_05/</id>
    <published>2019-04-22T14:06:46.000Z</published>
    <updated>2019-04-22T14:36:41.331Z</updated>
    
    <content type="html"><![CDATA[<p>水光潋滟晴方好，山色空蒙雨亦奇。<br>欲把西湖比西子，浓妆淡抹总相宜。<br>    ———-苏轼.《饮湖上初晴后雨》</p><p>一次疯狂的旅行，一次没有规划的旅行，一群不靠谱的靠谱的旅行， 除此之外，我实在是找不到什么适合的言语来表达这次国庆之行了。岁月总是在不经意的手指尖划过，用心去捕捉生活一瞬间的美，认认真真地感受其中的乐趣，我想这才是我所期盼的生活吧。写作的灵感也就来源于那一刹那之间，仔细回想学生时代，每当写作文的时候，真的就是这么一回事，其实生活亦如此，此次的国庆之行更是如此。</p><p>关于国庆之行的最初构想，是由大学班长何伟同志提出的，我只是从旁提提意见，准备十一回武汉聚聚，然后找个景点游哉悠哉。毕业一年了，大家是该聚聚的时候了，说长不长的一年，相信大家经历了很多，也收获了很多，相互叨叨，未必没人不期待吧。为此还特地，班长建了一个群，叫“十一去哪儿”，刚开始那会，激情四起，我心中甚喜，提前了一个月跟部门老大说十一想请假（要知道节前假后请个假有多么困难）。临近九月中旬，再次确定人数的时候，发现就不是原来那么回事了，各有各的忙，离别时难聚更难，相聚是多么不容易啊！没有闲人，既然如此，不必强求，也无须介怀，匆匆之间的生活，理解万岁。说实在话，我的内心依然不甘，计划的十一出行难道真的就要被不能班聚而葬送吗？思来想去，还是不甘心，十一不出行又能干嘛呢？他们都忙， 我闲人一个，那就一个人漂泊了，避远就近，人在苏州，苏杭苏杭，那就杭州了。所以一个人就默默地买好票了。原本不想打扰别人已有的安排，这实在不是我的风格，不强求于人，一切随心所愿的好。可我还是没有忍住，问了下何伟，令我意想不到的是他已经买好回家票了，三言两语，他也改签了去往杭州的高铁票，谁叫我们是好哥们呢？算是坑，也愿跳。9月13日，杭州的票就这么定了，最坏的打算是两个爷们独闯杭州，不为别的，只为西湖。期间，我们也各自咨询了很多亲们，问有没有意向去？回复都是模棱两可的，一句话，不靠谱。不靠谱就不靠谱吧，希望与现实总是存在差距的，那就算一次不靠谱的旅行吧。但是我依然没有放弃寻求伙伴的机会，直到9月27日，一条好友的说说振奋了我，平时少聊天，这次竟然答应得如此爽快，让我惊喜让我意外，此次旅行总算不是纯爷们的队伍了，振奋人心啊！杭州附近的城市，费费劲还是搞到了30日的火车票，算是尘埃落定了。</p><p>30日下午，三人分别从不同的三个城市（无锡，杭州，马鞍山）出发，经历火车时间也差不多（5H），就这么开始这次疯子旅行。说是一群疯子，其实也不过，列几个事实，疯不疯，看着说吧：</p><p>一，30日晚上相聚约九点，找个餐馆就餐，边吃边聊，彼此熟悉熟悉，然后开始找房子。都说人多不好找，我们也确实找了一阵子，十点多找到了。</p><p>二，第二天八点出发，临时看公交，上车，游西湖，随身没有一张地图，只是问了一下团价，觉得太贵，没报，索性两腿跑西湖，一天下来，跑的地点有：三潭印月，博物馆，雷峰塔（人多，没有买门票），钱王祠，苏堤（2.8公里，没走完），花巷观鱼，曲院风荷。小有遗憾，六点多出大门未见音乐喷泉。西湖之景，美不胜收，知足就行，开心便罢。开始寻找吃饭的地方，疯疯癫癫地走了不少路，耗时不少，总算找到一家快餐自助餐厅了。</p><p>三，原想着，吃罢饭，该找住的地方，十一游客特多，房子有限，没想到<em>*</em>来了一句，我们去看电影吧。快八点了，我们连电影院都不知道在哪儿，两部手机开始疯狂地搜索，好不容易找到号称浙江省最大的电影院——胜利剧院，话说今天没票了。不达目的决不罢休。又一次次探索，功夫不有心人，错过了《黄金时代》，迎来了《亲爱的》，九点25分准时上演了。</p><p>四，看完电影，十一点二十分了。我们还能找到住宿吗？我们真的要睡大街吗？我们真的要夜行杭州城吗？真的，这点着实让人担心，又是两部手机的开始漫无目标地搜寻，电话咨询，我的电话下午就关机了，电源准备不足（出行的亲们，引以为戒）。时至凌晨，我们找到价格不高不低的房子，说实在的，个人感觉杭州的租房价格有点奇葩，单间竟然和标准间一个价，或许我孤陋寡闻了吧。</p><p>五，第二天一觉睡到八九点，去了钱塘江，真不是时候，空荡荡的。然后，我们又开始找吃的，不能白来杭州，游的（西湖），乐的（亲爱的），就剩吃喝了。 找了一家比较远的自助餐人均价69元/人，对于我们这几个穷屌丝而言还是可以接受的。下午五点陆续离开杭州，杭州，我们不虚此行。</p><p>一篇流水记，即将尾声。写的总是没有亲身经历的来得实在，来得刺激，来得更有价值。许多事情看起来就那么回事，实际上做起来还真不是那么回事，其中的付出，艰辛与快乐并存，恐怕只有当事人才能真真切切地感受了。用朋友的一句话，那就是——一切尽在不言之中。十一行，算是圆满了，完成了我2014年的旅游计划，聚聚聊聊的目的也算达到了，在此特别感谢二位至亲的鼎力相助，我们共同实现了”西湖梦”。这一次疯子旅行，不靠谱的旅行，给我的收获远不止这些，疯疯狂狂的旅行，简简单单的生活，实实在在的人生，何忧之有？</p><p>最后，来一张具有纪念意义而且大家都见过的小照，以此证明我们的西湖之行：</p><p><img src="/images/myself_04_20190422.jpeg" alt="三潭映月"></p><p>by zhangbc<br>2014-10-06</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;水光潋滟晴方好，山色空蒙雨亦奇。&lt;br&gt;欲把西湖比西子，浓妆淡抹总相宜。&lt;br&gt;    ———-苏轼.《饮湖上初晴后雨》&lt;/p&gt;
&lt;p&gt;一次疯狂的旅行，一次没有规划的旅行，一群不靠谱的靠谱的旅行， 除此之外，我实在是找不到什么适合的言语来表达这次国庆之行了。岁月总是在不经意
      
    
    </summary>
    
      <category term="心路历程" scheme="https://zhangbc.github.io/categories/mental-journey/"/>
    
    
      <category term="心路历程" scheme="https://zhangbc.github.io/tags/mental-journey/"/>
    
  </entry>
  
</feed>
