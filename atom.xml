<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天堂的鸽子</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangbc.github.io/"/>
  <updated>2019-04-22T11:37:46.818Z</updated>
  <id>https://zhangbc.github.io/</id>
  
  <author>
    <name>Bocheng Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【数据库实践】T-SQL语言及其存储过程</title>
    <link href="https://zhangbc.github.io/2019/04/22/db_tsql_procedure/"/>
    <id>https://zhangbc.github.io/2019/04/22/db_tsql_procedure/</id>
    <published>2019-04-22T00:35:17.000Z</published>
    <updated>2019-04-22T11:37:46.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p><blockquote><p>课本第11～13章主要知识点</p></blockquote></blockquote><h2 id="一，T-SQL语言"><a href="#一，T-SQL语言" class="headerlink" title="一，T-SQL语言"></a>一，T-SQL语言</h2><p><code>T-SQL</code>语言是<code>Microsoft</code>公司在关系型数据库管理系统<code>SQL Server</code>中的<code>SQL-3</code>标准的实现，是<code>Microsoft</code>公司对结构化查询语言(<code>SQL</code>)的扩展。<code>T-SQL</code>语言是一种交互式的语言，具有功能强大，容易理解和掌握等特点。</p><p>1，<strong>数据定义语言(<code>DDL</code>)</strong>：<code>DDL</code>是指用于定义和管理数据库及数据库中各种对象的语句，包括<code>create</code>，<code>alter</code>，<code>drop</code>等。</p><ul><li><p>创建表的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure></li><li><p>增加列的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 列的描述</span><br></pre></td></tr></table></figure></li><li><p>删除列的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">column</span> 列名</span><br></pre></td></tr></table></figure></li><li><p>修改列定义为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">alter</span> <span class="keyword">column</span> 列名 列的描述</span><br></pre></td></tr></table></figure></li><li><p>删除表的语句格式为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure></li></ul><p>2，<strong>数据操纵语言(<code>DML</code>)</strong>：<code>DML</code>是指用于查询，添加，修改和删除数据库中数据的语句，包括<code>select</code>，<code>insert</code>，<code>update</code>，<code>delete</code>等。</p><p>3，<strong>数据控制语言(<code>DCL</code>)</strong>：<code>DCL</code>是指用于设置或更改数据库用户或者角色权限的语句，包括<code>grant</code>，<code>revoke</code>，<code>deny</code>等。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给所有用户授予select权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> student <span class="keyword">to</span> <span class="keyword">public</span></span><br><span class="line"><span class="keyword">go</span> </span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 给指定用户授予特定权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span> <span class="keyword">on</span> student <span class="keyword">to</span> LiMing,ZhangBin</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 联级授权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">update</span> <span class="keyword">on</span> student <span class="keyword">to</span> <span class="keyword">user</span> <span class="keyword">with</span> [<span class="keyword">admin</span>] <span class="keyword">option</span>;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">from</span> ZhangWei;</span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> sc <span class="keyword">from</span> <span class="keyword">User</span>;</span><br><span class="line">deny <span class="keyword">select</span>, <span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">delete</span> <span class="keyword">on</span> student <span class="keyword">to</span> LiMing,ZhangBin;</span><br></pre></td></tr></table></figure><p>4，<strong>其他语言元素(<code>ALE</code>)</strong></p><p>1）<strong><code>注释</code></strong>：程序代码中不执行的文本字符串（也称<code>注解</code>），有：<code>--</code>和<code>/* */</code>。</p><p>2）<strong>变量(<code>@</code>)</strong>：局部变量（<code>@</code>），全局变量（<code>@@</code>）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">declare</span> @<span class="keyword">row</span> <span class="built_in">int</span> </span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">row</span>=(<span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> student)</span><br></pre></td></tr></table></figure><p>3）<strong>运算符</strong></p><blockquote><ul><li>算术运算符：<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>；</li><li>赋值运算符：<code>=</code>；</li><li>位运算符：<code>&amp;</code>，<code>|</code>，<code>^</code>；</li><li>比较运算符：也称关系运算符，用于比较两个表达式的大小或者是否相同，其比较结果是布尔值<code>TRUE</code>，<code>FALSE</code>，<code>UNKNOWN</code>；</li><li>逻辑运算符：<code>and</code>，<code>or</code>，<code>not</code>。优先级别：<code>not</code> &gt; <code>and</code> &gt; <code>or</code>；</li><li>字符串串联运算符：允许通过加号(<code>+</code>)进行字符串串联，这个加号称为<code>字符串串联运算符</code>。</li></ul></blockquote><p>4）<strong>函数</strong></p><p>在<code>T-SQL</code>语言中，<code>函数</code>用于执行一些特殊的运算以支持<code>SQL Server</code>的标准命令。</p><ul><li><p><code>行集函数</code>：在<code>T-SQL</code>语句中当成表引用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> openquery(<span class="keyword">local</span>, <span class="string">'select * from student;'</span>) ta;</span><br></pre></td></tr></table></figure></li><li><p><code>聚合函数</code>：用于对一组值进行计算并返回一个单一的值。除<code>count</code>之外，聚合函数忽略空值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_score,<span class="keyword">sum</span>(score) <span class="keyword">as</span> total_score <span class="keyword">from</span> sc;</span><br></pre></td></tr></table></figure></li><li><p><code>Ranking函数</code>：为查询结果数据集分区中的每行返回一个序列值。有：<code>rank</code>，<code>dense_rank</code>，<code>ntile</code>，<code>row_number</code>。</p></li><li><p><code>标量函数</code>：用于对传递给它的一个或多个参数值进行处理和计算，并返回一个单一的值。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">标量函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">配置函数</td><td style="text-align:left">返回当前的配置信息</td></tr><tr><td style="text-align:left">游标函数</td><td style="text-align:left">返回有关游标的信息</td></tr><tr><td style="text-align:left">日期和时间函数</td><td style="text-align:left">对日期和时间输入值进行处理</td></tr><tr><td style="text-align:left">数学函数</td><td style="text-align:left">对作为函数参数提供的输入值执行计算</td></tr><tr><td style="text-align:left">元数据函数</td><td style="text-align:left">返回有关数据库和数据库对象的信息</td></tr><tr><td style="text-align:left">安全函数</td><td style="text-align:left">返回有关用户和角色的信息</td></tr><tr><td style="text-align:left">字符串函数</td><td style="text-align:left">对字符串(char或者varchar)输入值执行操作</td></tr><tr><td style="text-align:left">系统函数</td><td style="text-align:left">执行操作并返回有关SQL Server中的值、对象和设置的信息</td></tr><tr><td style="text-align:left">系统统计函数</td><td style="text-align:left">返回系统的统计信息</td></tr><tr><td style="text-align:left">文本和图像函数</td><td style="text-align:left">对文本或者图像输入值或者列执行操作，返回有关这些值的信息</td></tr></tbody></table></div><p>5）<strong>流程控制语句</strong></p><ul><li><p><code>if-else</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">from</span> sc;</span><br><span class="line">if (<span class="keyword">select</span> <span class="keyword">avg</span>(score) <span class="keyword">from</span> sc) &lt; <span class="number">60</span></span><br><span class="line">print <span class="string">'很抱歉，你没有通过考试！'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">print <span class="string">'祝贺你，考试通过了！'</span></span><br></pre></td></tr></table></figure></li><li><p><code>begin-end</code>语句：能够将多个<code>T-SQL</code>语句组合成一个语句块，并将它们视为一个单元处理。</p></li><li><p><code>go</code>语句：批的结束语句。<code>批</code>是一起提交并作为一个组执行的若干<code>T-SQL</code>语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> @msg <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line"><span class="keyword">set</span> @msg=<span class="string">'Hello world!'</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure></li><li><p><code>case</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">select</span> <span class="string">'score'</span> = </span><br><span class="line"><span class="keyword">case</span></span><br><span class="line">   <span class="keyword">when</span> score <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="string">'没有成绩'</span></span><br><span class="line">   <span class="keyword">when</span> score &lt; <span class="number">60</span> <span class="keyword">then</span> <span class="string">'不及格'</span></span><br><span class="line">   <span class="keyword">when</span> score &lt; <span class="number">85</span> <span class="keyword">and</span> score &gt;= <span class="number">60</span> <span class="keyword">then</span> <span class="string">'良好'</span></span><br><span class="line">   <span class="keyword">else</span> <span class="string">'优秀'</span> </span><br><span class="line"><span class="keyword">end</span>, </span><br><span class="line">  <span class="keyword">cast</span>(sno <span class="keyword">as</span> <span class="built_in">varchar</span>(<span class="number">20</span>)) <span class="keyword">as</span> sno </span><br><span class="line"><span class="keyword">from</span> sc <span class="keyword">where</span> cno = <span class="string">'C03'</span> <span class="keyword">order</span> <span class="keyword">by</span> score;</span><br></pre></td></tr></table></figure></li><li><p><code>while-continue-break</code>语句</p></li><li><p><code>goto</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">goto label</span><br><span class="line">...</span><br><span class="line">label:</span><br></pre></td></tr></table></figure></li><li><p><code>waitfor</code>语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waitfor [delay 'time'|time 'time']</span><br></pre></td></tr></table></figure></li><li><p><code>return</code>语句</p></li></ul><h2 id="二，存储过程"><a href="#二，存储过程" class="headerlink" title="二，存储过程"></a>二，存储过程</h2><p>1，<strong><code>存储过程</code>定义</strong>：几乎包含了所有的<code>T-SQL</code>语句，是为了完成特定功能而汇集在一起的一组<code>SQL</code>程序语句，经编译后存储在数据库中。</p><p>2，<strong>存储过程的调用方法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec proc 存储过程名</span><br><span class="line">exec proc 存储过程名  参数值[,参数值...]</span><br></pre></td></tr></table></figure><p>3，<strong>存储过程分类</strong></p><blockquote><p>i）系统存储过程（前缀为<code>SP_</code>）；<br>ii）扩展存储过程（前缀为<code>XP_</code>）；<br>iii）用户自定义存储过程。</p></blockquote><p>4，<strong>存储过程的创建和执行</strong></p><ul><li><p>创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dbo.pro_sc_insert</span><br><span class="line">@sno <span class="built_in">char</span>(<span class="number">10</span>),@cno <span class="built_in">char</span>(<span class="number">2</span>),@score <span class="built_in">real</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc(sno, cno, score) <span class="keyword">values</span>(@sno, @cno, @score)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure></li><li><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec pro_sc_insert '2010009', 'C1', 88</span><br></pre></td></tr></table></figure></li></ul><p>5，<strong>存储过程中的游标</strong></p><p>1）<code>游标</code>的定义：可以把游标看成一种数据类型，用于遍历结果集，相当于指针，或是数组中的下标，分为<code>局部游标(local)</code>和<code>全局游标(global)</code>。</p><p>2）游标的使用方法</p><ul><li><p>创建游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 默认为global；</span></span><br><span class="line"><span class="comment">-- forward_only(默认值)：游标只能前进的，只能从头到尾提取记录；</span></span><br><span class="line"><span class="comment">-- scoll：可以在行间来回跳转。</span></span><br><span class="line"><span class="keyword">declare</span> 游标名 <span class="keyword">cursor</span> [<span class="keyword">local</span>|<span class="keyword">global</span>] [forward_only|scoll]</span><br><span class="line"><span class="keyword">for</span> </span><br><span class="line"><span class="keyword">select</span> 查询语句</span><br></pre></td></tr></table></figure></li><li><p>使用游标：增加了服务器的负担，使用游标的效果远没有使用默认结果集的效率高，因此，能不用游标尽量不要用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> cur_select_name <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> sname <span class="keyword">from</span> student;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">declare</span> @<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">open</span> cur_select_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> cur_select_name <span class="keyword">into</span> @<span class="keyword">name</span></span><br><span class="line"><span class="comment">-- fetch_status取值：0正常执行；-1超出了结果集；-2所指向的行已不存在。</span></span><br><span class="line">  <span class="keyword">while</span>(@@fetch_status = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">print <span class="string">'姓名：'</span> + @<span class="keyword">name</span></span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> cur_select_name <span class="keyword">into</span> @<span class="keyword">name</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">close</span> cur_select_name</span><br><span class="line"><span class="keyword">deallocate</span> cur_select_name</span><br></pre></td></tr></table></figure></li></ul><p>6，<strong>自动执行的存储过程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line">exec sp_procoption <span class="string">'存储过程名'</span>, <span class="string">'startup'</span>, <span class="string">'on'</span></span><br></pre></td></tr></table></figure><p>7，<strong>存储过程的查看，修改和删除</strong></p><p>1）查看存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示存储过程的参数及其数据类型</span></span><br><span class="line">sp_help[[@name=]name]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 显示存储过程的源代码</span></span><br><span class="line">sp_helptext[[@objname=]name]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 显示和存储过程相关的数据库对象</span></span><br><span class="line">sp_depends[@objname=]'object'</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 返回当前数据库中的存储过程列表</span></span><br><span class="line">sp_stored_procedures[[@sp_name=]'name']</span><br><span class="line">[,[@sp_owner=]'owner']</span><br><span class="line">[,[@sp_qualifier=]'sp_qualifier']</span><br></pre></td></tr></table></figure><p>2）修改存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">procedure</span> stu_info</span><br><span class="line"><span class="keyword">with</span> encryption</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> sno, age <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>3）删除存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> &#123;<span class="keyword">procedure</span>&#125;[, ...n]</span><br></pre></td></tr></table></figure><p>8，<strong><code>扩展存储过程</code></strong>：<code>SQL Server</code> 动态装载并执行的动态链接库（<code>DDL</code>），只能添加到<code>master</code>数据库中。</p><h2 id="三，触发器及其应用"><a href="#三，触发器及其应用" class="headerlink" title="三，触发器及其应用"></a>三，触发器及其应用</h2><p>1，<strong>触发器的概念和工作原理</strong></p><p>1）<strong><code>触发器</code>的概念</strong>：<code>触发器</code>是一种特殊类型的存储过程，在执行语言事件时自动生效。其<code>特殊性</code>表现：它是在执行某些<code>T-SQL</code>语句时自动生效的。</p><p>2）<strong><code>DML</code>触发器</strong>：在数据库中发生<code>DML</code>事件时启动。将触发器和触发它的语句作为可在触发器内回滚的单个事务对待，如果检测到错误，则整个事务即自动回滚。</p><p>3）<strong><code>DDL</code>触发器</strong>：是<code>SQL Server 2005</code>的新功能，当服务器或者数据库中发生<code>DDL</code>事件时将调用这些触发器。</p><p>2，<strong>创建触发器</strong></p><p>1）<code>DML</code>触发器<strong>主要优点</strong></p><blockquote><p>i）<code>DML</code>触发器可通过数据库中相关表实现联级更改；<br>ii）<code>DML</code>触发器可以防止恶意或者错误的<code>INSERT</code>，<code>UPDATE</code>及<code>DELETE</code>操作，并强制执行比<code>CHECK</code>约束定义的限制更为复杂的其他限制；<br>iii）<code>DML</code>触发器可以评估数据修改前后表的状态，并根据该差异采取措施。</p></blockquote><p>2）<code>insert</code>型<code>DML</code>触发器：通常用于更新时间标记字段，或者验证被触发器监控的字段中数据满足要求的标准，以确保数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检测sc表添加数据的合法性，即添加的数据与student表的数据不匹配时，将删除此数据. */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_sc_ins <span class="keyword">on</span> sc</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> @sno <span class="built_in">char</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">select</span> @sno=inserted.sno <span class="keyword">from</span> inserted </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> sno <span class="keyword">from</span> student <span class="keyword">where</span> student.sno=@sno)</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> sc <span class="keyword">where</span> sno=@sno</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>3）<code>update</code>型<code>DML</code>触发器：当在一个有<code>update</code>触发器的表中修改记录时，表中原来的记录被移动到删除表中，修改过的记录插入到了插入表中，触发器可以参考删除表和插入表及被修改的表，以确定如何完成数据库操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 防止用户修改SC表的成绩 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_sc_update <span class="keyword">on</span> sc</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">update</span>(scorce)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    raiserror(<span class="string">'不能修改成绩！'</span>, <span class="number">16</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">rollback</span> <span class="keyword">transaction</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>4）<code>delete</code>型<code>DML</code>触发器</p><blockquote><ul><li>为了防止确实需要删除但会引起数据一致性问题的记录的删除；</li><li>执行可删除主记录的子记录的级联删除操作。</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当删除student表中的记录时，自动删除sc表对应学号的记录. */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_del_sc </span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> @sno <span class="built_in">char</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">select</span> @sno=deleted.sno <span class="keyword">from</span> deleted</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> sc <span class="keyword">where</span> sno=@sno</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>5）<strong><code>DDL</code>触发器</strong></p><ul><li><code>DDL</code>触发器目的：<blockquote><p>i）防止对数据库架构进行某些更改；<br>ii）希望数据库中发生某种情况以响应数据库架构中的更改；<br>iii）要记录数据库架构中的更改或者事件。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 防止数据库中的任意表被修改或者删除. */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_safety</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">database</span></span><br><span class="line"><span class="keyword">for</span> drop_table, alter_table</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">print <span class="string">'You must disable trigger "tri_safety" to drop or alter tables!'</span></span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 防止在数据库中创建表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_ban_create</span><br><span class="line"><span class="keyword">in</span> <span class="keyword">database</span></span><br><span class="line"><span class="keyword">for</span> create_table</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">print <span class="string">'create table issued.'</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">eventdata</span>().value(<span class="string">'(/event_instance/TSQLCommand/CommandText)[1]'</span>, <span class="string">'nvarchar(max)'</span>)</span><br><span class="line">raiserror(<span class="string">'New tables cannot be created in this database.'</span>, <span class="number">16</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">rollback</span></span><br></pre></td></tr></table></figure><p>3，<strong>查看，修改和删除触发器</strong></p><p>1）查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查看触发器的一般信息，如触发器的名称，属性，类型和创建时间 */</span></span><br><span class="line">sp_help 'trigger_name'</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看触发器的正文信息 */</span></span><br><span class="line">sp_helptext 'trigger_name'</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看指定触发器所引用的表或者指定的表涉及的所有触发器 */</span></span><br><span class="line">sp_depends 'trigger_name'</span><br><span class="line">sp_depends 'table_name'</span><br></pre></td></tr></table></figure><p>2）修改触发器<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_rename oldname, newname</span><br></pre></td></tr></table></figure></p><p>3）删除触发器<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> &#123;<span class="keyword">trigger</span>&#125;[, ...n]</span><br></pre></td></tr></table></figure></p><p>4，<strong>触发器的用途</strong></p><blockquote><p>1）可以实现比约束更为复杂的数据约束；<br>2）可以检查SQL所做的操作是否被允许；<br>3）当一个SQL语句对数据表进行操作时，触发器可以根据该SQL语句的操作情况对另一个数据表进行操作；<br>4）约束的本身是不能调用存储过程的，但是触发器可以调用一个或者多个存储过程；<br>5）在执行完SQL语句之后，触发器可以判断更改过的记录是否达到一定条件，如果达到，触发器可以自动调用SQL Mail来发邮件；<br>6）约束不能返回信息，而触发器可以返回信息；<br>7）可以修改原本要操作的SQL语句；<br>8）为了保护已经建好的数据表，触发器可以在接收到以drop和alter开头的SQL语句中，不进行对数据表的操作。</p></blockquote><h2 id="四，嵌入式SQL"><a href="#四，嵌入式SQL" class="headerlink" title="四，嵌入式SQL"></a>四，嵌入式SQL</h2><p>1，<strong>嵌入式<code>SQL</code>简介</strong></p><p>1）<code>嵌入式SQL</code>定义：<code>嵌入式SQL</code>是一种将<code>SQL</code>语句直接写入<code>C</code>语言，<code>COLBOL</code>，<code>FORTRAN</code>，<code>Ada</code>等编程语言的源代码中的方法。将<code>SQL</code>语句嵌入的目标源码的语言称为<code>宿主语言</code>。</p><p>2，<strong>嵌入式<code>SQL</code>的工作原理</strong></p><blockquote><p>提供对于嵌入式SQL的支持，需要数据库厂商除了提供DBMS之外，还必须提供一些工具。为了实现对于嵌入式SQL的支持，技术上必须解决以下4个问题:</p><blockquote><p>1.宿主语言的编译器不可能识别和接受SQL文，需要解决如何将SQL的宿主语言源代码编译成可执行码;<br>2.宿主语言的应用程序如何与DBMS之间传递数据和消息;<br>3.如何把对数据的查询结果逐次赋值给宿主语言程序中的变量以供其处理;<br>4.数据库的数据类型与宿主语言的数据类型有时不完全对应或等价，如何解决必要的数据类型转换问题。<br>嵌入式SQL源码的处理流程 为了解决上述这些问题，数据库厂商需要提供一个嵌入式SQL的预编译器，把包含有嵌入式SQL文的宿主语言源码转换成纯宿主语言的代码。这样一来，源码即可使用宿主语言对应的编译器进行编译。通常情况下，经过嵌入式SQL的预编译之后，原有的嵌入式SQL会被转换成一系列函数调用。因此，数据库厂商还需要提供一系列函数库，以确保链接器能够把代码中的函数调用与对应的实现链接起来。</p></blockquote></blockquote><p>3，<strong>嵌入式<code>SQL</code>的一般形式</strong></p><blockquote><ul><li>预编译</li><li>修改和扩充主语言使之能处理<code>SQL</code>语句</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课本第11～13章主要知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，T-SQL语言&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库实践" scheme="https://zhangbc.github.io/tags/db-practice/"/>
    
  </entry>
  
  <entry>
    <title>【数据库实践】 数据表及其SQL基本操作</title>
    <link href="https://zhangbc.github.io/2019/04/21/db_table_sql/"/>
    <id>https://zhangbc.github.io/2019/04/21/db_table_sql/</id>
    <published>2019-04-21T12:05:44.000Z</published>
    <updated>2019-04-21T12:36:46.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p><blockquote><p>课本第09～10章主要知识点</p></blockquote></blockquote><h2 id="一，表的概述"><a href="#一，表的概述" class="headerlink" title="一，表的概述"></a>一，表的概述</h2><p>1，<strong><code>表</code>的定义</strong>：表是包含 <code>SQL Server 2005</code>数据库中的所有数据的对象。表定义是一个列集合。</p><p>2，<strong><code>表</code>的类型</strong></p><blockquote><p>1）<code>分区表</code>：将数据水平划分为多个单元的表，这些单元可以分布到数据库中的多个文件组中。<br>2）<code>系统表</code>：存储服务器配置及其所有表的数据。<br>3）<code>用户表</code>：用户自己创建的数据表和表示示例数据表，用于存储用户的信息，用户可以随意更改。<br>4）<code>临时表</code>：分为<code>本地临时表</code>和<code>全局临时表</code>，存储在<code>tempdb</code>中，当不再使用临时表时会自动将其删除。</p></blockquote><h2 id="二，创建表"><a href="#二，创建表" class="headerlink" title="二，创建表"></a>二，创建表</h2><p>1，<strong>表列的数据类型</strong></p><p>1）精确数字型</p><ul><li>整数类型（<code>bigint</code>，<code>int</code>，<code>smallint</code>，<code>tinyint</code>）</li></ul><blockquote><ul><li><code>bigint</code>：存储范围为 $-2^{63}$~$2^{63}-1$；占用8个字节。</li><li><code>int</code>：存储范围为 $-2^{31}$~$2^{31}-1$；占用4个字节。</li><li><code>smallint</code>：存储范围为 $-2^{15}$~$2^{15}-1$；占用2个字节。</li><li><code>tinyint</code>：存储范围为 0~255；占用1个字节。</li></ul></blockquote><ul><li>位数据类型（<code>bit</code>）</li></ul><blockquote><ul><li><code>bit</code>：存储范围是0和1，占用1个字节。常作为逻辑变量使用，用于表示真、假或者是、否等二值选择。</li></ul></blockquote><ul><li>数值类型（<code>decimal</code>，<code>numeric</code>）</li></ul><blockquote><ul><li><code>decimal</code>：和<code>numeric</code>一样，可以用2～17个字节来存储$-10^{38}+1$到$10^{38}-1$之间但是固定精度和小数位数位的数字。表示形式<code>decimal(p,s)</code>，其中<code>p</code>确定精确的总位数，默认为18位；<code>s</code>确定小数位数，默认为0。</li></ul></blockquote><ul><li>货币类型（<code>money</code>，<code>smallmoney</code>）：必须在有效位置前加一个货币单位符号。</li></ul><blockquote><ul><li><code>money</code>：用于存储货币值，数值分为一个正数和一个小数分别存储在两个4字节的整型值中，存储范围为$-2^{63}$~$2^{63}-1$，精确到货币单位的千分之一。</li><li><code>smallmoney</code>：与<code>money</code>数据类型相似，但是存储范为$-2^{31}$~$2^{31}-1$。</li></ul></blockquote><p>2）近似数据类型：<code>real</code>，<code>float</code>。</p><blockquote><ul><li><code>real</code>：存储十进制数值，最大可以为7位精确位数。存储范围为$-3.40 \times 10^{-38}$ ~ $3.40 \times 10^{38}$，占用4个字节。</li><li><code>float</code>：可以精确到15位小数。存储范围为$-1.79 \times 10^{-308}$ ~ $1.79 \times 10^{308}$，占用8个字节。<code>float(n)</code>：<code>n</code>指定<code>float</code>数据的精度，<code>n</code>为1～15的整数值。当<code>n</code>为1～7时，实际上是定义了一个<code>real</code>类型的数据，占用4个字节；当<code>n</code>为8～15时，系统认为其是<code>float</code>类型，占用8个字节。</li></ul></blockquote><p>3）日期和时间数据类型：<code>datetime</code>和<code>smalldatetime</code>。</p><blockquote><ul><li><code>datetime</code>：存储日期和时间的结合体，存储从1753年1月1日0时到9999年12月31日23时59分59秒，其精确度可以达到三百分之一秒，即3.33ms。占用8个字节，日期和时间分别占用4个字节。默认格式为 <code>MM DD YYYY hh:mm A.M./P.M.</code>。</li><li><code>smalldatetime</code>：与<code>datetime</code>类型相似，但是存储范围为1900年1月1日至2079年6月6日。占用4个字节，时间和日期分别占用2个字节，精确度为1min。</li></ul></blockquote><p>4）字符数据类型：<code>char</code>，<code>varchar</code>，<code>text</code>。</p><blockquote><ul><li><code>char</code>：定义形式为<code>char(n)</code>，<code>n</code>表示所有字符占用的存储空间，其取值为1～8000，默认值为1。如果输入数据的字符串长度小于<code>n</code>，则系统自动在其后面添加空格来填充；如果输入的数据过长，将会截掉其超出部分。如果定义一个<code>char</code>数据类型，且允许该列为空，则该字段被当成<code>varchar</code>来处理。</li><li><code>varchar</code>：定义形式为<code>varchar(n)</code>，可存储长达8000个字符的客人变长度字符串。其存储空间是根据存储在表的每列值的字符数变化的。</li><li><code>text</code>：用于存储文本数据，其容量理论上为 1~$2^{31}-1$，实际应用根据硬盘的存储空间而定。</li></ul></blockquote><p>5）<code>unicode</code>字符数据类型：<code>nchar</code>，<code>nvarchar</code>，<code>ntext</code>。</p><blockquote><ul><li><code>nchar</code>：定义形式为<code>nchar(n)</code>，<code>n</code>的取值为1～4000。与<code>char</code>类似，但采用<code>unicode</code>标准字符集，<code>unicode</code>标准用2个字节为1个存储单位。</li><li><code>nvarchar</code>：定义形式为<code>nvarchar(n)</code>，<code>n</code>的取值为1～4000。与<code>varchar</code>类似，但采用<code>unicode</code>标准字符集。</li><li><code>ntext</code>：理论上容量为$2^{30}-1$，与<code>text</code>类似，但采用<code>unicode</code>标准字符集。</li></ul></blockquote><p>6）二进制数据类型：<code>binary</code>，<code>varbinary</code>，<code>image</code>。</p><blockquote><ul><li><code>binary</code>：定义形式为<code>binary(n)</code>，数据存储长度是固定的，即n+4个字节。当输入的二进制数据长度小于n时，余下部分填充0。二进制数据类型的最大长度为8000，常用于存储图像等数据。</li><li><code>varbinary</code>：定义形式为<code>varbinary(n)</code>，数据存储长度是变化的，为实际输入数据的长度加上4个字节，其他类似<code>binary</code>。</li><li><code>image</code>：用于存储图像数据，其理论容量为$2^{31}-1$个字节。</li></ul></blockquote><p>7）其他数据类型：<code>sql_variant</code>，<code>table</code>，<code>timestamp</code>，<code>uniqueidentifier</code>，<code>xml</code>，<code>cursor</code>等。</p><blockquote><ul><li><code>sql_variant</code>：用于存储除文本、图形数据和<code>timestamp</code>类型数据外的其他任何合法的<code>SQL Server 2005</code>数据。</li><li><code>table</code>：用于存储对表或者视图处理后的结果集。</li><li><code>timestamp</code>：时间戳数据类型，提供数据库范围内的唯一值。</li><li><code>uniqueidentifier</code>：用于存储一个16字节长的二进制数据类型，是<code>SQL Server 2005</code>根据计算机网络适配器地址和<code>CPU</code>时钟产生的全局唯一标识符代码（<code>GUID</code>），通过调用 <code>SQL Server 2005</code> 的<code>NEWID()</code>函数获取。</li><li><code>xml</code>：存储<code>xml</code>类型的数据，其数据容量不能超过2GB。</li><li><code>cursor</code>：是变量或者存储过程<code>OUTPUT</code>参数的一种数据类型，这些参数包含对游标的引用。</li></ul></blockquote><p>8）用户自定义数据类型</p><ul><li>语法格式如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp_addtype [@typename=]type, [@phystype=]system_data_type[, [@nulltype=]'null_type'][, [@owner=]'owner_name']</span><br></pre></td></tr></table></figure><ul><li>举例：自定义一个地址(<code>address</code>)数据类型。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addtype address, 'varchar(80)', 'not null'</span><br></pre></td></tr></table></figure><p>2，<strong>列的其他属性</strong></p><p>1）<code>NULL</code>，<code>NOT NULL</code>和默认值<br>在数据库中，<code>NULL</code>是一个特殊值，表示未知值的概念。默认值是指如果插入行时没有为列指定值，默认值则指定列中使用的值。</p><p>2）<code>IDENTITY</code>属性：实现标识符列。</p><blockquote><ul><li>一个表只能有一个使用<code>IDENTITY</code>属性定义的列，且必须通过使用<code>bigint</code>，<code>int</code>，<code>smallint</code>，<code>tinyint</code>或者<code>decimal</code>，<code>numeric</code>数据类型类定义该列；</li><li>可指定种子和增量，两者的默认值均为1；</li><li>标识符列不允许为空值，也不能包含<code>default</code>定义或者对象；</li><li>在设置<code>IDENTITY</code>属性后，可以使用<code>$IDENTITY</code>关键字在选择列表中引用该列，也可以通过名称引用该列；</li><li><code>objectproperty</code>函数可以用于确定一个表是否具有<code>IDENTITY</code>列，<code>columnproperty</code>函数可以确定<code>IDENTITY</code>列的名称；</li><li>通过使值能显示插入，<code>set identity_insert</code>可以用于禁用该列的<code>IDENTITY</code>属性。</li></ul></blockquote><p>3，<strong>表的创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student</span><br><span class="line">(</span><br><span class="line">studentID <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">studentName <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">class</span> <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">depart <span class="built_in">char</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">yearClass <span class="built_in">char</span>(<span class="number">6</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="三，维护表"><a href="#三，维护表" class="headerlink" title="三，维护表"></a>三，维护表</h2><p>1，<strong>修改表名与表结构</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表名，将studentcourse修改为course</span></span><br><span class="line">exec sp_rename 'studentcourse', 'course';</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 修改表结构</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> sex <span class="built_in">char</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> yearClass;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">alter</span> <span class="keyword">column</span> studentName <span class="built_in">char</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>2，<strong>删除表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> course;</span><br></pre></td></tr></table></figure><p>3，<strong>表数据的维护</strong></p><p>1）添加数据（<code>insert</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span>(<span class="string">'10015'</span>, <span class="string">'计算机网络'</span>, <span class="string">'张三'</span>, <span class="number">2</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>2）更新表数据（<code>update</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> cname=<span class="string">'计算机组成原理'</span> <span class="keyword">where</span> cno=<span class="string">'10015'</span>;</span><br></pre></td></tr></table></figure><p>3）删除表数据（<code>delete</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> sno=<span class="number">200901020023</span>;</span><br></pre></td></tr></table></figure><h2 id="四，表数据完整性"><a href="#四，表数据完整性" class="headerlink" title="四，表数据完整性"></a>四，表数据完整性</h2><p>1，<strong><code>SQL Server</code>提供的数据类型完整性组件</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">完整性类型</th><th style="text-align:left">组件</th></tr></thead><tbody><tr><td style="text-align:left">实体完整性</td><td style="text-align:left">索引，unique约束，primary key约束和identity属性</td></tr><tr><td style="text-align:left">域完整性</td><td style="text-align:left">foreign key约束，check约束，default定义，not null定义和规则</td></tr><tr><td style="text-align:left">参照完整性</td><td style="text-align:left">foreign key约束，check约束和触发器</td></tr><tr><td style="text-align:left">用户定义完整性</td><td style="text-align:left">create table中的所有列级和表级约束，存储过程和触发器</td></tr></tbody></table></div><p>2，<strong><code>primary key</code>约束</strong></p><p>表通常具有一列或者一组列可以用于唯一标识表中的一行，这样的一列或者多列称为表的<code>主键</code>（<code>PK</code>），用于强制表的实体完整性。</p><p>3，<strong><code>foreign key</code>约束</strong></p><p><code>外键</code>是用于建立和加强两个表数据之间的链接的一列或者多列，用于强制参照完整性。</p><blockquote><ul><li>一个表 中最多可以有253个参照表，因此每个表最多可以有253个<code>foreign key</code>约束；</li><li>在<code>foreign key</code>约束中，只能参照同一个数据库中的表；</li><li><code>foreign key</code>子句中的列数目和每个列指定的数据类型必须和<code>reference</code>子句中的相同；</li><li><code>foreign key</code>约束不能自动创建索引；</li><li>参照同一个表中的列时，必须只使用<code>reference</code>子句，而不能使用<code>foreign key</code>子句；</li><li>在临时表中，不能使用<code>foreign key</code>约束。</li></ul></blockquote><p>4，<strong><code>check</code>约束</strong>：通过限制列可接受的值，<code>check</code>约束可以强制域的完整性。</p><p>5，<strong>表关系</strong>：显示某个表中的列如何链接到另一个表的列；可以防止出现冗余数据。</p><h2 id="五，视图"><a href="#五，视图" class="headerlink" title="五，视图"></a>五，视图</h2><p>1，<strong>视图概述</strong></p><p>1）<code>视图</code>是一个虚拟表，是由若干个表或者视图中导出的表，其结构和数据是建立在对表的查询基础上的，其内容由查询定义。</p><p>2）视图的<strong>主要优点</strong>和<strong>作用</strong>：</p><blockquote><p>i）着重于特定数据：视图使用户能够着重于他们所感兴趣的特定数据和所负责的特定任务，不必要的数据或者敏感数据可以不出现在视图中；<br>ii）简化数据操作：视图可以简化用户处理数据的方式；<br>iii）提供向后兼容性：视图能够在表的架构更改时为表创建向后兼容接口；<br>iv）自定义数据：视图允许用户以不同方式查看数据，即使在他们同时使用相同的数据时也是如此；<br>v）导出和导入数据：可使用视图将数据导出到其他应用程序；<br>vi）跨服务器组合分区数据：使用分区视图，可以使用多个服务器对数据进行分区。</p></blockquote><p>3）视图<strong>分类</strong>：</p><blockquote><p>i）标准视图：组合了一个或者多个表中的数据，可以获得使用视图的大多数好处，包括将重点放在特定数据上及简化数据操作。<br>ii）索引视图：被具体化了的视图，即它已经经过计算并存储，可以为视图创建唯一的聚集索引。<br>iii）分区视图：在一台或者多台服务器间水平连接一组成员表的分区数据。</p></blockquote><p>2，<strong>创建视图</strong></p><p>1）创建视图<strong>原则</strong></p><blockquote><p>i) 只能在当前数据库中创建视图；<br>ii) 视图名称必须遵循标志符的规则，且对每个用户必须唯一；<br>iii) 可以在其他视图和引用视图的过程之上创建视图；<br>iv) 定义视图的查询不能包括<code>order by</code>，<code>compute</code>，<code>compute by</code>子句或者<code>into</code>关键字；<br>v) 不能在视图上定义全文索引定义；<br>vi) 不能创建临时视图，也不能在临时表上创建视图；<br>vii) 不能对视图执行全文查询，但是如果查询所引用的表被配置为支持全文索引，就可以在视图定义中包含全文查询。</p></blockquote><ul><li>举例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_teacher_choice <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> b.tname, a.chsu <span class="keyword">from</span> course a, teacher b <span class="keyword">where</span> a.tid=b.tid;</span><br></pre></td></tr></table></figure><p>3，<strong>使用视图</strong></p><p>1）使用视图进行数据检索</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> view_teacher_choice;</span><br></pre></td></tr></table></figure><p>2）通过视图修改数据</p><blockquote><ul><li>如果在视图定义中使用了<code>with check option</code>子句，则所有在视图上执行的数据修改语句都必须符合定义视图的<code>select</code>语句中所设定的条件。</li><li><code>SQL Server</code> 必须能够明确地解析对视图所引用基表中的特定行所做的修改操作。</li><li>对基表中须更新而又不允许空值的所有列，其值在<code>insert</code>语句或者<code>default</code>定义中指定。</li><li>如果在视图删除数据，在视图定义的<code>from</code>子句中只能列出一个表。</li><li>视图修图数据通过<code>insert</code>，<code>update</code>，<code>delete</code>语句来完成。</li></ul></blockquote><p>4，<strong>修改视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_teacher_choice <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> b.tname, a.chsu <span class="keyword">from</span> course a, teacher b <span class="keyword">where</span> a.tid=b.tid <span class="keyword">and</span> a.chsu &gt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>5，<strong>重命名视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_rename 'view_teacher_choice', 'view_teacher_choice_total';</span><br></pre></td></tr></table></figure><p>6，<strong>查看视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line">exec sp_helptext <span class="string">'view_teacher_choice_total'</span>;</span><br></pre></td></tr></table></figure><p>7，<strong>删除视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_teacher_choice_total;</span><br></pre></td></tr></table></figure><h2 id="六，索引"><a href="#六，索引" class="headerlink" title="六，索引"></a>六，索引</h2><p>1，<strong>索引概述</strong></p><p>1）<strong><code>索引</code>定义</strong>：<code>索引</code>是对数据库表中一个或者多个列的值进行排序而创建的一种存储结构。</p><p>2）索引分类：</p><blockquote><p>i）<code>聚集索引(clustered)</code>：保证数据库表中记录的物理顺序与索引顺序相同，一个表只能有一个聚集索引。<br>ii）<code>非聚集索引(nonclustered)</code>：数据库表中记录的物理顺序与索引顺序可以不相同，一个表可以有多个非聚集索引。<br>iii）<strong>唯一索引(<code>unique</code>)</strong>：表示表中的任何两个记录的索引值都不相同，与表的主键类似，确保索引列不包括重复的值；<br>iv）<strong>组合索引</strong>：将两个或者多个字段组合起来的索引，而单独的字段允许不是唯一的值。</p></blockquote><p>2，<strong>创建索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> stuSystem</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_time <span class="keyword">in</span> course(choice_time <span class="keyword">asc</span>);</span><br></pre></td></tr></table></figure><p>3，<strong>查看索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_helpindex idx_time;</span><br></pre></td></tr></table></figure><p>4，<strong>删除索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> course.idx_time;</span><br></pre></td></tr></table></figure><h2 id="七，SQL操作查询"><a href="#七，SQL操作查询" class="headerlink" title="七，SQL操作查询"></a>七，SQL操作查询</h2><p>1，<strong>简单查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,sn,age <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sno <span class="keyword">from</span> course;</span><br><span class="line"><span class="keyword">select</span> sn <span class="keyword">as</span> sname,sno,age <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> sn,age<span class="number">-5</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(age) <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>2，<strong>带条件的列查询</strong></p><blockquote><ul><li>比较大小和确定范围</li><li>部分匹配查询</li><li>查询的排序</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,score <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'C01'</span>;</span><br><span class="line"><span class="keyword">select</span> sno,cno,score <span class="keyword">from</span> sc <span class="keyword">where</span> score&gt;<span class="number">80</span>;</span><br><span class="line"><span class="keyword">select</span> sno,cno,score <span class="keyword">from</span> sc <span class="keyword">where</span> (cno=<span class="string">'C01'</span> <span class="keyword">or</span> cno=<span class="string">'C02'</span>) <span class="keyword">and</span> score&gt;<span class="number">80</span>;</span><br><span class="line"><span class="keyword">select</span> sno,sn <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> sno,sn,cno <span class="keyword">from</span> student <span class="keyword">where</span> score <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> sno,cno,score <span class="keyword">from</span> sc <span class="keyword">where</span> cno <span class="keyword">in</span>(<span class="string">'C01'</span>, <span class="string">'C02'</span>);</span><br><span class="line"><span class="keyword">select</span> sno,sn <span class="keyword">from</span> student <span class="keyword">where</span> sn <span class="keyword">like</span> <span class="string">'李%'</span>;</span><br><span class="line"><span class="keyword">select</span> sno,score <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'C01'</span> <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(score) <span class="keyword">as</span> total_score, <span class="keyword">avg</span>(score) <span class="keyword">as</span> avg_score <span class="keyword">from</span> sc <span class="keyword">where</span> sno=<span class="string">'0001'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(score) <span class="keyword">as</span> max_score,<span class="keyword">min</span>(score) <span class="keyword">as</span> min_score,<span class="keyword">max</span>(score)-<span class="keyword">min</span>(score) <span class="keyword">as</span> diff <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'C01'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> dept) <span class="keyword">as</span> dept_num <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> sno,<span class="keyword">sum</span>(score) aas total_score <span class="keyword">from</span> sc <span class="keyword">where</span> score &gt;= <span class="number">60</span> <span class="keyword">group</span> <span class="keyword">by</span> sno <span class="keyword">having</span>(*) &gt;= <span class="number">3</span> <span class="keyword">order</span> bu <span class="keyword">sum</span>(score) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>3，<strong>多表查询</strong></p><p>所谓<code>多表查询</code>，即在两个或者两个以上的表中进行的查询操作，分为：<code>连接查询</code>和<code>子查询</code>（<code>嵌套查询</code>）。</p><ul><li><strong>连接查询</strong></li></ul><blockquote><p>1）内连接</p><blockquote><ul><li><code>等值连接</code>：在连接条件中使用等于号(<code>=</code>)运算符，与被连接列的列值进行比较，在查询结果中列出被连接表中的所有列，包括其中的重复列。</li><li><code>不等连接</code>：在连接条件中使用除等于号(<code>=</code>)以外的其他比较运算符，与被连接列的列值进行比较，这些运算符包括<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>!&gt;</code>，<code>!&lt;</code>，<code>&lt;&gt;</code>。</li><li><code>自然连接</code>：在连接条件中使用等于号(<code>=</code>)运算符，与被连接列的列值进行比较，在查询结果中列出被连接表中的所有列，但会删除其中的重复列。</li></ul></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student a <span class="keyword">inner</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br></pre></td></tr></table></figure><blockquote><p>2）交叉连接（笛卡尔积）：两个关系中所有元组的任意组合。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">cross</span> <span class="keyword">join</span> sc;</span><br></pre></td></tr></table></figure><blockquote><p>3）自连接：如果在一个连接查询中，涉及的两个表都是同一张表，这种查询称为<code>自连接查询</code>。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> student a <span class="keyword">inner</span> <span class="keyword">join</span> student b <span class="keyword">on</span> a.cno=b.cno <span class="keyword">and</span> b.sno=<span class="string">'20090701027'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>4）外连接：其查询结果既包含那些满足条件的行，又包含其中某个表的全部行。</p><blockquote><ul><li>左外连接（<code>left join</code>）</li><li>右外连接（<code>right join</code>）</li><li>全外连接（<code>full join</code>）</li></ul></blockquote></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.sno,a.sname,a.class,a.cno,b.score <span class="keyword">from</span> student a <span class="keyword">left</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br><span class="line"><span class="keyword">select</span> a.sno,a.sname,a.class,a.cno,b.score <span class="keyword">from</span> student a <span class="keyword">right</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br><span class="line"><span class="keyword">select</span> a.sno,a.sname,a.class,a.cno,b.score <span class="keyword">from</span> student a <span class="keyword">full</span> <span class="keyword">join</span> sc b <span class="keyword">on</span> a.sno=b.sno;</span><br></pre></td></tr></table></figure><ul><li><strong>子查询</strong></li></ul><blockquote><ul><li>在where子句中包含一个形如select-from-where的查询块，此查询称为<code>子查询</code>或者<code>嵌套查询</code>，包含子查询的语句称为<code>父查询</code>或者<code>外部查询</code>。<br>基本关键字：<code>any</code>，<code>in</code>，<code>all</code>，<code>exists</code></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tname <span class="keyword">from</span> teacher <span class="keyword">where</span> tno=<span class="keyword">any</span>(<span class="keyword">select</span> tno <span class="keyword">from</span> tc <span class="keyword">where</span> cno=<span class="string">'C05'</span>);</span><br><span class="line"><span class="keyword">select</span> tname <span class="keyword">from</span> teacher <span class="keyword">where</span> tno <span class="keyword">in</span> (<span class="keyword">select</span> tno <span class="keyword">from</span> tc <span class="keyword">where</span> cno=<span class="string">'C05'</span>);</span><br><span class="line"><span class="keyword">select</span> tname,sal <span class="keyword">from</span> teacher <span class="keyword">where</span> sal&gt;<span class="keyword">all</span>(<span class="keyword">select</span> sal <span class="keyword">from</span> teacher <span class="keyword">where</span> dept=<span class="string">'电力系'</span>) <span class="keyword">and</span> dept!=<span class="string">'电力系'</span>;</span><br><span class="line"><span class="keyword">select</span> tname <span class="keyword">from</span> teacher <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> tc <span class="keyword">where</span> teacher.tno=tc.tno <span class="keyword">and</span> cno=<span class="string">'C05'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课本第09～10章主要知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，表的概述&quot;&gt;&lt;a href=&quot;#一
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库实践" scheme="https://zhangbc.github.io/tags/db-practice/"/>
    
  </entry>
  
  <entry>
    <title>【数据库实践】 数据库及其管理</title>
    <link href="https://zhangbc.github.io/2019/04/17/db_table_manager/"/>
    <id>https://zhangbc.github.io/2019/04/17/db_table_manager/</id>
    <published>2019-04-17T15:32:38.000Z</published>
    <updated>2019-04-18T11:37:54.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p><blockquote><p>课本第07～08章主要知识点</p></blockquote></blockquote><h2 id="一，SQL-Server-2005概述"><a href="#一，SQL-Server-2005概述" class="headerlink" title="一，SQL Server 2005概述"></a>一，SQL Server 2005概述</h2><p>1，<strong><code>SQL Server 2005</code> 新特性</strong></p><p><code>SQL Server</code> 是一个全面的，集成的数据库解决方案，为企业中的用户提供了用于企业数据管理和商业智能的一个安全，可靠和高效的平台。</p><p>1）<code>Service Broker</code></p><blockquote><ul><li>提供了一个功能强大的，异步编程的新模型。数据库应用程序通常使用异步编程来缩短交互式响应时间，并增加应用程序总吞吐量。</li><li>帮助数据库开发人员生成可靠且可扩展的应用程序。</li><li>在<code>SQL Server</code>实例之间提供可靠的消息传递服务。</li></ul></blockquote><p>2）<code>CLR</code>集成<br>3）专用管理员<code>DAC</code>：<code>SQL Server 2005</code>为管理员提供了一种特殊的诊断连接，以供在无法与服务器建立标准连接时使用。<br>4）用户与架构分离</p><blockquote><ul><li>简化删除数据库用户的操作</li><li>多个用户可以用户同一个架构</li></ul></blockquote><p>5）分区：<code>分区</code>是大型数据表和索引采取的优化存储性能和数据存储的技术。</p><p>2，<strong><code>SQL Server 2005</code> 体系结构</strong><br><img src="/images/db_table_manager_architecture_20190417.png" alt="SQL Server体系结构"></p><p>1）<strong>数据库引擎组件</strong>：为数据存储、处理和安全实现高可伸缩性和高可用性服务。<br>2）<strong>报表组件服务组件</strong>：提供了全面的报表解决方案，可创建、管理和发布传统的、可打印的报表和交互性的、基于<code>Web</code>的报表。<br>3）<strong>分析服务组件</strong>：提供数据分析服务。利用分析服务开发人员设计、创建和管理多种数据源和多种数据结构，通过数据分析规律，获取数据知识。<br>4）<strong>集成服务组件</strong>：用于构建高性能数据集成解决方案（包括为数据仓库提取、转换和加载（<code>ETL</code>）包）的平台。<br>5）<strong>其他组件</strong>：复制服务组件，通知服务组件，服务代理组件，全文搜索。</p><p>3，<strong><code>SQL Server 2005</code>安装</strong></p><p>1）<strong><code>SQL Server 2005</code>版本选择</strong></p><blockquote><ul><li><code>SQL Server 2005</code>企业版：支持<code>32位</code>和<code>64位</code>系统，适合超大型企业。包括联机事务处理，高度复杂的数据分析，数据仓库系统和网站所需的基本功能。</li><li><code>SQL Server 2005</code>标准版：支持<code>32位</code>和<code>64位</code>系统，适合中小型企业。包括电子商务，数据仓库和业务流解决方案所需的基本功能。</li><li><code>SQL Server 2005</code>工作组版：仅支持<code>32位</code>系统，适合小型企业使用。包括<code>SQL Server</code>产品系列的核心数据库功能，可升级至标准版或者企业版。</li><li><code>SQL Server 2005</code>开发版：支持<code>32位</code>和<code>64位</code>系统，仅适合于开发和测试系统使用。具备和企业版完全一样的功能，但有许可限制，只能用于开发和测试。</li><li><code>SQL Server 2005</code>简易版：仅支持<code>32位</code>系统，是一个免费的，使用简单，易于管理的数据库。</li><li><code>SQL Server 2005</code>精简版：仅支持<code>32位</code>系统，适合在移动智能设备上使用。</li></ul></blockquote><h2 id="二，数据库的类型"><a href="#二，数据库的类型" class="headerlink" title="二，数据库的类型"></a>二，数据库的类型</h2><p>1，<strong>系统数据库</strong></p><p><code>数据库</code>是表、视图、索引、存储过程等对象的集合，是数据库管理系统的核心，数据库与管理它的数据库管理系统统一组成数据库服务器。</p><p> 1）<strong><code>master</code></strong>：记录了<code>SQL Server</code>系统的所有服务器的系统信息，包括实例范围的元数据，端点，链接服务器和系统配置设置。</p><p> 2）<strong><code>model</code></strong>：用于在<code>SQL Server</code>实例上创建的所有数据库的模板。</p><p> 3）<strong><code>msdb</code></strong>：提供给<code>SQL Server</code>代理服务器使用的数据库，主要用于为警报，作业，任务调度及记录操作员的操作提供相应的支持。</p><p> 4）<strong><code>tempdb</code></strong>：连接到<code>SQL Server</code>实例的所有用户都可用的全局资源，保存所有临时表和临时存储过程。</p><p> 5）<strong><code>resource</code></strong>：是一个隐藏的只读数据库，包含了<code>SQL Server</code>中的所有系统对象，但不包含用户数据或者用户元数据。</p><p>2，<strong>用户数据库</strong></p><ul><li>数据库<code>命名规则</code>如下：<blockquote><ul><li>第一个字符必须是字母<code>a～z</code>和<code>A~Z</code>、汉字或者下画线(<code>_</code>)、符号<code>@</code>，<code>#</code>；</li><li>后续字符可以是字母<code>a～z</code>和<code>A~Z</code>、汉字、数字或者下画线(<code>_</code>)、符号<code>@</code>，<code>$</code>、数字符号；</li><li>标识符不能是<code>T-SQL</code>的保留字；</li><li>长度不能超过128。</li></ul></blockquote></li></ul><p>3，<strong>数据库快照</strong></p><p>1）<strong><code>数据库快照</code>的定义</strong>：<code>数据库快照</code>是用户数据库的只读、静态视图，不包括未提交的事务。</p><p>2）<strong><code>数据库快照</code>的特点</strong>：</p><blockquote><ul><li>反映某个时刻（完成数据库快照创建的时刻）数据库的数据；</li><li>不允许更新；</li><li>一个用户数据库可以创建多个数据库快照，并且必须与数据库在同一个服务器实例上。</li></ul></blockquote><h2 id="三，数据库存储文件"><a href="#三，数据库存储文件" class="headerlink" title="三，数据库存储文件"></a>三，数据库存储文件</h2><p><code>SQL Server 2005</code>数据库<strong>文件名称</strong>包括：</p><blockquote><ul><li><code>逻辑文件名</code>：在所有 <code>T-SQL</code> 语句中引用物理文件时所使用的名称，必须符合<code>SQL Server</code> 标识符规则，而且是唯一的。</li><li><code>物理文件名</code>：包括目录路径的物理文件名称，必须符合操作系统文件命名规则。</li></ul></blockquote><p><code>SQL Server 2005</code>数据库<strong>操作系统文件</strong>包括：</p><blockquote><ul><li><code>数据文件</code>：包括数据和对象，如表、索引、存储过程和视图。</li><li><code>日志文件</code>：包含恢复数据库中的所有事务所需的信息。</li></ul></blockquote><p>1，<strong>数据库文件</strong></p><blockquote><ul><li><strong>主要数据库文件（<code>.mdf</code>）</strong>：数据库的起点，包括数据库的启动信息，并指向数据库中其他文件。</li><li><strong>次要数据库文件（<code>.ndf</code>）</strong>：是可选的，由用户定义并存储用户数据。</li><li><strong>事务日志文件（<code>.ldf</code>）</strong>：用于恢复数据库的日志信息。</li></ul></blockquote><p>2，<strong>数据库文件组</strong></p><blockquote><ul><li><strong>主文件组</strong>：包含主要数据文件和任何没有明确分配给其他文件组的其他文件。<code>系统表</code>的所有页均分配在主文件组中。</li><li><strong>用户定义文件组</strong>：通过在 <code>create database</code> 或者 <code>alter database</code> 语句中使用 <code>filegroup</code> 关键字指定的任何文件组。</li><li><strong>默认文件组（<code>primary</code>文件组）</strong>：如果在数据库中创建对象时没有指定对象所属的文件组，对象将被分配给默认文件组。</li></ul></blockquote><p><strong><code>注意</code></strong>：日志文件包括在文件组内。</p><h2 id="四，数据库的对象"><a href="#四，数据库的对象" class="headerlink" title="四，数据库的对象"></a>四，数据库的对象</h2><p>1，<strong>数据库关系图</strong>：以<code>图形</code>方式来表示表之间的关系。</p><p>2，<strong>表</strong>：组织和存储数据。</p><p>3，<strong>索引</strong>：提高数据检索速度，但增加了系统存储空间的开销。</p><p>4，<strong>视图</strong>：实现用户对数据对查询，但是视图的结构和数据是建立在对表的查询基础上的。</p><p>5，<strong>存储过程和触发器</strong>：数据库中的对编程对象。</p><blockquote><ul><li><code>存储过程</code>独立于表，存储在服务器上，供客户端调用，提供应用程序的效率。</li><li><code>触发器</code>是一种特殊的存储过程，可以大大增强应用程序的健壮性，数据的可恢复性和可管理性。</li></ul></blockquote><p>6，<strong>规则和约束</strong>：对能够放入表中的内容进行限定。</p><blockquote><ul><li><code>规则</code>：用于在用户定义数据类型上加以限制。</li><li><code>约束</code>：本身并非实际的对象，而只是描述特定表的元数据。</li></ul></blockquote><p>7，<strong>默认值</strong>：</p><ul><li><code>默认值</code>有两种类型：<blockquote><ul><li>默认值默认其本身是一个对象；</li><li>默认值不是实际的对象，只描述表特定列的元数据。</li></ul></blockquote></li></ul><p>8，<strong>全文目录</strong>：<code>全文目录</code>是数据的映射，以加速对启用了全文搜索的列中特定文本块的搜索。</p><h2 id="五，创建数据库"><a href="#五，创建数据库" class="headerlink" title="五，创建数据库"></a>五，创建数据库</h2><ul><li>一个<code>SQL Server</code>实例，最多可以创建<code>32767</code>个数据库。</li></ul><p>1，<strong>使用<code>SQL Server</code>管理工具创建</strong></p><p>2，<strong>使用<code>T-SQL</code>创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> xsxk </span><br><span class="line"><span class="keyword">on</span> primary                   <span class="comment">-- 建立主要数据文件</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_data'</span>,         <span class="comment">-- 逻辑名称</span></span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_data.mdf'</span>,   <span class="comment">-- 物理文件路径和名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">1024</span>KB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="keyword">unlimited</span>,   <span class="comment">-- 最大尺寸为无限大</span></span><br><span class="line">    filegrowth = <span class="number">10</span>%       <span class="comment">-- 增长速度</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">log</span> <span class="keyword">on</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_log'</span>,         <span class="comment">-- 建立日志文件</span></span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_log.ldf'</span>,   <span class="comment">-- 物理文件路径和名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">1024</span>KB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="number">5120</span>KB,  </span><br><span class="line">    filegrowth = <span class="number">1024</span>KB</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><h2 id="六，维护数据库"><a href="#六，维护数据库" class="headerlink" title="六，维护数据库"></a>六，维护数据库</h2><p>1，<strong>查看数据库状态</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,state,state_desc <span class="keyword">from</span> sys.databases;</span><br></pre></td></tr></table></figure><p>2，<strong>修改数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> xsxk </span><br><span class="line"><span class="keyword">modify</span> <span class="keyword">file</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_data'</span>,         <span class="comment">-- 逻辑名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">5</span>MB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="number">50</span>MB,   </span><br><span class="line">    filegrowth = <span class="number">2</span>%       <span class="comment">-- 增长速度</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> xsxk</span><br><span class="line"><span class="keyword">log</span> <span class="keyword">on</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">name</span> = <span class="string">'xsxk_log'</span>,         <span class="comment">-- 建立日志文件</span></span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_log.ldf'</span>,   <span class="comment">-- 物理文件路径和名称</span></span><br><span class="line">    <span class="keyword">size</span> = <span class="number">1024</span>KB,         <span class="comment">-- 初始大小</span></span><br><span class="line">    <span class="keyword">maxsize</span> = <span class="number">5120</span>KB,  </span><br><span class="line">    filegrowth = <span class="number">2</span>MB</span><br><span class="line"> )</span><br><span class="line"> <span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>3，<strong>删除数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> xsxk;</span><br></pre></td></tr></table></figure><p>4，<strong>分离和附加数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分离数据库</span></span><br><span class="line">sp_detach_db xsxk;</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 附加数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> xsxk <span class="keyword">on</span></span><br><span class="line">(</span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_data.mdf'</span></span><br><span class="line">),(</span><br><span class="line">    filename = <span class="string">'E:\students\xsxk_log.ldf'</span></span><br><span class="line">)</span><br><span class="line">    <span class="keyword">for</span> attach;</span><br><span class="line">go</span><br></pre></td></tr></table></figure><p>5，<strong>其他操作</strong></p><p>1）<strong>脱机用户数据库</strong></p><p>2）<strong>联机用户数据库</strong></p><p>3）<strong>重命名数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> xsxk <span class="keyword">modify</span> <span class="keyword">name</span> = xsxks</span><br></pre></td></tr></table></figure><p>4）<strong>收缩数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将userDB用户数据库中的文件减小，以使userDB中的文件有10%的可用空间</span></span><br><span class="line">dbcc sharinkdatabases(userDB, 10)</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 将userDB用户数据库中名为DataFile的文件大小收缩到7M</span></span><br><span class="line">DBCC shrinkfile(DataFile, 7)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;课本第07～08章主要知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，SQL-Server-2005概述
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库实践" scheme="https://zhangbc.github.io/tags/db-practice/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】数据库的安全和保护</title>
    <link href="https://zhangbc.github.io/2019/04/14/db_security/"/>
    <id>https://zhangbc.github.io/2019/04/14/db_security/</id>
    <published>2019-04-14T11:05:17.000Z</published>
    <updated>2019-04-14T16:43:26.612Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，安全与保护概述"><a href="#一，安全与保护概述" class="headerlink" title="一，安全与保护概述"></a>一，安全与保护概述</h2><p>1）<strong><code>数据安全性控制</code></strong>：防止未经授权的用户和存取数据库中的数据，避免数据的泄露，更改或破坏；</p><p>2）<strong><code>数据完整性控制</code></strong>：保证数据库中数据及语义的正确性和有效性，防止任何对数据库造成错误的操作；</p><p>3）<strong><code>数据库的并发控制</code></strong>：在多用户同时对一个个数据进行操作时，系统应能够加以控制，防止破坏数据库中的数据；</p><p>4）<strong><code>数据库的恢复</code></strong>：在数据库遭到破坏或者数据不正确时，系统有能力把数据库恢复到正确的状态。</p><h2 id="二，数据库的安全性"><a href="#二，数据库的安全性" class="headerlink" title="二，数据库的安全性"></a>二，数据库的安全性</h2><p>1，<strong>数据库安全性控制</strong></p><p>1）<strong>用户标识与鉴别</strong>：系统提供的最外层的安全保护措施，其方法是由系统提供一定的方式让用户标识自己的名字或身份。</p><p> 2）<strong>存取控制</strong>：</p><blockquote><p>（1）<code>定义用户权限</code>，并将用户权限等存储在数据字典中。<code>用户权限</code>是指不同等用户对不同对数据对象允许执行对操作权限，这些定义经过编译后存放在数据字典中，这些定义称为<code>安全规则</code>或<code>授权规则</code>；<br>（2）<code>合法权限检查</code>。用户权限定义和合法权限检查机制组成类<code>DBMS</code>的安全子系统。</p></blockquote><p>3）<strong>试图机制</strong>：数据安全性，逻辑数据独立性和操作简便性。</p><p>4）<strong>审计</strong>：<code>审计追踪</code>是一个对数据库进行更新对日志，还包括一些其他信息，如哪个用户执行了更新和什么时候执行的更新等。</p><p>5）<strong>数据加密</strong>：防止数据库中数据在存储和传输中失密的有效手段。</p><p>2，<strong>SQL Server的安全性措施</strong></p><p>1）<strong><code>SQL Server</code>安全控制概述</strong></p><blockquote><p>（1）操作系统安全验证（网络层）：通过设置安全模式来实现。<br>（2）<code>SQL Server</code>安全验证（服务器）：通过<code>SQL Server</code>服务器登录名管理来实现。<br>（3）<code>SQL Server</code>数据库安全验证：通过<code>SQL Server</code>数据库用户管理来实现。<br>（4）<code>SQL Server</code>数据库对象安全验证（处理权限）：通过权限管理来实现。</p></blockquote><p>2）<strong><code>SQL Server</code>的安全认证模式</strong></p><blockquote><p>（1）身份验证阶段：Windows身份验证，混合模式验证。<br>（2）权限认证阶段<br>（3）设置身份验证</p></blockquote><p>3）<strong>登录名和用户管理</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> &lt;<span class="keyword">DATABASE</span> <span class="keyword">NAME</span>&gt;</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &lt;<span class="keyword">new</span> user_name&gt; <span class="keyword">FOR</span> LOGIN &lt;login <span class="keyword">name</span>&gt;;</span><br></pre></td></tr></table></figure></p><p>4）<strong>权限管理</strong></p><blockquote><p>（1）<strong>权限分类</strong>：<code>语句权限</code>，<code>对象权限</code>，<code>隐含权限</code>；<br>（2）<strong>角色分类</strong>：在<code>SQL Server</code>中，组是通过角色来实现的。角色分为<code>服务器角色</code>和<code>数据库角色</code>（预定义的数据库角色，用户自定义数据库角色和应用程序角色）。</p></blockquote><h2 id="三，数据库的完整性"><a href="#三，数据库的完整性" class="headerlink" title="三，数据库的完整性"></a>三，数据库的完整性</h2><p>1，<strong><code>数据库的完整性</code>定义</strong>：<code>数据库的完整性</code>是指数据的正确性（<code>Correctness</code>），有效性（<code>Validity</code>）和相容性（<code>Consistency</code>）。<code>正确性</code>是指数据的合法性；<code>有效性</code>是指数据是否属于所定义的有效范围；<code>相容性</code>是指表示同一事实的两个数据应一致，不一致就是不相容。</p><p><code>完整性检查</code>：在<code>DBMS</code>中，检查数据库中的数据是否满足语义规定的条件。</p><p>2，<strong>完整性约束条件</strong></p><p>1）<strong>完整性约束作用的对象</strong>可以是<code>列</code>，<code>元组</code>，<code>关系</code>。其中：<code>列的约束</code>主要是列的类型，取值范围，精度，排序等约束条件；<code>元组的约束</code>是元组中各个字段间的联系约束；<code>关系的约束</code>是若干元组间，关系集合上及关系之间的联系约束。</p><p>2）<strong><code>静态约束</code></strong>：指数据库在每个确定状态时的数据对象所应满足的约束条件，是反映数据库状态合理性的约束。</p><blockquote><p>（1）<code>静态列级约束</code>：对一个列的取值范围的说明，即对数据类型的约束（数据的类型，长度，单位，精度等），对数据格式的约束，对取值范围或者取值集合的约束，对空值的约束，其他约束。<br>（2）<code>静态元组约束</code>：规定元组的各个列之间的约束关系。<br>（3）<code>静态关系约束</code>：实体完整性约束，参照完整性约束，函数依赖约束，统计约束。</p></blockquote><p>3）<strong><code>动态约束</code></strong>：指数据库从一种状态转变为另一种状态时，新旧值之间所应满足的约束条件，是反映数据库状态变迁的约束。</p><blockquote><p>（1）<code>动态列级约束</code>：修改列定义或者列值时应满足的约束条件。<br>（2）<code>动态元组约束</code>：修改元组中各个字段间需要满足某种约束条件。<br>（3）<code>动态关系约束</code>：加在关系变化前后状态上的限制条件，如事务一致性，原子性等。</p></blockquote><p>3，<strong>完整性控制</strong></p><p>1）<strong>定义功能</strong>：提供定义完整性约束条件的机制。</p><p>2）<strong>检查功能</strong>：检查用户发出的操作请求是否违背列完整性约束条件。</p><p>3）如果发现用户的操作请求使数据违背了完整性约束条件，则采取恰当的操作。</p><p>4，<strong><code>SQL Server</code>的完整性实现</strong></p><p>1）<strong>声明型数据完整性约束</strong>：在 <code>create table</code> 和 <code>alter table</code> 定义中使用约束限制表中的值。</p><p>2）<strong>过程型数据完整性约束</strong>：由缺省，规则和触发器实现，由视图和存储过程支持。</p><p>（1）<strong><code>约束</code></strong>：是SQL Server提供的自动保持数据库完整性的一种方法。分为：<br>i）<code>空值约束</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] [NULL/NOT NULL]</span><br></pre></td></tr></table></figure></p><p>ii）<code>主键约束</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列级</span></span><br><span class="line">[CONSTRAINT constraint_name] PRIMARY KEY  </span><br><span class="line"><span class="comment">-- 表级</span></span><br><span class="line">[CONSTRAINT constraint_name] PRIMARY KEY(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;])</span><br></pre></td></tr></table></figure></p><p>iii）<code>唯一约束</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列级</span></span><br><span class="line">[CONSTRAINT constraint_name] UNIQUE  </span><br><span class="line"><span class="comment">-- 表级</span></span><br><span class="line">[CONSTRAINT constraint_name] UNIQUE(&lt;column_name&gt;[&#123;,&lt;column_name&gt;&#125;])</span><br></pre></td></tr></table></figure></p><ul><li><code>唯一约束</code>和<code>主键约束</code>的区别：<blockquote><p>（1）在一个基本表中，只能定义在一个主键约束，但可以定义多个唯一约束；<br>（2）两者都为指定但列建立唯一索引，但主键约束限制更为严格，不但不允许有重复值，而且也不允许由空值；<br>（3）唯一约束与主键约束产生但约束可以是聚集索引，也可以是非聚集索引，在缺省情况下，唯一约束产生非聚集索引，主键约束产生聚集索引；<br>（4）不能同时为同一列或者一组列既定义唯一约束，又定义主键约束。</p></blockquote></li></ul><p>iv）<code>外键约束和参照约束</code><br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] [FOREIGN KEY] REFERENCES ref_table (ref_column[&#123;,&lt;trf_column&gt;&#125;])</span><br></pre></td></tr></table></figure></p><p>v）<code>缺省值约束</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] DEFAULT constraint_expression</span><br></pre></td></tr></table></figure></p><p>vi）<code>检查约束</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT constraint_name] <span class="keyword">CHECK</span>(logical_expression)</span><br></pre></td></tr></table></figure></p><ul><li>例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line"><span class="keyword">go</span> </span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Titles </span><br><span class="line">(</span><br><span class="line">    title_id <span class="built_in">varchar</span>(<span class="number">6</span>) <span class="keyword">constraint</span> pk_title_id primary <span class="keyword">key</span>,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">80</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">constraint</span> uniq_title <span class="keyword">unique</span>,</span><br><span class="line">    [<span class="keyword">type</span>] <span class="built_in">char</span>(<span class="number">12</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">constraint</span> def_type <span class="keyword">default</span> <span class="string">'UNDECIDED'</span>,</span><br><span class="line">    pub_id <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">    price money <span class="keyword">constraint</span> chk_price <span class="keyword">check</span>(price <span class="keyword">between</span> <span class="number">5</span> <span class="keyword">and</span> <span class="number">100</span>),</span><br><span class="line">    ytd_sales <span class="built_in">int</span>,</span><br><span class="line">    pub_date datetime <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">constraint</span> def_pub_date <span class="keyword">default</span> <span class="keyword">getdate</span>()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>（2）<strong><code>规则</code></strong>：当向表当某列（或使用与该规则绑定的用户定义数据类型的所有列）插入列或更新数据时，它指定限制输入新值的取值范围。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> rule rule_price <span class="keyword">as</span> @price &gt;= <span class="number">5</span> <span class="keyword">and</span> @price &lt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line">exec sp_bindrule <span class="string">'rule_price'</span>, <span class="string">'Titles.price'</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>（3）<strong><code>缺省</code></strong>：它指定在向数据库中的表插入数据时，如果用户没有明确给出某列的值，<code>SQL Server</code>自动为该列（使用与该缺省绑定的用户定义数据类型的所有列）输入值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">default</span> def_price <span class="keyword">as</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line">​</span><br><span class="line">exec sp_bindefault def_price, <span class="string">'Titles.price'</span></span><br><span class="line"><span class="keyword">go</span></span><br></pre></td></tr></table></figure><h2 id="四，事务"><a href="#四，事务" class="headerlink" title="四，事务"></a>四，事务</h2><p>1，<strong>事务的概念</strong></p><p>1）<strong><code>事务</code>定义</strong>：用户定义的一个数据库操作序列，这些操作要么可全部成功执行，否则，将不执行其中任何一个操作。事务是一个不可分割的工作单元。</p><p>2）<strong>事务基本性质(<code>ACID</code>)</strong></p><blockquote><p>（1）<strong><code>原子性(Atomicity)</code></strong>：事务中包含的所有操作要么全做，要么一个也不做。<br>（2）<strong><code>一致性(Consistency)</code></strong>：定义在数据库上的各种完整性约束。<br>（3）<strong><code>隔离性(Ioslation)</code></strong>：确保事务并发执行后的系统状态与这些事务以某种次序串行执行后的状态是等价的。<br>（4）<strong><code>持久性(Durability)</code></strong>：一个事务一旦成功完成，它对数据库的改变必须是永久的，即使是在系统遇到故障的情况下也不会丢失。</p></blockquote><p>2，<strong>事务调度</strong></p><p>1）<code>事务调度</code>的定义：在一个大型的<code>DBMS</code>中，可能会同时存在多个事务处理请求，系统需要确定这组事务的执行次序，即每个事务的指令在系统中执行的时间顺序，这称为<code>事务的调度</code>。</p><p>2）<code>合法调度</code>须满足以下条件：</p><blockquote><p>i）调度必须包含所有的事务的指令；<br>ii）一个事务中指令的顺序在调度中必须保持不变。</p></blockquote><p>3）调度的<strong>基本形式</strong></p><p>i）<code>串行调度</code></p><blockquote><ul><li><code>串行调度</code>：在前一个事务完成之后，在开始另外一个事务，类似与操作系统中的单道批处理作业。</li><li><code>可串行化调度</code>：定义多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，这种调度策略称为<code>可串行化调度</code>。</li></ul></blockquote><p>ii）<code>并行调度</code></p><blockquote><ul><li><code>并行调度可串行化</code>：如果一组事务并行调度的执行结果等价于这组事务中所有提交事务的某个串行调度，则称该<code>并行调度可串行化</code>。</li><li><code>级联回滚</code>：由于一个事务的故障而导致一系列其他事务的回滚。</li><li><code>无级联调度</code>：应该对调度做出某种限制以避免级联回滚发生，这样的调度称为<code>无级联调度</code>。</li><li><code>可恢复调度</code>：对每对事务$T_i$和$T_j$，如果$T_j$读取了由$T_i$所写的数据项，则$T_i$必须先于$T_j$提交。</li></ul></blockquote><p>3，<strong>事务隔离级别</strong></p><p>1）<strong>并发操作带来的问题</strong></p><blockquote><p>i）<code>丢失修改</code>：又称<code>写-写错误</code>，两个事务$T_1$和$T_2$读入同一数据并修改，$T_2$提交的结果破坏了$T_1$提交的结果，导致$T_1$的修改被丢失。<br>ii）<code>脏读</code>：又称<code>写-读错误</code>，事务$T_1$修改某一数据，并将其写回磁盘，事务$T_2$读取同一数据后，$T_1$由于某种原因被撤销，这时$T_1$已修改过的数据恢复原值，$T_2$读到的数据就与数据库中的数据不一致，则$T_2$读到的数据即为<code>“脏”数据</code>，即<code>不正确的数据</code>。<br>iii）<code>不可重复读</code>：又称<code>读-写错误</code>，事务$T_1$读取某一数据后，事务$T_2$对其做了修改，当$T_1$再次读取该数据时，得到与前次不同的值。<br>iv）<code>幻想读</code>：事务$T_2$按一定条件读取了某些数据后，事务$T_1$插入（删除）了一些满足这些条件的数据，当$T_2$再次按相同条件读取数据时，发现多（少）了一些记录。</p></blockquote><p>2）<strong>事务隔离级别的定义</strong></p><blockquote><p>i）<code>未提交读</code>：又称<code>脏读</code>，允许运行在该隔离级别上的事务读取当前数据页上的任何数据，而不管该数据是否已提交，解决了<code>丢失修改</code>问题。<br>ii）<code>提交读</code>：保证运行在该隔离级别上的事务不会读取其他未提交事务所修改的数据，解决了<code>丢失修改</code>和<code>脏读</code>的问题。<br>iii）<code>可重复读</code>：保证一个事务如果再次访问同一数据，与此前访问相比，数据不会发生修改，解决了<code>丢失修改</code>，<code>脏读</code>和<code>不可重复读</code>问题。<br>iv）<code>可串行化</code>：在这个级别上的一组事务的并发执行与它们的某个串行调度是等价的，解决了并发操作带来的四个不一致问题。</p></blockquote><p>4，<strong><code>SQL Server</code>中的事务定义</strong></p><p>1）<strong>事务定义模式</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN[SACTION] [事务名[<span class="keyword">WITH</span> MARK[<span class="string">'事务描述'</span>]]]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 提交1</span></span><br><span class="line"><span class="keyword">COMMIT</span> [TRAN[SACTION] [事务名]]</span><br><span class="line"><span class="comment">-- 提交2</span></span><br><span class="line"><span class="keyword">COMMIT</span>[<span class="keyword">WORK</span>]</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- 回滚1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> [TRAN[SACTION] [事务名|保存点名]]</span><br><span class="line"><span class="comment">-- 回滚2</span></span><br><span class="line"><span class="keyword">COMMIT</span>[<span class="keyword">WORK</span>]</span><br></pre></td></tr></table></figure></p><p>2）<strong>事务执行模式</strong></p><blockquote><p>i）<code>显式事务</code>：每个事务均以 <code>BEGIN TRANSACTION</code> 语句显式开始，以 <code>COMMIT</code> 或者 <code>ROLLBACK</code> 语句显式结束。<br>ii）<code>隐性事务</code>：每个事务无须描述事务的开始，但仍以 <code>COMMIT</code> 或 <code>ROLLBACK</code>语句显式完成。<br>iii）<code>自动提交事务</code>：<code>SQL Server</code> 的默认事务管理模式，意指每条单独的语句都是一个事务。在完成每个 <code>T-SQL</code> 语句时，都被提交或者回滚。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐性事务设置方法</span></span><br><span class="line"><span class="keyword">SET</span> IMPLICIT_TRANSACTIONS &#123;<span class="keyword">ON</span>|<span class="keyword">OFF</span>&#125;</span><br></pre></td></tr></table></figure><p>3）<strong>事务隔离级别的定义</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> committed;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</span><br></pre></td></tr></table></figure></p><p>4）<strong>批处理，触发器的事务</strong></p><p><code>批处理</code>是包含一个或者多个<code>SQL</code>语句的组，从应用程序一次性地发送到服务器执行。服务器将批处理语句编译成一个可执行单元，此单元称为<code>执行计划</code>。</p><h2 id="五，并发控制"><a href="#五，并发控制" class="headerlink" title="五，并发控制"></a>五，并发控制</h2><p>1，<strong>相关概念</strong></p><p><code>事务</code>是并发控制的基本单位，<code>事务</code>最基本的特征之一是<code>隔离性</code>。为保证事务的隔离性，系统必须对并发事务之间的相互作用加以控制，这称为<code>并发控制</code>。并发控制的主要技术是<code>封锁</code>。</p><p>2，<strong>封锁技术</strong></p><p>1）<code>封锁</code>：事务$T$在对某个数据库对象操作之前，先向系统发出请求，对其加锁。<strong>最基本</strong>的封锁模式有<code>排他锁(X锁)</code>和<code>共享锁(S锁)</code>。</p><blockquote><p>i）<code>排他锁</code>：又称<code>写锁</code>，如果事务$T$对数据对象$A$加上$X$锁，则只允许$T$读取和修改$A$，其他任何事务都不能再对$A$加任何类型的锁，直到$T$释放$A$上的锁。申请对$A$的排他锁可表示为$XLOCK(A)$。<br>ii）<code>共享锁</code>：又称<code>读锁</code>，如果事务$T$对数据对象$A$加上$S$锁，则只允许$T$读取$A$但不允许修改$A$，其他事务只能再对$A$加$S$锁而不能加$X$锁，直到$T$释放$A$上的$S$锁。申请对$A$的共享锁可表示为$SLOCK(A)$。</p></blockquote><p>3，<strong>事务隔离级别与封锁规则</strong></p><p>1）<code>封锁协议（Locking Protocol）</code>：在运用$X$锁和$S$锁这两种基本封锁对数据对象加锁时，还需要约定规则，如何时申请$X$锁或$S$锁，持锁时间，何时释放等，这些规则称为<code>封锁协议</code>。</p><p>2）<code>长锁</code>：保持到事务结束的锁；<code>短锁</code>：用完就释放的锁。</p><p>4，<strong>封锁粒度（<code>MGL</code>）</strong></p><p>1）<code>封锁粒度</code>定义：封锁对象的大小称为<code>粒度</code>。</p><blockquote><p>i）<code>多粒度封锁</code>：数据库中被封锁的资源按粒度大小会呈现处一种层次关系，元组隶属于关系，关系隶属于数据库，称为<code>粒度树</code>。当为某结点加上意向锁（$I$锁）时，就表明某些内层结点已发生事实上的封锁，防止其他事务再去封锁该结点，这种封锁方式称为<code>多粒度封锁（Multi Granularity Lock）</code>。<br>ii）<code>意向锁</code>：如果对一个结点加意向锁，则说明该节点的下层结点正在加锁；对任意节点加锁时，必须先对它所在的上层结点加意向锁。</p><blockquote><ul><li><code>意向共享锁（IS锁）</code>：如果对一个数据对象加<code>IS</code>锁，表示它的后裔结点拟（意向）加<code>S</code>锁。</li><li><code>意向排他锁（IX锁）</code>：如果对一个数据对象加<code>IX</code>锁，表示它的后裔结点拟（意向）加<code>X</code>锁。</li><li><code>共享意向排他锁（SIX锁）</code>：如果对一个数据对象加<code>SIX</code>锁，表示对它加<code>S</code>锁，再加<code>IX</code>锁。</li></ul></blockquote></blockquote><p>5，<strong>并发控制</strong></p><p>1）<strong><code>SQL Server</code>锁模式</strong>：共享锁（<code>S</code>锁），更新锁（<code>U</code>锁），排他锁（<code>X</code>锁），意向共享锁（<code>IS</code>锁）， 意向排他锁（<code>IX</code>锁），共享意向排他锁（<code>SIX</code>锁）。</p><p>2）<strong><code>SQL Server</code>锁粒度</strong>：行级（<code>Row</code>），页面级（<code>Page</code>），表级（<code>Table</code>）</p><p>3）<strong>强制封锁类型</strong><br>在通常情况下，数据封锁由<code>DBMS</code>控制，对用户是透明的，但可以在<code>SQL</code>语句中加入锁定提示来强制 <code>SQL Server</code> 使用特定类型但锁。</p><h2 id="六，数据库恢复技术"><a href="#六，数据库恢复技术" class="headerlink" title="六，数据库恢复技术"></a>六，数据库恢复技术</h2><p>1，<strong><code>恢复</code>的概念</strong>：负责将数据库从故障所造成的错误状态中恢复到某一已知的正确状态（也称为一致性状态或者完整状态）。</p><p>2，<strong>故障的种类</strong></p><p>1）<code>事务故障</code>：指事务的运行没达到预期对象终点就终止，有两种错误可能造成事务执行失败。</p><blockquote><p>i）<code>非预期故障</code>：是指不能由应用程序处理的故障，如运算溢出，但该事务可以在以后但某个时间重新执行。<br>ii）<code>可预期故障</code>：指应用程序可以发现的事务故障，并且可以控制让事务回滚。</p></blockquote><p>2）<code>系统故障</code>：又称<code>软故障</code>，指在硬件故障，软件错误的影响下，导致内存中的数据丢失，并使得事务处理终止，但未破坏外存中数据库。<br>由于硬件错误和软件漏洞致使系统终止，而不破坏外存内容但故障又称为<code>故障-停止假设</code>。</p><p>3）<code>介质故障</code>：又称<code>硬故障</code>，指由于磁盘的磁头碰撞，瞬时的强磁场干扰等造成磁盘的损坏，破坏外存上的数据库，并影响正在存取的这部分数据的所有事务。</p><p>4）恢复的<strong>基本原理</strong>是<code>冗余</code>，即数据库中任意部分的数据可以根据存储在系统别处的冗余数据来重建。一般的冗余形式：<code>副本</code>和<code>日志</code>。</p><p>3，<strong>恢复的实现技术</strong></p><p>1）<strong><code>数据转储</code></strong>：<code>DBA</code>定期将整个数据库复制到磁带或者在另一个磁盘上保存起来的过程。</p><blockquote><p>i）<code>静态转储</code>：在系统中无运行事务时进行的转储操作，即转储操作开始的时刻，数据库处于一致性状态，而转储期间不允许对数据库的任何存取，修改活动。<br>ii）<code>动态转储</code>：指在转储期间允许对数据库进行存取或修改，即转储与用户事务可以并发执行。<br>iii）全量转储：每次转储全部数据库。<br>iv）增量转储：每次只转储上一次转储后更新过的数据。</p></blockquote><p>2）<strong>登记日志文件</strong></p><p><code>日志</code>是以<code>事务</code>为单位记录数据库每次更新活动的文件，由系统自动记录。遵循以下<strong>原则</strong>：</p><blockquote><p>i）登记的次序严格按并发事务执行的时间次序；<br>ii）必须先写日志文件，然后写数据库。</p></blockquote><p><code>前像</code>：要撤消事务，日志中必须包含数据库发生变化前的所有记录的备份，这些记录称为<code>前像(Before-Images)</code>。</p><p><code>后像</code>：为了恢复事务，日志中必须包含数据库改变之后的所有记录的备份，这些记录称为<code>后像(After-Images)</code>。</p><p>3）<strong>基本日志结构</strong></p><p><code>日志</code>是日志记录(<code>Log Records</code>)的序列，主要包含：</p><blockquote><p>（1）事务开始标识，如&lt;$T_i$ start&gt;；<br>（2）更新日志记录，描述一次数据库写操作，如&lt;$T_i,X_i,V_1,V_2$&gt;</p><blockquote><p>事务标识$T_i$是执行WRITE操作的事务的唯一标识；<br>数据项标识$X_i$是所写数据项的唯一标识，通常是数据项在磁盘上的位置；<br>更新前数据的旧值$V_1$ (对插入操作而言此项为空值)；<br> 更新后数据的新值$V_2$ (对删除操作而言此项为空值)。<br>（3）事务结束标识<br>&lt;$T_i$ COMMIT&gt;，表示事务$T_i$提交；<br>&lt;$T_i$ ABORT&gt;，表示事务$T_i$中止。</p></blockquote></blockquote><p>4，<strong><code>SQL Server</code>基于日志的恢复策略</strong></p><p>1）<strong>事务分类</strong></p><blockquote><p>i）<code>圆满事务</code>：指日志文件中记录了事务的<code>COMMIT</code>标识，说明日志中已经完整地记录下事务所有的更新活动。<br>ii）<code>夭折事务</code>：指日志文件只有事务的开始标识，而无<code>COMMIT</code>标识，说明对事务更新活动的记录是不完整的，无法根据日志来重现事务。</p></blockquote><p>2）<strong>基本的恢复操作</strong></p><blockquote><p>i）<code>重做</code>：对圆满事务所做过的修改操作应执行<code>REDO</code>操作，即重新执行该操作，修改对象赋予其新记录值，这种方法称为<code>前滚</code>。<br>ii）<code>撤销</code>：对夭折事务所做过的修改操作应执行<code>UNDO</code>操作，即撤销该操作，修改对象赋予其旧记录值，这种方法又称为<code>回滚</code>。</p></blockquote><p>3）<strong>事务故障恢复</strong></p><blockquote><p>i）反向扫描日志文件，查找该事务的更新操作；<br>ii）对该事务的更新操作执行逆操作，即将事务更新前的旧值写入数据库；<br>iii）继续反向扫描日志文件，查找其他事务的其他更新操作，做同样处理；<br>iv）如此处理下去，直至读到该事务的开始标识，事务恢复故障完成。</p></blockquote><p>4）<strong>系统故障恢复</strong></p><blockquote><p>i）正向扫描日志文件，找出圆满事务，将其事务标识记入重做队列；找出夭折事务，将其事务标识记入撤销队列；<br>ii）对撤销队列中的各个事务进行撤销处理，即反向扫描日志文件，对每个撤销事务对更新操作执行逆操作；<br>iii）对重做队列中的各个事务进行重做处理，即正向扫描日志文件，对每个重做事务重新执行日志文件登记的操作。</p></blockquote><p>5）<strong>介质故障恢复</strong></p><blockquote><p>i）装入最新的数据库后备副本，将数据库恢复到最近一次转储时的一致性状态；<br>ii）装入相应的日志文件副本，重做已完成的事务。</p></blockquote><p>5，<strong><code>SQL Server</code>的备份与恢复</strong></p><p>1）<strong><code>SQL Server</code>的备份</strong></p><blockquote><p>i）数据库备份：即<code>完全备份</code>。</p></blockquote><ul><li><p>设置简单恢复模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">set</span> <span class="keyword">recovery</span> simple;</span><br></pre></td></tr></table></figure></li><li><p>执行完全备份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- init:如果已存在bak文件，则首先删除，后执行</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">to</span> disk=<span class="string">'E:\mater_full.bak'</span> <span class="keyword">with</span> init;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>ii）<code>差异备份</code>：只存储上一次完备之后发生改变的数据。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="comment">-- init:如果已存在bak文件，则首先删除，后执行</span></span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">to</span> disk=<span class="string">'E:\mater_diff.bak'</span> <span class="keyword">with</span> init, differential;</span><br></pre></td></tr></table></figure><blockquote><p>iii）<code>日志备份</code>：数据库的恢复模式必须设为完整恢复模式并且必须在数据更改为完整恢复模式后至少执行一次完整数据库备份。</p></blockquote><ul><li><p>设置完整恢复模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">set</span> <span class="keyword">recovery</span> <span class="keyword">full</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行日志备份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">master</span>;</span><br><span class="line">go</span><br><span class="line">​</span><br><span class="line"><span class="keyword">backup</span> <span class="keyword">log</span> <span class="keyword">master</span> <span class="keyword">to</span> disk=<span class="string">'E:\master_log.bak'</span></span><br></pre></td></tr></table></figure></li></ul><p>2）<strong><code>SQL Server</code>恢复</strong></p><blockquote><p>i）使用<code>SQL Server</code>管理工具还原数据库<br>ii）使用<code>T-SQL</code>语句从简单备份策略还原数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_full.bak'</span>;</span><br></pre></td></tr></table></figure></p><p>iii）使用<code>T-SQL</code>语句还原差异备份<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_full.bak'</span> <span class="keyword">with</span> norecovery;</span><br><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_diff.bak'</span>;</span><br></pre></td></tr></table></figure></p><p>iv）使用<code>T-SQL</code>语句从完整备份策略还原数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">restore</span> <span class="keyword">database</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_full.bak'</span> <span class="keyword">with</span> <span class="keyword">replace</span>, norecovery;</span><br><span class="line"><span class="keyword">restore</span> <span class="keyword">log</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_log1.bak'</span> <span class="keyword">with</span> norecovery;</span><br><span class="line"><span class="keyword">restore</span> <span class="keyword">log</span> <span class="keyword">master</span> <span class="keyword">from</span> disk=<span class="string">'E:\master_log2.bak'</span>;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，安全与保护概述&quot;&gt;&lt;a href=&quot;#一，安全与保护概述&quot; class=&quot;headerlink&quot; title=&quot;一，安全与保护概述&quot;
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】数据库的设计与实施</title>
    <link href="https://zhangbc.github.io/2019/04/14/db_design/"/>
    <id>https://zhangbc.github.io/2019/04/14/db_design/</id>
    <published>2019-04-14T10:44:12.000Z</published>
    <updated>2019-04-14T10:46:42.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，数据库设计概述"><a href="#一，数据库设计概述" class="headerlink" title="一，数据库设计概述"></a>一，数据库设计概述</h2><p><code>数据库技术</code>是信息资源开发，管理和服务的最有效手段，从小型 单项事务处理系统到大型的信息系统都利用了数据库技术来保证系统数据的整体性，完整性和共享性。</p><p>1，<strong>数据库设计的内容与特点</strong></p><p>1）<strong>数据库设计</strong>包括<code>结构特性设计</code>与<code>行为特性设计</code>。</p><blockquote><ul><li><code>结构特性设计</code>即数据库框架和数据库结构设计，其结果是得到一个合理的数据模型，以反映真实的事务间的联系，目的是汇总各用户的视图，尽量减少冗余，实现数据共享。结构特性是<code>静态的</code>。</li><li><code>行为特性设计</code>是指应用程序设计，如查询，报表处理等，结构特性必须适应行为特性。</li></ul></blockquote><p>2，<strong>数据库设计方法</strong></p><p>1）<code>新奥尔良方法</code>：将数据库设计分为需求分析，概念设计，逻辑设计，物理设计。</p><p>2）从本质上，规范设计法的<strong>基本思想</strong>是“<code>反复探寻，逐步求精</code>”。</p><p>3，<strong>数据库设计的步骤</strong></p><p>1）<strong>数据库设计的过程</strong>：<code>三大阶段六步骤</code>，即：数据库规范设计，需求分析，概念结构设计，逻辑结构设计，物理结构设计，数据库实施与维护（总体规划阶段，系统开发设计阶段，系统运行与维护阶段）。</p><p>2）<strong>六个步骤</strong>：</p><blockquote><p>（1）<code>数据规划设计</code>：明确数据库建设的总体目标和技术路线，得出数据库设计项目的可行性分析报告，对数据库设计的进度和人员分工做出安排。<br>（2）<code>需求分析</code>：准确弄清用户要求是数据库设计的基础。<br>（3）<code>概念结构设计</code>：数据库逻辑结构依赖于具体的<code>DBMS</code>。概念结构是各用户关心的系统信息结构，是对现实世界的第一层抽象。<br>（4）<code>逻辑结构设计</code>：使概念结构转换为某个<code>DBMS</code>所支持的数据模型，并进行优化。<br>（5）<code>物理结构设计</code>：设计目标是从一个满足用户要求的已确定的逻辑模型出发，设计一个在限定的软件，硬件条件和应用环境下可实现的，运行效率高的数据库结构。<br>（6）<code>数据库实施与维护</code></p></blockquote><h2 id="二，数据库规划"><a href="#二，数据库规划" class="headerlink" title="二，数据库规划"></a>二，数据库规划</h2><p>1，<strong>系统调查</strong>：搞清楚企业的组织层次，得到企业的组织结构图。</p><p>2，<strong>可行性分析</strong>：分析数据库建设是否具有可行性，即从经济，法律，技术等多方面进行可行性论证分析，在此基础上得到可行性报告。</p><p>3，<strong>数据库建设的总体目标和数据库建设的实施总安排</strong></p><h2 id="三，需求分析"><a href="#三，需求分析" class="headerlink" title="三，需求分析"></a>三，需求分析</h2><p>1，<strong>需求分析的任务</strong></p><p>1）<code>需求分析</code>的<strong>任务</strong>：通过详细调查现实世界要处理的对象，充分了解原系统工作概况，明确各用户需求，在此基础上确定新的功能。</p><p>2）<code>需求分析</code>的<strong>重点</strong>：调查，搜集用户在数据管理中的信息要求，处理要求，安全性与完整性要求。</p><blockquote><ul><li><code>信息要求</code>是指用户需要从数据库中获取信息的内容和性质，由用户的信息要求可以导出数据要求，即在数据库中需要存储哪些数据。</li><li><code>处理要求</code>是指用户要求完成什么样的处理功能，对处理的响应时间有什么要求，处理方式是批处理还是联机处理。</li><li><code>安全性要求</code>是指保护数据不被未授权的用户破坏。</li><li><code>完整性要求</code>是指保护数据不被授权的用户破坏。</li></ul></blockquote><p>2，<strong>需求分析的方法</strong></p><p>1）常用的调查方法</p><blockquote><p>（1）跟班作业<br>（2）开调查会<br>（3）查阅档案资料<br>（4）询问<br>（5）设计调查用表并请用户填写</p></blockquote><p>3，<strong>需求分析的步骤</strong></p><p>1）<strong>分析用户的活动</strong></p><p>2）<strong>确定系统的边界</strong></p><p>3）<strong>分析用户活动所设计的数据</strong><br><code>数据流图（DFD）</code>是描述各处理活动之间数据流动的有力工具，是一种从数据流的角度描述一个组织业务活动的图示。</p><p>4）<strong>分析系统数据</strong></p><p><code>数据字典（DD）</code>是描述每个数据流，每个文件，每个加工的集合，是对数据流图中出现的所有数据元素给出逻辑定义和描述。</p><p><code>数据字典</code>包括<code>数据项</code>，<code>数据文件</code>，<code>数据流</code>，<code>数据加工处理</code>。</p><blockquote><ul><li><code>数据项描述</code>={数据项名，别名，数据项含义，数据类型，字节长度，取值范围，取值含义，与其他数据项的逻辑关系}</li><li><code>数据文件描述</code>={数据文件名，所有数据项名，数据存取频度，存取方式}</li><li><code>数据流描述</code>={数据流名称，所有数据项名，数据流来源，数据流去向，平均流量，峰值流量}</li><li><code>数据加工处理描述</code>={加工处理名，说明，输入的数据流名，输出的数据流名，处理要求}</li></ul></blockquote><h2 id="四，概念结构设计"><a href="#四，概念结构设计" class="headerlink" title="四，概念结构设计"></a>四，概念结构设计</h2><p><code>概念结构设计阶段</code>是将用户需求抽象为信息结构（概念模型）的过程。</p><p>1，<strong>局部E-R图的设计</strong></p><p>2，<strong>全局E-R图的设计</strong></p><h2 id="五，逻辑结构设计"><a href="#五，逻辑结构设计" class="headerlink" title="五，逻辑结构设计"></a>五，逻辑结构设计</h2><p>逻辑模式设计的<strong>主要目标</strong>是产生一个具体<code>DBMS</code>可处理的数据模型和数据库模式，即把概念设计阶段的全局<code>E-R</code>图转换成<code>DBMS</code>支持的数据模型。一般步骤： </p><blockquote><p>（1）将概念结构转换为一般的关系模型，网状模型或层次模型。<br>（2）将转换来的关系模型，网状模型，层次模型向<code>DBMS</code>支持的数据模型转换，变成合适的数据库模式。<br>（3）对模式进行挑战和优化。</p></blockquote><h2 id="六，物理结构设计"><a href="#六，物理结构设计" class="headerlink" title="六，物理结构设计"></a>六，物理结构设计</h2><p>1）在进行数据库的物理结构设计时，首先确定数据库的物理结构，然后是对所设计的物理结构设计进行评价。<br>2）物理结构设计的重要目标是满足主要应用的性能要求。<br>3）就<code>RDBMS</code>而言，物理结构设计主要内容有：为关系模式选取存取方法，设计关系，索引等数据库文件的物理存储结构。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，数据库设计概述&quot;&gt;&lt;a href=&quot;#一，数据库设计概述&quot; class=&quot;headerlink&quot; title=&quot;一，数据库设计概述&quot;
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】关系模式的规范化与查询优化</title>
    <link href="https://zhangbc.github.io/2019/04/13/db_query_opt/"/>
    <id>https://zhangbc.github.io/2019/04/13/db_query_opt/</id>
    <published>2019-04-13T14:31:38.000Z</published>
    <updated>2019-04-14T06:10:16.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，问题的提出"><a href="#一，问题的提出" class="headerlink" title="一，问题的提出"></a>一，问题的提出</h2><p>1，<strong>关系模式</strong></p><p><code>关系模式</code>定义：一个关系模式是一个系统，它是有一个五元组$R(U, D, DOM, I, F)$组成，其中，$R$为关系名，$U$是$R$的一组属性集合$\{ A_1,A_2,A_3,\dots,A_n \}$，$D$是$U$中属性的域集合$\{ D_1,D_2,D_3,\dots,D_n \}$，$DOM$为属性$U$到域$D$的映射，$I$为完整性约束集合，$F$为属性间的函数依赖关系。</p><p>2，<strong>关系</strong></p><p>1）<code>关系</code>定义：在关系模式$R( U, D, DOM, I, F )$中，当且仅当$U$上的一个关系$r$足$F$时，$r$称为关系模式$R$的一个关系，记作$R(U)$或$R(U,F)$。</p><p>2）关系数据库对关系有一个<strong>最起码的要求</strong>： 每个属性必须是不可分割的数据项。满足列这个条件的关系模式就属于<code>第一范式（1NF）</code>。</p><p>3）<code>数据依赖</code>：通过一个关系中属性间值的相等与否以体现数据间的相互关系，是现实世界属性间相互联系的抽象，是数据内在的性质，是语义的体现。主要有：<code>函数依赖FD</code>，<code>多值依赖MVD</code>。</p><p>3，<strong>插入异常</strong>：表示数据插入时出现问题，即无法在缺少另一个实体实例或者关系实例的情况下表示实体或者实体的信息。</p><p>4，<strong>删除异常</strong>：删除表的某一行来反映某个实体实例或者关系实例消失，会导致丢失另一个不同实例实体或者关系实例的信息。</p><p>5，<strong>更新异常</strong>：更改表所对应的某个实体实例或者关系实例的单个属性，会将多行的相关信息全部更新。</p><h2 id="二，关系模式的函数依赖"><a href="#二，关系模式的函数依赖" class="headerlink" title="二，关系模式的函数依赖"></a>二，关系模式的函数依赖</h2><p>1，<strong>函数依赖（<code>FD</code>）</strong></p><p>1）<code>函数依赖（FD）</code>定义：设$R(U)$是属性集$U$上的关系模式，$X$，$Y \subseteq U$。若对$R(U)$的任意一个可能的关系$r$，$r$中有任意两个元组$t_1$和$t_2$，如果$t_1 [ X ] = t_2 [ X ]$，有$t_1[ Y ] = t_2[ Y ]$，则称$X$函数确定$Y$，或者说$Y$函数依赖$X$，记为$X \rightarrow Y$。</p><blockquote><p>（1）如果$X \rightarrow Y$，但是$Y \nsubseteq X$，则称$X \rightarrow Y$是<code>非平凡的函数依赖</code>；<br>（2）如果$X \rightarrow Y$，但是$Y \subseteq X$，则称$X \rightarrow Y$是<code>平凡的函数依赖</code>；<br>（3）如果$X \rightarrow Y$，则$X$为这个函数依赖的<code>决定属性集(Determinant)</code>；<br>（4）如果$X \rightarrow Y$，$Y \rightarrow X$，则记为$X \longleftrightarrow Y$；<br>（5） 如果$Y$不函数依赖于$X$，则记为$X \nrightarrow Y$。</p></blockquote><p>2）<code>完全函数依赖</code>和<code>部分函数依赖</code><br>设$R(U)$是属性集$U$上的关系模式，如果$X \rightarrow Y$，并且对于$X$的任何一个真子集$Z$，都有$Z \nrightarrow Y$，则称$Y$完全依赖于$X$，记$X \stackrel{f}{\rightarrow} Y$；若$X \rightarrow Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记$X \stackrel{p}{\rightarrow} Y$。</p><p>3）<code>传递函数依赖</code><br>设$R(U)$是属性集$U$上的关系模式，$X \subseteq U$，$Y \subseteq U$，$Z \subseteq U$，$Z - X$，$Z - Y$，$Y - X$均非空，如果$X \rightarrow Y(Y \nsubseteq X)$，$Y \nrightarrow X$，$Y \rightarrow Z$，则称$Z$传递依赖于$X$。</p><p>2，<strong>键</strong></p><blockquote><p>1）<code>候选键</code>：设$R(U)$是属性集$U$上的关系模式，$K \subseteq U$，如果$K \stackrel{f}{\rightarrow}  U$，则$K$为$R$的<code>候选键</code>。<br>候选键包含了关系模式的所有属性，称为<code>全键</code>。<br>2）<code>主属性</code>：包含在任意一个候选键中的属性称为<code>主属性</code>。<br>3）<code>非主属性</code>：不包含在任意候选键中的属性称为<code>非主属性</code>或<code>非键属性</code>。<br>4）<code>外键</code>：在关系模式$R$中属性或者属性组$X$并非$R$的候选键，但$X$是另一个关系模式的候选键，则称$X$是$R$的<code>外部键</code>，也称<code>外键</code>。</p></blockquote><p>3，<strong>函数依赖的逻辑蕴含</strong></p><p>1）<strong>阿姆斯特朗公理体系</strong></p><p>   （1）<code>包含规则</code>：设$R(U)$是属性集$U$上的关系模式，$X \subseteq U$，$Y \subseteq U$，且$Y \subseteq X$，则$X \rightarrow Y$。</p><p>   （2）<code>平凡依赖</code>：由包含规则得到的函数依赖都是平凡函数依赖。</p><p>   （3）<code>逻辑蕴含</code>：设$R(U)$是属性集$U$上的关系模式，$F$是$R$上函数依赖集合，如果$R$的任意关系实例$r$使$F$成立的，函数依赖$X \rightarrow Y$均成立，则称$F$逻辑蕴含$X \rightarrow Y$。</p><p>   （4）<code>阿姆斯特朗公理</code>：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$的一个函数依赖集合，$X \subseteq U$，$Y \subseteq U$，$Z \subseteq U$。包含如下规则：</p><blockquote><p>i）<code>包含规则</code>：又称<code>自反律</code>，如果$Y \subseteq X \subseteq Z$，则$X \rightarrow Y$为$F$所蕴含；<br>ii）<code>传递规则</code>：如果$F$蕴含$X \rightarrow Y$，$Y \rightarrow Z$，则$X \rightarrow Z$为$F$所蕴含；<br>iii）<code>增广规则</code>：如果$F$蕴含$X \rightarrow Y$，且$Z \subseteq U$，则$XZ \rightarrow YZ$为$F$所蕴含。</p></blockquote><p><code>阿姆斯特朗公理</code>包含蕴含规则如下：</p><blockquote><p>i）<code>合并规则</code>：如果$X \rightarrow Y$，$X \rightarrow Z$，则$X \rightarrow YZ$；<br>ii）<code>伪传递规则</code>：如果$X \rightarrow Y$，$WY \rightarrow Z$，则$WX \rightarrow Z$；<br>iii）<code>分解规则</code>：如果$X \rightarrow Y$，$Z \subseteq Y$，则$X \rightarrow Z$；<br>iv）<code>集合累积规则</code>：如果$X \rightarrow YZ$且$Z \rightarrow W$，则$X \rightarrow YZW$。</p></blockquote><p><strong>【<code>引理4-1</code>】</strong> $X \rightarrow A_1A_2A_3 \dots A_n$ 成立的充分必要条件是$X \rightarrow A_i（i=1，2，\dots，n）$成立。</p><p>2）<strong>闭包，覆盖和最小覆盖</strong></p><p>（1）<code>函数依赖的闭包</code>：设$R$是一个具有属性集合$U$的关系模式，$F$是给定的函数依赖的集合，由$F$推导出的所有函数依赖的集合称为$F$的<code>闭包</code>，记作$F^{+}$。</p><p>（2）<code>函数依赖集的覆盖</code>：$R$表上的两个函数依赖集合$F$和$G$，如果函数依赖集$G$可以从$F$用<code>蕴含规则</code>推导出来，换言之，如果 $G \subset  F^{+}$，则称$F$ <code>覆盖</code> $G$，如果$F$ 覆盖 $G$ 且 $G$ 覆盖 $F$，则称这两个<code>函数依赖集等价</code>，记作$F \equiv G$。</p><p>（3）<code>属性集的闭包</code>：设$R$是一个具有属性集合$U$的关系模式，$F$是$R$上的函数依赖集，$X \subseteq U$，定义$X$的<code>闭包</code> $X^+$，作为$X$函数决定的最大属性集$Y$，则最大属性集满足 $X \rightarrow Y$ 存在于 $F^+$ 中。</p><p><strong>【<code>算法4-1</code>】</strong> 属性集 $X$ 的闭包 $X^+$ 的迭代算法：</p><blockquote><p>i）选$X$作为闭包$X^+$的初始值$X[0]$；<br>ii）由$X[i]$计算$X[i+1]$时，它是由 $X[i]$ 并上属性集合$A$所组成的，其中$A$为$F$中存在的函数依赖 $Y \rightarrow Z$，而$A \subseteq Z$，$Y \subseteq X[i]$。因为$U$是有穷的所以上述过程经过有限步后会达到$X[i] = X[i+1]$，此时$X[i]$为所求的$X^+$。</p></blockquote><p>（4）<code>最小覆盖</code></p><blockquote><p>i）$F$中任意函数依赖的右部只包含一个属性；<br>ii）不存在这样的函数依赖 $X \rightarrow A$，使得$F$与 $F- \{ X \rightarrow A \}$ 等价；<br>iii）不存在这样的函数依赖$X \rightarrow A$，$X$包含真子集$Z(Z \subset X)$，使得 $(F-\{ X \rightarrow A \} \cup \{ Z \rightarrow A \})$与$F$等价。<br>如果$F$满足上述条件，则函数依赖$F$称为<code>极小或者最小函数依赖集</code>。</p></blockquote><p>（5）<code>最小覆盖集算法</code></p><p>从函数依赖集$F$构造最小覆盖$M$的算法如下：</p><blockquote><p>i）从函数依赖集$F$，创建函数依赖的一个等价集$H$，它的函数依赖的右边只有单个属性（使用<code>分解规则</code>）<br>ii）从函数依赖集$H$，顺次去掉在$H$中非关键的单个函数依赖。一个函数依赖$X \rightarrow Y$在一个函数依赖集中是非关键的，指如果 $X \rightarrow Y$ 从$H$中去掉，得到结果$J$，仍然满足$H^+ = J^+$，或者说$H \equiv J$。<br>iii）从函数依赖集$J$，顺次用左边具有更少属性的函数依赖替换原来的函数依赖，只要不会导致$J^+$改变。<br>iv）从剩下的函数依赖集中收集所有左边相同的函数依赖，使用<code>合并规则</code>创建一个等价的函数依赖集$M$，它的所有依赖的左边是<code>唯一</code>的。</p></blockquote><p>（6）每个函数依赖集$F$都等价于一个极小函数依赖集。</p><h2 id="三，关系模式的规范化"><a href="#三，关系模式的规范化" class="headerlink" title="三，关系模式的规范化"></a>三，关系模式的规范化</h2><p><code>规范化</code>定义：把一个给定规范模式转化为某种范式的过程称为<code>关系模式的规范过程</code>，简称<code>规范化</code>。</p><p>1，<strong>第一范式</strong></p><p><strong>【<code>定义4-1</code>】</strong> 设$R$是一个关系模式，如果$R$的每个属性的值域都是<strong>不可分割</strong>的简单数据项的集合，则这个模式称为<code>第一范式关系模式</code>，记作<code>1NF</code>。</p><p>2，<strong>第二范式</strong></p><p><strong>【<code>定义4-2</code>】</strong> 如果关系模式$R$是<code>第一范式</code>，而且每个非主属性都<strong>完全函数依赖</strong>于$R$的键，则$R$称为<code>第二范式的关系模式</code>，记作<code>2NF</code>。</p><p>3，<strong>第三范式</strong></p><p><strong>【<code>定义4-3</code>】</strong> 设关系模式$R$满足<code>2NF</code>，而且它的任意一个非键属性都<strong>不传递依赖</strong>于任何候选键，则$R$称为<code>第三范式的关系模式</code>，记作<code>3NF</code>。</p><p>4，<strong>BCNF</strong></p><p><strong>【<code>定义4-4</code>】</strong> 设关系模式$R$满足<code>1NF</code>，如果对$R$的每个函数依赖 $X \rightarrow Y$ 且 $Y \nsubseteq X$，$X$必为<code>候选键</code>，则$R$满足<code>BCNF</code>，即：在关系模式 $R(U,F)$ 中，如果每个决定因素都包含键，则$R(U,F) \in BCNF$。</p><p><em>一个满足<code>BCNF</code>的关系模式有如下</em> <strong>条件</strong>：</p><blockquote><p>i）所有非键属性对每个键都是完全函数依赖；<br>ii）所有的键属性对每个不包含它的键，也是完全函数依赖；<br>iii）没有任何属性完全函数依赖于非键属性的任意一组属性。</p></blockquote><p>5，<strong>多值依赖与第四范式</strong></p><p>1）<strong>多值依赖</strong></p><p>   （1）<code>多值依赖</code>定义：设 $R(U)$ 是属性集$U$上的一个关系模式，$X$，$Y$，$Z$是$U$的子集，并且 $Z=U-X-Y$，关系模式$R(U)$中多值依赖 $X \rightarrow \rightarrow Y$ 成立，当且仅当对$R(U)$的任意关系$r$，给定的一对 $(x，z)$ 值，有一组$Y$的值，这组值仅仅取决于$x$值，而与$z$值无关。</p><p>   （2）如果 $X \rightarrow \rightarrow Y$，而 $Z=\varnothing$，即$Z$为空，则 $X \rightarrow \rightarrow Y$ 称为<code>平凡的多值依赖</code>。</p><p>   （3）<code>多值依赖的公理</code>（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。）</p><blockquote><p>i）<code>对称性规则</code>：如果 $X \rightarrow \rightarrow Y$，则 $X  \rightarrow \rightarrow U-X-Y$；<br>ii）<code>传递性规则</code>：如果 $X \rightarrow \rightarrow Y$，$Y  \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow Z-Y$；<br>iii）<code>增广规则</code>：如果 $X \rightarrow \rightarrow Y$，$V \subseteq W$，则 $WX  \rightarrow \rightarrow VY$；<br>iv）<code>替代规则</code>：如果 $X  \rightarrow Y$，则$X \rightarrow \rightarrow Y$；<br>v）<code>聚集规则</code>：如果$X \rightarrow \rightarrow Y$，$Z \subseteq Y$，$W \cap Z = \varnothing$，$W \rightarrow Z$，则 $X \rightarrow Z$。</p></blockquote><p>   （4）<code>多值依赖的推导规则</code>（设$U$是一个关系模式的属性集，$X，Y，Z，W，V$都是集合$U$的子集。）</p><blockquote><p>i）<code>合并规则</code>：如果 $X \rightarrow \rightarrow Y$， $X \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow YZ$；<br>ii）<code>分解规则</code>：如果 $X \rightarrow \rightarrow Y$， $X \rightarrow \rightarrow Z$，则 $X \rightarrow \rightarrow Y \cap Z$，$X \rightarrow \rightarrow Y-Z$，$X \rightarrow \rightarrow Z-Y$；<br>iii）<code>伪传递规则</code>：如果 $X \rightarrow \rightarrow Y$，$WY \rightarrow \rightarrow Z$，则 $WX \rightarrow \rightarrow (Z-WY)$；<br>iv）<code>混合伪传递规则</code>：如果 $X \rightarrow \rightarrow Y$，$XY \rightarrow Z$，则 $X \rightarrow (Z-Y)$。</p></blockquote><p>   （5）在$R(U)$上，如果有 $X \rightarrow \rightarrow Y$ 在 $W(W \subseteq U)$ 上成立，则 $X \rightarrow \rightarrow Y$ 称为$R(U)$的<code>嵌入型多值依赖</code>。</p><p>2）<strong>第四范式</strong></p><p><strong>【<code>定义4-5</code>】</strong>  设关系模式 $R(U,F) \in 1NF$，$F$是$R$上的多值依赖集，如果$R$的每个非平凡多值依赖 $X \rightarrow \rightarrow Y$（$Y-X \ne \varnothing$，$XY$未包含$R$的全部属性），$X$都含有$R$的候选键，则称$R$是<code>第四范式</code>，记为<code>4NF</code>。</p><p>6，<strong>各范式之间的关系</strong></p><p>1）<strong>各范式之间的关系</strong></p><script type="math/tex; mode=display">4NF \subset BCNF \subset 3NF \subset 2NF \subset 1NF</script><p>2）<strong>各范式小结</strong><br><img src="/images/db_query_opt_normal_form_20190413.png" alt="各范式小结"></p><blockquote><p>i）$4NF$：限制关系模式的属性之间<code>不允许</code>有非平凡且非函数依赖的多值依赖；<br>ii）$3NF \rightarrow BCNF$：消除主属性对候选关键字的<code>部分和传递</code>函数依赖；<br>iii）$2NF \rightarrow 3NF$：消除非主属性对候选关键字的<code>传递</code>函数依赖；<br>iv）$1NF \rightarrow 2NF$：消除非主属性对候选关键字的<code>部分</code>函数依赖。</p></blockquote><h2 id="四，关系模式的分解特性"><a href="#四，关系模式的分解特性" class="headerlink" title="四，关系模式的分解特性"></a>四，关系模式的分解特性</h2><p>1，<strong>关系模式的分解</strong></p><p>1）<code>关系模式的分解</code>定义：把一个关系模式分解成若干个关系模式的过程，称为<code>关系模式的分解</code>。</p><p><strong>【<code>定义4-6</code>】</strong> 关系模式$R(U, F)$ 的分解是指$R$为它的一组子集 $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 所代替的过程。其中，$U=U_1 \cup U_2 \dots \cup U_k$，并且设 $U_i \subseteq U_j(1 \le i,j \le k)$，$F_i$是$F$在$U$上的投影，即 $F_i = \{X \rightarrow Y \in F^+ \wedge XY \subseteq U_i \}$。</p><p>   分解后表的连接丢失或者多余元组的分解称为<code>有损分解</code>，或称<code>有损连接分解</code>。</p><p>2）<code>关系模式的分解</code>遵守原则： </p><blockquote><p>i）<code>无损连接性</code>：信息不失真（不增减信息）；<br>ii）<code>函数依赖保持性</code>：不破坏属性间存在的依赖关系。</p></blockquote><p>2，<strong>分解的无损连接性</strong></p><p>1）<strong>无损连接的概念</strong></p><p><strong>【<code>定义4-7</code>】</strong> 设$F$是关系模式$R$的函数依赖集，$\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 是$R$ 的一个分解，$r$是$R$的一个关系，定义</p><script type="math/tex; mode=display">m_{\rho}(r)=\pi_{U_{1}}(r) \infty \pi_{U_{2}}(r) \infty \cdots \infty_{\pi_{U_{k}}}(r)</script><p>如果$R$满足$F$的任意关系$r$均有则$r=m_\rho(r)$，则称分解 $\rho$ <code>具有无损连接性</code>。</p><p><strong>【<code>引理4-2</code>】</strong> 设 $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 为关系模式$R$的一个分解， $r$是$R$的任一个关系，有</p><blockquote><p>(1) $r \subseteq m_\rho(r)$；<br>(2) 如果 $s = m_\rho(r)$， 则 $\pi_{U_{i}}(r) = \pi_{U_{i}}(s)$；<br>(3) $m_\rho(m_\rho(r)) = m_\rho(r)$。</p></blockquote><p>2）<strong>进行关系分解的必要性</strong></p><p>一个关系模式分解后，可以存放原来所不能存放的信息，通常称为“<code>悬挂</code>”的元组，这是实际所需要的，也是分解的优点。</p><p>3）<strong>无损连接判定方法</strong></p><p><strong>【<code>算法4-2</code>】</strong> (<code>矩阵法</code>)判别一个分解的无损连接性的算法。</p><blockquote><p>(1) 构造初始表：构造一个$k$行$n$列的初始表，其中，每列对应于$R$的一个属性，每行用于表示分解后的一个模式组成。如果属性$A_j$属于关系模式$R_i$，则表示在表的第$i$行第$j$列置符号$a_j$，否则置符号$b_{ij}$。<br>(2) 根据$F$中的函数依赖修改表的内容：考察$F$中的每个函数依赖 $X \rightarrow Y$，在属性组$X$所在的那些列上寻找具有相同符号的行，如果找到这样的两行或者更多行，则修改这些行，使这些行上属性组$Y$所在的列上元素相同。<code>修改规则</code>是：如果$Y$所在的要修改的行有一个为$a_j$，则这些元素均变成$a_j$；否则改为$b_{mj}$（其中$m$为这些行的最小行号）。<br>(3) 判断分解是否为无损连接：如果通过修改，发现表中有一行变为 $a_1,a_2,\dots,a_n$，则<code>分解是无损连接的</code>，否则<code>分解不具有无损连接性</code>。</p></blockquote><p><strong>【<code>定理4-1</code>】</strong> （<code>定理法</code>）设 $\rho = \{ R_1,R_2 \}$ 是关系模式$R$的一个分解，$F$是$R$的函数依赖集，$U_1$，$U_2$和$U$分别是$R_1$，$R_2$和$R$的属性集合，那么$\rho$是$R$(关于$F$)的无损分解的充分必要条件为</p><script type="math/tex; mode=display">(U_1\cap U_2) \rightarrow U_1 - U_2 \in F^+</script><p><code>或者</code>  </p><script type="math/tex; mode=display">(U_1\cap U_2) \rightarrow U_2 - U_1 \in F^+</script><p><strong>【<code>定理4-2</code>】</strong> （<code>逐步分解定理</code>）设$F$是关系模式$R$的函数依赖集，$\rho = \{ R_1,R_2,\dots,R_k \}$ 是$R$关于$F$的一个无损连接。</p><blockquote><p>（1）如果 $\sigma = \{ S_1,S_2,\dots,S_m \}$ 是 $R_i$ 关于 $F_i$ 的一个无损连接分解，则 $\varepsilon = \{ R_1,R_2,\dots,R_{i-1},S_1,S_2,\dots,S_m,R_{i+1},\dots,R_k \}$ 是$R$关于$F$的无损连接分解，其中，$F_i = \pi_{R_i}(F)$。<br>（2）设 $\tau = \{ R_1,\dots,R_{k},R_{k+1},\dots,R_n \}$ 是 $R$ 的一个分解，其中，$\tau \supseteq \rho$，$\tau$ 也是$R$关于$F$的无损连接分解。</p></blockquote><p>3）<strong>分解的函数依赖保持性</strong></p><p><strong>【<code>定义4-8</code>】</strong> 设$F$是关系模式$R$的函数依赖集， $\rho=\{R_1(U_1, F_1),R_2(U_2, F_2),\dots,R_k(U_k, F_k)\}$ 为$R$的一个分解，如果 $F_i = \pi_{R_i}(F)(i=1,2,\dots,k)$ 的并集 $(F_1 \cup F_2 \cup \dots \cup F_k)^+ \equiv F^+$，则称分解 $\rho$ 具有<code>函数依赖保持性</code>。</p><p>3，<strong>关系模式分解算法</strong></p><p>1）<strong>分解的基本要求</strong>：分解后的关系模式与分解前的关系模式等价，即分解必须具有<code>无损连接</code>和<code>函数依赖保持性</code>。</p><p>2）<strong>分解算法的结论</strong></p><blockquote><p> i）如果要求分解具有<code>无损连接性</code>，则分解一定可以达到<code>BCNF</code>；<br> ii）如果要求分解保持<code>函数依赖</code>，则分解可以达到<code>3NF</code>，但不一定能够达到<code>BCNF</code>；<br> iii）如果要求分解既具有<code>无损连接性</code>，又保持<code>函数依赖</code>，则分解可以达到<code>3NF</code>，但不一定能够达到<code>BCNF</code>。</p></blockquote><h2 id="五，关系模式的优化"><a href="#五，关系模式的优化" class="headerlink" title="五，关系模式的优化"></a>五，关系模式的优化</h2><p>1，<strong>水平分解</strong></p><p>1）<code>水平分解</code>的<strong>定义</strong>：<code>水平分解</code>是把关系元组分为若干个子集合，每个子集合定义为一个子关系，以提高系统效率的过程。</p><p>2）<code>水平分解</code>的<strong>规则</strong>：</p><blockquote><p>（1）根据“<code>80%与20%原则</code>”，在一个大型关系中，经常使用的数据只是很有限的一部分，可以把经常使用的数据分解出来形成一个子关系。<br>（2）如果关系$R$上具有$n$个事务，而且多数事务存取的数据不相交，则$R$可分解为不大于$n$个子关系，使每个事务存取的数据形成一个关系。</p></blockquote><p>2，<strong>垂直分解</strong></p><p>1）<code>垂直分解</code>的<strong>定义</strong>设 $R(A_1,A_2,\dots,A_k)$ 是关系模式，$R$的一个垂直分解是$n$个关系的集合$\{ R_1(B_1,B_2,\dots,B_v),\dots,R_n(D_1,D_2,\dots,D_m) \}$，其中，$\{B_1,B_2,\dots,B_v \},\dots,\{ D_1,D_2,\dots,D_m \}$ 是 $\{ A_1,A_2,\dots,A_k  \}$ 的子集合。</p><p>2）<code>垂直分解</code>的<strong>基本原则</strong>：经常在一起使用的属性从$R$中分解出来形成一个独立的关系。</p><h2 id="六，关系查询优化"><a href="#六，关系查询优化" class="headerlink" title="六，关系查询优化"></a>六，关系查询优化</h2><p>1，<strong>关系系统及其查询优化</strong></p><p>1）<strong>查询优化工作</strong>：</p><blockquote><p>i）关系数据库内部提供的优化机制；<br>ii）用户通过改变查询的运算次序和建立索引等机制进行优化。</p></blockquote><p>2）<strong>关系数据库查询优化的<code>总目标</code></strong>：选择有效的策略，快速求得给定关系表达式的值，以减少查询执行的总开销。</p><p>3）<strong>查询执行的开销计算</strong></p><blockquote><p>i）在集中式数据库中，<code>总代价=I/O代价+CPU代价</code><br>ii）在多用户环境下，<code>总代价=I/O代价+CPU代价+内存代价</code></p></blockquote><p>2，<strong>查询优化的一般策略</strong></p><blockquote><p>1）尽量先执行选择运算<br>2）在执行连接前对关系适当地预处理：</p><blockquote><p>i）索引连接；<br>ii）排序合并连接</p></blockquote></blockquote><p>3，<strong>关系代数等价变换规则</strong></p><p>1）<code>连接，笛卡尔积交换律</code></p><script type="math/tex; mode=display">E_1 \times E_2 \equiv E_2 \times E_1</script><script type="math/tex; mode=display">E_{1} \infty E_{2} \equiv E_{2} \infty E_{1}</script><script type="math/tex; mode=display">\begin{array}{c}{E_{1} \infty E_{2}} \\ {F}\end{array} \equiv \begin{array}{c}{E_{2} \infty E_{1}} \\ {F}\end{array}</script><p>2）<code>连接，笛卡尔积结合律</code></p><script type="math/tex; mode=display">(E_1 \times E_2) \times E_3 \equiv E_1 \times (E_2 \times E_3)</script><script type="math/tex; mode=display">(E_{1} \infty E_{2}) \infty E_{3} \equiv E_{1} \infty (E_{2} \infty E_{3})</script><script type="math/tex; mode=display">\begin{array}{c}{(E_{1} \infty E_{2}) \infty E_{3}} \\ {F_1} \quad \quad {F_2} \end{array} \equiv \begin{array}{c}{E_{1} \infty (E_{2} \infty E_{3})} \\ {F_1} \quad \quad {F_2} \end{array}</script><p>3）<code>投影的串接定律</code></p><script type="math/tex; mode=display">\pi A_1,A_2,\dots,A_n(\pi B_1,B_2,\dots.B_m(E)) = \pi A_1,A_2,\dots,A_n(E)</script><p>4）<code>选择的串接定律</code></p><script type="math/tex; mode=display">\sigma_{F_1}(\sigma_{F_2}(E)) \equiv \sigma_{F_1 \wedge F_2}(E)</script><p>5）<code>选择与投影的交换律</code></p><script type="math/tex; mode=display">F(\pi A_1,A_2,\dots,A_n(E)) \equiv \pi A_1,A_2,\dots,A_n(\sigma_F(E))</script><p>6）<code>选择与笛卡尔积的交换律</code></p><script type="math/tex; mode=display">\sigma_F(E_1 \times E_2) \equiv \sigma_F(E_1) \times E_2</script><script type="math/tex; mode=display">\sigma_F(E_1 \times E_2) \equiv \sigma_{F_1}(E_1) \times \sigma_{F_2}(E_2) （其中F = F_1 \wedge F_2）</script><script type="math/tex; mode=display">\sigma_F(E_1 \times E_2) \equiv \sigma_{F_2}(\sigma_{F_1} (E_1) \times E_2)</script><p>7）<code>选择与并运算的交换</code><br>设$E = E_1 \cup E_2$，$E_1$、$E_2$有相同的属性名，则</p><script type="math/tex; mode=display">\sigma_F(E_1 \cup E_2) \equiv \sigma_F(E_1) \cup \sigma_F(E_2)</script><p>8）<code>选择与差运算的交换</code></p><script type="math/tex; mode=display">\sigma_F(E_1 - E_2) \equiv \sigma_F(E_1) - \sigma_F(E_2)</script><p>9）<code>投影与笛卡尔积的交换</code></p><script type="math/tex; mode=display">\pi A_1,A_2,\dots,A_n,B_1,B_2,\dots,B_m(E_1 \times E_2) \equiv \pi A_1,A_2,\dots,A_n(E_1) \cup \pi B_1,B_2,\dots,B_m(E_2)</script><p>10）<code>投影与并运算的交换</code></p><script type="math/tex; mode=display">\pi A_1,A_2,\dots,A_n(E_1 \cup E_2) \equiv \pi A_1,A_2,\dots,A_n(E_1) \cup \pi A_1,A_2,\dots,A_m(E_2)</script><p>4，<strong>关系代数表达式的优化算法</strong></p><ul><li>关系系统的查询优化步骤：<blockquote><p>（1）把查询转换成某种内部表示<br>（2）把语法树转换成标准（优化）形式<br>（3）选择底层的存取路径<br>（4）生成查询计划，选择代价最小的查询计划</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，问题的提出&quot;&gt;&lt;a href=&quot;#一，问题的提出&quot; class=&quot;headerlink&quot; title=&quot;一，问题的提出&quot;&gt;&lt;/a&gt;一
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java基础100实例</title>
    <link href="https://zhangbc.github.io/2019/04/12/java_code_100/"/>
    <id>https://zhangbc.github.io/2019/04/12/java_code_100/</id>
    <published>2019-04-12T14:52:13.000Z</published>
    <updated>2019-04-12T15:03:08.080Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><ul><li><em>通过<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a>的初步学习，现将其教程训练代码汇聚成篇。</em></li></ul><h1 id="菜鸟教程-Java-Coding学习笔记"><a href="#菜鸟教程-Java-Coding学习笔记" class="headerlink" title="菜鸟教程-Java Coding学习笔记"></a>菜鸟教程-Java Coding学习笔记</h1><blockquote><ol><li>Applet应用程序实例</li><li>文档注释演示实例</li><li>序列化和反序列化</li><li>Socket编程—服务端实例</li><li>Socket编程—客户端实例</li><li>Java进阶知识<blockquote><ul><li>遍历演示</li><li>Map遍历实例</li><li>泛型方法实例 </li><li>泛型的有界类型参数实例</li><li>泛型类实例</li><li>类型通配符实例</li></ul></blockquote></li><li>发邮件(纯文本，HTML文本，附件)</li><li>图片二进制转换</li><li>JAVA8新特性实例</li><li>JAVA操作MYSQL实例</li></ol></blockquote><h1 id="菜鸟教程-Java实例"><a href="#菜鸟教程-Java实例" class="headerlink" title="菜鸟教程-Java实例"></a>菜鸟教程-Java实例</h1><h2 id="Java-环境设置实例"><a href="#Java-环境设置实例" class="headerlink" title="Java 环境设置实例"></a>Java 环境设置实例</h2><blockquote><blockquote><ol><li>Java实例 – 如何编译一个Java文件？</li><li>Java实例 – Java如何运行一个编译过的类文件？</li><li>Java实例 – 如何执行指定class文件目录（classpath）？</li><li>Java实例 – 如何查看当前Java运行的版本？</li></ol></blockquote></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -d . HelloWorld.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java com.runoob.HelloWorld</span></span><br></pre></td></tr></table></figure><h2 id="Java-字符串"><a href="#Java-字符串" class="headerlink" title="Java 字符串"></a>Java 字符串</h2><blockquote><blockquote><ol><li>Java 实例 – 字符串比较</li><li>Java 实例 - 查找字符串最后一次出现的位置</li><li>Java 实例 - 删除字符串中的一个字符</li><li>Java 实例 - 字符串替换</li><li>Java 实例 - 字符串反转</li><li>Java 实例 - 字符串查找</li><li>Java 实例 - 字符串分割</li><li>Java 实例 - 字符串分割(StringTokenizer)</li><li>Java 实例 - 字符串大小写转换</li><li>Java 实例 - 测试两个字符串区域是否相等</li><li>Java 实例 - 字符串性能比较测试</li><li>Java 实例 - 字符串优化</li><li>Java 实例 - 字符串格式化</li><li>Java 实例 - 连接字符串</li></ol></blockquote></blockquote><h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h2><blockquote><blockquote><ol><li>Java 实例 – 数组排序及元素查找</li><li>Java 实例 – 数组添加元素</li><li>Java 实例 – 获取数组长度</li><li>Java 实例 – 数组反转</li><li>Java 实例 – 数组输出</li><li>Java 实例 – 数组获取最大和最小值</li><li>Java 实例 – 数组合并</li><li>Java 实例 – 数组填充</li><li>Java 实例 – 数组扩容</li><li>Java 实例 – 查找数组中的重复元素</li><li>Java 实例 – 删除数组元素</li><li>Java 实例 – 数组差集</li><li>Java 实例 – 数组交集</li><li>Java 实例 – 在数组中查找指定元素</li><li>Java 实例 – 判断数组是否相等</li><li>Java 实例 - 数组并集</li></ol></blockquote></blockquote><h2 id="Java-时间处理"><a href="#Java-时间处理" class="headerlink" title="Java 时间处理"></a>Java 时间处理</h2><blockquote><blockquote><ol><li>Java 实例 - 格式化时间（SimpleDateFormat）</li><li>Java 实例 - 获取当前时间</li><li>Java 实例 - 获取年份、月份等</li><li>Java 实例 - 时间戳转换成时间</li></ol></blockquote></blockquote><h2 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h2><blockquote><blockquote><ol><li>Java 实例 – 方法重载</li><li>Java 实例 – 输出数组元素</li><li>Java 实例 – 汉诺塔算法</li><li>Java 实例 – 斐波那契数列</li><li>Java 实例 – 阶乘</li><li>Java 实例 – 方法覆盖</li><li>Java 实例 – instanceOf 关键字用法</li><li>Java 实例 – break 关键字用法</li><li>Java 实例 – continue 关键字用法</li><li>Java 实例 – 标签(Label)</li><li>Java 实例 – enum 和 switch 语句使用</li><li>Java 实例 – Enum（枚举）构造函数及方法的使用</li><li>Java 实例 – for 和 foreach循环使用</li><li>Java 实例 – Varargs 可变参数使用</li><li>Java 实例 – 重载(overloading)方法中使用 Varargs</li></ol></blockquote></blockquote><h2 id="打印图形"><a href="#打印图形" class="headerlink" title="打印图形"></a>打印图形</h2><blockquote><blockquote><ol><li>Java 实例 – 打印菱形</li><li>Java 实例 – 九九乘法表</li><li>Java 实例 – 打印三角形</li><li>Java 实例 – 打印倒立的三角形</li><li>Java 实例 – 打印平行四边形</li><li>Java 实例 – 打印矩形</li></ol></blockquote></blockquote><h2 id="Java-文件操作"><a href="#Java-文件操作" class="headerlink" title="Java 文件操作"></a>Java 文件操作</h2><blockquote><blockquote><ol><li>Java 实例 - 文件写入</li><li>Java 实例 - 读取文件内容</li><li>Java 实例 - 删除文件</li><li>Java 实例 - 将文件内容复制到另一个文件</li><li>Java 实例 - 向文件中追加数据</li><li>Java 实例 - 创建临时文件</li><li>Java 实例 - 修改文件最后的修改日期</li><li>Java 实例 - 获取文件大小</li><li>Java 实例 - 文件重命名</li><li>Java 实例 - 设置文件只读</li><li>Java 实例 - 检测文件是否存在</li><li>Java 实例 - 在指定目录中创建文件</li><li>Java 实例 - 获取文件修改时间</li><li>Java 实例 - 创建文件</li><li>Java 实例 - 文件路径比较</li></ol></blockquote></blockquote><h2 id="Java-目录操作"><a href="#Java-目录操作" class="headerlink" title="Java 目录操作"></a>Java 目录操作</h2><blockquote><blockquote><ol><li>Java 实例 - 递归创建目录</li><li>Java 实例 - 删除目录</li><li>Java 实例 - 判断目录是否为空</li><li>Java 实例 - 判断文件是否隐藏</li><li>Java 实例 - 获取目录大小</li><li>Java 实例 - 在指定目录中查找文件</li><li>Java 实例 - 获取文件的上级目录</li><li>Java 实例 - 获取目录最后修改时间</li><li>Java 实例 - 打印目录结构</li><li>Java 实例 - 遍历指定目录下的所有目录</li><li>Java 实例 - 遍历指定目录下的所有文件</li><li>Java 实例 - 在指定目录中查找文件</li><li>Java 实例 - 遍历系统根目录</li><li>Java 实例 - 查看当前工作目录</li><li>Java 实例 - 遍历目录</li></ol></blockquote></blockquote><h2 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h2><blockquote><blockquote><ol><li>Java 实例 - 异常处理方法</li><li>Java 实例 - 多个异常处理（多个catch）</li><li>Java 实例 - Finally的用法</li><li>Java 实例 - 使用 catch 处理异常</li><li>Java 实例 - 多线程异常处理</li><li>Java 实例 - 获取异常的堆栈信息</li><li>Java 实例 - 重载方法异常处理</li><li>Java 实例 - 链试异常</li><li>Java 实例 - 自定义异常</li></ol></blockquote></blockquote><h2 id="Java-数据结构"><a href="#Java-数据结构" class="headerlink" title="Java 数据结构"></a>Java 数据结构</h2><blockquote><blockquote><ol><li>Java 实例 – 数字求和运算</li><li>Java 实例 – 利用堆栈将中缀表达式转换成后缀</li><li>Java 实例 – 在链表（LinkedList）的开头和结</li><li>Java 实例 – 获取链表（LinkedList）的第一个</li><li>Java 实例 – 删除链表中的元素</li><li>Java 实例 – 获取链表的元素</li><li>Java 实例 – 获取向量元素的索引值</li><li>Java 实例 – 栈的实现</li><li>Java 实例 – 链表元素查找</li><li>Java 实例 – 压栈出栈的方法实现字符串反转</li><li>Java 实例 – 队列（Queue）用法</li><li>Java 实例 – 获取向量的最大元素</li><li>Java 实例 – 链表修改</li><li>Java 实例 – 旋转向量</li></ol></blockquote></blockquote><h2 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h2><blockquote><blockquote><ol><li>Java 实例 – 数组转集合</li><li>Java 实例 – 集合比较</li><li>Java 实例 – HashMap遍历</li><li>Java 实例 – 集合长度</li><li>Java 实例 – 集合打乱顺序</li><li>Java 实例 – 集合遍历</li><li>Java 实例 – 集合反转</li><li>Java 实例 – 删除集合中指定元素</li><li>Java 实例 – 只读集合</li><li>Java 实例 – 集合输出</li><li>Java 实例 – 集合转数组</li><li>Java 实例 – List 循环移动元素</li><li>Java 实例 – 查找 List 中的最大最小值</li><li>Java 实例 – 遍历 HashTable 的键值</li><li>Java 实例 – 使用 Enumeration 遍历 HashTable</li><li>Java 实例 – 集合中添加不同类型元素</li><li>Java 实例 – List 元素替换</li><li>Java 实例 – List 截取</li></ol></blockquote></blockquote><h2 id="Java-网络实例"><a href="#Java-网络实例" class="headerlink" title="Java 网络实例"></a>Java 网络实例</h2><blockquote><blockquote><ol><li>Java 实例 – 获取指定主机的IP地址</li><li>Java 实例 – 查看端口是否已使用</li><li>Java 实例 – 获取本机ip地址及主机名</li><li>Java 实例 – 获取远程文件大小</li><li>Java 实例 – Socket 实现多线程服务器程序</li><li>Java 实例 – 查看主机指定文件的最后修改时间</li><li>Java 实例 – 使用 Socket 连接到指定主机</li><li>Java 实例 – 网页抓取</li><li>Java 实例 – 获取 URL响应头的日期信息</li><li>Java 实例 – 获取 URL 响应头信息</li><li>Java 实例 – 解析 URL</li><li>Java 实例 – ServerSocket 和 Socket 通信实例</li></ol></blockquote></blockquote><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><blockquote><blockquote><ol><li>Java 实例 – 查看线程是否存活</li><li>Java 实例 – 获取当前线程名称</li><li>Java 实例 – 状态监测</li><li>Java 实例 – 线程优先级设置</li><li>Java 实例 – 死锁及解决方法</li><li>Java 实例 – 获取线程id</li><li>Java 实例 – 线程挂起</li><li>Java 实例 – 终止线程</li><li>Java 实例 – 生产者/消费者问题</li><li>Java 实例 – 获取线程状态</li><li>Java 实例 – 获取所有线程</li><li>Java 实例 – 查看线程优先级</li><li>Java 实例 – 中断线程</li></ol></blockquote></blockquote><ul><li><a href="https://github.com" target="_blank" rel="noopener"><strong>github</strong></a>代码送门: <a href="https://github.com/zhangbc/java_projects/tree/runoob" target="_blank" rel="noopener">java_projects/runoob</a>  </li><li><a href="https://dev.tencent.com/user" target="_blank" rel="noopener"><strong>腾讯云coding</strong></a>代码送门: <a href="https://git.dev.tencent.com/zhangbocheng/java_project.git/tree/dev" target="_blank" rel="noopener">java_project/dev</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java扩展知识</title>
    <link href="https://zhangbc.github.io/2019/04/12/java_extend_knowledge/"/>
    <id>https://zhangbc.github.io/2019/04/12/java_extend_knowledge/</id>
    <published>2019-04-12T14:19:34.000Z</published>
    <updated>2019-04-12T14:24:20.104Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java文档注释"><a href="#1，Java文档注释" class="headerlink" title="1，Java文档注释"></a>1，Java文档注释</h2><p>1）<strong><code>Java</code>支持三种注释方式</strong>，分别是<code>//</code>、<code>/*  */</code>、<code>/**  */</code>(说明注释)。</p><p>2）<strong><code>javadoc</code>标签</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">标签</th><th style="text-align:left">描述</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">@author</td><td style="text-align:left">标识一个类的作者</td><td style="text-align:left">@author description</td></tr><tr><td style="text-align:left">@deprecated</td><td style="text-align:left">指名一个过期的类或成员</td><td style="text-align:left">@deprecated description</td></tr><tr><td style="text-align:left">{@docRoot}</td><td style="text-align:left">指明当前文档根目录的路径</td><td style="text-align:left">Directory Path</td></tr><tr><td style="text-align:left">@exception</td><td style="text-align:left">标志一个类抛出的异常</td><td style="text-align:left">@exception exception-name explanation</td></tr><tr><td style="text-align:left">{@inheritDoc}</td><td style="text-align:left">从直接父类继承的注释</td><td style="text-align:left">Inherits a comment from the immediate surperclass.</td></tr><tr><td style="text-align:left">{@link}</td><td style="text-align:left">插入一个到另一个主题的链接</td><td style="text-align:left">{@link name text}</td></tr><tr><td style="text-align:left">{@linkplain}</td><td style="text-align:left">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td style="text-align:left">Inserts an in-line link to another topic.</td></tr><tr><td style="text-align:left">@param</td><td style="text-align:left">说明一个方法的参数</td><td style="text-align:left">@param parameter-name explanation</td></tr><tr><td style="text-align:left">@return</td><td style="text-align:left">说明返回值类型</td><td style="text-align:left">@return explanation</td></tr><tr><td style="text-align:left">@see</td><td style="text-align:left">指定一个到另一个主题的链接</td><td style="text-align:left">@see anchor</td></tr><tr><td style="text-align:left">@serial</td><td style="text-align:left">说明一个序列化属性</td><td style="text-align:left">@serial description</td></tr><tr><td style="text-align:left">@serialData</td><td style="text-align:left">明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td style="text-align:left">@serialData description</td></tr><tr><td style="text-align:left">@serialField</td><td style="text-align:left">说明一个ObjectStreamField组件</td><td style="text-align:left">@serialField name type description</td></tr><tr><td style="text-align:left">@since</td><td style="text-align:left">标记当引入一个特定的变化时</td><td style="text-align:left">@since release</td></tr><tr><td style="text-align:left">@throws</td><td style="text-align:left">和 @exception标签一样.</td><td style="text-align:left">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td style="text-align:left">{@value}</td><td style="text-align:left">显示常量的值，该常量必须是static属性。</td><td style="text-align:left">Displays the value of a constant, which must be a static field.</td></tr><tr><td style="text-align:left">@version</td><td style="text-align:left">指定类的版本</td><td style="text-align:left">@version info</td></tr></tbody></table></div><ul><li>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档注释演示实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquareNumber</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the square of number.</span></span><br><span class="line"><span class="comment">     * This is a multiline description. You can use as many lines as you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number The value to be squared.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> number squared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number * number;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method input a number from the user.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The value input as a double.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException in input error</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getNumber</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        BufferedReader inData = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        String str;</span><br><span class="line">        str = inData.readLine();</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(str);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method demonstrates square().</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args args unused.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException on input error.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SquareNumber sn = <span class="keyword">new</span> SquareNumber();</span><br><span class="line">        <span class="keyword">double</span> val;</span><br><span class="line">        System.out.print(<span class="string">"Enter value to be squared:"</span>);</span><br><span class="line">        val = sn.getNumber();</span><br><span class="line">        val = sn.square(val);</span><br><span class="line">        System.out.println(<span class="string">"Squared value is : "</span> + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，Java-8-新特性"><a href="#2，Java-8-新特性" class="headerlink" title="2，Java 8 新特性"></a>2，Java 8 新特性</h2><p>1）<strong><code>Java8</code>(即<code>jdk1.8</code>)新特性</strong></p><blockquote><p>（1）<code>Lambda</code> 表达式：<code>Lambda</code>允许把函数作为一个方法的参数（函数作为参数传递进方法中。<br>（2）方法引用：可以直接引用已有<code>Java</code>类或对象（实例）的方法或构造器。与<code>lambda</code>联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>（3）默认方法：默认方法就是一个在接口里面有了一个实现的方法。<br>（4）新工具：新的编译工具，如：<code>Nashorn</code>引擎<code>jjs</code>、 类依赖分析器<code>jdeps</code>。<br>（5）<code>Stream API</code>：把真正的函数式编程风格引入到<code>Java</code>中。<br>（6）<code>Date Time API</code>：加强对日期与时间的处理。<br>（7）<code>Optional</code> 类：<code>Optional</code> 类已经成为 <code>Java 8</code> 类库的一部分，用来解决空指针异常。<br>（8）<code>Nashorn</code>, <code>JavaScript</code> 引擎：允许我们在<code>JVM</code>上运行特定的<code>javascript</code>应用。</p></blockquote><h2 id="3，Java-MySQL连接"><a href="#3，Java-MySQL连接" class="headerlink" title="3，Java MySQL连接"></a>3，Java MySQL连接</h2><ul><li>MysqlDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接数据库实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/28 22:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlDemo</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDBC驱动名及其数据库URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://127.0.0.1:3306/pyspider_db"</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库的用户与密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"xxxxxx"</span>;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            System.out.println(<span class="string">"连接数据库..."</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);</span><br><span class="line">​</span><br><span class="line">            System.out.println(<span class="string">"实例化Statement对象..."</span>);</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">"select id, name, url from websites;"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                String url = rs.getString(<span class="string">"url"</span>);</span><br><span class="line">​</span><br><span class="line">                System.out.printf(<span class="string">"ID: %d\t站点名称：%s\t站点URL：%s\n"</span>, id, name, url);</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException se) &#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">​</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4，Java-9-新特性"><a href="#4，Java-9-新特性" class="headerlink" title="4，Java 9 新特性"></a>4，Java 9 新特性</h2><p>详情参见：<a href="http://www.runoob.com/java/java9-new-features.html" target="_blank" rel="noopener">Java 9 新特性</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java网络编程</title>
    <link href="https://zhangbc.github.io/2019/04/12/java_net_program/"/>
    <id>https://zhangbc.github.io/2019/04/12/java_net_program/</id>
    <published>2019-04-12T14:13:28.000Z</published>
    <updated>2019-04-12T14:21:49.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java网络编程"><a href="#1，Java网络编程" class="headerlink" title="1，Java网络编程"></a>1，Java网络编程</h2><p>1）<strong>概述</strong></p><p><code>网络编程</code>：编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br><code>java.net</code>包中<code>J2EE</code>的<code>API</code>包含有类和接口，他们提供低层次的通信细节。主要有：</p><blockquote><ul><li><code>TCP</code>：传输控制协议，保障了两个应用程序之间的可靠通信，通常用于互联网协议，称为<code>TCP/IP</code>；</li><li><code>UDP</code>：用户数据报协议，一个无连接的协议，提供了应用程序之间要发送的数据的数据包。</li></ul></blockquote><p>2）Socket编程</p><p><code>套接字</code>使用<code>TCP</code>提供了两台计算机之间的通信机制。 客户端程序创建一个<code>套接字</code>，并尝试连接服务器的<code>套接字</code>。</p><p>当连接建立时，服务器会创建一个 <code>Socket</code> 对象。客户端和服务器现在可以通过对 <code>Socket</code> 对象的写入和读取来进行通信。</p><p> <code>java.net.Socket</code> 类代表一个套接字，并且 <code>java.net.ServerSocket</code> 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p><p>以下步骤在两台计算机之间使用<code>套接字</code>建立<code>TCP</code>连接时会出现：</p><blockquote><ul><li>服务器实例化一个 <code>ServerSocket</code> 对象，表示通过服务器上的端口通信。</li><li>服务器调用 <code>ServerSocket</code> 类的 <code>accept()</code> 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li><li>服务器正在等待时，一个客户端实例化一个 <code>Socket</code> 对象，指定服务器名称和端口号来请求连接。</li><li><code>Socket</code> 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 <code>Socket</code> 对象能够与服务器进行通信。</li><li>在服务器端，<code>accept()</code> 方法返回服务器上一个新的 <code>socket</code> 引用，该 <code>socket</code> 连接到客户端的 <code>socket</code>。</li></ul></blockquote><p>3）<strong><code>ServerSocket</code>类的方法</strong>：服务器应用程序通过使用 <code>java.net.ServerSocket</code> 类以获取一个端口,并且侦听客户端请求。</p><p>4）<strong><code>Socket</code>类的方法</strong>：<code>java.net.Socket</code> 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 <code>Socket</code> 对象通过实例化 ，而 服务器获得一个 <code>Socket</code> 对象则通过 <code>accept()</code> 方法的返回值。</p><p>5）<strong><code>InetAddress</code>类的方法</strong>：表示互联网协议（<code>IP</code>）地址。</p><p>6）<strong><code>demo</code>实例</strong></p><ul><li><p><em>GreetingClient.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Socket编程--客户端实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 14:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String serverName = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"连接到主机："</span> + serverName + <span class="string">", 端口号："</span> + port);</span><br><span class="line">            Socket client = <span class="keyword">new</span> Socket(serverName, port);</span><br><span class="line">            System.out.println(<span class="string">"远程主机地址："</span> + client.getRemoteSocketAddress());</span><br><span class="line">            OutputStream outServer = client.getOutputStream();</span><br><span class="line">            DataOutputStream outData = <span class="keyword">new</span> DataOutputStream(outServer);</span><br><span class="line"></span><br><span class="line">            outData.writeUTF(<span class="string">"Hello from "</span> + client.getLocalSocketAddress());</span><br><span class="line">            InputStream inFromServer = client.getInputStream();</span><br><span class="line">            DataInputStream inData = <span class="keyword">new</span> DataInputStream(inFromServer);</span><br><span class="line">            System.out.println(<span class="string">"服务器响应："</span> + inData.readUTF());</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>GreetingServer.java</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketTimeoutException;</span><br><span class="line"><span class="keyword">import</span> java.lang.Thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingServer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> GreetingServer(port);</span><br><span class="line">            thread.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetingServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        serverSocket.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"等待远程连接，端口号为："</span></span><br><span class="line">                        + serverSocket.getLocalPort() + <span class="string">"..."</span>);</span><br><span class="line">                Socket server = serverSocket.accept();</span><br><span class="line">                DataInputStream inData = <span class="keyword">new</span> DataInputStream(server.getInputStream());</span><br><span class="line">                System.out.println(inData.readUTF());</span><br><span class="line"></span><br><span class="line">                DataOutputStream outData = <span class="keyword">new</span> DataOutputStream(server.getOutputStream());</span><br><span class="line">                outData.writeUTF(<span class="string">"谢谢连接我："</span> + server.getLocalSocketAddress()</span><br><span class="line">                        + <span class="string">"\nGoodbye!"</span>);</span><br><span class="line">                server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException es) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Socket timed out!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，Java发送邮件"><a href="#2，Java发送邮件" class="headerlink" title="2，Java发送邮件"></a>2，Java发送邮件</h2><ul><li><em>SendEmail.java</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.runoob;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.DataHandler;</span><br><span class="line"><span class="keyword">import</span> javax.activation.DataSource;</span><br><span class="line"><span class="keyword">import</span> javax.activation.FileDataSource;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.Message.RecipientType;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发邮件(纯文本，HTML文本，附件)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangbocheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 20:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmail</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="comment">// 收件人邮箱</span></span><br><span class="line">        String to = <span class="string">"xxxxxxxxxxxxxxxxx@qq.com"</span>;</span><br><span class="line">        <span class="comment">// 发件人邮箱</span></span><br><span class="line">        <span class="keyword">final</span> String from = <span class="string">"xxxxxxxxxxxxxxxxx@163.com"</span>;</span><br><span class="line">        <span class="keyword">final</span> String pwd = <span class="string">"xxxxxxxx"</span>;</span><br><span class="line">        <span class="comment">// 指定发邮件的主机</span></span><br><span class="line">        String host = <span class="string">"smtp.163.com"</span>;</span><br><span class="line">        <span class="comment">// 获取系统属性</span></span><br><span class="line">        Properties properties = System.getProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置邮件服务器</span></span><br><span class="line">        properties.setProperty(<span class="string">"mail.host"</span>, host);</span><br><span class="line">        properties.put(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取默认Session对象</span></span><br><span class="line">        Session session = Session.getDefaultInstance(properties, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(from, pwd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建默认的MimeMessage对象</span></span><br><span class="line">            MimeMessage message = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">            <span class="comment">// Set From：头部头字段</span></span><br><span class="line">            message.setFrom(<span class="keyword">new</span> InternetAddress(from));</span><br><span class="line">            <span class="comment">// Set To：头部头字段</span></span><br><span class="line">            message.addRecipient(RecipientType.TO,</span><br><span class="line">                    <span class="keyword">new</span> InternetAddress(to));</span><br><span class="line">            <span class="comment">// Set Subject：头部头字段</span></span><br><span class="line">            message.setSubject(<span class="string">"This is the Subject Line!"</span>);</span><br><span class="line">            <span class="comment">// 设置消息体</span></span><br><span class="line">            message.setText(<span class="string">"This is test text."</span>);</span><br><span class="line">            <span class="comment">// 发送HTML消息，可以插入html标签</span></span><br><span class="line">            message.setContent(<span class="string">"&lt;h1&gt;This is actual message&lt;/h1&gt;"</span>,</span><br><span class="line">                    <span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            <span class="comment">// 创建消息部分</span></span><br><span class="line">            BodyPart messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">            <span class="comment">// 消息</span></span><br><span class="line">            messageBodyPart.setText(<span class="string">"This is message body."</span>);</span><br><span class="line">            <span class="comment">// 创建多重消息</span></span><br><span class="line">            Multipart multipart = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">            <span class="comment">// 设置文本消息</span></span><br><span class="line">            multipart.addBodyPart(messageBodyPart);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 附件部分</span></span><br><span class="line">            messageBodyPart = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">            String fileName = <span class="string">"/home/projects/java_pro/java_instances_demo/src/main/java/com/runoob/SendEmail.java"</span>;</span><br><span class="line">            DataSource source = <span class="keyword">new</span> FileDataSource(fileName);</span><br><span class="line">            messageBodyPart.setDataHandler(<span class="keyword">new</span> DataHandler(source));</span><br><span class="line">            messageBodyPart.setFileName(fileName);</span><br><span class="line">            multipart.addBodyPart(messageBodyPart);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送完整部分</span></span><br><span class="line">            message.setContent(multipart);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            Transport.send(message);</span><br><span class="line">            System.out.println(<span class="string">"Sent message successfully."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException mex) &#123;</span><br><span class="line">            mex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3，Java-Applet基础"><a href="#3，Java-Applet基础" class="headerlink" title="3，Java Applet基础"></a>3，Java Applet基础</h2><p>1）<strong><code>Applet</code>基础</strong></p><p><code>Applet</code>是一种<code>Java</code>程序，一般运行在支持<code>Java</code>的<code>Web</code>浏览器内，是一个全功能的Java应用程序。</p><blockquote><ul><li><code>Java</code> 中 <code>Applet</code> 类继承了 <code>java.applet.Applet</code> 类。</li><li><code>Applet</code> 类没有定义 <code>main()</code>，所以一个 <code>Applet</code> 程序不会调用 <code>main()</code> 方法。</li><li><code>Applet</code> 被设计为嵌入在一个 <code>HTML</code> 页面。</li><li>当用户浏览包含 <code>Applet</code> 的 <code>HTML</code> 页面，<code>Applet</code> 的代码就被下载到用户的机器上。</li><li>要查看一个 <code>Applet</code> 需要 <code>JVM</code>。 <code>JVM</code> 可以是 <code>Web</code> 浏览器的一个插件，或一个独立的运行时环境。</li><li>用户机器上的 <code>JVM</code> 创建一个 <code>Applet</code> 类的实例，并调用 <code>Applet</code> 生命周期过程中的各种方法。</li><li><code>Applet</code> 有 <code>Web</code> 浏览器强制执行的严格的安全规则，<code>Applet</code> 的安全机制被称为沙箱安全。</li><li><code>Applet</code> 需要的其他类可以用 <code>Java</code> 归档（<code>JAR</code>）文件的形式下载下来。</li></ul></blockquote><p>2）<strong><code>Applet</code>的生命周期</strong></p><p><code>Applet</code> 类中的四个方法给我们提供了一个框架：</p><blockquote><ul><li><code>init</code>:  提供所需的任何初始化。在 <code>Applet</code> 标记内的 <code>param</code> 标签被处理后调用该方法。</li><li><code>start</code>: 浏览器调用 <code>init</code> 方法后，该方法被自动调用。每当用户从其他页面返回到包含 <code>Applet</code> 的页面时，则调用该方法。</li><li><code>stop</code>: 当用户从包含 <code>Applet</code> 的页面移除的时候，该方法自动被调用。</li><li><code>destroy</code>: 此方法仅当浏览器正常关闭时调用。</li><li><code>paint</code>: 该方法在 <code>start()</code> 方法之后立即被调用，或者在 <code>Applet</code> 需要重绘在浏览器的时候调用。<code>paint()</code> 方法实际上继承于 <code>java.awt</code>。</li></ul></blockquote><p>3）<strong><code>Applet</code>类</strong></p><p>每一个 <code>Applet</code> 都是 <code>java.applet.Applet</code> 类的子类，基础的 <code>Applet</code> 类提供了供衍生类调用的方法,以此来得到浏览器上下文的信息和服务。</p><p>4）<strong><code>Applet</code>的调用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World, Applet<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">applet</span> <span class="attr">code</span>=<span class="string">"HelloWorldApplet.class"</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">applet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java进阶编程</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_advance_program/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_advance_program/</id>
    <published>2019-04-11T14:05:07.000Z</published>
    <updated>2019-04-11T16:14:43.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java数据结构"><a href="#1，Java数据结构" class="headerlink" title="1，Java数据结构"></a>1，Java数据结构</h2><p><code>Java</code>工具包提供了强大的数据结构，在<code>Java</code>中的数据结构主要包括以下接口和类：<code>枚举（Enumeration）</code>，<code>位集合（BitSet）</code>，<code>向量（Vector）</code>，<code>栈（Stack）</code>，<code>字典（Dictionary）</code>，<code>哈希表（Hashtable）</code>，<code>属性（Properties）</code>。</p><p>1）<strong>枚举（<code>Enumeration</code>）</strong>：该接口定义了一种从数据结构中取回连续元素的方式。</p><p>2）<strong>位集合（<code>BitSet</code>）</strong>：该类实现了一组可以单独设置和清除的位或标志。</p><p>3）<strong>向量（<code>Vector</code>）</strong>：对象的元素通过索引访问，在创建时不必给对象指定大小，其大小会根据需要动态的变化。</p><p>4）<strong>栈（<code>Stack</code>）</strong>：实现了一个后进先出的数据结构，是<code>Vector</code>的一个子类。</p><p>5）<strong>字典（<code>Dictionary</code>）</strong>：是一个抽象类，定义了键映射到值的数据结构。当想要通过特定的键而不是整数索引来访问数据时，应使用<code>Dictionary</code>。<br><strong><code>注意</code></strong>：<code>Dictionary</code>类已经过时了，在实际开发中，你可以实现<code>Map</code>接口来获取键/值的存储功能。</p><p>6）<strong>哈希表（<code>Hashtable</code>）</strong>：提供了一种在用户定义键结构的基础上来组织数据的手段。<code>Hashtable</code>是原始的<code>java.util</code>的一部分， 是一个<code>Dictionary</code>具体的实现 。</p><p>7）<strong>属性（<code>Properties</code>）</strong>：继承于 Hashtable.Properties 类表示了一个持久的属性集；属性列表中每个键及其对应值都是一个字符串。</p><h2 id="2，Java集合框架"><a href="#2，Java集合框架" class="headerlink" title="2，Java集合框架"></a>2，Java集合框架</h2><p>1）<strong>集合框架设计目标</strong></p><blockquote><p>（1）必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的；<br>（2）允许不同类型的集合，以类似的方式工作，具有高度的互操作性；<br>（3）对一个集合的扩展和适应必须是简单的。</p></blockquote><p>2）<strong>Java集合框架图</strong></p><p><img src="/images/java_advance_program_collection_20190411.png" alt="Java集合框架图"></p><p>3）<strong>集合框架是一个用来代表和操纵集合的统一架构</strong>，包含如下内容：</p><blockquote><p>（1）<code>接口</code>：是代表集合的抽象数据类型。例：<code>Collection</code>，<code>List</code>，<code>Set</code>，<code>Map</code>等。<br>（2）<code>实现（类）</code>：是集合接口的具体实现。从本质上，他们是可重复使用的数据结构，例：<code>ArrayList</code>，<code>LinkedList</code>，<code>HashSet</code>，<code>HashMap</code>。<br>（3）<code>算法</code>：是实现集合接口的对象里的方法执行的一些有用的计算，例：搜索和排序，这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。</p></blockquote><p><img src="/images/java_advance_program_collection_members_20190411.png" alt="Java 集合框架构成"></p><p>集合框架的类和接口均在<code>java.util</code>包中。<br>任何对象加入集合类后，自动转变为<code>Object</code>类型，所以在取出的时候，需要进行强制类型转换。</p><p>4）<strong>集合接口</strong></p><ul><li><p><code>Set</code>和<code>List</code>的区别</p><blockquote><ul><li><code>Set</code> 接口实例存储的是无序的，不重复的数据。<code>List</code> 接口实例存储的是有序的，可以重复的元素。</li><li><code>Set</code> 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有<code>HashSet</code>,<code>TreeSet</code>&gt;。</li><li><code>List</code>和数组类似，可以动态增长，根据实际存储的数据的长度自动增长<code>List</code>的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有<code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code>&gt; 。</li></ul></blockquote><p>5）<strong>集合实现类（集合类）</strong>：<code>Java</code>提供了一套实现了<code>Collection</code>接口的标准集合类。</p><p>6）<strong>集合算法</strong>：集合定义了三个不可改变的静态变量：<code>EMPTY_SET</code>，<code>EMPTY_LIST</code>，<code>EMPTY_MAP</code>。<code>Collection Algorithms</code>是一个列表中的所有算法实现。</p><p>7）<strong>迭代</strong>：使用<code>Java Iterator</code>，通过实例列出<code>Iterator</code>和<code>listIterator</code>接口提供的所有方法。</p></li><li><p>ArrayListDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"Hello"</span>);</span><br><span class="line">        list.add(<span class="string">"World"</span>);</span><br><span class="line">        list.add(<span class="string">"Maven"</span>);</span><br><span class="line">        list.add(<span class="string">"Demo"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历1：使用foreach遍历List</span></span><br><span class="line">        System.out.println(<span class="string">"使用foreach遍历List:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str: list) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历2：把链表变为数组相关的内容进行遍历List</span></span><br><span class="line">        String[] strArray = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        list.toArray(strArray);</span><br><span class="line">        System.out.println(<span class="string">"\n把链表变为数组相关的内容进行遍历List:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">            System.out.print(strArray[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历3：使用迭代器进行相关遍历List</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        System.out.println(<span class="string">"\n使用迭代器进行相关遍历List:"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MapDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        map.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        map.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历1：通过Map.KeySet遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.KeySet遍历key与value："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key: map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + key + <span class="string">", value="</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历2：通过Map.entrySet使用iterator遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + entry.getKey() + <span class="string">", value="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历3：推荐，通过Map.entrySet遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet遍历key和value:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry:</span><br><span class="line">             map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + entry.getKey() + <span class="string">", value="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历4：通过Map.values()遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String val: map.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"value="</span> + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>8）<strong>比较器</strong>：使用 <code>Java Comparator</code>，通过实例列出<code>Comparator</code>接口提供的所有方法。</p><h2 id="3，Java泛型"><a href="#3，Java泛型" class="headerlink" title="3，Java泛型"></a>3，Java泛型</h2><p>1）<strong>Java泛型（<code>generics</code>）</strong> 是<code>JDK5</code>中引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<code>泛型的本质</code>是参数化类型，即：所操作的数据类型被指定为一个参数。</p><p>2）<strong>定义泛型方法的规则</strong></p><blockquote><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<code>&lt;E&gt;</code>）。</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个<code>类型变量</code>，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（如<code>int</code>,<code>double</code>,<code>char</code>的等）。 </li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建不同类型的数组：Integer，Double和Character</span></span><br><span class="line">        Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubleArray = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">        Character[] charArray = &#123;<span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'0'</span>&#125;;</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"整型数组元素为："</span>);</span><br><span class="line">        printArray(intArray);</span><br><span class="line">        System.out.println(<span class="string">"双精度小数数组元素为："</span>);</span><br><span class="line">        printArray(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">"字符型数组元素为："</span>);</span><br><span class="line">        printArray(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法printArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E element: inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）<strong>有界的类型参数</strong>：限制那些被允许传递到一个类型参数的类型种类范围。声明首先要列出类型参数的名称，后跟 <code>extends</code> 关键字，最后紧跟它的上界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型的有界类型参数实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxGenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%d,%d和%d中最大的数为%d.\n\n"</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, maximum(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"%.2f,%.2f和%.2f中最大的数为%.2f.\n\n"</span>,</span><br><span class="line">                <span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span>, maximum(<span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span>));</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"%s,%s和%s中最大的数为%s.\n\n"</span>,</span><br><span class="line">                <span class="string">"pear"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>,</span><br><span class="line">                maximum(<span class="string">"pear"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">maximum</span><span class="params">(T x, T y, T z)</span> </span>&#123;</span><br><span class="line">        T max = x;</span><br><span class="line">        <span class="keyword">if</span> (y.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）<strong>泛型类</strong>：在类名后面添加类型参数声明部分。泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个<code>类型变量</code>，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为<code>参数化的类</code>或<code>参数化的类型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        integerBox.add(<span class="number">10</span>);</span><br><span class="line">        stringBox.add(<span class="string">"菜鸟教程"</span>);</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"整型值为：%d\n"</span>, integerBox.get());</span><br><span class="line">        System.out.printf(<span class="string">"字符串为：%s\n"</span>, stringBox.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）<strong>类型通配符</strong>：一般使用<code>?</code>代替具体的类型参数。</p><blockquote><p>（1）类型通配符上限通过形如<code>List</code>来定义，如此定义就是通配符泛型值接受<code>Number</code>及其下层子类类型；<br>（2）类型通配符下限通过形如<code>List&lt;? super Number&gt;</code>来定义，表示类型只能接受<code>Number</code>及其三层父类类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型通配符实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wildcard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">​</span><br><span class="line">        name.add(<span class="string">"icon"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line">​</span><br><span class="line">        getData(name);</span><br><span class="line">        getUpperNumber(age);</span><br><span class="line">        getUpperNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"data: %s\n"</span>, data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUpperNumber</span><span class="params">(List&lt;? extends Number&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"data: "</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4，Java序列化"><a href="#4，Java序列化" class="headerlink" title="4，Java序列化"></a>4，Java序列化</h2><p>1）<strong>Java序列化</strong>：<code>Java</code>提供了一种对象序列化的机制，该机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据，有关对象的类型的信息和存储在对象中数据的类型。</p><blockquote><p>（1）序列化一个对象，并将它发送到输出流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p><p>（2）从流中取出下一个对象，并将对象反序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException, ClassNotFundException</span></span><br></pre></td></tr></table></figure></p></blockquote><p>2）<strong>完整<code>demo</code>实例</strong>：</p><ul><li><p>Employee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> runoob;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Employee类实现Serializable接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 12:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mailing a check to "</span> + name + <span class="string">" "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SerializeDemo.java </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SerializeDemo类，序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.name = <span class="string">"Reyan Ali"</span>;</span><br><span class="line">        employee.address = <span class="string">"Phonkka kuan, Ambehta Peer."</span>;</span><br><span class="line">        employee.SSN = <span class="number">11122333</span>;</span><br><span class="line">        employee.number = <span class="number">101</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fileOut = <span class="keyword">new</span></span><br><span class="line">                    FileOutputStream(<span class="string">"employee.ser"</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">            out.writeObject(employee);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.println(<span class="string">"Serialized data is saved in employee.ser."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ul><li>DeserializeDemo.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DeserializeDemo类，反序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.ser"</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            employee = (Employee) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Employee class not found."</span>);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Deserialize Employee..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Name: "</span> + employee.name);</span><br><span class="line">        System.out.println(<span class="string">"Address: "</span> + employee.address);</span><br><span class="line">        System.out.println(<span class="string">"SSN: "</span> + employee.SSN);</span><br><span class="line">        System.out.println(<span class="string">"Number: "</span> + employee.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java面向对象</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_object_oriented/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_object_oriented/</id>
    <published>2019-04-11T11:57:07.000Z</published>
    <updated>2019-04-11T12:07:56.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java-继承"><a href="#1，Java-继承" class="headerlink" title="1，Java 继承"></a>1，Java 继承</h2><p>1）<strong><code>Java</code>继承的概念</strong>：<code>继承</code>就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>2）<strong><code>Java</code>继承类型</strong>：Java不支持多继承，但是支持多重继承。<br><img src="/images/java_obj_oriented_extends_20190411.png" alt="Java继承"><br>3）<strong><code>Java</code>继承的特性</strong></p><blockquote><ul><li>子类拥有父类非 <code>private</code> 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li><code>Java</code> 的继承是<code>单继承</code>，但是可以<code>多重继承</code>，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的<code>耦合性</code>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul></blockquote><p>4）<strong><code>Java</code>继承关键字</strong></p><p><code>继承</code>可以使用<code>extends</code>和<code>implements</code>这两个关键字来实现继承，都继承于<code>java.lang.Object</code>，默认继承<code>object</code>祖先类。</p><blockquote><p>（1）<code>extends</code>：只能继承一个类。<br>（2）<code>implements</code>：可以变相地使<code>java</code>具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口。<br>（3）<code>super</code>：通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。<br>（4）<code>this</code>：指向自己的引用。<br>（5）<code>finally</code>：声明类可以把类定义为不能继承的，即<code>最终类</code>；或用于修饰方法，该方法不能被子类重写。</p></blockquote><p> 5）<strong><code>Java</code>构造器</strong><br> 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <code>super</code> 关键字调用父类的构造器并配以适当的参数列表。</p><ul><li>ExtendsDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/3/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========SubClassOne 类继承==========="</span>);</span><br><span class="line">        SubClassOne sc1 = <span class="keyword">new</span> SubClassOne();</span><br><span class="line">        SubClassOne sc2 = <span class="keyword">new</span> SubClassOne(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"==========SubClassTwo 类继承==========="</span>);</span><br><span class="line">        SubClassTwo sc3 = <span class="keyword">new</span> SubClassTwo();</span><br><span class="line">        SubClassTwo sc4 = <span class="keyword">new</span> SubClassTwo(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SuperClass 祖先类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SuperClass() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SuperClass(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass(int number)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SubClassOne 类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassOne</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SubClassOne() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClassOne()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SubClassOne(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SubClassOne(int number): "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SubClassTwo 类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassTwo</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SubClassTwo() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"SubClassTwo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SubClassTwo(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SubClassTwo(int number): "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，Java-Override-Overload"><a href="#2，Java-Override-Overload" class="headerlink" title="2，Java Override/Overload"></a>2，Java Override/Overload</h2><p>1）<strong>重写（<code>Override</code>）</strong><br><code>重写</code>是子类对父类对允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即<code>外壳不变，核心重写</code>。重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animal类，祖先类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物可以移动..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnimalDog类，继承Animal，并重写父类的move()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalDog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">"狗可以跑和走."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal dog = <span class="keyword">new</span> AnimalDog();</span><br><span class="line">        animal.move();</span><br><span class="line">        dog.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）<strong>方法的重写规则</strong></p><blockquote><ul><li>参数列表必须完全与被重写方法的相同。</li><li>返回类型必须完全与被重写方法的返回类型相同。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为<code>final</code>的方法不能被重写。</li><li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote><p>3）<strong><code>super</code></strong>：当需要在子类中调用父类的被重写方法时，要使用<code>super</code>关键字。</p><p>4）<strong>重载（<code>Overload</code>）</strong>：在一个类里面，方法名字相同，而参数不同，返回类型可同可不同。</p><p>5）<strong>重载规则</strong></p><blockquote><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载；</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul></blockquote><ul><li>OverLoading.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(int)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> number, String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(int, String)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test(int, String)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(String,int)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test(String,int)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverLoading overLoad = <span class="keyword">new</span> OverLoading();</span><br><span class="line">        System.out.println(overLoad.test());</span><br><span class="line">        overLoad.test(<span class="number">100</span>);</span><br><span class="line">        System.out.println(overLoad.test(<span class="number">100</span>, <span class="string">"test3"</span>));</span><br><span class="line">        System.out.println(overLoad.test(<span class="string">"test"</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>6）<strong><code>重写</code>和<code>重载</code>的区别</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">区别点</th><th style="text-align:left">重载方法</th><th style="text-align:left">重写方法</th></tr></thead><tbody><tr><td style="text-align:left">参数列表</td><td style="text-align:left">必须修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">返回类型</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">异常</td><td style="text-align:left">可以修改</td><td style="text-align:left">可以减少或删除，一定不能抛出新的或更广的异常</td></tr><tr><td style="text-align:left">访问</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table></div><p>方法的重写(<code>Overriding</code>)和重载(<code>Overloading</code>)是<code>java</code>多态性的不同表现，<code>重写</code>是父类与子类之间多态性的一种表现，<code>重载</code>可以理解成多态的具体表现形式。</p><blockquote><ul><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为<code>方法的重载(Overloading)</code>。</li><li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为<code>重写(Overriding)</code>。</li><li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul></blockquote><h2 id="3，Java-多态"><a href="#3，Java-多态" class="headerlink" title="3，Java 多态"></a>3，Java 多态</h2><p><code>多态</code>是同一个行为具有多个不同表现形式或形态的能力。<strong>多态的好处</strong>：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><p>1）<strong>多态的优点</strong>：消除类型之间的耦合关系；可替换性；可扩充性；接口性；灵活性；简化性。</p><p>2）<strong>多态存在的三个必要条件</strong>：<code>继承</code>；<code>重写</code>；<code>父类引用指向子类对象</code>。</p><ul><li>PolymorphicDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/3/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show(<span class="keyword">new</span> Cat());</span><br><span class="line">        show(<span class="keyword">new</span> Dog());</span><br><span class="line">​</span><br><span class="line">        Animals animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        animal.eat();</span><br><span class="line">​</span><br><span class="line">        Cat cat = (Cat) animal;</span><br><span class="line">        cat.work();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animals animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            Cat cat = (Cat) animal;</span><br><span class="line">            cat.work();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            Dog dog = (Dog) animal;</span><br><span class="line">            dog.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抓老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"看家"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3）<strong>虚函数</strong>：虚函数的存在是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。</p><p>4）<strong>多态的实现方式</strong>：<code>重写</code>；<code>接口</code>；<code>抽象类</code>和<code>抽象方法</code>。</p><h2 id="4，Java-抽象类"><a href="#4，Java-抽象类" class="headerlink" title="4，Java 抽象类"></a>4，Java 抽象类</h2><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>1）<strong>抽象类</strong>：在Java语言中使用<code>abstract class</code>定义抽象类。</p><p>2）<strong>继承抽象类</strong></p><p>3）<strong>抽象方法</strong>：<code>abstract</code> 关键字可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体；抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><p>4）<strong>抽象类总结规定</strong></p><blockquote><p>（1）抽象类不能被实例化；只有抽象类的非抽象子类可以创建对象；<br>（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；<br>（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能；<br>（4）构造方法，类方法（用 <code>static</code> 修饰的方法）不能声明为抽象方法；<br>（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></blockquote><h2 id="5，Java-封装"><a href="#5，Java-封装" class="headerlink" title="5，Java 封装"></a>5，Java 封装</h2><p>1）在面向对象程式设计方法中，<code>封装（Encapsulation）</code>是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的<code>接口</code>控制。</p><p><code>封装</code> <strong>最主要的功能</strong>在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>2）<strong>封装的优点</strong></p><blockquote><p>（1）两个的封装能够减少耦合；<br>（2）类内部的结构可以自由修改；<br>（3）可以对成员变量进行更精确的控制；<br>（4）隐藏信息，实现细节。</p></blockquote><h2 id="6，Java-接口"><a href="#6，Java-接口" class="headerlink" title="6，Java 接口"></a>6，Java 接口</h2><p>1）<strong>接口概念</strong><br>     <code>接口（Interface）</code>，在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p> 类描述对象的属性和方法。接口则包含类要实现的方法。</p><p> 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p> 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 <code>Java</code> 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p>2）<strong>接口与类相似点</strong></p><blockquote><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在<code>.java</code> 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 <code>.class</code> 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul></blockquote><p>3）<strong>接口与类的区别</strong></p><blockquote><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 <code>static</code> 和 <code>final</code> 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul></blockquote><p>4）<strong>接口特性</strong></p><blockquote><ul><li>接口是隐式的，接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 <code>public abstract</code>。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <code>public static final</code> 变量。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li><li>接口的方法都是公有的。</li></ul></blockquote><p>5）<strong>抽象类和接口的区别</strong></p><blockquote><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <code>public static final</code> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 <code>static</code> 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul></blockquote><p>6）<strong>接口的声明</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7）<strong>接口的实现</strong>：当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类；类使用<code>implements</code>关键字实现接口，在类声明中，<code>implements</code>关键字放在<code>class</code>声明后面。</p><p>（1）重写接口中声明的方法时，需要注意以下规则：</p><blockquote><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul></blockquote><p>（2）在实现接口的时候，需要注意以下规则：</p><blockquote><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul></blockquote><p>8）<strong>接口的继承</strong></p><p>9）<strong>接口的多继承</strong>：在<code>Java</code>中，类的多继承是不合法，但接口允许多继承；在接口的多继承中<code>extenfs</code>关键字只需要用一次，在其后跟着继承接口。</p><p>10）<strong>标记接口</strong><br>    <code>标记接口</code>是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。</p><p><code>标记接口</code>的<strong>作用</strong>：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p><code>标记接口</code>的<strong>主要目的</strong>：建立一个公共的父接口；向一个类添加数据类型。</p><h2 id="7，Java-包（Package）"><a href="#7，Java-包（Package）" class="headerlink" title="7，Java 包（Package）"></a>7，Java 包（Package）</h2><p> 1）<strong>包的作用</strong></p><blockquote><p>（1）把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。<br>（2）如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。<br>（3）包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p></blockquote><p> 总之，<code>Java</code> 使用包（<code>package</code>）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（<code>class</code>）、接口、枚举（<code>enumerations</code>）和注释（<code>annotation</code>）等。</p><p> 2）<strong>创建包</strong></p><p> 3）<strong><code>impor</code>t语句</strong>：为了能够使用某一个包的成员，需要在<code>Java</code>程序中明确导入该包。</p><p> 4）<strong><code>package</code>的目录结构</strong><br> 类目录的绝对路径叫做 <code>class path</code>。设置在系统变量 <code>CLASSPATH</code> 中。编译器和 <code>java</code> 虚拟机通过将 <code>package</code> 名字加到 <code>class path</code> 后来构造 <code>.class</code> 文件的路径。</p><p>5）<strong>设置<code>CLASSPATH</code>系统变量</strong></p><ul><li><p>用下面的命令显示当前的<code>CLASSPATH</code>变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows 平台（DOS 命令行下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C:\&gt; <span class="built_in">set</span> CLASSPATH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX 平台（Bourne shell 下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CLASSPATH</span></span></span><br></pre></td></tr></table></figure></li><li><p>删除当前<code>CLASSPATH</code>变量内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows 平台（DOS 命令行下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C:\&gt; <span class="built_in">set</span> CLASSPATH=</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX 平台（Bourne shell 下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> CLASSPATH; <span class="built_in">export</span> CLASSPATH</span></span><br></pre></td></tr></table></figure></li><li><p>设置<code>CLASSPATH</code>变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Windows 平台（DOS 命令行下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> C:\&gt; <span class="built_in">set</span> CLASSPATH=C:\users\jack\java\classes</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> UNIX 平台（Bourne shell 下）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> CLASSPATH=/home/jack/java/classes; <span class="built_in">export</span> CLASSPATH</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java基础知识</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_basic_knowledge/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_basic_knowledge/</id>
    <published>2019-04-10T16:39:20.000Z</published>
    <updated>2019-04-10T17:10:49.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java基本数据类型"><a href="#1，Java基本数据类型" class="headerlink" title="1，Java基本数据类型"></a>1，Java基本数据类型</h2><p><code>变量</code>就是申请内存来存储值。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p><p>Java有两大数据类型：<code>内置数据类型</code>和<code>引用数据类型</code>。</p><p>1）<strong>内置数据类型</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th><th style="text-align:center">取值范围</th><th style="text-align:center">默认值</th><th style="text-align:center">主要用途</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">- $2^7$ ~ $2^7$ -1</td><td style="text-align:center">0</td><td style="text-align:center">在大型数组中节约空间，代替整数</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">-$2^{15}$~$2^{15}$-1</td><td style="text-align:center">0</td><td style="text-align:center">节省空间</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">-$2^{31}$~$2^{31}$-1</td><td style="text-align:center">0</td><td style="text-align:center">整型变量的默认类型</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">-$2^{63}$~$2^{63}$-1</td><td style="text-align:center">0L</td><td style="text-align:center">使用在需要比较大整数的系统上</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">单精度、32位、符合IEEE 754标准的浮点数</td><td style="text-align:center">-$2^{31}$~$2^{31}$-1</td><td style="text-align:center">0.0f</td><td style="text-align:center">在存储大型浮点数组时可以节省空间；不能用来表示精确的值</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">双精度、64位、符合IEEE 754标准的浮点数</td><td style="text-align:center">-$2^{63}$~$2^{63}$-1</td><td style="text-align:center">0.0d</td><td style="text-align:center">浮点数变量的默认类型</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">表示一位的信息</td><td style="text-align:center">true,false</td><td style="text-align:center">false</td><td style="text-align:center">作为一种标记来记录true/false情况</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">单一的 16 位 Unicode 字符</td><td style="text-align:center">\u0000<code>~</code>\uffff(0~$2^{16}$-1)</td><td style="text-align:center"></td><td style="text-align:center">存储任何字符</td></tr></tbody></table></div><p>2）<strong>引用类型</strong></p><blockquote><ul><li>在Java中，引用类型的变量非常类似于<code>C/C++</code>的<code>指针</code>。引用类型指向一个对象，指向对象的变量是引用变量。</li><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是<code>null</code>。</li><li>一个引用变量可以用来引用与任何与之兼容的类型。</li></ul></blockquote><p>3）<strong>Java常量</strong>：常量在程序运行时，不会被修改，关键字<code>final</code>。通常使用<code>大写字母</code>表示常量。</p><p>4）<strong>Java类型转换</strong></p><blockquote><ul><li><code>自动类型转换</code>：转换从低级到高级。<blockquote><ul><li>数据类型转换满足的<code>原则</code>：<br>（1）不能对boolean类型进行类型转换；<br>（2）不能把对象类型转换成不相关类的对象；<br>（3）在把容量大的类型转换为容量小的类型时必须使用强制类型转换；<br>（4）转换过程中可能导致溢出或损失精度；<br>（5）浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。</li></ul></blockquote></li><li><code>强制类型转换</code>：条件是转换的数据类型必须是兼容的。</li><li><code>隐含强制类型转换</code></li></ul></blockquote><h2 id="2，Java语句类型"><a href="#2，Java语句类型" class="headerlink" title="2，Java语句类型"></a>2，Java语句类型</h2><p>1）<strong>循环结构</strong></p><blockquote><ul><li><code>while</code></li><li><code>do...while</code></li><li><code>for</code></li><li><code>foreach</code></li><li><code>增强型for循环</code>：主要用于数组</li><li>demo：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> x : numbers )&#123;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">      String [] names =&#123;<span class="string">"James"</span>, <span class="string">"Larry"</span>, <span class="string">"Tom"</span>, <span class="string">"Lacy"</span>&#125;;</span><br><span class="line">      # 增强型for循环</span><br><span class="line">      <span class="keyword">for</span>( String name : names ) &#123;</span><br><span class="line">         System.out.print( name );</span><br><span class="line">         System.out.print(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>2）<strong><code>break</code>语句</strong>：主要用于循环语句或者switch语句中；跳出最里层的循环，并且继续执行该循环下面的语句。</p><p>3）<strong><code>continue</code>语句</strong>：适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代。</p><p>4）<strong>分支结构</strong></p><blockquote><ul><li><code>if</code>：一个<code>if语句</code>包含一个布尔表达式和一条或多条语句。</li><li><code>switch case</code>语句：判断一个变量与一系列值中某个值是否相等，每个值称为一个<code>分支</code>。</li></ul></blockquote><h2 id="3，Java基础类"><a href="#3，Java基础类" class="headerlink" title="3，Java基础类"></a>3，Java基础类</h2><p>1）<strong>Number &amp; Math类</strong><br><img src="/images/java_basic_knowledge_number_20190411.png" alt="Number &amp; Math类"></p><p>2）<strong>Math类</strong>：包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><p>3）<strong>Character类</strong>：对单个字符进行操作。<br> 将一个<code>char</code>类型的参数传递给需要一个<code>Character</code>类型参数的方法时，那么编译器会自动地将<code>char</code>类型参数转换为<code>Character</code>对象。 这种特征称为<code>装箱</code>，反过来称为<code>拆箱</code>。</p><p>4）<strong>String类</strong><br>        用于获取有关对象的信息的方法称为<code>访问器方法</code>。</p><p>5）<strong>StringBuffer和StringBuilder类</strong></p><blockquote><ul><li>和<code>String</code>类不同的是，<code>StringBuffer</code>和<code>StringBuilder</code>类的对象能够被多次的修改，并且不产生新的未使用对象。</li><li><code>StringBuilder</code>类在<code>Java 5</code>中被提出，它和<code>StringBuffer</code>之间的<strong>最大不同</strong>在于 <code>StringBuilder</code>的方法不是线程安全的（不能同步访问）。</li><li>由于<code>StringBuilder</code>相较于<code>StringBuffer</code>有速度优势，所以多数情况下建议使用 <code>StringBuilder</code>类。</li><li>在应用程序要求线程安全的情况下，则必须使用 <code>StringBuffer</code>类。</li></ul></blockquote><h2 id="4，Java数组"><a href="#4，Java数组" class="headerlink" title="4，Java数组"></a>4，Java数组</h2><p>1）<strong>声明数组</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"> # or</span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure></p><p> 2）<strong>创建数组</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure></p><p>3）<strong>多维数组</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type[][] typeName = <span class="keyword">new</span> type[typeLength1][typeLength2];   <span class="comment">// 直接为每一维分配空间</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 从最高维开始，分别为每一维分配空间</span></span><br><span class="line">String s[][] = <span class="keyword">new</span> String[<span class="number">2</span>][];</span><br><span class="line">s[<span class="number">0</span>] = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">s[<span class="number">1</span>] = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">new</span> String(<span class="string">"Good"</span>);</span><br><span class="line">s[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">new</span> String(<span class="string">"Luck"</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">new</span> String(<span class="string">"to"</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">new</span> String(<span class="string">"you"</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">2</span>] = <span class="keyword">new</span> String(<span class="string">"!"</span>);</span><br></pre></td></tr></table></figure></p><p>4）<strong>Arrays类</strong><br><code>java.util.Arrays</code> 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能：</p><blockquote><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法，按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul></blockquote><h2 id="5，Java日期时间"><a href="#5，Java日期时间" class="headerlink" title="5，Java日期时间"></a>5，Java日期时间</h2><p><code>java.util</code>包提供了<code>Date</code>类来封装当前的日期和时间。 <code>Date</code>类提供两个构造函数来实例化 <code>Date</code> 对象。<br>第一个构造函数使用当前日期和时间来初始化对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date( )</span><br></pre></td></tr></table></figure></p><p>第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date(<span class="keyword">long</span> millisec)</span><br></pre></td></tr></table></figure></p><p>1）<strong>获取当前日期时间</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       Date date = <span class="keyword">new</span> Date();</span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）<strong>日期比较</strong></p><blockquote><ul><li><code>getTime()</code>：获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li><li><code>before()</code>, <code>after()</code>, <code>equals()</code></li><li><code>compareTo()</code>：由<code>Comparable</code>接口定义的，<code>Date</code>类实现了这个接口。</li></ul></blockquote><p>3）<strong>格式化日期时间</strong></p><ul><li><code>SimpleDataFormat</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间为："</span>+ft.format(now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>printf</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//c的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"全部日期和时间信息：%tc%n"</span>, now);</span><br><span class="line">        <span class="comment">//f的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"年-月-日格式：%tF%n"</span>, now);</span><br><span class="line">        <span class="comment">//d的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"月/日/年格式：%tD%n"</span>, now);</span><br><span class="line">        <span class="comment">//r的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"HH:MM:SS PM格式（12时制）：%tr%n"</span>, now);</span><br><span class="line">        <span class="comment">//t的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"HH:MM:SS格式（24时制）：%tT%n"</span>, now);</span><br><span class="line">        <span class="comment">//R的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"HH:MM格式（24时制）：%tR"</span>, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>4）<strong>Java休眠（<code>Sleep</code>）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Got an exception: "</span>+ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5）<strong><code>Calendar</code>类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个代表系统当前日期的Calendar对象</span></span><br><span class="line">        Calendar now = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> year = now.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> month = now.get(Calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> day = now.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> date = now.get(Calendar.DATE);</span><br><span class="line">        <span class="keyword">int</span> hour = now.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> minute = now.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> second = now.get(Calendar.SECOND);</span><br><span class="line">​</span><br><span class="line">        System.out.println(now.getTime());</span><br><span class="line">        System.out.printf(<span class="string">"%d-%d-%d %d:%d:%d\n%d\n"</span>,</span><br><span class="line">                year, month, day, hour, minute, second, date);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 创建一个表示2009年3月12日的Calendar对象</span></span><br><span class="line">        now.set(<span class="number">2009</span>, <span class="number">3</span>-<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(now.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6）<strong><code>GregorianCalendar</code>类</strong>：实现了公历日历，是<code>Calendar</code>类的一个具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GregorianCalendar gCalender = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">        <span class="keyword">int</span> year = gCalender.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">if</span> (gCalender.isLeapYear(year)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前年份是闰年！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前年份不是闰年！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6，正则表达式"><a href="#6，正则表达式" class="headerlink" title="6，正则表达式"></a>6，正则表达式</h2><p>1） <strong><code>java.util.regex</code>包</strong>主要包括以下三个类：</p><blockquote><ul><li><code>Pattern</code>类：是一个正则表达式的编译表示。<code>Pattern</code>类没有公共构造方法。要创建一个<code>Pattern</code>对象，你必须首先调用其公共静态编译方法，它返回一个<code>Pattern</code> 对象。该方法接受一个正则表达式作为它的第一个参数。</li><li><code>Matcher</code>类：是对输入字符串进行解释和匹配操作的引擎。</li><li><code>PatternSyntaxException</code>：是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">"I am a student, graduated from HuBei University."</span>;</span><br><span class="line">        String pattern = <span class="string">".*HuBei.*"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMath = Pattern.matches(pattern, content);</span><br><span class="line">        System.out.println(<span class="string">"字符串是否包含类'HuBei'子字符串？"</span>+isMath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）<strong>捕获组</strong><br><code>捕获组</code>是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。<br><code>特殊的组（group(0)）</code>，它总是代表整个表达式。该组不包括在 groupCount 的返回值中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">"I am a student, graduated from HuBei University in 2013. "</span>;</span><br><span class="line">        String pattern = <span class="string">"(\\D*)(\\d+)(.*)"</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 创建Pattern对象</span></span><br><span class="line">        Pattern rex = Pattern.compile(pattern);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 创建matcher对象</span></span><br><span class="line">        Matcher matcher = rex.matcher(content);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No match!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7，Java方法"><a href="#7，Java方法" class="headerlink" title="7，Java方法"></a>7，Java方法</h2><p>1）<strong><code>Java方法</code>定义</strong>：Java方法是语句的集合，他们在一起执行一个功能。</p><blockquote><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul></blockquote><p> 2）<strong><code>Java方法</code>的优点</strong></p><blockquote><ul><li>使程序变得更简短而清晰</li><li>有利于程序维护</li><li>可以提高程序开发的效率</li><li>提高了代码的重用性</li></ul></blockquote><p>3）<strong><code>Java方法</code>的命名规则</strong></p><blockquote><ul><li>必须以<code>字母</code>、<code>&#39;_&#39;</code>或<code>&#39;＄&#39;</code>开头（方法名第一个单词应以小写字母开头，后面的单词则用大写字母开头写，不使用连接符）；</li><li>可以包括数字，但不能以它开头；</li><li>下划线可能出现在<code>JUnit</code>测试方法名称中用以分隔名称的逻辑组件。</li></ul></blockquote><p>4）<strong><code>Java方法</code>的定义</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5）<strong><code>Java方法</code>调用</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> max = getMax(i, j);</span><br><span class="line">        System.out.printf(<span class="string">"%d和%d比较，最大值是：%d."</span>, i, j, max);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">            result = num1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6）<strong><code>void</code>关键字</strong></p><p>7）<strong><code>Java方法重载</code></strong>：一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p><p>8）<strong>变量作用域</strong></p><p>9）<strong>命令行参数</strong>：<code>命令行参数</code>是在执行程序时候紧跟在程序名字后面的信息。</p><p>10）<strong>构造方法</strong>：当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p><p>11）<strong>可变参数</strong>：<code>JDK1.5</code>开始，<code>Java</code>支持传递同类型的可变参数给一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName... parameterName</span><br></pre></td></tr></table></figure></p><ul><li>在方法声明中，在指定参数类型后加一个省略号(<code>...</code>) 。</li><li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">double</span> max = getMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.printf(<span class="string">"...numbers中，最大值是：%.2f."</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMax</span><span class="params">(<span class="keyword">double</span>... numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"No argument passed."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">10000000000L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">double</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> <span class="keyword">var</span>: numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">var</span> &gt; result) &#123;</span><br><span class="line">                result = <span class="keyword">var</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>12）<strong><code>finalize()</code>方法</strong>：在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。</p><ul><li><strong><code>Java 的内存回收可以由 JVM 来自动完成。</code></strong></li><li>FinalizationDemo.java如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cake c1 = <span class="keyword">new</span> Cake(<span class="number">1</span>);</span><br><span class="line">        Cake c2 = <span class="keyword">new</span> Cake(<span class="number">2</span>);</span><br><span class="line">        Cake c3 = <span class="keyword">new</span> Cake(<span class="number">3</span>);</span><br><span class="line">​</span><br><span class="line">        c2 = c3 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 调用Java垃圾回收集器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cake</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        System.out.println(<span class="string">"Cake Object "</span> + id + <span class="string">" is created."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"Cake object "</span> + id + <span class="string">" is disposed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="8，Java流（Stream），文件（File）和IO"><a href="#8，Java流（Stream），文件（File）和IO" class="headerlink" title="8，Java流（Stream），文件（File）和IO"></a>8，Java流（Stream），文件（File）和IO</h2><p><code>Java.io</code>包几乎包含了所有操作输入、输出需要的类。<br>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>1）<strong>读取控制台输入</strong>：<code>Java</code>的控制台输入由<code>System.in</code>完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br></pre></td></tr></table></figure></p><p>2）<strong>从控制台读取多字符输入</strong>：从<code>BufferedReader</code>对象读取一个字符要使用 <code>read()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p><ul><li>BRReadLine.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRReadLine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.println(<span class="string">"输入字符，按下'q'键退出."</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ch = (<span class="keyword">char</span>) br.read();</span><br><span class="line">            System.out.println(ch);</span><br><span class="line">        &#125; <span class="keyword">while</span> (ch != <span class="string">'q'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3）<strong>从控制台读取字符串</strong>：从 标准输入读取一个字符要使用<code>BufferedReader</code>的 <code>readLine()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p><ul><li>BRReadLines.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRReadLines</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.println(<span class="string">"Enter lines of text;"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Enter 'end' to quit."</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            str = br.readLine();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!str.equals(<span class="string">"end"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>4）<strong>控制台输出</strong>：控制台的输出由 <code>print()</code> 和 <code>println()</code> 完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        num = <span class="string">'A'</span>;</span><br><span class="line">        System.out.write(num);</span><br><span class="line">        System.out.write(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5）<strong>读写文件</strong>：一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br><img src="/images/java_basic_knowledge_io_20190411.png" alt="IO流"></p><p>6）<strong><code>FileInputStream</code></strong>：该流用于从文件读取数据，它的对象可以用关键字<code>new</code>来创建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把给定的context以二进制写进文件，同时输出控制台</span></span><br><span class="line"><span class="comment"> * 但是存在乱码问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bWrite = &#123;<span class="string">'a'</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">54</span>&#125;;</span><br><span class="line">            OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"file_test.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> <span class="keyword">var</span>: bWrite) &#123;</span><br><span class="line">                os.write(<span class="keyword">var</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line">​</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"file_test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> size = is.available();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) is.read() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"File InputStream error: "</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7）<strong><code>FileOutputStream</code></strong>：该流用来创建一个文件并向文件中写数据，它的对象可以用关键字 <code>new</code> 来创建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把给定的context以二进制写进文件，同时输出控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIOStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"file_test.txt"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 构建FileOutputStream对象，文件不存在会自动新建</span></span><br><span class="line">        FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 构建对象，参数可以指定编码，默认为操作系统默认编码，windows是gbk</span></span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fop, <span class="string">"UTF-8"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 写入到缓冲区</span></span><br><span class="line">        writer.append(<span class="string">"中文输入"</span>);</span><br><span class="line">        writer.append(<span class="string">"\r\n"</span>);</span><br><span class="line">        writer.append(<span class="string">"English input"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 关闭写入流，同时会把缓冲区的内容写入文件</span></span><br><span class="line">        writer.close();</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 关闭输出流，释放系统资源</span></span><br><span class="line">        fop.close();</span><br><span class="line">​</span><br><span class="line">        FileInputStream fip = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fip, <span class="string">"UTF-8"</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (reader.ready()) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) reader.read());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        reader.close();</span><br><span class="line">        fip.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>关于文件和<code>I/O</code>的一些其他类：<code>File Class</code>；<code>FileReader Class</code>；<code>FileWriter Class</code>。</li></ul><h2 id="9，Java中的目录"><a href="#9，Java中的目录" class="headerlink" title="9，Java中的目录"></a>9，Java中的目录</h2><p>1）<strong>创建目录</strong><br><code>File</code>类中有两个方法可以用来创建文件夹：</p><blockquote><ul><li><code>mkdir( )</code>方法创建一个文件夹，成功则返回<code>true</code>，失败则返回<code>false</code>。</li><li><code>mkdirs()</code>方法创建一个文件夹和它的所有父文件夹。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String dirName = <span class="string">"/home/share/java"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(dirName);</span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）<strong>读取目录</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String dirName = <span class="string">"/home/share"</span>;</span><br><span class="line">        File fp = <span class="keyword">new</span> File(dirName);</span><br><span class="line">        <span class="keyword">if</span> (fp.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"目录："</span> + dirName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 提取包含的文件和文件夹的列表</span></span><br><span class="line">            String[] strings = fp.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">                File tmp = <span class="keyword">new</span> File(dirName + <span class="string">"/"</span> + strings[i]);</span><br><span class="line">                <span class="keyword">if</span> (tmp.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(strings[i] + <span class="string">"  是一个目录."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(strings[i] + <span class="string">"  是一个文件."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirName + <span class="string">"  不是一个目录."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）<strong>删除目录或文件</strong>：删除文件可以使用<code>java.io.File.delete()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File folder = <span class="keyword">new</span> File(<span class="string">"/home/share/java"</span>);</span><br><span class="line">        deleteFolder(folder);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 删除文件及目录</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(File folder)</span> </span>&#123;</span><br><span class="line">        File[] files = folder.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File fp: files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fp.isDirectory()) &#123;</span><br><span class="line">                    deleteFolder(fp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fp.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        folder.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="10，Java-Scanner类"><a href="#10，Java-Scanner类" class="headerlink" title="10，Java Scanner类"></a>10，Java Scanner类</h2><p><code>java.util.Scanner</code> 是 <code>Java5</code> 的新特征，我们可以通过 <code>Scanner</code> 类来获取用户的输入。基本语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure></p><p>1）<strong>使用<code>next</code>方法</strong></p><blockquote><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，<code>next()</code> 方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li><code>next()</code>不能得到带有空格的字符串。</li></ul></blockquote><ul><li>ScannerNext.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerNext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"Next方式接收："</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext()) &#123;</span><br><span class="line">            String str = scan.next();</span><br><span class="line">            System.out.println(<span class="string">"输入的数据为："</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2）<strong>使用<code>nextLine</code>方法</strong></p><blockquote><ul><li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul></blockquote><ul><li>ScannerNextLines.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerNextLines</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"NextLine方式接收："</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextLine()) &#123;</span><br><span class="line">            String str = scan.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"输入的数据为："</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：如果要输入 <code>int</code> 或 <code>float</code> 类型的数据，在 <code>Scanner</code> 类中也有支持，但是在输入之前最好先使用 <code>hasNextXxx()</code> 方法进行验证，再使用 <code>nextXxx()</code> 来读取。</p><ul><li>ScannerNumbers.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">int</span> numberI;</span><br><span class="line">        <span class="keyword">float</span> numberF;</span><br><span class="line">        <span class="keyword">double</span> numberD;</span><br><span class="line">        System.out.println(<span class="string">"输入整数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextInt()) &#123;</span><br><span class="line">            numberI = scan.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"整数是："</span> + numberI);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是整数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"输入浮点数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat()) &#123;</span><br><span class="line">            numberF = scan.nextFloat();</span><br><span class="line">            System.out.println(<span class="string">"浮点数是："</span> + numberF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是浮点数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"输入双精度小数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextDouble()) &#123;</span><br><span class="line">            numberD = scan.nextDouble();</span><br><span class="line">            System.out.println(<span class="string">"双精度小数是："</span> + numberD);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是双精度小数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11，Java异常处理"><a href="#11，Java异常处理" class="headerlink" title="11，Java异常处理"></a>11，Java异常处理</h2><p>1）<strong>理解<code>Java</code>异常处理是如何工作的，需掌握以下三种类型的异常</strong>：</p><blockquote><ul><li><code>检查性异常</code>：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。</li><li><code>运行时异常</code>： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><code>错误</code>： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。</li></ul></blockquote><p>2）<strong><code>Exception</code> 类的层次</strong></p><blockquote><ul><li>所有的异常类是从 <code>java.lang.Exception</code> 类继承的子类。</li><li><code>Exception</code> 类是 <code>Throwable</code> 类的子类。除了<code>Exception</code>类外，<code>Throwable</code> 类还有一个子类<code>Error</code> 。</li><li><code>Error</code> 用来指示运行时环境发生的错误。例如，<code>JVM</code> 内存溢出。一般地，程序不会从错误中恢复。</li><li>异常类有两个主要的子类：<code>IOException</code> 类和 <code>RuntimeException</code> 类。</li><li>在 Java 内置类中，有大部分常用<code>检查性</code>和<code>非检查性</code>异常。<br><img src="/images/java_basic_knowledge_ex_20190411.jpg" alt="JavaException"></li></ul></blockquote><p>3）<strong>Java内置类</strong><br>4）<strong>异常方法</strong>：主要是<code>Throwable</code>的方法。<br>5）<strong>捕获异常</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"Access elements three: "</span> + array[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception: "</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Out of the block."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6）<strong>多重捕获块</strong>：一个 <code>try</code> 代码块后面跟随多个 <code>catch</code> 代码块的情况就叫<code>多重捕获</code>。</p><p>7）<strong><code>throws/throw</code>关键字</strong>：如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法签名的尾部。</p><p>8）<strong><code>finally</code>关键字</strong>：<code>finally</code> 关键字用来创建在 <code>try</code> 代码块后面执行的代码块；无论是否发生异常，finally 代码块中的代码总会被执行；在 <code>finally</code>  代码块中，可以运行清理类型等收尾善后性质的语句。</p><ul><li>ExceptionDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Access elements three: "</span> + array[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception throw: "</span> + ex.toString());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            array[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">            System.out.println(<span class="string">"First element value: "</span> + array[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(<span class="string">"The finally statement is executed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>9）<strong>声明自定义异常</strong></p><blockquote><ul><li>所有异常都必须是 Throwable 的子类。</li><li>如写一个检查性异常类，则需要继承 Exception 类。</li><li>如写一个运行时异常类，那么需要继承 RuntimeException 类。    </li></ul></blockquote><p><em>综合实例</em></p><ul><li><p>InsufficientFundException.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常，继承Exception类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsufficientFundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsufficientFundException</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CheckingAccount.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行账户基本操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckingAccount</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 取钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InsufficientFundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt;= balance) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> needs = amount - balance;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundException(needs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 返回余额</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 返回账号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BankDemo.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 模拟银行账户基本操作实例</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CheckingAccount account = <span class="keyword">new</span> CheckingAccount(<span class="number">6228481</span>);</span><br><span class="line">        System.out.println(<span class="string">"Deposit $500..."</span>);</span><br><span class="line">        account.deposit(<span class="number">500.00</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Withdrawing $100..."</span>);</span><br><span class="line">            account.withdraw(<span class="number">100</span>);</span><br><span class="line">​</span><br><span class="line">            System.out.println(<span class="string">"Withdrawing $600..."</span>);</span><br><span class="line">            account.withdraw(<span class="number">600</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InsufficientFundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry, but you are short $"</span>+ex.getAmount());</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>10）<strong>通用异常</strong><br>在Java中定义了两种类型的异常和错误：</p><blockquote><ul><li><strong><code>JVM</code>(Java虚拟机) 异常</strong>：由 <code>JVM</code> 抛出的异常或错误。例如：<code>NullPointerException</code> 类，<code>ArrayIndexOutOfBoundsException</code> 类，<code>ClassCastException</code> 类。</li><li><strong>程序级异常</strong>：由程序或者API程序抛出的异常。例如 <code>IllegalArgumentException</code> 类，<code>IllegalStateException</code> 类。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】关系数据库</title>
    <link href="https://zhangbc.github.io/2019/04/10/db_rdb/"/>
    <id>https://zhangbc.github.io/2019/04/10/db_rdb/</id>
    <published>2019-04-10T13:22:51.000Z</published>
    <updated>2019-04-10T16:13:32.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，关系模型的基本概念"><a href="#一，关系模型的基本概念" class="headerlink" title="一，关系模型的基本概念"></a>一，关系模型的基本概念</h2><ol><li><p><strong>关系及基本术语</strong></p><blockquote><ul><li>在关系模型中，表格的第一行称为<code>关系框架</code>，是属性$A_1$，$A_2$，$A_3$，$\dots$，$A_k$的<code>有限集合</code>。</li><li>表中的每行称为关系的一个<code>元组</code>；每列称为<code>属性</code>，它在某个值域上的取值，不同的属性可以在相同的值域上取值。</li><li>关系中的属性个数称为<code>元数</code>（<code>Arity</code>），元组个数称为<code>基数</code>。</li></ul></blockquote></li><li><p><strong>关键字</strong></p><blockquote><ul><li><code>超关键字</code>(<code>Super Key</code>)：在关系中能够唯一标识元组的属性集合。</li><li><code>候选关键字</code>(<code>Candidate Key</code>)：如果某一属性集合是<code>超关键字</code>，但去掉其中任意属性后就不再是超关键字，这样的属性称为<code>候选关键字</code>。<blockquote><ul><li><code>候选关键字</code>的诸属性称为<code>主属性</code>，不包含在任何候选关键字中的属性称为<code>非主属性</code>（<code>非码属性</code>）。</li></ul></blockquote></li><li><code>主关键字</code>(<code>Primary Key</code>)：如果关系中存在多个<code>候选关键字</code>，用户可选作元组标识的一个<code>候选关键字</code>为<code>主关键字</code>。</li><li><code>合成关键字</code>(<code>Composite Key</code>)：当某个候选关键字包含多个属性时，该候选关键字称为<code>合成关键字</code>。</li><li><code>外部关键字</code>(<code>Foreign Key</code>)：如果关系R的某个（些）属性K不是R中的候选关键字，而是另一个关系S的候选关键字，则K称为R的<code>外部关键字</code>。</li></ul></blockquote></li></ol><h2 id="二，关系模式"><a href="#二，关系模式" class="headerlink" title="二，关系模式"></a>二，关系模式</h2><ol><li><p>在关系数据库中，关系模式是<code>型</code>，关系是<code>值</code>。</p></li><li><p>【<strong><code>定义3-1</code></strong>】关系的描述称为关系模式，形式化表示为<br>$R(U, D, DOM, I, F)$<br>其中，$R$为<code>关系名</code>，$U$为组成该关系的<code>属性名集合</code>，$D$是$U$中属性的<code>域</code>，$DOM$为属性到域的<code>映像集合</code>，$I$为<code>完整性约束集合</code>，$F$为属性间数据的<code>依赖关系集合</code>。</p></li></ol><p><strong>⚠️</strong>关系模式中带有下画线的属性集为<code>主关键字</code>。</p><h2 id="三，关系模型的完整性"><a href="#三，关系模型的完整性" class="headerlink" title="三，关系模型的完整性"></a>三，关系模型的完整性</h2><ol><li><p><code>域完整性约束</code>：主要规定属性值必须取自值域，一个属性能否为空值由其语义决定。</p></li><li><p><code>实体完整性约束</code>：规定基本关系的所有主属性都不能取空值，而不仅是主属性整体不能取空值。</p></li><li><p><code>参照完整性约束</code>：要求“不引用不存在的实体”，考虑的是不同关系之间的或同一关系的不同元组之间的制约。形式定义：</p><p> 如果属性集K是关系R的<code>主关键字</code>，K也是关系S的<code>外关键字</code>，那么在关系S中，K的取值只允许两种可能，要么为空值，要么等于关系R中某个主关键字的值。关系R称为<code>“参照关系”模式</code>，关系S称为<code>“依赖关系”模式</code>。</p></li><li><p><code>用户自定义完整性约束</code>：针对某个具体关系数据库的约束条件。</p></li></ol><h2 id="四，关系代数"><a href="#四，关系代数" class="headerlink" title="四，关系代数"></a>四，关系代数</h2><ol><li><p><strong>关系查询语言分类</strong></p><blockquote><ul><li><code>关系代数语言</code>：查询操作是以<code>集合操作</code>为基础运算的<code>DML</code>语言。</li><li><code>关系演算语言</code>：查询操作是以<code>谓词演算</code>为基础运算的<code>DML</code>语言。</li></ul></blockquote></li><li><p><strong>关系代数的五种基本操作</strong></p><p><code>相等</code>定义：设有同类关系$r_1$和$r_2$，若$r_1$的任何一个元组都是$r_2$的一个元组，则称关系$r_2$包含关系$r1$，记作$r_1$ $\subseteq$ $r_2$或 $r_2$ $\supseteq$ $r_1$，如果$r_1$ $\subseteq$ $r_2$且$r_1$ $\supseteq$ $r_2$，则称关系$r_1$等于关系$r_2$，记作$r_1$=$r_2$。</p></li></ol><p>【<strong><code>定义3-2</code></strong>】<strong><code>并</code>(<code>Union</code>)</strong>：设有同类关系$r_1$[R]和$r_2$[R]，两者的<code>并</code>(<code>Union</code>)运算定义 $r_1$ $\bigcup$ $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\vee$ $t$ $\in$ $r_2$ }<br>式中，$\bigcup$为并运算符。$r_1$ $\bigcup$ $r_2$的结果关系是$r_1$的所有元组与$r_2$的所有元组的并集（去掉重复元组）。</p><p>【<strong><code>定义3-3</code></strong>】<strong><code>差</code>(<code>Difference</code>)</strong>：设有同类关系$r_1$[R]和$r_2$[R]，两者的<code>差</code>(<code>Difference</code>)运算定义为  $r_1$ - $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\wedge$ $t$ $\notin$ $r_2$ }<br>式中，- 为相减运算符。$r_1$ - $r_2$的结果关系是$r_1$的所有元组减去$r_1$与$r_2$相同的元组所剩下的元组的集合。</p><p>【<strong><code>定义3-4</code></strong>】<strong><code>笛卡儿积</code>(<code>Difference</code>)</strong>：设$r$[R]为$k_1$元关系，$s$[S]为$k_2$元关系，两者的<code>笛卡儿积</code>(<code>Difference</code>)运算定义为 $r$ $\times$ $s$ = { $t$ $\mid$ $t$ = &lt;$u,v$&gt; $\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $s$ }。</p><p>【<strong><code>定义3-5</code></strong>】<strong><code>投影</code>(<code>Projection</code>)</strong>：是对一个关系进行垂直分割，消去某些列，并重新安排列的顺序的操作。<br>设有$r$[R]为$k$元关系，其关系框架R={$A_1$,$A_2$,$\dots$,$A_k$}，$A_{j_1}$，$A_{j_2}$，$\dots$，$A_{j_n}$ 为R中互不相同的属性，那么关系$r$在属性（分量）$A_{j_1}$，$A_{j_2}$，$\dots$，$A_{j_n}$ 上的投影运算定义为 $\Pi$ $A_{j_1}$,$A_{j_2}$,$\dots$,$A_{j_n}$ $($ $r$ $)$ = { $u$ $\mid$ $u$ = &lt; $t$ [$A_{j_1}$],$t$[$A_{j_2}$],$\dots$,$t$[$A_{j_n}$] &gt; $\wedge$ $t$ $\in$ $r$ }<br>式中，$\Pi$为投影运算符。</p><p>【<strong><code>定义3-6</code></strong>】<strong><code>选择</code>(<code>Selection</code>)</strong>：根据某些条件对关系进行水平分割，即选取符合条件的元组的操作。条件可用命题公式F表示，由<code>运算对象</code>和<code>运算符</code>组成：</p><blockquote><ul><li><code>运算对象</code>：常数（用引号括起来）、元组分量（属性名或列的序号）</li><li><code>运算符</code>：算术比较运算符（$\lt$,$\le$,$\gt$,$\ge$,=,$\ne$，也称$\theta$符），逻辑运算符（$\vee$,$\wedge$,$\neg$）</li></ul></blockquote><p>关系R关于公式F的选择操作用$\sigma$F$($R$)$表示，其定义为：<br>$\sigma$F $($ R $)$ $\equiv$ { $t$ $\mid$ $t$ $\in$ R $\wedge$ F($t$)=true}<br>式中，$\sigma$为选择运算符。$\sigma$F$($R$)$表示从R中挑选满足公式F为真的元组所构成的关系。</p><ol><li><strong>关系代数的其他操作</strong></li></ol><p>【<strong><code>定义3-7</code></strong>】<strong><code>交</code>(<code>Intersection</code>)</strong>：设有同类关系$r_1$[R]和$r_2$[R]，两者的<code>交</code>(<code>Intersection</code>)运算定义 $r_1$ $\bigcap$ $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\wedge$ $t$ $\in$ $r_2$}<br>式中，$\bigcap$为交运算符。$r_1<script type="math/tex">\bigcap</script>r_2$的结果关系是$r_1$与$r_2$的所有相同元组构成的集合，显然，$r_1<script type="math/tex">\bigcap</script>r_2$ 等于$r_1$ - ($r_1$ - $r_2$ )或者$r_2$ - ($r_2$ - $r_1$ )。</p><p>【<strong><code>定义3-8</code></strong>】$\theta$<strong><code>-连接</code></strong>：设$r$[R]、$s$[S]关系框架分别为R = {$A_1$,$A_2$,$\dots$,$A_n$} 和 {$B_1$,$B_2$,$\dots$,$B_m$}，那么关系$r$和$s$的$\theta$<strong><code>-连接</code></strong>（$\theta$-Join）运算定义为：<br>$r$ $\Join$ $s$ = { $t$ $\mid$ $t$ = &lt; $u, v$ &gt;$\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $u$[$A_i$]$\theta$ $v$[$B_j$]}</p><p>【<strong><code>定义3-9</code></strong>】<strong><code>F-连接</code></strong> ：设$r$[R]、$s$[S]关系框架分别为R = { $A_1$,$A_2$,$\dots$,$A_n$ }，{ $B_1$,$B_2$,$\dots$,$B_m$ }，F($A_1$,$A_2$,$\dots$,$A_n$,$B_1$,$B_2$,$\dots$,$B_m$)为一公式，那么关系$r$和$s$的<strong>F-连接</strong>（<code>F-Join</code>）运算定义为：<br>$r$ $\Join$ $s$ = { $t$ $\mid$ $t$ = &lt; $u, v$&gt;$\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $s$ $\wedge$F($u$[$A_1$],$\dots$,$u$[$A_n$]),$u$[$B_1$],$\dots$,$u$[$B_m$]) }<br>即：$r$ $\Join$ $s$ = $\sigma$F $(r$ $\times$ $s)$</p><p>【<strong><code>定义3-10</code></strong>】<strong><code>自然连接</code></strong>：    <code>Natural Jion</code>是一种特殊的等值连接，它要求关系R和关系S具有相同的属性组B($b_1$,$b_2$,$b_3$,$\dots$ $\dots$)，这些属性组的取值是相等的，在最后生成的关系中去掉属性重复的列。其计算过程如下：</p><blockquote><p>(1)计算$r$ $\times$ $s$；<br>(2)设$r$和$s$的公共属性是$A_1$,$A_2$,$\dots$,$A_m$，选出$r$ $\times$ $s$中满足$r.A_1$=$s.A_1$,$r.A_2$=$s.A_2$, $\dots$, $r.A_m$=$s.A_m$的那些元组；<br>(3)去掉$s.A_1$,$s.A_2$,$\dots$,$s.A_m$这些列。</p></blockquote><p>【<strong><code>定义3-11</code></strong>】<strong><code>除</code>(<code>Division</code>)</strong>：给定关系$r$(X,Y)和$s$(Y,Z)，其中，X，Y，Z为属性组，$r$中的Y与$s$中的Y可以有不同的属性名，但必须出自相同的域集。R与S的<code>除</code>(<code>Division</code>)运算得到一个新的关系$p$(X)，$p$是r中满足下列条件的元组在X属性列上的投影，即元组在X上的分量值$x$的像集$Y_x$包含s在Y上投影的集合，记为<br>$r$ $\div$ $s$ = { $t_r$[X]$\mid$ $t_r$ $\in$ $r$ $\wedge$ $\pi_y$($s$) $\subseteq$ $Y_x$ }<br>式中，$Y_x$为$x$在$r$中的像集，$x$=$t_r$[X]。</p><h2 id="五，关系演算"><a href="#五，关系演算" class="headerlink" title="五，关系演算"></a>五，关系演算</h2><p>关系演算是以<code>数理逻辑</code>中的<code>谓词</code>为基础的，按<code>谓词变元</code>的不同，关系演算可以分为<code>元组关系演算</code>和<code>域关系演算</code>。</p><ol><li><p><strong>元组关系演算</strong>：以<code>元组</code>为变量。<br>1） 在元组关系演算中，元组关系演算表达式的一般形式为：<br>$\{t|P(t)\}$<br>式中，t是元组变量，表示一个元数确定的元组，P是满足一定逻辑条件的公式，公式可以分解为一些原子公式，$\{t|P(t)\}$表示满足公式P的所有元组$t$的集合。<br>2）在一个演算公式中，未用存在量词$\exists$或全称量词$\forall$符号定义的元组变量，称为<code>自由元组变量</code>，否则称为<code>约束元组变量</code>。</p></li><li><p><strong>域关系演算</strong>：以<code>属性(域)</code>为变量，简称<code>域演算</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，关系模型的基本概念&quot;&gt;&lt;a href=&quot;#一，关系模型的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一，关系模型
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java入门知识</title>
    <link href="https://zhangbc.github.io/2019/04/08/java_introductory_knowledge/"/>
    <id>https://zhangbc.github.io/2019/04/08/java_introductory_knowledge/</id>
    <published>2019-04-08T15:52:05.000Z</published>
    <updated>2019-04-10T16:56:20.703Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，java简介"><a href="#1，java简介" class="headerlink" title="1，java简介"></a>1，java简介</h2><p>   Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。</p><p>   1）<strong>Java分为三个体系</strong>：</p><blockquote><ul><li>JavaSE(J2SE)Java2 Platform Standard Edition，java平台标准版）</li><li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li><li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)</li></ul></blockquote><p>   2）<strong>Java的主要特性</strong>：</p><blockquote><ul><li>java语言是简单的；</li><li>java语言是面向对象的（纯面向对象）；</li><li>java语言的分布式的；</li><li>java语言是健壮的（丢弃指针，强类型机制，异常处理，垃圾的自动收集）；</li><li>java语言是安全的（安全防范机制（类ClassLoader），安全管理机制（类SecurityManager））；</li><li>java语言是可移植的；</li><li>java语言是解释型的；</li><li>java是高性能的；</li><li>java语言多线程的；</li><li>java语言是动态的。</li></ul></blockquote><p>   3）<strong>Java的发展史</strong>：诞生于1995年；2014年3月18日，Oracle公司发表Java SE8。</p><p>   4）<strong>Java工具</strong>：Java语言尽量保证系统内存在1G以上。</p><h2 id="2，Java开发环境配置"><a href="#2，Java开发环境配置" class="headerlink" title="2，Java开发环境配置"></a>2，Java开发环境配置</h2><p>1）下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener"><strong>JDK工具</strong></a>解压安装，对应不同的系统选择适合的版本。</p><p>2）<strong>变量设置参数</strong>如下：</p><blockquote><ul><li>变量名：<code>JAVA_HOME</code></li><li>变量值：<code>C:\Program Files (x86)\Java\jdk1.8.0_91</code>        <strong>// 要根据自己的实际路径配置</strong></li><li>变量名：<code>CLASSPATH</code></li><li>变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code>   <strong>//记得前面有个”<code>.</code>“</strong></li><li>变量名：<code>Path</code></li><li>变量值：<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code></li></ul></blockquote><p>3）<strong>测试JDK是否安装成功</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ java -version  # 输出java安装的版本</span><br><span class="line">~ javac -version # 输出javac安装的版本</span><br></pre></td></tr></table></figure></p><p><strong><code>注意</code></strong>：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。</p><p>4）<strong>Java开发工具选择</strong></p><ul><li><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a></li><li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a>(推荐)</li></ul><h2 id="3，Java基础语法"><a href="#3，Java基础语法" class="headerlink" title="3，Java基础语法"></a>3，Java基础语法</h2><p>1）<strong>相关概念</strong><br>   <strong><code>类</code></strong>：类是一个模板，描述一个对象的行为和状态。<br>    java中的<code>类</code>：  </p><blockquote><ul><li><code>局部变量</code>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><code>成员变量</code>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><code>类变量</code>：类变量也声明在类中，方法体之外，但必须声明为<code>static</code>类型。</li><li><code>构造方法</code>：每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 </li></ul></blockquote><p>   创建对象：在<code>Java</code>中，使用关键字<code>new</code>创建一个新的对象，主要有三步：<code>声明</code>，<code>实例化（new）</code>，<code>初始化</code>。<br>   <code>对象</code>：对象是一个类的实例，有状态和行为。<br>   在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。<br>    <code>方法</code>：方法即行为，一个类可以有很多方法。<br>    <code>实例变量</code>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p><p>2）<strong>编程注意点</strong></p><blockquote><ul><li>大小写敏感</li><li>类名每个单词的首字母大写（帕斯卡命名法）</li><li>方法名以小写字母开头，之后每个单词首字母大写（驼峰命名法）</li><li>源文件名必须和类名相同</li><li>主方法入口，所有的<code>Java</code>程序由<code>public static void main(String []args)</code>方法开始执行</li></ul></blockquote><p>3）<strong>Java标识符</strong></p><p><code>标识符</code>：类名，变量名及方法名都称为<code>标识符</code>。</p><blockquote><ul><li>所有的<code>标识符</code>都应该以字母（<code>A-Z</code>或者<code>a-z</code>）,美元符（<code>$</code>）、或者下划线（<code>_</code>）开始；</li><li>首字符之后可以是字母（<code>A-Z</code>或者<code>a-z</code>）,美元符（<code>$</code>）、下划线（<code>_</code>）或数字的任何字符组合；</li><li><code>关键字</code>不能用作标识符；</li><li><code>标识符</code>是大小写敏感的；</li><li>合法标识符举例：<code>age</code>、<code>$salary</code>、<code>_value</code>、<code>__1_value</code>；</li><li>非法标识符举例：<code>123abc</code>、<code>-salary</code>；</li></ul></blockquote><p>4）<strong>Java修饰符</strong></p><p>（1）访问控制： <code>default</code>, <code>public</code>, <code>protected</code>, <code>private</code> </p><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子孙类（同一包）</th><th style="text-align:center">子孙类（不同包）</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y /N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table></div><p><strong><code>protected</code>说明</strong>：</p><blockquote><ul><li>子类与基类在同一包中：被声明为<code>protected</code>的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的<code>protected</code>方法。</li></ul></blockquote><p>（2）访问控制和继承，注意以下原则：</p><blockquote><ul><li>父类中声明为<code>public</code>的方法在子类中也必须为<code>public</code>。</li><li>父类中声明为<code>protected</code>的方法在子类中要么声明为<code>protected</code>，要么声明为 <code>public</code>，不能声明为<code>private</code>。</li><li>父类中声明为<code>private</code>的方法，不能够被继承。                </li></ul></blockquote><p>（3）非访问控制：<code>final</code>, <code>abstract</code>,<code>static</code>, <code>synchronized</code>,<code>volatile</code></p><blockquote><ul><li><code>static</code>：创建类方法和类变量；</li><li><code>final</code>：修饰类，方法和变量。修饰的类不可被继承；修饰的方法不能被继承的类重新定义；修饰的变量为常量，不可修改。</li><li><code>abstract</code>：创建抽象类和抽象方法；</li><li><code>synchronized</code>：用于线程编程，synchronized声明的方法同一时间只能被一个线程访问；</li><li><code>transient</code>：序列化的对象包含被 <code>transient</code>修饰的实例变量时，<code>Java</code>虚拟机(<code>JVM</code>)跳过该特定的变量；该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li><li><code>volatile</code>：用于线程编程， 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值，当成员变量发生变化时，会强制线程将变化值回写到共享内</li></ul></blockquote><p>5）<strong>Java变量</strong></p><p><code>局部变量</code>：类的方法中的变量。</p><blockquote><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在<code>栈</code>上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul></blockquote><p><code>类变量（静态变量）</code>：独立于方法之外的变量，用<code>static</code>修饰。<br><code>成员变量（非静态变量）</code>：独立于方法之外的变量，不用<code>static</code>修饰。</p><p>6）<strong>Java数组</strong>：储存在堆上的对象，可以保存多个同类型变量。</p><p>7）<strong>Java枚举</strong>：Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。</p><p>8）<strong>Java关键字</strong>：参见<a href="http://www.runoob.com/java/java-basic-syntax.html" target="_blank" rel="noopener">Java关键字列表</a></p><p>9）<strong>Java注释</strong></p><p>10）<strong>Java空行</strong>：空白行，或者有注释的行，Java编译器都会忽略掉。</p><p>11）<strong>Java继承</strong><br>在Java中，一个类可以由其他类派生。被继承的类称为<code>超类</code>（<code>super class</code>），派生类称为<code>子类</code>（<code>subclass</code>）。</p><p>12）<strong>Java接口</strong>：在Java中，接口可以理解为对象间相互通信的协议。</p><p>13）<strong>源文件声明规则</strong></p><blockquote><ul><li>一个源文件中只能有一个public类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和public类的类名保持一致</li><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行</li><li>如果源文件包含import语句，那么应该放在package语句和类定义之间；如果没有package语句，那么import语句应该在源文件中最前面。</li><li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul></blockquote><p>14）<strong>Java包</strong>：包主要用来对类和接口进行分类。</p><p>15）<strong>Import语句</strong></p><p>16）<strong>Java运算符</strong></p><blockquote><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符：Java定义类位运算符，应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符（instanceof，自增，自减，条件运算符）</li></ul></blockquote><p>17）<strong>Java 源程序与编译型运行区别</strong><br><img src="/images/java_intrductory_knowledge_20190408.png" alt="Java 源程序与编译型运行区别"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>【数据库实战】SQL Server数据库常用脚本</title>
    <link href="https://zhangbc.github.io/2019/04/07/sql_used_script/"/>
    <id>https://zhangbc.github.io/2019/04/07/sql_used_script/</id>
    <published>2019-04-07T08:40:27.000Z</published>
    <updated>2019-04-09T13:11:32.517Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1，创建链接远程服务器及其删除"><a href="#1，创建链接远程服务器及其删除" class="headerlink" title="1，创建链接远程服务器及其删除"></a>1，创建链接远程服务器及其删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addlinkedserver  'web','','SQLOLEDB','192.168.10.106'</span><br><span class="line">exec sp_addlinkedsrvlogin 'web','false',null,'sa','123'</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除链接服务器</span></span><br><span class="line">exec sp_dropserver 'web','droplogins'</span><br></pre></td></tr></table></figure><h4 id="2，重置SQLSERVER表的自增列，让自增列重新计数"><a href="#2，重置SQLSERVER表的自增列，让自增列重新计数" class="headerlink" title="2，重置SQLSERVER表的自增列，让自增列重新计数"></a>2，重置SQLSERVER表的自增列，让自增列重新计数</h4><p>语法：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DBCC CHECKIDENT</span><br><span class="line">(</span><br><span class="line">  table_name</span><br><span class="line">  <span class="comment">[, &#123; NORESEED | &#123; RESEED <span class="comment">[,new_reseed_value ]</span> &#125; &#125; ]</span></span><br><span class="line"> )</span><br><span class="line"> <span class="comment">[ WITH NO_INFOMSGS ]</span></span><br></pre></td></tr></table></figure></p><blockquote><p>参数：</p><blockquote><ul><li>table_name:是要对其当前标识值进行检查的表名。指定的表必须包含标识列。表名必须符合标识符规则。</li><li>NORESEED:指定不应更改当前标识值。</li><li>RESEED:指定应该更改当前标识值。</li><li>new_reseed_value:用作标识列的当前值的新值。</li><li>WITH NO_INFOMSGS:取消显示所有信息性消息。</li></ul></blockquote></blockquote><p>查看某表当前的种子值，示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbcc checkident('mainTable',noreseed);</span><br></pre></td></tr></table></figure></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">------------显示如下--------------</span></span><br><span class="line"><span class="ruby">--检查标识信息: 当前标识值 <span class="string">'2707'</span>，当前列值 <span class="string">'2707'</span>。</span></span><br><span class="line"><span class="ruby">--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。</span></span><br></pre></td></tr></table></figure><p>重置表mainTable的当前标识值为1，示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbcc checkident('mainTable',reseed,1);</span><br></pre></td></tr></table></figure></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">------------显示如下--------------</span></span><br><span class="line"><span class="ruby">--检查标识信息: 当前标识值 <span class="string">'NULL'</span>，当前列值 <span class="string">'1'</span>。</span></span><br><span class="line"><span class="ruby">--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。</span></span><br></pre></td></tr></table></figure><h4 id="3，几个有用的存储过程"><a href="#3，几个有用的存储过程" class="headerlink" title="3，几个有用的存储过程"></a>3，几个有用的存储过程</h4><ul><li><p>修改xx表中所有值null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment">   功能：修改xx表中所有列为NULL=''</span></span><br><span class="line"><span class="comment">   作者：by zhangbc</span></span><br><span class="line"><span class="comment">   时间：2015-10-19</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line">if (OBJECT_ID('modifyNull','P') is not null)</span><br><span class="line">     <span class="keyword">drop</span> <span class="keyword">procedure</span> modifyNull</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> modifyNull(@<span class="keyword">table</span> <span class="built_in">char</span>(<span class="number">100</span>))</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">--定义游标</span></span><br><span class="line">    <span class="keyword">declare</span> col_cur <span class="keyword">cursor</span> <span class="keyword">scroll</span> dynamic <span class="comment">--scroll表示可以向前或向后移动    dynamic：表示可写也可读</span></span><br><span class="line"> <span class="keyword">for</span></span><br><span class="line"> <span class="keyword">select</span> b.name <span class="keyword">from</span> sysobjects a</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span> syscolumns b <span class="keyword">on</span> a.id=b.id</span><br><span class="line">  <span class="keyword">where</span> a.name=@<span class="keyword">table</span></span><br><span class="line">    <span class="comment">--打开游标</span></span><br><span class="line">    <span class="keyword">open</span> col_cur</span><br><span class="line"> <span class="keyword">declare</span> @columnName <span class="keyword">nvarchar</span>(<span class="number">100</span>)</span><br><span class="line"> <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> col_cur <span class="keyword">into</span> @columnName</span><br><span class="line"> <span class="keyword">declare</span> @<span class="keyword">sql</span> <span class="keyword">nvarchar</span>(<span class="number">1000</span>)</span><br><span class="line"> <span class="keyword">while</span> (@@FETCH_STATUS=<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">set</span> @<span class="keyword">sql</span>=<span class="string">'update '</span> + @<span class="keyword">table</span> + <span class="string">' set '</span> + @columnName + <span class="string">' = ISNULL('</span> + @columnName + <span class="string">', '''')'</span></span><br><span class="line">   exec(@<span class="keyword">sql</span>)</span><br><span class="line">   <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> col_cur <span class="keyword">into</span> @columnName</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> <span class="comment">--关闭游标</span></span><br><span class="line"> <span class="keyword">close</span> col_cur</span><br><span class="line"> <span class="comment">--释放游标</span></span><br><span class="line"> <span class="keyword">deallocate</span> col_cur</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>修改数据库中所有表的所有列为null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment">   功能：修改数据库中所有表的所有列为NULL=''</span></span><br><span class="line"><span class="comment">   作者：by zhangbc</span></span><br><span class="line"><span class="comment">   时间：2015-10-19</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> [dbo].[modifyAllNull]</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> tab_cur <span class="keyword">cursor</span> <span class="keyword">scroll</span> dynamic <span class="comment">--scroll表示可以向前或向后移动    dynamic：表示可写也可读</span></span><br><span class="line"> <span class="keyword">for</span></span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> sysobjects <span class="keyword">where</span> xtype=<span class="string">'U'</span></span><br><span class="line">    <span class="comment">--打开游标</span></span><br><span class="line">    <span class="keyword">open</span> tab_cur</span><br><span class="line"> <span class="keyword">declare</span> @tableName <span class="keyword">nvarchar</span>(<span class="number">100</span>)</span><br><span class="line"> <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> tab_cur <span class="keyword">into</span> @tableName</span><br><span class="line"> <span class="keyword">declare</span> @<span class="keyword">sql</span> <span class="keyword">nvarchar</span>(<span class="number">1000</span>)</span><br><span class="line"> <span class="keyword">while</span> (@@FETCH_STATUS=<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">set</span> @<span class="keyword">sql</span>=<span class="string">'exec dbo.modifyNull '</span> +<span class="string">''''</span> + @tableName + <span class="string">''''</span></span><br><span class="line">   exec(@<span class="keyword">sql</span>)</span><br><span class="line">   <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> tab_cur <span class="keyword">into</span> @tableName</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> <span class="comment">--关闭游标</span></span><br><span class="line"> <span class="keyword">close</span> tab_cur</span><br><span class="line"> <span class="comment">--释放游标</span></span><br><span class="line"> <span class="keyword">deallocate</span> tab_cur</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1，创建链接远程服务器及其删除&quot;&gt;&lt;a href=&quot;#1，创建链接远程服务器及其删除&quot; class=&quot;headerlink&quot; title=&quot;1，创建链接远程服务器及其删除&quot;&gt;&lt;/a&gt;1，创建链接远程服务器及其删除&lt;/h4&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库实战" scheme="https://zhangbc.github.io/tags/db-actual-combat/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】绪论</title>
    <link href="https://zhangbc.github.io/2019/04/06/db_introduction/"/>
    <id>https://zhangbc.github.io/2019/04/06/db_introduction/</id>
    <published>2019-04-06T10:42:18.000Z</published>
    <updated>2019-04-10T16:56:20.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。<br><img src="/images/db_introduction_20190406.png" alt="数据库系统与应用"></p></blockquote><h2 id="一，数据库的概念"><a href="#一，数据库的概念" class="headerlink" title="一，数据库的概念"></a>一，数据库的概念</h2><ol><li><strong>数据库定义</strong>：<code>数据库（DB）</code>是长期保存在计算机的存储设备上并按照某种模型组织起来的，可以被各种用户或应用共享的数据集合。</li><li><strong>数据库分类</strong>：<code>关系数据库</code>，<code>层次数据库</code>，<code>网状数据库</code>.</li><li><strong>数据库基本特征</strong>：<br>1）具有较高的数据独立性；<code>数据独立性</code>是指数据的组织方法和储存方法与应用程序互不依赖，彼此独立的特性，包括<code>物理独立性</code>和<code>逻辑独立性</code>。<br>2）数据库用综合的方法组织数据，保证尽可能高的访问效率；<br>3）具有较小的数据冗余，可以供多个用户共享；<br>4）具有安全控制机制，能够保证数据的安全，可靠；<br>5）数据允许多用户共享，能够有效，及时地处理数据，并能够保证数据的一致性和完整性。</li></ol><h2 id="二，数据库管理系统（DBMS）"><a href="#二，数据库管理系统（DBMS）" class="headerlink" title="二，数据库管理系统（DBMS）"></a>二，数据库管理系统（<code>DBMS</code>）</h2><ol><li><p><strong>DBMS的定义</strong>：<code>DBMS</code>是位于用户与操作系统之间的<code>数据管理软件</code>，数据库在建立，运用和维护时由数据库管理系统统一管理，控制。</p></li><li><p><strong>DBMS的目标</strong>：<br> 1）用户界面友好；<br> 2）功能完备；<br> 3）效率高，DBMS应该具有较高的系统效率和高的用户生产率，其中系统效率包括：</p><blockquote><p>（1）<strong>计算机内部资源的利用率</strong>，即能够充分利用磁盘空间，CPU，设备等资源，并注意使各种资源的负载均衡以提高整个系统的效率；<br>（2）<strong>DBMS本身的运行效率</strong>，根据系统目标确定恰当的体系结构，数据结构和算法，保证DBMS运行的高效率；<code>用户生产率</code>是指用户设计和开发应用程序的效率；</p></blockquote><p> 4）结构清晰：DBMS内部结构清新，层次分明既便于支持其外层开发环境的构造，也便于自身的设计、开发与维护；<br> 5）开放性：DBMS的开放性是指符合标准和规范，如<code>ODBC标准</code>，<code>SQL标准</code>等。</p></li><li><p><strong>DBMS的基本功能</strong>：</p><p>1）数据库定义功能：<code>DDL</code>可以定义数据库中数据之间的联系，可以定义数据的完整性约束条件和保证完整性的触发机制等，包括全局逻辑数据结构（模式）的定义，局部逻辑数据结构（外模式）的定义，保密定义等；<br>2）数据库操纵功能：<code>DML</code>可以接收，分析和执行用户提出的访问数据库的各种要求，完成对数据库的各种基本操作，如对数据库的检索，插入，删除和修改等操作，可以重新组织数据的存储结构，可以完成数据库的备份和恢复等操作；<br>3）数据库的控制功能：<code>DCL</code>包括整个数据库系统的运行控制，数据库的完整性控制，数据库的安全性控制及多用户环境下的数据库并发访问控制等；<br>4）数据库的运行管理功能：指<code>DBMS</code>运行机制和管理功能；<br>5）数据库组织和存储管理功能<br>6）数据库的建立和维护功能<br>7）数据库通信功能</p></li><li><p><strong>DBMS的组成</strong>：</p><p> 1）数据库定义语言及其翻译程序：</p></li></ol><blockquote><p> <code>DDL</code>用于描述数据库中要存储的现实世界实体的语言，包括数据字典中数据库的逻辑结构，完整性约束，物理存储结构的表述，数据库的各种数据操作和数据库的维护管理的各种依据。包括：</p><blockquote><p> <code>模式DDL</code>：定义全局逻辑数据结构(包括所有字段的名称，特征及其相互关系)，数据的完整性，安全性约束；<br><code>外模式DDL</code>：为用户定义所用的局部逻辑数据结构(包括与用户的应用程序有关的字段名称，特征及其相互关系)，描述外模式到模式之间的映射关系；<br><code>内模式DDL</code>：用于描述数据在存储介质上的安排和存放方式，描述模式到内模式之间的映射关系；</p></blockquote></blockquote><p>   2）数据库操纵语言及其编译（或解释）程序：</p><blockquote><p><code>DML</code>用于实现对数据库的一些基本操作，如数据检索，数据插入，数据修改和数据删除，其中数据插入，数据修改和数据删除操作又称为<code>数据更新操作</code>。分为：</p><blockquote><p><code>宿主型DML</code>：本身不能独立使用，必须嵌入到宿主语言中，如<code>C</code>，<code>COLBOL</code>，<code>PASCAL</code>等，因此也称<code>嵌入型DML</code>，仅负责对数据库数据的操纵，其他工作都由宿主语言完成；<br><code>自主型DML</code>，又称<code>自含型DML</code>，可以独立进行数据查询，数据更新等操作，语法简单，使用方便，适合终端用户使用；</p></blockquote></blockquote><p>   3）数据库运行控制程序：包括系统初启程序(<code>DBMS</code>的<code>神经中枢</code>)，访问控制程序，安全性控制程序，完整性检查程序，并发控制程序，数据存取/更新程序，通信控制程序；<br>   4）数据库服务实用程序：包括数据装入程序，工作日志程序，性能监督程序，数据库重新组织程序，系统恢复程序，转储/编辑/打印程序。</p><ol><li><p><strong>数据库管理与数据库管理员(<code>DBA</code>)</strong>：</p><p>   1）<code>DBA</code>：从事数据库管理工作的人员，不是数据库的“占有者”，而是数据库的“保护者”。<br>   2)  <code>DBA</code>职责</p><blockquote><ul><li>在数据库设计开始之前，<code>DBA</code>首先调查数据库的用户需求。</li><li>在数据库设计阶段，<code>DBA</code>要负责数据库标准的制定和功用数据字典的研制，要负责各级数据库模式的设计，负责数据库安全，可靠方面的设计，决定文件组织的方法。</li><li>在数据库运行阶段，<code>DBA</code>要负责对用户进行数据库方面的培训，负责数据库的转储和恢复，数据维护，用户的使用权限等，负责监控数据库的性能。</li></ul></blockquote></li></ol><h2 id="三，数据库系统（DBS）"><a href="#三，数据库系统（DBS）" class="headerlink" title="三，数据库系统（DBS）"></a>三，数据库系统（<code>DBS</code>）</h2><ol><li><strong>DBS定义</strong>：指在计算机系统中引入数据库后的系统构成，一般由<code>数据库</code>，<code>数据库系统运行环境</code>，<code>数据库管理系统及其开发工具</code>，<code>数据库管理员</code>和<code>用户</code>组成。</li><li><p><strong>数据库系统的三级模式结构</strong>：<br> 1）<strong>模式定义</strong>：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，而不涉及具体的值。<br> 2）三级模式结构：</p><blockquote><ul><li><code>外模式</code>：也称<code>子模式</code>或者<code>用户模式</code>，是数据库用户看见和使用的局部数据的逻辑结构和特征的描述，是数据库的用户视图，是和某个应用相关的数据逻辑表示；一个数据库可以有多个外模式；</li><li><code>模式</code>：也称<code>逻辑模式</code>，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共视图，是数据库的整个逻辑描述，并说明一个数据库所采用的数据模型；一个数据库只有一个模式；</li><li><code>内模式</code>：也称<code>存储模式</code>，是数据物理结构和存储方式的描述，是数据库的内部表示方式；一个数据库只有一个内模式。</li></ul></blockquote></li><li><p><strong>二级映像功能和数据独立性</strong>：<br>  1）<strong>外模式/模式映像</strong>：当模式改变时，<code>DBA</code>对各个外模式/模式的映像做出相应改变，使外模式保持不变，从而使应用程序不改变，保证了<code>数据的逻辑独立性</code>；<br>  2）<strong>模式/内模式映像</strong>：唯一定义了数据全局逻辑结构和存储方式之间的对应关系。当数据库的存储方式改变时，<code>DBA</code>将对模式/内模式映像做出相应的改变，使模式保持不变，从而保证了<code>数据的物理独立性</code>。</p></li><li><p><strong>数据库系统的体系结构</strong>：<br> 1）<code>单用户结构</code>的数据库系统：最早最简单，不能共享数据；<br> 2）<code>主从式结构</code>的数据库系统：结构简单，数据易于维护维护和管理，但系统的可靠性不高；<br> 3）<code>分布式结构</code>的数据库系统：数据在逻辑上上一个整体，但是分布在计算机网络的不同结点上。<br> 4）<code>客户端/服务器结构</code>的数据库系统</p></li><li><p><strong>数据库系统的工作流程</strong>：<br> 1）<code>DBA</code>建立并维护数据库；<br> 2）用户编写应用程序；<br> 3）应用程序在<code>DBMS</code>支持下运行，在模式，外模式，内模式，用户源程序翻译为目标代码后，即可启动目标程序。</p></li></ol><h2 id="四，数据库的发展"><a href="#四，数据库的发展" class="headerlink" title="四，数据库的发展"></a>四，数据库的发展</h2><ol><li><p><strong>人工管理阶段</strong>：<br> 1）特点：数据不保存；应用程序管理数据；数据不共享；数据不具有独立性。</p></li><li><p><strong>文件系统阶段</strong>：<br> 1）优点：数据可以长期保存；有专门的软件即文件系统管理数据，文件系统把数据组织成相互独立的数据文件；文件的形式多样化；<br> 2）缺点：数据共享性差，冗余度大；数据独立性差；数据联系弱。</p></li><li><p><strong>数据库系统阶段</strong></p></li><li><p><strong>数据库技术的研究，应用领域和发展方向</strong></p></li></ol><blockquote><ul><li>数据模型</li><li>数据库管理系统软件的研制</li><li>数据操作</li><li>数据库理论：主要集中在关系的规范化理论，关系数据理论等。<blockquote><p>代表性的数据库应用领域和发展方向：</p><ul><li>因特网上的Web数据库</li><li>面向对象数据库</li><li>多媒体数据库</li></ul></blockquote></li><li><p>并行数据库</p></li><li><p>人工智能领域的知识库和主动数据库</p></li><li><p>模糊数据库系统</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;br&gt;&lt;img src=&quot;/images/db_introduction_20190406.png&quot; alt=&quot;数据库系统与应用&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】数据模型</title>
    <link href="https://zhangbc.github.io/2019/04/06/db_data_model/"/>
    <id>https://zhangbc.github.io/2019/04/06/db_data_model/</id>
    <published>2019-04-06T04:48:52.000Z</published>
    <updated>2019-04-09T13:11:32.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，数据描述"><a href="#一，数据描述" class="headerlink" title="一，数据描述"></a>一，数据描述</h2><ol><li><p><strong>数据的三种范畴</strong><br>  1）<code>现实世界</code>（<code>客观世界</code>）：<code>现实世界</code>所反映的客观存在的事物及其相互之间的联系，指数处理对象最原始的表现形式。<br>  2）<code>信息世界</code>（<code>观念世界</code>）：是<code>现实世界</code>在人们头脑中的反映，经过一定的选择，命名和分类而形成的。以下为相关概念：</p><blockquote><ul><li><code>实体（Entity）</code>：客观存在的事物在人们头脑中的反映，或说，客观存在并可相互区别的客观事物或抽象事件。</li><li><code>属性（Attribute）</code>：实体所具有的某一方面的特性。</li><li><code>域（Domain）</code>：一个属性可能取的所有属性值的范围称为该属性的域。</li><li><code>码（Key）</code>：唯一标识实体的属性集。</li><li><code>实体型（Entity Type）</code>：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li><li><code>实体集（Entity Set）</code>：同一类型实体的集合。</li></ul></blockquote><p>3）<code>机器世界</code>（<code>数据世界</code>或<code>存储世界</code>）<br>数据化后的信息称为<code>数据</code>，所以说<code>数据</code>是信息的符号表示。以下为相关概念：</p><blockquote><ul><li><code>数据项（字段，Field）</code>：对应于信息世界中的属性。</li><li><code>记录（Record）</code>：对应于每个实体所对应的数据。</li><li><code>记录型（Record Type）</code>：对应于信息世界中的实体型。</li><li><code>文件（File）</code>：对应于信息世界中的实体集。</li><li><code>关键字（Key）</code>：对应于能够唯一标识一个记录的字段集。</li></ul></blockquote></li><li><p><strong>实体间的联系</strong></p><blockquote><ul><li><code>一对一联系</code>：如果实体集<code>A</code>中每个实体，实体集<code>B</code>中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有<code>一对一联系</code>，记作<code>1:1</code>；</li><li><code>一对多联系</code>：如果实体集<code>A</code>中每个实体，实体集<code>B</code>中有n（n&gt;=0）个实体与之联系，反之，实体集<code>B</code>中每个实体，实体集<code>A</code>中至多有一个实体与之联系，则称实体集A与实体集B具有<code>一对多联系</code>，记作<code>1:n</code>；</li><li><code>多对多联系</code>：如果实体集<code>A</code>中每个实体，实体集<code>B</code>中有n（n&gt;=0）个实体与之联系，反之，实体集<code>B</code>中每个实体，实体集<code>A</code>中有m（m&gt;=0）个实体与之联系，则称实体集A与实体集B具有<code>多对多联系</code>，记作<code>n:m</code>。</li></ul></blockquote></li></ol><h2 id="二，概念模型与E-R方法"><a href="#二，概念模型与E-R方法" class="headerlink" title="二，概念模型与E-R方法"></a>二，概念模型与E-R方法</h2><ol><li><p><strong>数据模型</strong><br>  1）数据模型应满足以下要求：</p><blockquote><p>i）能够比较真实地模拟现实世界；<br>ii）容易为人所理解；<br>iii）便于在计算机上实现。</p></blockquote><p>  2）数据模型分类：</p><blockquote><p>i）<code>概念模型</code>：即<code>信息模型</code>，是按用户的观点来对数据和信息建模的，主要用于数据设计；<br>ii）<code>基本数据模型</code>：主要包括<code>网状模型</code>，<code>层次模型</code>，<code>关系模型</code>等，是按计算机系统的观点对数据建模的，主要用于DBMS的实现。</p></blockquote></li><li><p><strong>数据模型的三要素</strong><br>  1）<code>数据结构</code>：用于描述系统的静态特性。<code>数据结构</code>是所有研究对象类型的集合，这些对象是数据库的组成部分，分为两大类：</p><blockquote><ul><li>与数据类型，内容，性质有关的对象；</li><li>与数据之间联系有关的对象。</li></ul></blockquote><p>  2）<code>数据操作</code>：用于描述系统的动态特征。<code>数据操作</code>是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有<strong>检索</strong>和<strong>修改</strong>（插入，删除，更新）两大数据操作。<br>  3）<code>数据完整性约束</code>：是一组完整性规则的集合。<code>完整性规则</code>是给定的数据模型中的数据及其联系所具有的制约和存储规则，用于限制符合数据模型的数据库状态及状态的变化，用于确保数据的<code>正确</code>、<code>有效</code>和<code>相容</code>。</p></li><li><p><strong>概念数据模型</strong><br>  1）<code>概念模型</code>的定义：按用户的观点对现实世界进行数据建模而形成的，是一种独立于计算机系统的模型，完全不涉及信息在计算机系统中的表示，也不依赖于具体的数据库管理系统，用于描述某个特定组织所关心的信息结构。<br>  2）<code>概念模型</code>的相关基本概念：<code>实体</code>、<code>属性</code>、<code>域</code>、<code>码</code>、<code>实体型</code>和<code>实体集</code>。<br>  3）<code>概念模型</code>的基本关系：在<code>概念模型</code>中主要解决问题是实体间的联系。</p></li><li><p><strong>E-R图表示法</strong><br>  1）<code>实体型</code>：用<code>矩形</code>表示，矩形框内写明实体名；<br>  2）<code>属性</code>：用<code>椭圆</code>表示，椭圆内写明属性名；<br>  3）<code>联系</code>：用<code>菱形</code>表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标注联系的类型（<code>1:1</code>，<code>1:n</code>，<code>n:m</code>）。<br>  <code>E-R模型</code>优点：</p><blockquote><p>i）接近人的思想，容易理解；<br>ii）与计算机无关，用户容易接受。</p></blockquote></li></ol><h2 id="三，传统的三大数据模型"><a href="#三，传统的三大数据模型" class="headerlink" title="三，传统的三大数据模型"></a>三，传统的三大数据模型</h2><ol><li><p><strong>层次模型</strong><br>  1）<code>层次模型</code>定义：用<code>树形结构</code>表示实体之间的联系的模型称为<code>层次模型</code>。<br>  2）建立数据的<code>层次模型</code>需要满足以下条件：</p><blockquote><p>i）有且仅有一个结点没有父结点，这个结点即为树根结点；<br>ii）其他数据记录有且仅有一个父结点。</p></blockquote><p>  3）<code>层次模型</code>的<strong>基本特点</strong>：任何一个给定的记录值只有按其路径查看，才能体现它的全部含义，没有一个子记录值能够脱离父记录值而独立存在的。<br>  4）<code>层次模型</code>的<strong>最明显特点</strong>：层次清晰，构造简单，易于实现，可以很方便地表示一对一和一对多这两种实体之间的联系。<br>  5）<code>层次模型</code>的主要优点：</p><blockquote><p>i）<code>层次模型</code>本身比较简单；<br>ii）实体间联系是固定的，且预先定义好的应用系统采用<code>层次模型</code>来实现，其性能优于<code>关系模型</code>的性能，不低于<code>网状模型</code>的性能；<br>iii）<code>层次模型</code>提供了良好的完整性支持。</p></blockquote><p> 6）<code>层次模型</code>的主要缺点：</p><blockquote><p>i）现实世界中很多联系是非层次性的，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据或创建非自然组织（引入虚结点）来解决；<br>ii）对插入和删除操作的限制比较多；<br>iii）查询子结点必须通过父结点；<br>iv）由于结构严谨，层次命令趋于程序化。</p></blockquote></li><li><p><strong>网状模型</strong><br>  1）<code>网状模型</code>的定义： 网状模型是一种有向图，在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：</p><blockquote><p>i）允许一个以上的结点无父结点；<br>ii）一个结点可以有多于一个的父结点。</p></blockquote><p>  2）为了描述网状模型的记录之间的联系，引进了<code>系（Set）</code>的概念，所谓<code>系</code>可以理解为命名了的<code>联系</code>，它由一个父记录型和一个或多个子记录型构成。<br>  3）<code>网状数据库</code>的定义：用网状模型设计出来的数据库称为<code>网状数据库</code>。<br>  4）<code>网状模型</code>的主要优点：</p><blockquote><p>i）能够更为直接地描述现实世界，如一个结点可以有多个父结点；<br>ii）具有良好的性能，存取效率较高。</p></blockquote><p>  5）<code>网状模型</code>的主要缺点：</p><blockquote><p>i）结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于用户最终掌握；<br>ii）其DDL，DML语言复杂，用户不易使用。</p></blockquote></li><li><p><strong>关系模型</strong><br>  1）<code>关系模型</code>的主要优点：</p><blockquote><p>i）数据结构比较简单；<br>ii）具有很高的数据独立性；<br>iii）可以直接处理多对多联系；<br>iv）坚实的理论基础。</p></blockquote><p>  2）<code>值域</code>的定义：在关系模型中，一个n元关系有n个属性，属性的取值范围称为值域。<br>  3）<code>关系模型</code>主要缺点：存取路径对用户透明，查询效率往往不如非关系数据模型。</p></li></ol><h2 id="四，数据独立与三层结构"><a href="#四，数据独立与三层结构" class="headerlink" title="四，数据独立与三层结构"></a>四，数据独立与三层结构</h2><ol><li><p><strong>三级模式结构</strong></p><blockquote><ul><li><code>外模式</code>：又称为<code>用户模式</code>，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看得见和使用的局部数据的逻辑结构和特征描述，是与某一个应用有关的数据的逻辑表示。</li><li><code>模式</code>：可分为<code>概念模式</code>和<code>逻辑模式</code>，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。<blockquote><p>一个数据库只有一个<code>模式</code>，其中<code>概念模式</code>可以用<code>实体-联系模型</code>模型来描述，<code>逻辑模式</code>以某种数据模型为基础，综合考虑所有用户的需求，并将其形成全局逻辑结构。</p></blockquote></li><li><code>内模式</code>：又称为<code>存储模式</code>，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。</li></ul></blockquote></li><li><p><strong>数据的独立性</strong></p><blockquote><ul><li><code>逻辑数据独立性</code>：当<code>模式</code>改变时，只要对<code>外模式/模式映像</code>做相应的改变，就可以使<code>外模式</code>保持不变，以<code>外模式</code>为依据编写的应用程序就不受影响，从而应用程序不必修改，保证了数据与程序之间的<code>逻辑独立性</code>。</li><li><code>存储数据独立性</code>：当<code>内模式</code>改变时，只要对<code>模式/内模式映像</code>做相应的改变，使<code>模式</code>保持不变，应用程序就不受影响，从而保证了数据与程序之间的<code>物理独立性</code>，称为<code>存储数据独立性</code>。</li></ul></blockquote></li></ol><h2 id="五，数据库管理系统"><a href="#五，数据库管理系统" class="headerlink" title="五，数据库管理系统"></a>五，数据库管理系统</h2><ol><li><p><strong><code>DBMS</code>的主要功能</strong><br>  数据库的<code>主要职责</code>就是有效地实现数据库三级模式之间的转换，即把用户或应用程序对数据库的一次访问，从用户级带到概念级，再导向物理级，转换为对存储数据的操作。</p><blockquote><p>1）数据库定义<br>2）数据库操作及查询优化<br>3）数据库控制运行管理<br>4）数据组织，存储和管理<br>5）数据库的恢复和维护<br>6）数据库的多种接口<br>7）其他功能</p></blockquote></li><li><p><strong><code>DBMS</code>的组成</strong><br>  1）<code>DBMS</code>由<code>查询处理器</code>和<code>存储管理器</code>两大部分组成。其中：</p><blockquote><p>(1) <code>查询处理器</code>主要有<code>DDL</code>编译器，<code>DML</code>编译器，<code>嵌入式DML</code>的预编译器及查询运行核心程序；<br>(2) <code>存储管理器</code>有授权和完整性管理器，事务管理器，文件管理器及缓冲区管理器。</p></blockquote><p>  2）<code>查询处理程序</code>：把用较高级的语言所表示的数据库操作（查询、更新等）转换成一系列对数据库的请求。<br>  3）<code>存储管理程序</code>：包括<code>文件管理程序</code>和<code>缓冲区管理程序</code>。<br>  4）<code>事务管理程序</code>：保证数据库中所有事务全部都能正确执行。</p></li><li><p><strong>用户访问数据库的过程</strong>（略）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，数据描述&quot;&gt;&lt;a href=&quot;#一，数据描述&quot; class=&quot;headerlink&quot; title=&quot;一，数据描述&quot;&gt;&lt;/a&gt;一，数据
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/database/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/db-theory/"/>
    
  </entry>
  
</feed>
