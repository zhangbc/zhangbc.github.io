<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天堂的鸽子</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangbc.github.io/"/>
  <updated>2019-04-11T14:20:11.713Z</updated>
  <id>https://zhangbc.github.io/</id>
  
  <author>
    <name>Bocheng Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java基础】Java进阶编程</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_advance_program/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_advance_program/</id>
    <published>2019-04-11T14:05:07.000Z</published>
    <updated>2019-04-11T14:20:11.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java数据结构"><a href="#1，Java数据结构" class="headerlink" title="1，Java数据结构"></a>1，Java数据结构</h2><p><code>Java</code>工具包提供了强大的数据结构，在<code>Java</code>中的数据结构主要包括以下接口和类：<code>枚举（Enumeration）</code>，<code>位集合（BitSet）</code>，<code>向量（Vector）</code>，<code>栈（Stack）</code>，<code>字典（Dictionary）</code>，<code>哈希表（Hashtable）</code>，<code>属性（Properties）</code>。</p><p>1）<strong>枚举（<code>Enumeration</code>）</strong>：该接口定义了一种从数据结构中取回连续元素的方式。</p><p>2）<strong>位集合（<code>BitSet</code>）</strong>：该类实现了一组可以单独设置和清除的位或标志。</p><p>3）<strong>向量（<code>Vector</code>）</strong>：对象的元素通过索引访问，在创建时不必给对象指定大小，其大小会根据需要动态的变化。</p><p>4）<strong>栈（<code>Stack</code>）</strong>：实现了一个后进先出的数据结构，是<code>Vector</code>的一个子类。</p><p>5）<strong>字典（<code>Dictionary</code>）</strong>：是一个抽象类，定义了键映射到值的数据结构。当想要通过特定的键而不是整数索引来访问数据时，应使用<code>Dictionary</code>。<br><strong><code>注意</code></strong>：<code>Dictionary</code>类已经过时了，在实际开发中，你可以实现<code>Map</code>接口来获取键/值的存储功能。</p><p>6）<strong>哈希表（<code>Hashtable</code>）</strong>：提供了一种在用户定义键结构的基础上来组织数据的手段。<code>Hashtable</code>是原始的<code>java.util</code>的一部分， 是一个<code>Dictionary</code>具体的实现 。</p><p>7）<strong>属性（<code>Properties</code>）</strong>：继承于 Hashtable.Properties 类表示了一个持久的属性集；属性列表中每个键及其对应值都是一个字符串。</p><h2 id="2，Java集合框架"><a href="#2，Java集合框架" class="headerlink" title="2，Java集合框架"></a>2，Java集合框架</h2><p>1）<strong>集合框架设计目标</strong></p><blockquote><p>（1）必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的；<br>（2）允许不同类型的集合，以类似的方式工作，具有高度的互操作性；<br>（3）对一个集合的扩展和适应必须是简单的。</p></blockquote><p>2）<strong>Java集合框架图</strong></p><p><img src="/images/java_advance_program_collection_20190411.png" alt="Java集合框架图"></p><p>3）<strong>集合框架是一个用来代表和操纵集合的统一架构</strong>，包含如下内容：</p><blockquote><p>（1）<code>接口</code>：是代表集合的抽象数据类型。例：<code>Collection</code>，<code>List</code>，<code>Set</code>，<code>Map</code>等。<br>（2）<code>实现（类）</code>：是集合接口的具体实现。从本质上，他们是可重复使用的数据结构，例：<code>ArrayList</code>，<code>LinkedList</code>，<code>HashSet</code>，<code>HashMap</code>。<br>（3）<code>算法</code>：是实现集合接口的对象里的方法执行的一些有用的计算，例：搜索和排序，这些算法被称为多态，因为相同的方法可以在相似的接口上有着不同的实现。</p></blockquote><p><img src="/images/java_advance_program_collection_members_20190411.png" alt="Java 集合框架构成"></p><p>集合框架的类和接口均在<code>java.util</code>包中。<br>任何对象加入集合类后，自动转变为<code>Object</code>类型，所以在取出的时候，需要进行强制类型转换。</p><p>4）<strong>集合接口</strong></p><ul><li><p><code>Set</code>和<code>List</code>的区别</p><blockquote><ul><li><code>Set</code> 接口实例存储的是无序的，不重复的数据。<code>List</code> 接口实例存储的是有序的，可以重复的元素。</li><li><code>Set</code> 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有<code>HashSet</code>,<code>TreeSet</code>&gt;。</li><li><code>List</code>和数组类似，可以动态增长，根据实际存储的数据的长度自动增长<code>List</code>的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有<code>ArrayList</code>,<code>LinkedList</code>,<code>Vector</code>&gt; 。</li></ul></blockquote><p>5）<strong>集合实现类（集合类）</strong>：<code>Java</code>提供了一套实现了<code>Collection</code>接口的标准集合类。</p><p>6）<strong>集合算法</strong>：集合定义了三个不可改变的静态变量：<code>EMPTY_SET</code>，<code>EMPTY_LIST</code>，<code>EMPTY_MAP</code>。<code>Collection Algorithms</code>是一个列表中的所有算法实现。</p><p>7）<strong>迭代</strong>：使用<code>Java Iterator</code>，通过实例列出<code>Iterator</code>和<code>listIterator</code>接口提供的所有方法。</p></li><li><p>ArrayListDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"Hello"</span>);</span><br><span class="line">        list.add(<span class="string">"World"</span>);</span><br><span class="line">        list.add(<span class="string">"Maven"</span>);</span><br><span class="line">        list.add(<span class="string">"Demo"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历1：使用foreach遍历List</span></span><br><span class="line">        System.out.println(<span class="string">"使用foreach遍历List:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String str: list) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历2：把链表变为数组相关的内容进行遍历List</span></span><br><span class="line">        String[] strArray = <span class="keyword">new</span> String[list.size()];</span><br><span class="line">        list.toArray(strArray);</span><br><span class="line">        System.out.println(<span class="string">"\n把链表变为数组相关的内容进行遍历List:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++) &#123;</span><br><span class="line">            System.out.print(strArray[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历3：使用迭代器进行相关遍历List</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        System.out.println(<span class="string">"\n使用迭代器进行相关遍历List:"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MapDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">        map.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">        map.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历1：通过Map.KeySet遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.KeySet遍历key与value："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key: map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + key + <span class="string">", value="</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历2：通过Map.entrySet使用iterator遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet使用iterator遍历key和value："</span>);</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + entry.getKey() + <span class="string">", value="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历3：推荐，通过Map.entrySet遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.entrySet遍历key和value:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry:</span><br><span class="line">             map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"key="</span> + entry.getKey() + <span class="string">", value="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 遍历4：通过Map.values()遍历</span></span><br><span class="line">        System.out.println(<span class="string">"通过Map.values()遍历所有的value，但不能遍历key："</span>);</span><br><span class="line">        <span class="keyword">for</span> (String val: map.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"value="</span> + val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>8）<strong>比较器</strong>：使用 <code>Java Comparator</code>，通过实例列出<code>Comparator</code>接口提供的所有方法。</p><h2 id="3，Java泛型"><a href="#3，Java泛型" class="headerlink" title="3，Java泛型"></a>3，Java泛型</h2><p>1）<strong>Java泛型（<code>generics</code>）</strong> 是<code>JDK5</code>中引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<code>泛型的本质</code>是参数化类型，即：所操作的数据类型被指定为一个参数。</p><p>2）<strong>定义泛型方法的规则</strong></p><blockquote><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<code>&lt;E&gt;</code>）。</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个<code>类型变量</code>，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（如<code>int</code>,<code>double</code>,<code>char</code>的等）。 </li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建不同类型的数组：Integer，Double和Character</span></span><br><span class="line">        Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Double[] doubleArray = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line">        Character[] charArray = &#123;<span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'0'</span>&#125;;</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"整型数组元素为："</span>);</span><br><span class="line">        printArray(intArray);</span><br><span class="line">        System.out.println(<span class="string">"双精度小数数组元素为："</span>);</span><br><span class="line">        printArray(doubleArray);</span><br><span class="line">        System.out.println(<span class="string">"字符型数组元素为："</span>);</span><br><span class="line">        printArray(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法printArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputArray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E element: inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）<strong>有界的类型参数</strong>：限制那些被允许传递到一个类型参数的类型种类范围。声明首先要列出类型参数的名称，后跟 <code>extends</code> 关键字，最后紧跟它的上界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型的有界类型参数实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxGenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%d,%d和%d中最大的数为%d.\n\n"</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, maximum(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"%.2f,%.2f和%.2f中最大的数为%.2f.\n\n"</span>,</span><br><span class="line">                <span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span>, maximum(<span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span>));</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"%s,%s和%s中最大的数为%s.\n\n"</span>,</span><br><span class="line">                <span class="string">"pear"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>,</span><br><span class="line">                maximum(<span class="string">"pear"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">maximum</span><span class="params">(T x, T y, T z)</span> </span>&#123;</span><br><span class="line">        T max = x;</span><br><span class="line">        <span class="keyword">if</span> (y.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = z;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）<strong>泛型类</strong>：在类名后面添加类型参数声明部分。泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个<code>类型变量</code>，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为<code>参数化的类</code>或<code>参数化的类型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">        integerBox.add(<span class="number">10</span>);</span><br><span class="line">        stringBox.add(<span class="string">"菜鸟教程"</span>);</span><br><span class="line">​</span><br><span class="line">        System.out.printf(<span class="string">"整型值为：%d\n"</span>, integerBox.get());</span><br><span class="line">        System.out.printf(<span class="string">"字符串为：%s\n"</span>, stringBox.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）<strong>类型通配符</strong>：一般使用<code>?</code>代替具体的类型参数。</p><blockquote><p>（1）类型通配符上限通过形如<code>List</code>来定义，如此定义就是通配符泛型值接受<code>Number</code>及其下层子类类型；<br>（2）类型通配符下限通过形如<code>List&lt;? super Number&gt;</code>来定义，表示类型只能接受<code>Number</code>及其三层父类类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类型通配符实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wildcard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">​</span><br><span class="line">        name.add(<span class="string">"icon"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line">​</span><br><span class="line">        getData(name);</span><br><span class="line">        getUpperNumber(age);</span><br><span class="line">        getUpperNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"data: %s\n"</span>, data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUpperNumber</span><span class="params">(List&lt;? extends Number&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"data: "</span> + data.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4，Java序列化"><a href="#4，Java序列化" class="headerlink" title="4，Java序列化"></a>4，Java序列化</h2><p>1）<strong>Java序列化</strong>：<code>Java</code>提供了一种对象序列化的机制，该机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据，有关对象的类型的信息和存储在对象中数据的类型。</p><blockquote><p>（1）序列化一个对象，并将它发送到输出流。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p><p>（2）从流中取出下一个对象，并将对象反序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException, ClassNotFundException</span></span><br></pre></td></tr></table></figure></p></blockquote><p>2）<strong>完整<code>demo</code>实例</strong>：</p><ul><li><p>Employee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> runoob;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Employee类实现Serializable接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/7 12:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mailing a check to "</span> + name + <span class="string">" "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SerializeDemo.java </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SerializeDemo类，序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.name = <span class="string">"Reyan Ali"</span>;</span><br><span class="line">        employee.address = <span class="string">"Phonkka kuan, Ambehta Peer."</span>;</span><br><span class="line">        employee.SSN = <span class="number">11122333</span>;</span><br><span class="line">        employee.number = <span class="number">101</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fileOut = <span class="keyword">new</span></span><br><span class="line">                    FileOutputStream(<span class="string">"employee.ser"</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">            out.writeObject(employee);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.println(<span class="string">"Serialized data is saved in employee.ser."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ul><li>DeserializeDemo.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DeserializeDemo类，反序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee employee;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.ser"</span>);</span><br><span class="line">            ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">            employee = (Employee) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Employee class not found."</span>);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Deserialize Employee..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Name: "</span> + employee.name);</span><br><span class="line">        System.out.println(<span class="string">"Address: "</span> + employee.address);</span><br><span class="line">        System.out.println(<span class="string">"SSN: "</span> + employee.SSN);</span><br><span class="line">        System.out.println(<span class="string">"Number: "</span> + employee.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java面向对象</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_object_oriented/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_object_oriented/</id>
    <published>2019-04-11T11:57:07.000Z</published>
    <updated>2019-04-11T12:07:56.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java-继承"><a href="#1，Java-继承" class="headerlink" title="1，Java 继承"></a>1，Java 继承</h2><p>1）<strong><code>Java</code>继承的概念</strong>：<code>继承</code>就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>2）<strong><code>Java</code>继承类型</strong>：Java不支持多继承，但是支持多重继承。<br><img src="/images/java_obj_oriented_extends_20190411.png" alt="Java继承"><br>3）<strong><code>Java</code>继承的特性</strong></p><blockquote><ul><li>子类拥有父类非 <code>private</code> 的属性、方法。</li><li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li><li><code>Java</code> 的继承是<code>单继承</code>，但是可以<code>多重继承</code>，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li><li>提高了类之间的<code>耦合性</code>（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li></ul></blockquote><p>4）<strong><code>Java</code>继承关键字</strong></p><p><code>继承</code>可以使用<code>extends</code>和<code>implements</code>这两个关键字来实现继承，都继承于<code>java.lang.Object</code>，默认继承<code>object</code>祖先类。</p><blockquote><p>（1）<code>extends</code>：只能继承一个类。<br>（2）<code>implements</code>：可以变相地使<code>java</code>具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口。<br>（3）<code>super</code>：通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。<br>（4）<code>this</code>：指向自己的引用。<br>（5）<code>finally</code>：声明类可以把类定义为不能继承的，即<code>最终类</code>；或用于修饰方法，该方法不能被子类重写。</p></blockquote><p> 5）<strong><code>Java</code>构造器</strong><br> 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <code>super</code> 关键字调用父类的构造器并配以适当的参数列表。</p><ul><li>ExtendsDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/3/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==========SubClassOne 类继承==========="</span>);</span><br><span class="line">        SubClassOne sc1 = <span class="keyword">new</span> SubClassOne();</span><br><span class="line">        SubClassOne sc2 = <span class="keyword">new</span> SubClassOne(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"==========SubClassTwo 类继承==========="</span>);</span><br><span class="line">        SubClassTwo sc3 = <span class="keyword">new</span> SubClassTwo();</span><br><span class="line">        SubClassTwo sc4 = <span class="keyword">new</span> SubClassTwo(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SuperClass 祖先类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SuperClass() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SuperClass(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass(int number)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SubClassOne 类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassOne</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SubClassOne() &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClassOne()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SubClassOne(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">300</span>);</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SubClassOne(int number): "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SubClassTwo 类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassTwo</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    SubClassTwo() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"SubClassTwo()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    SubClassTwo(<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        System.out.println(<span class="string">"SubClassTwo(int number): "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2，Java-Override-Overload"><a href="#2，Java-Override-Overload" class="headerlink" title="2，Java Override/Overload"></a>2，Java Override/Overload</h2><p>1）<strong>重写（<code>Override</code>）</strong><br><code>重写</code>是子类对父类对允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即<code>外壳不变，核心重写</code>。重写方法不能抛出新的检查异常或者比被重写方法声明更加宽泛的异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Animal类，祖先类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"动物可以移动..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnimalDog类，继承Animal，并重写父类的move()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalDog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">"狗可以跑和走."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal dog = <span class="keyword">new</span> AnimalDog();</span><br><span class="line">        animal.move();</span><br><span class="line">        dog.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）<strong>方法的重写规则</strong></p><blockquote><ul><li>参数列表必须完全与被重写方法的相同。</li><li>返回类型必须完全与被重写方法的返回类型相同。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为<code>final</code>的方法不能被重写。</li><li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul></blockquote><p>3）<strong><code>super</code></strong>：当需要在子类中调用父类的被重写方法时，要使用<code>super</code>关键字。</p><p>4）<strong>重载（<code>Overload</code>）</strong>：在一个类里面，方法名字相同，而参数不同，返回类型可同可不同。</p><p>5）<strong>重载规则</strong></p><blockquote><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载；</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul></blockquote><ul><li>OverLoading.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoading</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test()"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(int)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> number, String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(int, String)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test(int, String)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test(String,int)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test(String,int)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OverLoading overLoad = <span class="keyword">new</span> OverLoading();</span><br><span class="line">        System.out.println(overLoad.test());</span><br><span class="line">        overLoad.test(<span class="number">100</span>);</span><br><span class="line">        System.out.println(overLoad.test(<span class="number">100</span>, <span class="string">"test3"</span>));</span><br><span class="line">        System.out.println(overLoad.test(<span class="string">"test"</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>6）<strong><code>重写</code>和<code>重载</code>的区别</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">区别点</th><th style="text-align:left">重载方法</th><th style="text-align:left">重写方法</th></tr></thead><tbody><tr><td style="text-align:left">参数列表</td><td style="text-align:left">必须修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">返回类型</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能修改</td></tr><tr><td style="text-align:left">异常</td><td style="text-align:left">可以修改</td><td style="text-align:left">可以减少或删除，一定不能抛出新的或更广的异常</td></tr><tr><td style="text-align:left">访问</td><td style="text-align:left">可以修改</td><td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table></div><p>方法的重写(<code>Overriding</code>)和重载(<code>Overloading</code>)是<code>java</code>多态性的不同表现，<code>重写</code>是父类与子类之间多态性的一种表现，<code>重载</code>可以理解成多态的具体表现形式。</p><blockquote><ul><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为<code>方法的重载(Overloading)</code>。</li><li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为<code>重写(Overriding)</code>。</li><li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul></blockquote><h2 id="3，Java-多态"><a href="#3，Java-多态" class="headerlink" title="3，Java 多态"></a>3，Java 多态</h2><p><code>多态</code>是同一个行为具有多个不同表现形式或形态的能力。<strong>多态的好处</strong>：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><p>1）<strong>多态的优点</strong>：消除类型之间的耦合关系；可替换性；可扩充性；接口性；灵活性；简化性。</p><p>2）<strong>多态存在的三个必要条件</strong>：<code>继承</code>；<code>重写</code>；<code>父类引用指向子类对象</code>。</p><ul><li>PolymorphicDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot;</span><br><span class="line">​</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@function</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 张伯成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/3/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolymorphicDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        show(<span class="keyword">new</span> Cat());</span><br><span class="line">        show(<span class="keyword">new</span> Dog());</span><br><span class="line">​</span><br><span class="line">        Animals animal = <span class="keyword">new</span> Cat();</span><br><span class="line">        animal.eat();</span><br><span class="line">​</span><br><span class="line">        Cat cat = (Cat) animal;</span><br><span class="line">        cat.work();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animals animal)</span> </span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            Cat cat = (Cat) animal;</span><br><span class="line">            cat.work();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            Dog dog = (Dog) animal;</span><br><span class="line">            dog.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抓老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"看家"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3）<strong>虚函数</strong>：虚函数的存在是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。</p><p>4）<strong>多态的实现方式</strong>：<code>重写</code>；<code>接口</code>；<code>抽象类</code>和<code>抽象方法</code>。</p><h2 id="4，Java-抽象类"><a href="#4，Java-抽象类" class="headerlink" title="4，Java 抽象类"></a>4，Java 抽象类</h2><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p>1）<strong>抽象类</strong>：在Java语言中使用<code>abstract class</code>定义抽象类。</p><p>2）<strong>继承抽象类</strong></p><p>3）<strong>抽象方法</strong>：<code>abstract</code> 关键字可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体；抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><p>4）<strong>抽象类总结规定</strong></p><blockquote><p>（1）抽象类不能被实例化；只有抽象类的非抽象子类可以创建对象；<br>（2）抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；<br>（3）抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能；<br>（4）构造方法，类方法（用 <code>static</code> 修饰的方法）不能声明为抽象方法；<br>（5）抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></blockquote><h2 id="5，Java-封装"><a href="#5，Java-封装" class="headerlink" title="5，Java 封装"></a>5，Java 封装</h2><p>1）在面向对象程式设计方法中，<code>封装（Encapsulation）</code>是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的<code>接口</code>控制。</p><p><code>封装</code> <strong>最主要的功能</strong>在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>2）<strong>封装的优点</strong></p><blockquote><p>（1）两个的封装能够减少耦合；<br>（2）类内部的结构可以自由修改；<br>（3）可以对成员变量进行更精确的控制；<br>（4）隐藏信息，实现细节。</p></blockquote><h2 id="6，Java-接口"><a href="#6，Java-接口" class="headerlink" title="6，Java 接口"></a>6，Java 接口</h2><p>1）<strong>接口概念</strong><br>     <code>接口（Interface）</code>，在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p> 类描述对象的属性和方法。接口则包含类要实现的方法。</p><p> 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p> 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 <code>Java</code> 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p>2）<strong>接口与类相似点</strong></p><blockquote><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在<code>.java</code> 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 <code>.class</code> 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul></blockquote><p>3）<strong>接口与类的区别</strong></p><blockquote><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 <code>static</code> 和 <code>final</code> 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul></blockquote><p>4）<strong>接口特性</strong></p><blockquote><ul><li>接口是隐式的，接口中每一个方法也是隐式抽象的，接口中的方法会被隐式的指定为 <code>public abstract</code>。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <code>public static final</code> 变量。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li><li>接口的方法都是公有的。</li></ul></blockquote><p>5）<strong>抽象类和接口的区别</strong></p><blockquote><ul><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <code>public static final</code> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 <code>static</code> 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul></blockquote><p>6）<strong>接口的声明</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7）<strong>接口的实现</strong>：当类实现接口的时候，类要实现接口中所有的方法，否则，类必须声明为抽象的类；类使用<code>implements</code>关键字实现接口，在类声明中，<code>implements</code>关键字放在<code>class</code>声明后面。</p><p>（1）重写接口中声明的方法时，需要注意以下规则：</p><blockquote><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul></blockquote><p>（2）在实现接口的时候，需要注意以下规则：</p><blockquote><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul></blockquote><p>8）<strong>接口的继承</strong></p><p>9）<strong>接口的多继承</strong>：在<code>Java</code>中，类的多继承是不合法，但接口允许多继承；在接口的多继承中<code>extenfs</code>关键字只需要用一次，在其后跟着继承接口。</p><p>10）<strong>标记接口</strong><br>    <code>标记接口</code>是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。</p><p><code>标记接口</code>的<strong>作用</strong>：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p><code>标记接口</code>的<strong>主要目的</strong>：建立一个公共的父接口；向一个类添加数据类型。</p><h2 id="7，Java-包（Package）"><a href="#7，Java-包（Package）" class="headerlink" title="7，Java 包（Package）"></a>7，Java 包（Package）</h2><p> 1）<strong>包的作用</strong></p><blockquote><p>（1）把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。<br>（2）如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。<br>（3）包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p></blockquote><p> 总之，<code>Java</code> 使用包（<code>package</code>）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（<code>class</code>）、接口、枚举（<code>enumerations</code>）和注释（<code>annotation</code>）等。</p><p> 2）<strong>创建包</strong></p><p> 3）<strong><code>impor</code>t语句</strong>：为了能够使用某一个包的成员，需要在<code>Java</code>程序中明确导入该包。</p><p> 4）<strong><code>package</code>的目录结构</strong><br> 类目录的绝对路径叫做 <code>class path</code>。设置在系统变量 <code>CLASSPATH</code> 中。编译器和 <code>java</code> 虚拟机通过将 <code>package</code> 名字加到 <code>class path</code> 后来构造 <code>.class</code> 文件的路径。</p><p>5）<strong>设置<code>CLASSPATH</code>系统变量</strong></p><ul><li><p>用下面的命令显示当前的<code>CLASSPATH</code>变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Windows 平台（DOS 命令行下）</span><br><span class="line"><span class="meta">$</span> C:\&gt; set CLASSPATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> UNIX 平台（Bourne shell 下）</span><br><span class="line"><span class="meta">$</span> echo $CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>删除当前<code>CLASSPATH</code>变量内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Windows 平台（DOS 命令行下）</span><br><span class="line"><span class="meta">$</span> C:\&gt; set CLASSPATH=</span><br><span class="line"><span class="meta">#</span> UNIX 平台（Bourne shell 下）</span><br><span class="line"><span class="meta">$</span> unset CLASSPATH; export CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>设置<code>CLASSPATH</code>变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Windows 平台（DOS 命令行下）</span><br><span class="line"><span class="meta">$</span> C:\&gt; set CLASSPATH=C:\users\jack\java\classes</span><br><span class="line"><span class="meta">#</span> UNIX 平台（Bourne shell 下）</span><br><span class="line"><span class="meta">$</span> CLASSPATH=/home/jack/java/classes; export CLASSPATH</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java基础知识</title>
    <link href="https://zhangbc.github.io/2019/04/11/java_basic_knowledge/"/>
    <id>https://zhangbc.github.io/2019/04/11/java_basic_knowledge/</id>
    <published>2019-04-10T16:39:20.000Z</published>
    <updated>2019-04-10T17:10:49.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，Java基本数据类型"><a href="#1，Java基本数据类型" class="headerlink" title="1，Java基本数据类型"></a>1，Java基本数据类型</h2><p><code>变量</code>就是申请内存来存储值。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p><p>Java有两大数据类型：<code>内置数据类型</code>和<code>引用数据类型</code>。</p><p>1）<strong>内置数据类型</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th><th style="text-align:center">取值范围</th><th style="text-align:center">默认值</th><th style="text-align:center">主要用途</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">- $2^7$ ~ $2^7$ -1</td><td style="text-align:center">0</td><td style="text-align:center">在大型数组中节约空间，代替整数</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">-$2^{15}$~$2^{15}$-1</td><td style="text-align:center">0</td><td style="text-align:center">节省空间</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">-$2^{31}$~$2^{31}$-1</td><td style="text-align:center">0</td><td style="text-align:center">整型变量的默认类型</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64位，有符号的，以二进制补码表示的整数</td><td style="text-align:center">-$2^{63}$~$2^{63}$-1</td><td style="text-align:center">0L</td><td style="text-align:center">使用在需要比较大整数的系统上</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">单精度、32位、符合IEEE 754标准的浮点数</td><td style="text-align:center">-$2^{31}$~$2^{31}$-1</td><td style="text-align:center">0.0f</td><td style="text-align:center">在存储大型浮点数组时可以节省空间；不能用来表示精确的值</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">双精度、64位、符合IEEE 754标准的浮点数</td><td style="text-align:center">-$2^{63}$~$2^{63}$-1</td><td style="text-align:center">0.0d</td><td style="text-align:center">浮点数变量的默认类型</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">表示一位的信息</td><td style="text-align:center">true,false</td><td style="text-align:center">false</td><td style="text-align:center">作为一种标记来记录true/false情况</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">单一的 16 位 Unicode 字符</td><td style="text-align:center">\u0000<code>~</code>\uffff(0~$2^{16}$-1)</td><td style="text-align:center"></td><td style="text-align:center">存储任何字符</td></tr></tbody></table></div><p>2）<strong>引用类型</strong></p><blockquote><ul><li>在Java中，引用类型的变量非常类似于<code>C/C++</code>的<code>指针</code>。引用类型指向一个对象，指向对象的变量是引用变量。</li><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是<code>null</code>。</li><li>一个引用变量可以用来引用与任何与之兼容的类型。</li></ul></blockquote><p>3）<strong>Java常量</strong>：常量在程序运行时，不会被修改，关键字<code>final</code>。通常使用<code>大写字母</code>表示常量。</p><p>4）<strong>Java类型转换</strong></p><blockquote><ul><li><code>自动类型转换</code>：转换从低级到高级。<blockquote><ul><li>数据类型转换满足的<code>原则</code>：<br>（1）不能对boolean类型进行类型转换；<br>（2）不能把对象类型转换成不相关类的对象；<br>（3）在把容量大的类型转换为容量小的类型时必须使用强制类型转换；<br>（4）转换过程中可能导致溢出或损失精度；<br>（5）浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。</li></ul></blockquote></li><li><code>强制类型转换</code>：条件是转换的数据类型必须是兼容的。</li><li><code>隐含强制类型转换</code></li></ul></blockquote><h2 id="2，Java语句类型"><a href="#2，Java语句类型" class="headerlink" title="2，Java语句类型"></a>2，Java语句类型</h2><p>1）<strong>循环结构</strong></p><blockquote><ul><li><code>while</code></li><li><code>do...while</code></li><li><code>for</code></li><li><code>foreach</code></li><li><code>增强型for循环</code>：主要用于数组</li><li>demo：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> x : numbers )&#123;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">      String [] names =&#123;<span class="string">"James"</span>, <span class="string">"Larry"</span>, <span class="string">"Tom"</span>, <span class="string">"Lacy"</span>&#125;;</span><br><span class="line">      # 增强型for循环</span><br><span class="line">      <span class="keyword">for</span>( String name : names ) &#123;</span><br><span class="line">         System.out.print( name );</span><br><span class="line">         System.out.print(<span class="string">","</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>2）<strong><code>break</code>语句</strong>：主要用于循环语句或者switch语句中；跳出最里层的循环，并且继续执行该循环下面的语句。</p><p>3）<strong><code>continue</code>语句</strong>：适用于任何循环控制结构中，作用是让程序立刻跳转到下一次循环的迭代。</p><p>4）<strong>分支结构</strong></p><blockquote><ul><li><code>if</code>：一个<code>if语句</code>包含一个布尔表达式和一条或多条语句。</li><li><code>switch case</code>语句：判断一个变量与一系列值中某个值是否相等，每个值称为一个<code>分支</code>。</li></ul></blockquote><h2 id="3，Java基础类"><a href="#3，Java基础类" class="headerlink" title="3，Java基础类"></a>3，Java基础类</h2><p>1）<strong>Number &amp; Math类</strong><br><img src="/images/java_basic_knowledge_number_20190411.png" alt="Number &amp; Math类"></p><p>2）<strong>Math类</strong>：包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><p>3）<strong>Character类</strong>：对单个字符进行操作。<br> 将一个<code>char</code>类型的参数传递给需要一个<code>Character</code>类型参数的方法时，那么编译器会自动地将<code>char</code>类型参数转换为<code>Character</code>对象。 这种特征称为<code>装箱</code>，反过来称为<code>拆箱</code>。</p><p>4）<strong>String类</strong><br>        用于获取有关对象的信息的方法称为<code>访问器方法</code>。</p><p>5）<strong>StringBuffer和StringBuilder类</strong></p><blockquote><ul><li>和<code>String</code>类不同的是，<code>StringBuffer</code>和<code>StringBuilder</code>类的对象能够被多次的修改，并且不产生新的未使用对象。</li><li><code>StringBuilder</code>类在<code>Java 5</code>中被提出，它和<code>StringBuffer</code>之间的<strong>最大不同</strong>在于 <code>StringBuilder</code>的方法不是线程安全的（不能同步访问）。</li><li>由于<code>StringBuilder</code>相较于<code>StringBuffer</code>有速度优势，所以多数情况下建议使用 <code>StringBuilder</code>类。</li><li>在应用程序要求线程安全的情况下，则必须使用 <code>StringBuffer</code>类。</li></ul></blockquote><h2 id="4，Java数组"><a href="#4，Java数组" class="headerlink" title="4，Java数组"></a>4，Java数组</h2><p>1）<strong>声明数组</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"> # or</span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure></p><p> 2）<strong>创建数组</strong><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure></p><p>3）<strong>多维数组</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type[][] typeName = <span class="keyword">new</span> type[typeLength1][typeLength2];   <span class="comment">// 直接为每一维分配空间</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 从最高维开始，分别为每一维分配空间</span></span><br><span class="line">String s[][] = <span class="keyword">new</span> String[<span class="number">2</span>][];</span><br><span class="line">s[<span class="number">0</span>] = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">s[<span class="number">1</span>] = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">s[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">new</span> String(<span class="string">"Good"</span>);</span><br><span class="line">s[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">new</span> String(<span class="string">"Luck"</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">new</span> String(<span class="string">"to"</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">new</span> String(<span class="string">"you"</span>);</span><br><span class="line">s[<span class="number">1</span>][<span class="number">2</span>] = <span class="keyword">new</span> String(<span class="string">"!"</span>);</span><br></pre></td></tr></table></figure></p><p>4）<strong>Arrays类</strong><br><code>java.util.Arrays</code> 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能：</p><blockquote><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法，按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul></blockquote><h2 id="5，Java日期时间"><a href="#5，Java日期时间" class="headerlink" title="5，Java日期时间"></a>5，Java日期时间</h2><p><code>java.util</code>包提供了<code>Date</code>类来封装当前的日期和时间。 <code>Date</code>类提供两个构造函数来实例化 <code>Date</code> 对象。<br>第一个构造函数使用当前日期和时间来初始化对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date( )</span><br></pre></td></tr></table></figure></p><p>第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date(<span class="keyword">long</span> millisec)</span><br></pre></td></tr></table></figure></p><p>1）<strong>获取当前日期时间</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       Date date = <span class="keyword">new</span> Date();</span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）<strong>日期比较</strong></p><blockquote><ul><li><code>getTime()</code>：获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li><li><code>before()</code>, <code>after()</code>, <code>equals()</code></li><li><code>compareTo()</code>：由<code>Comparable</code>接口定义的，<code>Date</code>类实现了这个接口。</li></ul></blockquote><p>3）<strong>格式化日期时间</strong></p><ul><li><code>SimpleDataFormat</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间为："</span>+ft.format(now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>printf</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//c的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"全部日期和时间信息：%tc%n"</span>, now);</span><br><span class="line">        <span class="comment">//f的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"年-月-日格式：%tF%n"</span>, now);</span><br><span class="line">        <span class="comment">//d的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"月/日/年格式：%tD%n"</span>, now);</span><br><span class="line">        <span class="comment">//r的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"HH:MM:SS PM格式（12时制）：%tr%n"</span>, now);</span><br><span class="line">        <span class="comment">//t的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"HH:MM:SS格式（24时制）：%tT%n"</span>, now);</span><br><span class="line">        <span class="comment">//R的使用</span></span><br><span class="line">        System.out.printf(<span class="string">"HH:MM格式（24时制）：%tR"</span>, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>4）<strong>Java休眠（<code>Sleep</code>）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">"\n"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date()+<span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Got an exception: "</span>+ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5）<strong><code>Calendar</code>类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个代表系统当前日期的Calendar对象</span></span><br><span class="line">        Calendar now = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> year = now.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> month = now.get(Calendar.MONTH);</span><br><span class="line">        <span class="keyword">int</span> day = now.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> date = now.get(Calendar.DATE);</span><br><span class="line">        <span class="keyword">int</span> hour = now.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">        <span class="keyword">int</span> minute = now.get(Calendar.MINUTE);</span><br><span class="line">        <span class="keyword">int</span> second = now.get(Calendar.SECOND);</span><br><span class="line">​</span><br><span class="line">        System.out.println(now.getTime());</span><br><span class="line">        System.out.printf(<span class="string">"%d-%d-%d %d:%d:%d\n%d\n"</span>,</span><br><span class="line">                year, month, day, hour, minute, second, date);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 创建一个表示2009年3月12日的Calendar对象</span></span><br><span class="line">        now.set(<span class="number">2009</span>, <span class="number">3</span>-<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(now.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6）<strong><code>GregorianCalendar</code>类</strong>：实现了公历日历，是<code>Calendar</code>类的一个具体实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GregorianCalendar gCalender = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">        <span class="keyword">int</span> year = gCalender.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">if</span> (gCalender.isLeapYear(year)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前年份是闰年！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前年份不是闰年！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6，正则表达式"><a href="#6，正则表达式" class="headerlink" title="6，正则表达式"></a>6，正则表达式</h2><p>1） <strong><code>java.util.regex</code>包</strong>主要包括以下三个类：</p><blockquote><ul><li><code>Pattern</code>类：是一个正则表达式的编译表示。<code>Pattern</code>类没有公共构造方法。要创建一个<code>Pattern</code>对象，你必须首先调用其公共静态编译方法，它返回一个<code>Pattern</code> 对象。该方法接受一个正则表达式作为它的第一个参数。</li><li><code>Matcher</code>类：是对输入字符串进行解释和匹配操作的引擎。</li><li><code>PatternSyntaxException</code>：是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">"I am a student, graduated from HuBei University."</span>;</span><br><span class="line">        String pattern = <span class="string">".*HuBei.*"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMath = Pattern.matches(pattern, content);</span><br><span class="line">        System.out.println(<span class="string">"字符串是否包含类'HuBei'子字符串？"</span>+isMath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）<strong>捕获组</strong><br><code>捕获组</code>是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。<br><code>特殊的组（group(0)）</code>，它总是代表整个表达式。该组不包括在 groupCount 的返回值中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">"I am a student, graduated from HuBei University in 2013. "</span>;</span><br><span class="line">        String pattern = <span class="string">"(\\D*)(\\d+)(.*)"</span>;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 创建Pattern对象</span></span><br><span class="line">        Pattern rex = Pattern.compile(pattern);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 创建matcher对象</span></span><br><span class="line">        Matcher matcher = rex.matcher(content);</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">"Found value: "</span> + matcher.group(<span class="number">3</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No match!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7，Java方法"><a href="#7，Java方法" class="headerlink" title="7，Java方法"></a>7，Java方法</h2><p>1）<strong><code>Java方法</code>定义</strong>：Java方法是语句的集合，他们在一起执行一个功能。</p><blockquote><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul></blockquote><p> 2）<strong><code>Java方法</code>的优点</strong></p><blockquote><ul><li>使程序变得更简短而清晰</li><li>有利于程序维护</li><li>可以提高程序开发的效率</li><li>提高了代码的重用性</li></ul></blockquote><p>3）<strong><code>Java方法</code>的命名规则</strong></p><blockquote><ul><li>必须以<code>字母</code>、<code>&#39;_&#39;</code>或<code>&#39;＄&#39;</code>开头（方法名第一个单词应以小写字母开头，后面的单词则用大写字母开头写，不使用连接符）；</li><li>可以包括数字，但不能以它开头；</li><li>下划线可能出现在<code>JUnit</code>测试方法名称中用以分隔名称的逻辑组件。</li></ul></blockquote><p>4）<strong><code>Java方法</code>的定义</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5）<strong><code>Java方法</code>调用</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> max = getMax(i, j);</span><br><span class="line">        System.out.printf(<span class="string">"%d和%d比较，最大值是：%d."</span>, i, j, max);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">            result = num1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6）<strong><code>void</code>关键字</strong></p><p>7）<strong><code>Java方法重载</code></strong>：一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p><p>8）<strong>变量作用域</strong></p><p>9）<strong>命令行参数</strong>：<code>命令行参数</code>是在执行程序时候紧跟在程序名字后面的信息。</p><p>10）<strong>构造方法</strong>：当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p><p>11）<strong>可变参数</strong>：<code>JDK1.5</code>开始，<code>Java</code>支持传递同类型的可变参数给一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName... parameterName</span><br></pre></td></tr></table></figure></p><ul><li>在方法声明中，在指定参数类型后加一个省略号(<code>...</code>) 。</li><li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">double</span> max = getMax(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.printf(<span class="string">"...numbers中，最大值是：%.2f."</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMax</span><span class="params">(<span class="keyword">double</span>... numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"No argument passed."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">10000000000L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">double</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> <span class="keyword">var</span>: numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">var</span> &gt; result) &#123;</span><br><span class="line">                result = <span class="keyword">var</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>12）<strong><code>finalize()</code>方法</strong>：在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。</p><ul><li><strong><code>Java 的内存回收可以由 JVM 来自动完成。</code></strong></li><li>FinalizationDemo.java如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cake c1 = <span class="keyword">new</span> Cake(<span class="number">1</span>);</span><br><span class="line">        Cake c2 = <span class="keyword">new</span> Cake(<span class="number">2</span>);</span><br><span class="line">        Cake c3 = <span class="keyword">new</span> Cake(<span class="number">3</span>);</span><br><span class="line">​</span><br><span class="line">        c2 = c3 = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 调用Java垃圾回收集器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cake</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        System.out.println(<span class="string">"Cake Object "</span> + id + <span class="string">" is created."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"Cake object "</span> + id + <span class="string">" is disposed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="8，Java流（Stream），文件（File）和IO"><a href="#8，Java流（Stream），文件（File）和IO" class="headerlink" title="8，Java流（Stream），文件（File）和IO"></a>8，Java流（Stream），文件（File）和IO</h2><p><code>Java.io</code>包几乎包含了所有操作输入、输出需要的类。<br>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>1）<strong>读取控制台输入</strong>：<code>Java</code>的控制台输入由<code>System.in</code>完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br></pre></td></tr></table></figure></p><p>2）<strong>从控制台读取多字符输入</strong>：从<code>BufferedReader</code>对象读取一个字符要使用 <code>read()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p><ul><li>BRReadLine.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRReadLine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.println(<span class="string">"输入字符，按下'q'键退出."</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ch = (<span class="keyword">char</span>) br.read();</span><br><span class="line">            System.out.println(ch);</span><br><span class="line">        &#125; <span class="keyword">while</span> (ch != <span class="string">'q'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3）<strong>从控制台读取字符串</strong>：从 标准输入读取一个字符要使用<code>BufferedReader</code>的 <code>readLine()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></p><ul><li>BRReadLines.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BRReadLines</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String str;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        System.out.println(<span class="string">"Enter lines of text;"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Enter 'end' to quit."</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            str = br.readLine();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!str.equals(<span class="string">"end"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>4）<strong>控制台输出</strong>：控制台的输出由 <code>print()</code> 和 <code>println()</code> 完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        num = <span class="string">'A'</span>;</span><br><span class="line">        System.out.write(num);</span><br><span class="line">        System.out.write(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5）<strong>读写文件</strong>：一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。<br><img src="/images/java_basic_knowledge_io_20190411.png" alt="IO流"></p><p>6）<strong><code>FileInputStream</code></strong>：该流用于从文件读取数据，它的对象可以用关键字<code>new</code>来创建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把给定的context以二进制写进文件，同时输出控制台</span></span><br><span class="line"><span class="comment"> * 但是存在乱码问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bWrite = &#123;<span class="string">'a'</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">54</span>&#125;;</span><br><span class="line">            OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"file_test.txt"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> <span class="keyword">var</span>: bWrite) &#123;</span><br><span class="line">                os.write(<span class="keyword">var</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            os.close();</span><br><span class="line">​</span><br><span class="line">            InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"file_test.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> size = is.available();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) is.read() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"File InputStream error: "</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7）<strong><code>FileOutputStream</code></strong>：该流用来创建一个文件并向文件中写数据，它的对象可以用关键字 <code>new</code> 来创建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把给定的context以二进制写进文件，同时输出控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIOStreamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"file_test.txt"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 构建FileOutputStream对象，文件不存在会自动新建</span></span><br><span class="line">        FileOutputStream fop = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 构建对象，参数可以指定编码，默认为操作系统默认编码，windows是gbk</span></span><br><span class="line">        OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(fop, <span class="string">"UTF-8"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 写入到缓冲区</span></span><br><span class="line">        writer.append(<span class="string">"中文输入"</span>);</span><br><span class="line">        writer.append(<span class="string">"\r\n"</span>);</span><br><span class="line">        writer.append(<span class="string">"English input"</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 关闭写入流，同时会把缓冲区的内容写入文件</span></span><br><span class="line">        writer.close();</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 关闭输出流，释放系统资源</span></span><br><span class="line">        fop.close();</span><br><span class="line">​</span><br><span class="line">        FileInputStream fip = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(fip, <span class="string">"UTF-8"</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (reader.ready()) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) reader.read());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        reader.close();</span><br><span class="line">        fip.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>关于文件和<code>I/O</code>的一些其他类：<code>File Class</code>；<code>FileReader Class</code>；<code>FileWriter Class</code>。</li></ul><h2 id="9，Java中的目录"><a href="#9，Java中的目录" class="headerlink" title="9，Java中的目录"></a>9，Java中的目录</h2><p>1）<strong>创建目录</strong><br><code>File</code>类中有两个方法可以用来创建文件夹：</p><blockquote><ul><li><code>mkdir( )</code>方法创建一个文件夹，成功则返回<code>true</code>，失败则返回<code>false</code>。</li><li><code>mkdirs()</code>方法创建一个文件夹和它的所有父文件夹。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String dirName = <span class="string">"/home/share/java"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(dirName);</span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）<strong>读取目录</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String dirName = <span class="string">"/home/share"</span>;</span><br><span class="line">        File fp = <span class="keyword">new</span> File(dirName);</span><br><span class="line">        <span class="keyword">if</span> (fp.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"目录："</span> + dirName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 提取包含的文件和文件夹的列表</span></span><br><span class="line">            String[] strings = fp.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">                File tmp = <span class="keyword">new</span> File(dirName + <span class="string">"/"</span> + strings[i]);</span><br><span class="line">                <span class="keyword">if</span> (tmp.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(strings[i] + <span class="string">"  是一个目录."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(strings[i] + <span class="string">"  是一个文件."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirName + <span class="string">"  不是一个目录."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）<strong>删除目录或文件</strong>：删除文件可以使用<code>java.io.File.delete()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDir</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File folder = <span class="keyword">new</span> File(<span class="string">"/home/share/java"</span>);</span><br><span class="line">        deleteFolder(folder);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 删除文件及目录</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(File folder)</span> </span>&#123;</span><br><span class="line">        File[] files = folder.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File fp: files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fp.isDirectory()) &#123;</span><br><span class="line">                    deleteFolder(fp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    fp.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        folder.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="10，Java-Scanner类"><a href="#10，Java-Scanner类" class="headerlink" title="10，Java Scanner类"></a>10，Java Scanner类</h2><p><code>java.util.Scanner</code> 是 <code>Java5</code> 的新特征，我们可以通过 <code>Scanner</code> 类来获取用户的输入。基本语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure></p><p>1）<strong>使用<code>next</code>方法</strong></p><blockquote><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，<code>next()</code> 方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li><code>next()</code>不能得到带有空格的字符串。</li></ul></blockquote><ul><li>ScannerNext.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerNext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"Next方式接收："</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext()) &#123;</span><br><span class="line">            String str = scan.next();</span><br><span class="line">            System.out.println(<span class="string">"输入的数据为："</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2）<strong>使用<code>nextLine</code>方法</strong></p><blockquote><ul><li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul></blockquote><ul><li>ScannerNextLines.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerNextLines</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"NextLine方式接收："</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextLine()) &#123;</span><br><span class="line">            String str = scan.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"输入的数据为："</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：如果要输入 <code>int</code> 或 <code>float</code> 类型的数据，在 <code>Scanner</code> 类中也有支持，但是在输入之前最好先使用 <code>hasNextXxx()</code> 方法进行验证，再使用 <code>nextXxx()</code> 来读取。</p><ul><li>ScannerNumbers.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannerNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">int</span> numberI;</span><br><span class="line">        <span class="keyword">float</span> numberF;</span><br><span class="line">        <span class="keyword">double</span> numberD;</span><br><span class="line">        System.out.println(<span class="string">"输入整数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextInt()) &#123;</span><br><span class="line">            numberI = scan.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"整数是："</span> + numberI);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是整数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"输入浮点数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextFloat()) &#123;</span><br><span class="line">            numberF = scan.nextFloat();</span><br><span class="line">            System.out.println(<span class="string">"浮点数是："</span> + numberF);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是浮点数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        System.out.println(<span class="string">"输入双精度小数："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextDouble()) &#123;</span><br><span class="line">            numberD = scan.nextDouble();</span><br><span class="line">            System.out.println(<span class="string">"双精度小数是："</span> + numberD);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是双精度小数！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11，Java异常处理"><a href="#11，Java异常处理" class="headerlink" title="11，Java异常处理"></a>11，Java异常处理</h2><p>1）<strong>理解<code>Java</code>异常处理是如何工作的，需掌握以下三种类型的异常</strong>：</p><blockquote><ul><li><code>检查性异常</code>：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。</li><li><code>运行时异常</code>： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li><code>错误</code>： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。</li></ul></blockquote><p>2）<strong><code>Exception</code> 类的层次</strong></p><blockquote><ul><li>所有的异常类是从 <code>java.lang.Exception</code> 类继承的子类。</li><li><code>Exception</code> 类是 <code>Throwable</code> 类的子类。除了<code>Exception</code>类外，<code>Throwable</code> 类还有一个子类<code>Error</code> 。</li><li><code>Error</code> 用来指示运行时环境发生的错误。例如，<code>JVM</code> 内存溢出。一般地，程序不会从错误中恢复。</li><li>异常类有两个主要的子类：<code>IOException</code> 类和 <code>RuntimeException</code> 类。</li><li>在 Java 内置类中，有大部分常用<code>检查性</code>和<code>非检查性</code>异常。<br><img src="/images/java_basic_knowledge_ex_20190411.jpg" alt="JavaException"></li></ul></blockquote><p>3）<strong>Java内置类</strong><br>4）<strong>异常方法</strong>：主要是<code>Throwable</code>的方法。<br>5）<strong>捕获异常</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"Access elements three: "</span> + array[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception: "</span> + ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Out of the block."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6）<strong>多重捕获块</strong>：一个 <code>try</code> 代码块后面跟随多个 <code>catch</code> 代码块的情况就叫<code>多重捕获</code>。</p><p>7）<strong><code>throws/throw</code>关键字</strong>：如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法签名的尾部。</p><p>8）<strong><code>finally</code>关键字</strong>：<code>finally</code> 关键字用来创建在 <code>try</code> 代码块后面执行的代码块；无论是否发生异常，finally 代码块中的代码总会被执行；在 <code>finally</code>  代码块中，可以运行清理类型等收尾善后性质的语句。</p><ul><li>ExceptionDemo.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Access elements three: "</span> + array[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception throw: "</span> + ex.toString());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            array[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">            System.out.println(<span class="string">"First element value: "</span> + array[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(<span class="string">"The finally statement is executed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>9）<strong>声明自定义异常</strong></p><blockquote><ul><li>所有异常都必须是 Throwable 的子类。</li><li>如写一个检查性异常类，则需要继承 Exception 类。</li><li>如写一个运行时异常类，那么需要继承 RuntimeException 类。    </li></ul></blockquote><p><em>综合实例</em></p><ul><li><p>InsufficientFundException.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常，继承Exception类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsufficientFundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsufficientFundException</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CheckingAccount.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行账户基本操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckingAccount</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 取钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InsufficientFundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt;= balance) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> needs = amount - balance;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundException(needs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 返回余额</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">// 返回账号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BankDemo.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 模拟银行账户基本操作实例</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CheckingAccount account = <span class="keyword">new</span> CheckingAccount(<span class="number">6228481</span>);</span><br><span class="line">        System.out.println(<span class="string">"Deposit $500..."</span>);</span><br><span class="line">        account.deposit(<span class="number">500.00</span>);</span><br><span class="line">​</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Withdrawing $100..."</span>);</span><br><span class="line">            account.withdraw(<span class="number">100</span>);</span><br><span class="line">​</span><br><span class="line">            System.out.println(<span class="string">"Withdrawing $600..."</span>);</span><br><span class="line">            account.withdraw(<span class="number">600</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InsufficientFundException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry, but you are short $"</span>+ex.getAmount());</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>10）<strong>通用异常</strong><br>在Java中定义了两种类型的异常和错误：</p><blockquote><ul><li><strong><code>JVM</code>(Java虚拟机) 异常</strong>：由 <code>JVM</code> 抛出的异常或错误。例如：<code>NullPointerException</code> 类，<code>ArrayIndexOutOfBoundsException</code> 类，<code>ClassCastException</code> 类。</li><li><strong>程序级异常</strong>：由程序或者API程序抛出的异常。例如 <code>IllegalArgumentException</code> 类，<code>IllegalStateException</code> 类。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】关系数据库</title>
    <link href="https://zhangbc.github.io/2019/04/10/db_rdb/"/>
    <id>https://zhangbc.github.io/2019/04/10/db_rdb/</id>
    <published>2019-04-10T13:22:51.000Z</published>
    <updated>2019-04-10T16:13:32.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，关系模型的基本概念"><a href="#一，关系模型的基本概念" class="headerlink" title="一，关系模型的基本概念"></a>一，关系模型的基本概念</h2><ol><li><p><strong>关系及基本术语</strong></p><blockquote><ul><li>在关系模型中，表格的第一行称为<code>关系框架</code>，是属性$A_1$，$A_2$，$A_3$，$\dots$，$A_k$的<code>有限集合</code>。</li><li>表中的每行称为关系的一个<code>元组</code>；每列称为<code>属性</code>，它在某个值域上的取值，不同的属性可以在相同的值域上取值。</li><li>关系中的属性个数称为<code>元数</code>（<code>Arity</code>），元组个数称为<code>基数</code>。</li></ul></blockquote></li><li><p><strong>关键字</strong></p><blockquote><ul><li><code>超关键字</code>(<code>Super Key</code>)：在关系中能够唯一标识元组的属性集合。</li><li><code>候选关键字</code>(<code>Candidate Key</code>)：如果某一属性集合是<code>超关键字</code>，但去掉其中任意属性后就不再是超关键字，这样的属性称为<code>候选关键字</code>。<blockquote><ul><li><code>候选关键字</code>的诸属性称为<code>主属性</code>，不包含在任何候选关键字中的属性称为<code>非主属性</code>（<code>非码属性</code>）。</li></ul></blockquote></li><li><code>主关键字</code>(<code>Primary Key</code>)：如果关系中存在多个<code>候选关键字</code>，用户可选作元组标识的一个<code>候选关键字</code>为<code>主关键字</code>。</li><li><code>合成关键字</code>(<code>Composite Key</code>)：当某个候选关键字包含多个属性时，该候选关键字称为<code>合成关键字</code>。</li><li><code>外部关键字</code>(<code>Foreign Key</code>)：如果关系R的某个（些）属性K不是R中的候选关键字，而是另一个关系S的候选关键字，则K称为R的<code>外部关键字</code>。</li></ul></blockquote></li></ol><h2 id="二，关系模式"><a href="#二，关系模式" class="headerlink" title="二，关系模式"></a>二，关系模式</h2><ol><li><p>在关系数据库中，关系模式是<code>型</code>，关系是<code>值</code>。</p></li><li><p>【<strong><code>定义3-1</code></strong>】关系的描述称为关系模式，形式化表示为<br>$R(U, D, DOM, I, F)$<br>其中，$R$为<code>关系名</code>，$U$为组成该关系的<code>属性名集合</code>，$D$是$U$中属性的<code>域</code>，$DOM$为属性到域的<code>映像集合</code>，$I$为<code>完整性约束集合</code>，$F$为属性间数据的<code>依赖关系集合</code>。</p></li></ol><p><strong>⚠️</strong>关系模式中带有下画线的属性集为<code>主关键字</code>。</p><h2 id="三，关系模型的完整性"><a href="#三，关系模型的完整性" class="headerlink" title="三，关系模型的完整性"></a>三，关系模型的完整性</h2><ol><li><p><code>域完整性约束</code>：主要规定属性值必须取自值域，一个属性能否为空值由其语义决定。</p></li><li><p><code>实体完整性约束</code>：规定基本关系的所有主属性都不能取空值，而不仅是主属性整体不能取空值。</p></li><li><p><code>参照完整性约束</code>：要求“不引用不存在的实体”，考虑的是不同关系之间的或同一关系的不同元组之间的制约。形式定义：</p><p> 如果属性集K是关系R的<code>主关键字</code>，K也是关系S的<code>外关键字</code>，那么在关系S中，K的取值只允许两种可能，要么为空值，要么等于关系R中某个主关键字的值。关系R称为<code>“参照关系”模式</code>，关系S称为<code>“依赖关系”模式</code>。</p></li><li><p><code>用户自定义完整性约束</code>：针对某个具体关系数据库的约束条件。</p></li></ol><h2 id="四，关系代数"><a href="#四，关系代数" class="headerlink" title="四，关系代数"></a>四，关系代数</h2><ol><li><p><strong>关系查询语言分类</strong></p><blockquote><ul><li><code>关系代数语言</code>：查询操作是以<code>集合操作</code>为基础运算的<code>DML</code>语言。</li><li><code>关系演算语言</code>：查询操作是以<code>谓词演算</code>为基础运算的<code>DML</code>语言。</li></ul></blockquote></li><li><p><strong>关系代数的五种基本操作</strong></p><p><code>相等</code>定义：设有同类关系$r_1$和$r_2$，若$r_1$的任何一个元组都是$r_2$的一个元组，则称关系$r_2$包含关系$r1$，记作$r_1$ $\subseteq$ $r_2$或 $r_2$ $\supseteq$ $r_1$，如果$r_1$ $\subseteq$ $r_2$且$r_1$ $\supseteq$ $r_2$，则称关系$r_1$等于关系$r_2$，记作$r_1$=$r_2$。</p></li></ol><p>【<strong><code>定义3-2</code></strong>】<strong><code>并</code>(<code>Union</code>)</strong>：设有同类关系$r_1$[R]和$r_2$[R]，两者的<code>并</code>(<code>Union</code>)运算定义 $r_1$ $\bigcup$ $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\vee$ $t$ $\in$ $r_2$ }<br>式中，$\bigcup$为并运算符。$r_1$ $\bigcup$ $r_2$的结果关系是$r_1$的所有元组与$r_2$的所有元组的并集（去掉重复元组）。</p><p>【<strong><code>定义3-3</code></strong>】<strong><code>差</code>(<code>Difference</code>)</strong>：设有同类关系$r_1$[R]和$r_2$[R]，两者的<code>差</code>(<code>Difference</code>)运算定义为  $r_1$ - $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\wedge$ $t$ $\notin$ $r_2$ }<br>式中，- 为相减运算符。$r_1$ - $r_2$的结果关系是$r_1$的所有元组减去$r_1$与$r_2$相同的元组所剩下的元组的集合。</p><p>【<strong><code>定义3-4</code></strong>】<strong><code>笛卡儿积</code>(<code>Difference</code>)</strong>：设$r$[R]为$k_1$元关系，$s$[S]为$k_2$元关系，两者的<code>笛卡儿积</code>(<code>Difference</code>)运算定义为 $r$ $\times$ $s$ = { $t$ $\mid$ $t$ = &lt;$u,v$&gt; $\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $s$ }。</p><p>【<strong><code>定义3-5</code></strong>】<strong><code>投影</code>(<code>Projection</code>)</strong>：是对一个关系进行垂直分割，消去某些列，并重新安排列的顺序的操作。<br>设有$r$[R]为$k$元关系，其关系框架R={$A_1$,$A_2$,$\dots$,$A_k$}，$A_{j_1}$，$A_{j_2}$，$\dots$，$A_{j_n}$ 为R中互不相同的属性，那么关系$r$在属性（分量）$A_{j_1}$，$A_{j_2}$，$\dots$，$A_{j_n}$ 上的投影运算定义为 $\Pi$ $A_{j_1}$,$A_{j_2}$,$\dots$,$A_{j_n}$ $($ $r$ $)$ = { $u$ $\mid$ $u$ = &lt; $t$ [$A_{j_1}$],$t$[$A_{j_2}$],$\dots$,$t$[$A_{j_n}$] &gt; $\wedge$ $t$ $\in$ $r$ }<br>式中，$\Pi$为投影运算符。</p><p>【<strong><code>定义3-6</code></strong>】<strong><code>选择</code>(<code>Selection</code>)</strong>：根据某些条件对关系进行水平分割，即选取符合条件的元组的操作。条件可用命题公式F表示，由<code>运算对象</code>和<code>运算符</code>组成：</p><blockquote><ul><li><code>运算对象</code>：常数（用引号括起来）、元组分量（属性名或列的序号）</li><li><code>运算符</code>：算术比较运算符（$\lt$,$\le$,$\gt$,$\ge$,=,$\ne$，也称$\theta$符），逻辑运算符（$\vee$,$\wedge$,$\neg$）</li></ul></blockquote><p>关系R关于公式F的选择操作用$\sigma$F$($R$)$表示，其定义为：<br>$\sigma$F $($ R $)$ $\equiv$ { $t$ $\mid$ $t$ $\in$ R $\wedge$ F($t$)=true}<br>式中，$\sigma$为选择运算符。$\sigma$F$($R$)$表示从R中挑选满足公式F为真的元组所构成的关系。</p><ol><li><strong>关系代数的其他操作</strong></li></ol><p>【<strong><code>定义3-7</code></strong>】<strong><code>交</code>(<code>Intersection</code>)</strong>：设有同类关系$r_1$[R]和$r_2$[R]，两者的<code>交</code>(<code>Intersection</code>)运算定义 $r_1$ $\bigcap$ $r_2$ = { $t$ $\mid$ $t$ $\in$ $r_1$ $\wedge$ $t$ $\in$ $r_2$}<br>式中，$\bigcap$为交运算符。$r_1<script type="math/tex">\bigcap</script>r_2$的结果关系是$r_1$与$r_2$的所有相同元组构成的集合，显然，$r_1<script type="math/tex">\bigcap</script>r_2$ 等于$r_1$ - ($r_1$ - $r_2$ )或者$r_2$ - ($r_2$ - $r_1$ )。</p><p>【<strong><code>定义3-8</code></strong>】$\theta$<strong><code>-连接</code></strong>：设$r$[R]、$s$[S]关系框架分别为R = {$A_1$,$A_2$,$\dots$,$A_n$} 和 {$B_1$,$B_2$,$\dots$,$B_m$}，那么关系$r$和$s$的$\theta$<strong><code>-连接</code></strong>（$\theta$-Join）运算定义为：<br>$r$ $\Join$ $s$ = { $t$ $\mid$ $t$ = &lt; $u, v$ &gt;$\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $u$[$A_i$]$\theta$ $v$[$B_j$]}</p><p>【<strong><code>定义3-9</code></strong>】<strong><code>F-连接</code></strong> ：设$r$[R]、$s$[S]关系框架分别为R = { $A_1$,$A_2$,$\dots$,$A_n$ }，{ $B_1$,$B_2$,$\dots$,$B_m$ }，F($A_1$,$A_2$,$\dots$,$A_n$,$B_1$,$B_2$,$\dots$,$B_m$)为一公式，那么关系$r$和$s$的<strong>F-连接</strong>（<code>F-Join</code>）运算定义为：<br>$r$ $\Join$ $s$ = { $t$ $\mid$ $t$ = &lt; $u, v$&gt;$\wedge$ $u$ $\in$ $r$ $\wedge$ $v$ $\in$ $s$ $\wedge$F($u$[$A_1$],$\dots$,$u$[$A_n$]),$u$[$B_1$],$\dots$,$u$[$B_m$]) }<br>即：$r$ $\Join$ $s$ = $\sigma$F $(r$ $\times$ $s)$</p><p>【<strong><code>定义3-10</code></strong>】<strong><code>自然连接</code></strong>：    <code>Natural Jion</code>是一种特殊的等值连接，它要求关系R和关系S具有相同的属性组B($b_1$,$b_2$,$b_3$,$\dots$ $\dots$)，这些属性组的取值是相等的，在最后生成的关系中去掉属性重复的列。其计算过程如下：</p><blockquote><p>(1)计算$r$ $\times$ $s$；<br>(2)设$r$和$s$的公共属性是$A_1$,$A_2$,$\dots$,$A_m$，选出$r$ $\times$ $s$中满足$r.A_1$=$s.A_1$,$r.A_2$=$s.A_2$, $\dots$, $r.A_m$=$s.A_m$的那些元组；<br>(3)去掉$s.A_1$,$s.A_2$,$\dots$,$s.A_m$这些列。</p></blockquote><p>【<strong><code>定义3-11</code></strong>】<strong><code>除</code>(<code>Division</code>)</strong>：给定关系$r$(X,Y)和$s$(Y,Z)，其中，X，Y，Z为属性组，$r$中的Y与$s$中的Y可以有不同的属性名，但必须出自相同的域集。R与S的<code>除</code>(<code>Division</code>)运算得到一个新的关系$p$(X)，$p$是r中满足下列条件的元组在X属性列上的投影，即元组在X上的分量值$x$的像集$Y_x$包含s在Y上投影的集合，记为<br>$r$ $\div$ $s$ = { $t_r$[X]$\mid$ $t_r$ $\in$ $r$ $\wedge$ $\pi_y$($s$) $\subseteq$ $Y_x$ }<br>式中，$Y_x$为$x$在$r$中的像集，$x$=$t_r$[X]。</p><h2 id="五，关系演算"><a href="#五，关系演算" class="headerlink" title="五，关系演算"></a>五，关系演算</h2><p>关系演算是以<code>数理逻辑</code>中的<code>谓词</code>为基础的，按<code>谓词变元</code>的不同，关系演算可以分为<code>元组关系演算</code>和<code>域关系演算</code>。</p><ol><li><p><strong>元组关系演算</strong>：以<code>元组</code>为变量。<br>1） 在元组关系演算中，元组关系演算表达式的一般形式为：<br>$\{t|P(t)\}$<br>式中，t是元组变量，表示一个元数确定的元组，P是满足一定逻辑条件的公式，公式可以分解为一些原子公式，$\{t|P(t)\}$表示满足公式P的所有元组$t$的集合。<br>2）在一个演算公式中，未用存在量词$\exists$或全称量词$\forall$符号定义的元组变量，称为<code>自由元组变量</code>，否则称为<code>约束元组变量</code>。</p></li><li><p><strong>域关系演算</strong>：以<code>属性(域)</code>为变量，简称<code>域演算</code>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，关系模型的基本概念&quot;&gt;&lt;a href=&quot;#一，关系模型的基本概念&quot; class=&quot;headerlink&quot; title=&quot;一，关系模型
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】Java入门知识</title>
    <link href="https://zhangbc.github.io/2019/04/08/java_introductory_knowledge/"/>
    <id>https://zhangbc.github.io/2019/04/08/java_introductory_knowledge/</id>
    <published>2019-04-08T15:52:05.000Z</published>
    <updated>2019-04-10T16:56:20.703Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>【学习参考资料】：<a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">菜鸟教程-Java教程</a></p></blockquote><h2 id="1，java简介"><a href="#1，java简介" class="headerlink" title="1，java简介"></a>1，java简介</h2><p>   Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。</p><p>   1）<strong>Java分为三个体系</strong>：</p><blockquote><ul><li>JavaSE(J2SE)Java2 Platform Standard Edition，java平台标准版）</li><li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li><li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)</li></ul></blockquote><p>   2）<strong>Java的主要特性</strong>：</p><blockquote><ul><li>java语言是简单的；</li><li>java语言是面向对象的（纯面向对象）；</li><li>java语言的分布式的；</li><li>java语言是健壮的（丢弃指针，强类型机制，异常处理，垃圾的自动收集）；</li><li>java语言是安全的（安全防范机制（类ClassLoader），安全管理机制（类SecurityManager））；</li><li>java语言是可移植的；</li><li>java语言是解释型的；</li><li>java是高性能的；</li><li>java语言多线程的；</li><li>java语言是动态的。</li></ul></blockquote><p>   3）<strong>Java的发展史</strong>：诞生于1995年；2014年3月18日，Oracle公司发表Java SE8。</p><p>   4）<strong>Java工具</strong>：Java语言尽量保证系统内存在1G以上。</p><h2 id="2，Java开发环境配置"><a href="#2，Java开发环境配置" class="headerlink" title="2，Java开发环境配置"></a>2，Java开发环境配置</h2><p>1）下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener"><strong>JDK工具</strong></a>解压安装，对应不同的系统选择适合的版本。</p><p>2）<strong>变量设置参数</strong>如下：</p><blockquote><ul><li>变量名：<code>JAVA_HOME</code></li><li>变量值：<code>C:\Program Files (x86)\Java\jdk1.8.0_91</code>        <strong>// 要根据自己的实际路径配置</strong></li><li>变量名：<code>CLASSPATH</code></li><li>变量值：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code>   <strong>//记得前面有个”<code>.</code>“</strong></li><li>变量名：<code>Path</code></li><li>变量值：<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code></li></ul></blockquote><p>3）<strong>测试JDK是否安装成功</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ java -version  # 输出java安装的版本</span><br><span class="line">~ javac -version # 输出javac安装的版本</span><br></pre></td></tr></table></figure></p><p><strong><code>注意</code></strong>：如果使用1.5以上版本的JDK，不用设置CLASSPATH环境变量，也可以正常编译和运行Java程序。</p><p>4）<strong>Java开发工具选择</strong></p><ul><li><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a></li><li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a>(推荐)</li></ul><h2 id="3，Java基础语法"><a href="#3，Java基础语法" class="headerlink" title="3，Java基础语法"></a>3，Java基础语法</h2><p>1）<strong>相关概念</strong><br>   <strong><code>类</code></strong>：类是一个模板，描述一个对象的行为和状态。<br>    java中的<code>类</code>：  </p><blockquote><ul><li><code>局部变量</code>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><code>成员变量</code>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><code>类变量</code>：类变量也声明在类中，方法体之外，但必须声明为<code>static</code>类型。</li><li><code>构造方法</code>：每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。 </li></ul></blockquote><p>   创建对象：在<code>Java</code>中，使用关键字<code>new</code>创建一个新的对象，主要有三步：<code>声明</code>，<code>实例化（new）</code>，<code>初始化</code>。<br>   <code>对象</code>：对象是一个类的实例，有状态和行为。<br>   在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。<br>    <code>方法</code>：方法即行为，一个类可以有很多方法。<br>    <code>实例变量</code>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p><p>2）<strong>编程注意点</strong></p><blockquote><ul><li>大小写敏感</li><li>类名每个单词的首字母大写（帕斯卡命名法）</li><li>方法名以小写字母开头，之后每个单词首字母大写（驼峰命名法）</li><li>源文件名必须和类名相同</li><li>主方法入口，所有的<code>Java</code>程序由<code>public static void main(String []args)</code>方法开始执行</li></ul></blockquote><p>3）<strong>Java标识符</strong></p><p><code>标识符</code>：类名，变量名及方法名都称为<code>标识符</code>。</p><blockquote><ul><li>所有的<code>标识符</code>都应该以字母（<code>A-Z</code>或者<code>a-z</code>）,美元符（<code>$</code>）、或者下划线（<code>_</code>）开始；</li><li>首字符之后可以是字母（<code>A-Z</code>或者<code>a-z</code>）,美元符（<code>$</code>）、下划线（<code>_</code>）或数字的任何字符组合；</li><li><code>关键字</code>不能用作标识符；</li><li><code>标识符</code>是大小写敏感的；</li><li>合法标识符举例：<code>age</code>、<code>$salary</code>、<code>_value</code>、<code>__1_value</code>；</li><li>非法标识符举例：<code>123abc</code>、<code>-salary</code>；</li></ul></blockquote><p>4）<strong>Java修饰符</strong></p><p>（1）访问控制： <code>default</code>, <code>public</code>, <code>protected</code>, <code>private</code> </p><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">同一包内</th><th style="text-align:center">子孙类（同一包）</th><th style="text-align:center">子孙类（不同包）</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y /N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table></div><p><strong><code>protected</code>说明</strong>：</p><blockquote><ul><li>子类与基类在同一包中：被声明为<code>protected</code>的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的<code>protected</code>方法。</li></ul></blockquote><p>（2）访问控制和继承，注意以下原则：</p><blockquote><ul><li>父类中声明为<code>public</code>的方法在子类中也必须为<code>public</code>。</li><li>父类中声明为<code>protected</code>的方法在子类中要么声明为<code>protected</code>，要么声明为 <code>public</code>，不能声明为<code>private</code>。</li><li>父类中声明为<code>private</code>的方法，不能够被继承。                </li></ul></blockquote><p>（3）非访问控制：<code>final</code>, <code>abstract</code>,<code>static</code>, <code>synchronized</code>,<code>volatile</code></p><blockquote><ul><li><code>static</code>：创建类方法和类变量；</li><li><code>final</code>：修饰类，方法和变量。修饰的类不可被继承；修饰的方法不能被继承的类重新定义；修饰的变量为常量，不可修改。</li><li><code>abstract</code>：创建抽象类和抽象方法；</li><li><code>synchronized</code>：用于线程编程，synchronized声明的方法同一时间只能被一个线程访问；</li><li><code>transient</code>：序列化的对象包含被 <code>transient</code>修饰的实例变量时，<code>Java</code>虚拟机(<code>JVM</code>)跳过该特定的变量；该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</li><li><code>volatile</code>：用于线程编程， 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值，当成员变量发生变化时，会强制线程将变化值回写到共享内</li></ul></blockquote><p>5）<strong>Java变量</strong></p><p><code>局部变量</code>：类的方法中的变量。</p><blockquote><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在<code>栈</code>上分配的。</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul></blockquote><p><code>类变量（静态变量）</code>：独立于方法之外的变量，用<code>static</code>修饰。<br><code>成员变量（非静态变量）</code>：独立于方法之外的变量，不用<code>static</code>修饰。</p><p>6）<strong>Java数组</strong>：储存在堆上的对象，可以保存多个同类型变量。</p><p>7）<strong>Java枚举</strong>：Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。</p><p>8）<strong>Java关键字</strong>：参见<a href="http://www.runoob.com/java/java-basic-syntax.html" target="_blank" rel="noopener">Java关键字列表</a></p><p>9）<strong>Java注释</strong></p><p>10）<strong>Java空行</strong>：空白行，或者有注释的行，Java编译器都会忽略掉。</p><p>11）<strong>Java继承</strong><br>在Java中，一个类可以由其他类派生。被继承的类称为<code>超类</code>（<code>super class</code>），派生类称为<code>子类</code>（<code>subclass</code>）。</p><p>12）<strong>Java接口</strong>：在Java中，接口可以理解为对象间相互通信的协议。</p><p>13）<strong>源文件声明规则</strong></p><blockquote><ul><li>一个源文件中只能有一个public类</li><li>一个源文件可以有多个非public类</li><li>源文件的名称应该和public类的类名保持一致</li><li>如果一个类定义在某个包中，那么package语句应该在源文件的首行</li><li>如果源文件包含import语句，那么应该放在package语句和类定义之间；如果没有package语句，那么import语句应该在源文件中最前面。</li><li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul></blockquote><p>14）<strong>Java包</strong>：包主要用来对类和接口进行分类。</p><p>15）<strong>Import语句</strong></p><p>16）<strong>Java运算符</strong></p><blockquote><ul><li>算术运算符</li><li>关系运算符</li><li>位运算符：Java定义类位运算符，应用于整数类型（int），长整型（long），短整型（short），字符型（char）和字节型（byte）等类型。</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符（instanceof，自增，自减，条件运算符）</li></ul></blockquote><p>17）<strong>Java 源程序与编译型运行区别</strong><br><img src="/images/java_intrductory_knowledge_20190408.png" alt="Java 源程序与编译型运行区别"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;【学习参考资料】：&lt;a href=&quot;http://www.runoob.com/java/java-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟教程-Java教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="Java" scheme="https://zhangbc.github.io/categories/Java/"/>
    
    
      <category term="Java基础" scheme="https://zhangbc.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【数据库实战】SQL Server数据库常用脚本</title>
    <link href="https://zhangbc.github.io/2019/04/07/sql_used_script/"/>
    <id>https://zhangbc.github.io/2019/04/07/sql_used_script/</id>
    <published>2019-04-07T08:40:27.000Z</published>
    <updated>2019-04-09T13:11:32.517Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1，创建链接远程服务器及其删除"><a href="#1，创建链接远程服务器及其删除" class="headerlink" title="1，创建链接远程服务器及其删除"></a>1，创建链接远程服务器及其删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec sp_addlinkedserver  'web','','SQLOLEDB','192.168.10.106'</span><br><span class="line">exec sp_addlinkedsrvlogin 'web','false',null,'sa','123'</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除链接服务器</span></span><br><span class="line">exec sp_dropserver 'web','droplogins'</span><br></pre></td></tr></table></figure><h4 id="2，重置SQLSERVER表的自增列，让自增列重新计数"><a href="#2，重置SQLSERVER表的自增列，让自增列重新计数" class="headerlink" title="2，重置SQLSERVER表的自增列，让自增列重新计数"></a>2，重置SQLSERVER表的自增列，让自增列重新计数</h4><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DBCC CHECKIDENT</span><br><span class="line">(</span><br><span class="line">  table_name</span><br><span class="line">  [, &#123; NORESEED | &#123; RESEED [,new_reseed_value ] &#125; &#125; ]</span><br><span class="line"> )</span><br><span class="line"> [ WITH NO_INFOMSGS ]</span><br></pre></td></tr></table></figure></p><blockquote><p>参数：</p><blockquote><ul><li>table_name:是要对其当前标识值进行检查的表名。指定的表必须包含标识列。表名必须符合标识符规则。</li><li>NORESEED:指定不应更改当前标识值。</li><li>RESEED:指定应该更改当前标识值。</li><li>new_reseed_value:用作标识列的当前值的新值。</li><li>WITH NO_INFOMSGS:取消显示所有信息性消息。</li></ul></blockquote></blockquote><p>查看某表当前的种子值，示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbcc checkident('mainTable',noreseed);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-------------显示如下--------------</span><br><span class="line">--检查标识信息: 当前标识值 &apos;2707&apos;，当前列值 &apos;2707&apos;。</span><br><span class="line">--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。</span><br></pre></td></tr></table></figure><p>重置表mainTable的当前标识值为1，示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbcc checkident('mainTable',reseed,1);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-------------显示如下--------------</span><br><span class="line">--检查标识信息: 当前标识值 &apos;NULL&apos;，当前列值 &apos;1&apos;。</span><br><span class="line">--DBCC 执行完毕。如果 DBCC 输出了错误信息，请与系统管理员联系。</span><br></pre></td></tr></table></figure><h4 id="3，几个有用的存储过程"><a href="#3，几个有用的存储过程" class="headerlink" title="3，几个有用的存储过程"></a>3，几个有用的存储过程</h4><ul><li><p>修改xx表中所有值null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment">   功能：修改xx表中所有列为NULL=''</span></span><br><span class="line"><span class="comment">   作者：by zhangbc</span></span><br><span class="line"><span class="comment">   时间：2015-10-19</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line">if (OBJECT_ID('modifyNull','P') is not null)</span><br><span class="line">     <span class="keyword">drop</span> <span class="keyword">procedure</span> modifyNull</span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> modifyNull(@<span class="keyword">table</span> <span class="built_in">char</span>(<span class="number">100</span>))</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">--定义游标</span></span><br><span class="line">    <span class="keyword">declare</span> col_cur <span class="keyword">cursor</span> <span class="keyword">scroll</span> dynamic <span class="comment">--scroll表示可以向前或向后移动    dynamic：表示可写也可读</span></span><br><span class="line"> <span class="keyword">for</span></span><br><span class="line"> <span class="keyword">select</span> b.name <span class="keyword">from</span> sysobjects a</span><br><span class="line">  <span class="keyword">inner</span> <span class="keyword">join</span> syscolumns b <span class="keyword">on</span> a.id=b.id</span><br><span class="line">  <span class="keyword">where</span> a.name=@<span class="keyword">table</span></span><br><span class="line">    <span class="comment">--打开游标</span></span><br><span class="line">    <span class="keyword">open</span> col_cur</span><br><span class="line"> <span class="keyword">declare</span> @columnName <span class="keyword">nvarchar</span>(<span class="number">100</span>)</span><br><span class="line"> <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> col_cur <span class="keyword">into</span> @columnName</span><br><span class="line"> <span class="keyword">declare</span> @<span class="keyword">sql</span> <span class="keyword">nvarchar</span>(<span class="number">1000</span>)</span><br><span class="line"> <span class="keyword">while</span> (@@FETCH_STATUS=<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">set</span> @<span class="keyword">sql</span>=<span class="string">'update '</span> + @<span class="keyword">table</span> + <span class="string">' set '</span> + @columnName + <span class="string">' = ISNULL('</span> + @columnName + <span class="string">', '''')'</span></span><br><span class="line">   exec(@<span class="keyword">sql</span>)</span><br><span class="line">   <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> col_cur <span class="keyword">into</span> @columnName</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> <span class="comment">--关闭游标</span></span><br><span class="line"> <span class="keyword">close</span> col_cur</span><br><span class="line"> <span class="comment">--释放游标</span></span><br><span class="line"> <span class="keyword">deallocate</span> col_cur</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>修改数据库中所有表的所有列为null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************</span></span><br><span class="line"><span class="comment">   功能：修改数据库中所有表的所有列为NULL=''</span></span><br><span class="line"><span class="comment">   作者：by zhangbc</span></span><br><span class="line"><span class="comment">   时间：2015-10-19</span></span><br><span class="line"><span class="comment">*************************/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> [dbo].[modifyAllNull]</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> tab_cur <span class="keyword">cursor</span> <span class="keyword">scroll</span> dynamic <span class="comment">--scroll表示可以向前或向后移动    dynamic：表示可写也可读</span></span><br><span class="line"> <span class="keyword">for</span></span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> sysobjects <span class="keyword">where</span> xtype=<span class="string">'U'</span></span><br><span class="line">    <span class="comment">--打开游标</span></span><br><span class="line">    <span class="keyword">open</span> tab_cur</span><br><span class="line"> <span class="keyword">declare</span> @tableName <span class="keyword">nvarchar</span>(<span class="number">100</span>)</span><br><span class="line"> <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> tab_cur <span class="keyword">into</span> @tableName</span><br><span class="line"> <span class="keyword">declare</span> @<span class="keyword">sql</span> <span class="keyword">nvarchar</span>(<span class="number">1000</span>)</span><br><span class="line"> <span class="keyword">while</span> (@@FETCH_STATUS=<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">set</span> @<span class="keyword">sql</span>=<span class="string">'exec dbo.modifyNull '</span> +<span class="string">''''</span> + @tableName + <span class="string">''''</span></span><br><span class="line">   exec(@<span class="keyword">sql</span>)</span><br><span class="line">   <span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> tab_cur <span class="keyword">into</span> @tableName</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> <span class="comment">--关闭游标</span></span><br><span class="line"> <span class="keyword">close</span> tab_cur</span><br><span class="line"> <span class="comment">--释放游标</span></span><br><span class="line"> <span class="keyword">deallocate</span> tab_cur</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1，创建链接远程服务器及其删除&quot;&gt;&lt;a href=&quot;#1，创建链接远程服务器及其删除&quot; class=&quot;headerlink&quot; title=&quot;1，创建链接远程服务器及其删除&quot;&gt;&lt;/a&gt;1，创建链接远程服务器及其删除&lt;/h4&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库实战" scheme="https://zhangbc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】绪论</title>
    <link href="https://zhangbc.github.io/2019/04/06/db_introduction/"/>
    <id>https://zhangbc.github.io/2019/04/06/db_introduction/</id>
    <published>2019-04-06T10:42:18.000Z</published>
    <updated>2019-04-10T16:56:20.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。<br><img src="/images/db_introduction_20190406.png" alt="数据库系统与应用"></p></blockquote><h2 id="一，数据库的概念"><a href="#一，数据库的概念" class="headerlink" title="一，数据库的概念"></a>一，数据库的概念</h2><ol><li><strong>数据库定义</strong>：<code>数据库（DB）</code>是长期保存在计算机的存储设备上并按照某种模型组织起来的，可以被各种用户或应用共享的数据集合。</li><li><strong>数据库分类</strong>：<code>关系数据库</code>，<code>层次数据库</code>，<code>网状数据库</code>.</li><li><strong>数据库基本特征</strong>：<br>1）具有较高的数据独立性；<code>数据独立性</code>是指数据的组织方法和储存方法与应用程序互不依赖，彼此独立的特性，包括<code>物理独立性</code>和<code>逻辑独立性</code>。<br>2）数据库用综合的方法组织数据，保证尽可能高的访问效率；<br>3）具有较小的数据冗余，可以供多个用户共享；<br>4）具有安全控制机制，能够保证数据的安全，可靠；<br>5）数据允许多用户共享，能够有效，及时地处理数据，并能够保证数据的一致性和完整性。</li></ol><h2 id="二，数据库管理系统（DBMS）"><a href="#二，数据库管理系统（DBMS）" class="headerlink" title="二，数据库管理系统（DBMS）"></a>二，数据库管理系统（<code>DBMS</code>）</h2><ol><li><p><strong>DBMS的定义</strong>：<code>DBMS</code>是位于用户与操作系统之间的<code>数据管理软件</code>，数据库在建立，运用和维护时由数据库管理系统统一管理，控制。</p></li><li><p><strong>DBMS的目标</strong>：<br> 1）用户界面友好；<br> 2）功能完备；<br> 3）效率高，DBMS应该具有较高的系统效率和高的用户生产率，其中系统效率包括：</p><blockquote><p>（1）<strong>计算机内部资源的利用率</strong>，即能够充分利用磁盘空间，CPU，设备等资源，并注意使各种资源的负载均衡以提高整个系统的效率；<br>（2）<strong>DBMS本身的运行效率</strong>，根据系统目标确定恰当的体系结构，数据结构和算法，保证DBMS运行的高效率；<code>用户生产率</code>是指用户设计和开发应用程序的效率；</p></blockquote><p> 4）结构清晰：DBMS内部结构清新，层次分明既便于支持其外层开发环境的构造，也便于自身的设计、开发与维护；<br> 5）开放性：DBMS的开放性是指符合标准和规范，如<code>ODBC标准</code>，<code>SQL标准</code>等。</p></li><li><p><strong>DBMS的基本功能</strong>：</p><p>1）数据库定义功能：<code>DDL</code>可以定义数据库中数据之间的联系，可以定义数据的完整性约束条件和保证完整性的触发机制等，包括全局逻辑数据结构（模式）的定义，局部逻辑数据结构（外模式）的定义，保密定义等；<br>2）数据库操纵功能：<code>DML</code>可以接收，分析和执行用户提出的访问数据库的各种要求，完成对数据库的各种基本操作，如对数据库的检索，插入，删除和修改等操作，可以重新组织数据的存储结构，可以完成数据库的备份和恢复等操作；<br>3）数据库的控制功能：<code>DCL</code>包括整个数据库系统的运行控制，数据库的完整性控制，数据库的安全性控制及多用户环境下的数据库并发访问控制等；<br>4）数据库的运行管理功能：指<code>DBMS</code>运行机制和管理功能；<br>5）数据库组织和存储管理功能<br>6）数据库的建立和维护功能<br>7）数据库通信功能</p></li><li><p><strong>DBMS的组成</strong>：</p><p> 1）数据库定义语言及其翻译程序：</p></li></ol><blockquote><p> <code>DDL</code>用于描述数据库中要存储的现实世界实体的语言，包括数据字典中数据库的逻辑结构，完整性约束，物理存储结构的表述，数据库的各种数据操作和数据库的维护管理的各种依据。包括：</p><blockquote><p> <code>模式DDL</code>：定义全局逻辑数据结构(包括所有字段的名称，特征及其相互关系)，数据的完整性，安全性约束；<br><code>外模式DDL</code>：为用户定义所用的局部逻辑数据结构(包括与用户的应用程序有关的字段名称，特征及其相互关系)，描述外模式到模式之间的映射关系；<br><code>内模式DDL</code>：用于描述数据在存储介质上的安排和存放方式，描述模式到内模式之间的映射关系；</p></blockquote></blockquote><p>   2）数据库操纵语言及其编译（或解释）程序：</p><blockquote><p><code>DML</code>用于实现对数据库的一些基本操作，如数据检索，数据插入，数据修改和数据删除，其中数据插入，数据修改和数据删除操作又称为<code>数据更新操作</code>。分为：</p><blockquote><p><code>宿主型DML</code>：本身不能独立使用，必须嵌入到宿主语言中，如<code>C</code>，<code>COLBOL</code>，<code>PASCAL</code>等，因此也称<code>嵌入型DML</code>，仅负责对数据库数据的操纵，其他工作都由宿主语言完成；<br><code>自主型DML</code>，又称<code>自含型DML</code>，可以独立进行数据查询，数据更新等操作，语法简单，使用方便，适合终端用户使用；</p></blockquote></blockquote><p>   3）数据库运行控制程序：包括系统初启程序(<code>DBMS</code>的<code>神经中枢</code>)，访问控制程序，安全性控制程序，完整性检查程序，并发控制程序，数据存取/更新程序，通信控制程序；<br>   4）数据库服务实用程序：包括数据装入程序，工作日志程序，性能监督程序，数据库重新组织程序，系统恢复程序，转储/编辑/打印程序。</p><ol><li><p><strong>数据库管理与数据库管理员(<code>DBA</code>)</strong>：</p><p>   1）<code>DBA</code>：从事数据库管理工作的人员，不是数据库的“占有者”，而是数据库的“保护者”。<br>   2)  <code>DBA</code>职责</p><blockquote><ul><li>在数据库设计开始之前，<code>DBA</code>首先调查数据库的用户需求。</li><li>在数据库设计阶段，<code>DBA</code>要负责数据库标准的制定和功用数据字典的研制，要负责各级数据库模式的设计，负责数据库安全，可靠方面的设计，决定文件组织的方法。</li><li>在数据库运行阶段，<code>DBA</code>要负责对用户进行数据库方面的培训，负责数据库的转储和恢复，数据维护，用户的使用权限等，负责监控数据库的性能。</li></ul></blockquote></li></ol><h2 id="三，数据库系统（DBS）"><a href="#三，数据库系统（DBS）" class="headerlink" title="三，数据库系统（DBS）"></a>三，数据库系统（<code>DBS</code>）</h2><ol><li><strong>DBS定义</strong>：指在计算机系统中引入数据库后的系统构成，一般由<code>数据库</code>，<code>数据库系统运行环境</code>，<code>数据库管理系统及其开发工具</code>，<code>数据库管理员</code>和<code>用户</code>组成。</li><li><p><strong>数据库系统的三级模式结构</strong>：<br> 1）<strong>模式定义</strong>：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，而不涉及具体的值。<br> 2）三级模式结构：</p><blockquote><ul><li><code>外模式</code>：也称<code>子模式</code>或者<code>用户模式</code>，是数据库用户看见和使用的局部数据的逻辑结构和特征的描述，是数据库的用户视图，是和某个应用相关的数据逻辑表示；一个数据库可以有多个外模式；</li><li><code>模式</code>：也称<code>逻辑模式</code>，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共视图，是数据库的整个逻辑描述，并说明一个数据库所采用的数据模型；一个数据库只有一个模式；</li><li><code>内模式</code>：也称<code>存储模式</code>，是数据物理结构和存储方式的描述，是数据库的内部表示方式；一个数据库只有一个内模式。</li></ul></blockquote></li><li><p><strong>二级映像功能和数据独立性</strong>：<br>  1）<strong>外模式/模式映像</strong>：当模式改变时，<code>DBA</code>对各个外模式/模式的映像做出相应改变，使外模式保持不变，从而使应用程序不改变，保证了<code>数据的逻辑独立性</code>；<br>  2）<strong>模式/内模式映像</strong>：唯一定义了数据全局逻辑结构和存储方式之间的对应关系。当数据库的存储方式改变时，<code>DBA</code>将对模式/内模式映像做出相应的改变，使模式保持不变，从而保证了<code>数据的物理独立性</code>。</p></li><li><p><strong>数据库系统的体系结构</strong>：<br> 1）<code>单用户结构</code>的数据库系统：最早最简单，不能共享数据；<br> 2）<code>主从式结构</code>的数据库系统：结构简单，数据易于维护维护和管理，但系统的可靠性不高；<br> 3）<code>分布式结构</code>的数据库系统：数据在逻辑上上一个整体，但是分布在计算机网络的不同结点上。<br> 4）<code>客户端/服务器结构</code>的数据库系统</p></li><li><p><strong>数据库系统的工作流程</strong>：<br> 1）<code>DBA</code>建立并维护数据库；<br> 2）用户编写应用程序；<br> 3）应用程序在<code>DBMS</code>支持下运行，在模式，外模式，内模式，用户源程序翻译为目标代码后，即可启动目标程序。</p></li></ol><h2 id="四，数据库的发展"><a href="#四，数据库的发展" class="headerlink" title="四，数据库的发展"></a>四，数据库的发展</h2><ol><li><p><strong>人工管理阶段</strong>：<br> 1）特点：数据不保存；应用程序管理数据；数据不共享；数据不具有独立性。</p></li><li><p><strong>文件系统阶段</strong>：<br> 1）优点：数据可以长期保存；有专门的软件即文件系统管理数据，文件系统把数据组织成相互独立的数据文件；文件的形式多样化；<br> 2）缺点：数据共享性差，冗余度大；数据独立性差；数据联系弱。</p></li><li><p><strong>数据库系统阶段</strong></p></li><li><p><strong>数据库技术的研究，应用领域和发展方向</strong></p></li></ol><blockquote><ul><li>数据模型</li><li>数据库管理系统软件的研制</li><li>数据操作</li><li>数据库理论：主要集中在关系的规范化理论，关系数据理论等。<blockquote><p>代表性的数据库应用领域和发展方向：</p><ul><li>因特网上的Web数据库</li><li>面向对象数据库</li><li>多媒体数据库</li></ul></blockquote></li><li><p>并行数据库</p></li><li><p>人工智能领域的知识库和主动数据库</p></li><li><p>模糊数据库系统</p></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;br&gt;&lt;img src=&quot;/images/db_introduction_20190406.png&quot; alt=&quot;数据库系统与应用&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【数据库理论】数据模型</title>
    <link href="https://zhangbc.github.io/2019/04/06/db_data_model/"/>
    <id>https://zhangbc.github.io/2019/04/06/db_data_model/</id>
    <published>2019-04-06T04:48:52.000Z</published>
    <updated>2019-04-09T13:11:32.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。</p></blockquote><h2 id="一，数据描述"><a href="#一，数据描述" class="headerlink" title="一，数据描述"></a>一，数据描述</h2><ol><li><p><strong>数据的三种范畴</strong><br>  1）<code>现实世界</code>（<code>客观世界</code>）：<code>现实世界</code>所反映的客观存在的事物及其相互之间的联系，指数处理对象最原始的表现形式。<br>  2）<code>信息世界</code>（<code>观念世界</code>）：是<code>现实世界</code>在人们头脑中的反映，经过一定的选择，命名和分类而形成的。以下为相关概念：</p><blockquote><ul><li><code>实体（Entity）</code>：客观存在的事物在人们头脑中的反映，或说，客观存在并可相互区别的客观事物或抽象事件。</li><li><code>属性（Attribute）</code>：实体所具有的某一方面的特性。</li><li><code>域（Domain）</code>：一个属性可能取的所有属性值的范围称为该属性的域。</li><li><code>码（Key）</code>：唯一标识实体的属性集。</li><li><code>实体型（Entity Type）</code>：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li><li><code>实体集（Entity Set）</code>：同一类型实体的集合。</li></ul></blockquote><p>3）<code>机器世界</code>（<code>数据世界</code>或<code>存储世界</code>）<br>数据化后的信息称为<code>数据</code>，所以说<code>数据</code>是信息的符号表示。以下为相关概念：</p><blockquote><ul><li><code>数据项（字段，Field）</code>：对应于信息世界中的属性。</li><li><code>记录（Record）</code>：对应于每个实体所对应的数据。</li><li><code>记录型（Record Type）</code>：对应于信息世界中的实体型。</li><li><code>文件（File）</code>：对应于信息世界中的实体集。</li><li><code>关键字（Key）</code>：对应于能够唯一标识一个记录的字段集。</li></ul></blockquote></li><li><p><strong>实体间的联系</strong></p><blockquote><ul><li><code>一对一联系</code>：如果实体集<code>A</code>中每个实体，实体集<code>B</code>中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有<code>一对一联系</code>，记作<code>1:1</code>；</li><li><code>一对多联系</code>：如果实体集<code>A</code>中每个实体，实体集<code>B</code>中有n（n&gt;=0）个实体与之联系，反之，实体集<code>B</code>中每个实体，实体集<code>A</code>中至多有一个实体与之联系，则称实体集A与实体集B具有<code>一对多联系</code>，记作<code>1:n</code>；</li><li><code>多对多联系</code>：如果实体集<code>A</code>中每个实体，实体集<code>B</code>中有n（n&gt;=0）个实体与之联系，反之，实体集<code>B</code>中每个实体，实体集<code>A</code>中有m（m&gt;=0）个实体与之联系，则称实体集A与实体集B具有<code>多对多联系</code>，记作<code>n:m</code>。</li></ul></blockquote></li></ol><h2 id="二，概念模型与E-R方法"><a href="#二，概念模型与E-R方法" class="headerlink" title="二，概念模型与E-R方法"></a>二，概念模型与E-R方法</h2><ol><li><p><strong>数据模型</strong><br>  1）数据模型应满足以下要求：</p><blockquote><p>i）能够比较真实地模拟现实世界；<br>ii）容易为人所理解；<br>iii）便于在计算机上实现。</p></blockquote><p>  2）数据模型分类：</p><blockquote><p>i）<code>概念模型</code>：即<code>信息模型</code>，是按用户的观点来对数据和信息建模的，主要用于数据设计；<br>ii）<code>基本数据模型</code>：主要包括<code>网状模型</code>，<code>层次模型</code>，<code>关系模型</code>等，是按计算机系统的观点对数据建模的，主要用于DBMS的实现。</p></blockquote></li><li><p><strong>数据模型的三要素</strong><br>  1）<code>数据结构</code>：用于描述系统的静态特性。<code>数据结构</code>是所有研究对象类型的集合，这些对象是数据库的组成部分，分为两大类：</p><blockquote><ul><li>与数据类型，内容，性质有关的对象；</li><li>与数据之间联系有关的对象。</li></ul></blockquote><p>  2）<code>数据操作</code>：用于描述系统的动态特征。<code>数据操作</code>是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。数据库主要有<strong>检索</strong>和<strong>修改</strong>（插入，删除，更新）两大数据操作。<br>  3）<code>数据完整性约束</code>：是一组完整性规则的集合。<code>完整性规则</code>是给定的数据模型中的数据及其联系所具有的制约和存储规则，用于限制符合数据模型的数据库状态及状态的变化，用于确保数据的<code>正确</code>、<code>有效</code>和<code>相容</code>。</p></li><li><p><strong>概念数据模型</strong><br>  1）<code>概念模型</code>的定义：按用户的观点对现实世界进行数据建模而形成的，是一种独立于计算机系统的模型，完全不涉及信息在计算机系统中的表示，也不依赖于具体的数据库管理系统，用于描述某个特定组织所关心的信息结构。<br>  2）<code>概念模型</code>的相关基本概念：<code>实体</code>、<code>属性</code>、<code>域</code>、<code>码</code>、<code>实体型</code>和<code>实体集</code>。<br>  3）<code>概念模型</code>的基本关系：在<code>概念模型</code>中主要解决问题是实体间的联系。</p></li><li><p><strong>E-R图表示法</strong><br>  1）<code>实体型</code>：用<code>矩形</code>表示，矩形框内写明实体名；<br>  2）<code>属性</code>：用<code>椭圆</code>表示，椭圆内写明属性名；<br>  3）<code>联系</code>：用<code>菱形</code>表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标注联系的类型（<code>1:1</code>，<code>1:n</code>，<code>n:m</code>）。<br>  <code>E-R模型</code>优点：</p><blockquote><p>i）接近人的思想，容易理解；<br>ii）与计算机无关，用户容易接受。</p></blockquote></li></ol><h2 id="三，传统的三大数据模型"><a href="#三，传统的三大数据模型" class="headerlink" title="三，传统的三大数据模型"></a>三，传统的三大数据模型</h2><ol><li><p><strong>层次模型</strong><br>  1）<code>层次模型</code>定义：用<code>树形结构</code>表示实体之间的联系的模型称为<code>层次模型</code>。<br>  2）建立数据的<code>层次模型</code>需要满足以下条件：</p><blockquote><p>i）有且仅有一个结点没有父结点，这个结点即为树根结点；<br>ii）其他数据记录有且仅有一个父结点。</p></blockquote><p>  3）<code>层次模型</code>的<strong>基本特点</strong>：任何一个给定的记录值只有按其路径查看，才能体现它的全部含义，没有一个子记录值能够脱离父记录值而独立存在的。<br>  4）<code>层次模型</code>的<strong>最明显特点</strong>：层次清晰，构造简单，易于实现，可以很方便地表示一对一和一对多这两种实体之间的联系。<br>  5）<code>层次模型</code>的主要优点：</p><blockquote><p>i）<code>层次模型</code>本身比较简单；<br>ii）实体间联系是固定的，且预先定义好的应用系统采用<code>层次模型</code>来实现，其性能优于<code>关系模型</code>的性能，不低于<code>网状模型</code>的性能；<br>iii）<code>层次模型</code>提供了良好的完整性支持。</p></blockquote><p> 6）<code>层次模型</code>的主要缺点：</p><blockquote><p>i）现实世界中很多联系是非层次性的，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据或创建非自然组织（引入虚结点）来解决；<br>ii）对插入和删除操作的限制比较多；<br>iii）查询子结点必须通过父结点；<br>iv）由于结构严谨，层次命令趋于程序化。</p></blockquote></li><li><p><strong>网状模型</strong><br>  1）<code>网状模型</code>的定义： 网状模型是一种有向图，在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：</p><blockquote><p>i）允许一个以上的结点无父结点；<br>ii）一个结点可以有多于一个的父结点。</p></blockquote><p>  2）为了描述网状模型的记录之间的联系，引进了<code>系（Set）</code>的概念，所谓<code>系</code>可以理解为命名了的<code>联系</code>，它由一个父记录型和一个或多个子记录型构成。<br>  3）<code>网状数据库</code>的定义：用网状模型设计出来的数据库称为<code>网状数据库</code>。<br>  4）<code>网状模型</code>的主要优点：</p><blockquote><p>i）能够更为直接地描述现实世界，如一个结点可以有多个父结点；<br>ii）具有良好的性能，存取效率较高。</p></blockquote><p>  5）<code>网状模型</code>的主要缺点：</p><blockquote><p>i）结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于用户最终掌握；<br>ii）其DDL，DML语言复杂，用户不易使用。</p></blockquote></li><li><p><strong>关系模型</strong><br>  1）<code>关系模型</code>的主要优点：</p><blockquote><p>i）数据结构比较简单；<br>ii）具有很高的数据独立性；<br>iii）可以直接处理多对多联系；<br>iv）坚实的理论基础。</p></blockquote><p>  2）<code>值域</code>的定义：在关系模型中，一个n元关系有n个属性，属性的取值范围称为值域。<br>  3）<code>关系模型</code>主要缺点：存取路径对用户透明，查询效率往往不如非关系数据模型。</p></li></ol><h2 id="四，数据独立与三层结构"><a href="#四，数据独立与三层结构" class="headerlink" title="四，数据独立与三层结构"></a>四，数据独立与三层结构</h2><ol><li><p><strong>三级模式结构</strong></p><blockquote><ul><li><code>外模式</code>：又称为<code>用户模式</code>，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看得见和使用的局部数据的逻辑结构和特征描述，是与某一个应用有关的数据的逻辑表示。</li><li><code>模式</code>：可分为<code>概念模式</code>和<code>逻辑模式</code>，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。<blockquote><p>一个数据库只有一个<code>模式</code>，其中<code>概念模式</code>可以用<code>实体-联系模型</code>模型来描述，<code>逻辑模式</code>以某种数据模型为基础，综合考虑所有用户的需求，并将其形成全局逻辑结构。</p></blockquote></li><li><code>内模式</code>：又称为<code>存储模式</code>，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。</li></ul></blockquote></li><li><p><strong>数据的独立性</strong></p><blockquote><ul><li><code>逻辑数据独立性</code>：当<code>模式</code>改变时，只要对<code>外模式/模式映像</code>做相应的改变，就可以使<code>外模式</code>保持不变，以<code>外模式</code>为依据编写的应用程序就不受影响，从而应用程序不必修改，保证了数据与程序之间的<code>逻辑独立性</code>。</li><li><code>存储数据独立性</code>：当<code>内模式</code>改变时，只要对<code>模式/内模式映像</code>做相应的改变，使<code>模式</code>保持不变，应用程序就不受影响，从而保证了数据与程序之间的<code>物理独立性</code>，称为<code>存储数据独立性</code>。</li></ul></blockquote></li></ol><h2 id="五，数据库管理系统"><a href="#五，数据库管理系统" class="headerlink" title="五，数据库管理系统"></a>五，数据库管理系统</h2><ol><li><p><strong><code>DBMS</code>的主要功能</strong><br>  数据库的<code>主要职责</code>就是有效地实现数据库三级模式之间的转换，即把用户或应用程序对数据库的一次访问，从用户级带到概念级，再导向物理级，转换为对存储数据的操作。</p><blockquote><p>1）数据库定义<br>2）数据库操作及查询优化<br>3）数据库控制运行管理<br>4）数据组织，存储和管理<br>5）数据库的恢复和维护<br>6）数据库的多种接口<br>7）其他功能</p></blockquote></li><li><p><strong><code>DBMS</code>的组成</strong><br>  1）<code>DBMS</code>由<code>查询处理器</code>和<code>存储管理器</code>两大部分组成。其中：</p><blockquote><p>(1) <code>查询处理器</code>主要有<code>DDL</code>编译器，<code>DML</code>编译器，<code>嵌入式DML</code>的预编译器及查询运行核心程序；<br>(2) <code>存储管理器</code>有授权和完整性管理器，事务管理器，文件管理器及缓冲区管理器。</p></blockquote><p>  2）<code>查询处理程序</code>：把用较高级的语言所表示的数据库操作（查询、更新等）转换成一系列对数据库的请求。<br>  3）<code>存储管理程序</code>：包括<code>文件管理程序</code>和<code>缓冲区管理程序</code>。<br>  4）<code>事务管理程序</code>：保证数据库中所有事务全部都能正确执行。</p></li><li><p><strong>用户访问数据库的过程</strong>（略）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本系列为《数据库系统原理与应用（刘先锋等著）》的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一，数据描述&quot;&gt;&lt;a href=&quot;#一，数据描述&quot; class=&quot;headerlink&quot; title=&quot;一，数据描述&quot;&gt;&lt;/a&gt;一，数据
      
    
    </summary>
    
      <category term="数据库技术" scheme="https://zhangbc.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库理论" scheme="https://zhangbc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
</feed>
